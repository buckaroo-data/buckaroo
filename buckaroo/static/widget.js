var vN = Object.defineProperty;
var yN = (e, t, r) => t in e ? vN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var wr = (e, t, r) => yN(e, typeof t != "symbol" ? t + "" : t, r);
import { jsx as $, jsxs as He } from "react/jsx-runtime";
import O, { useState as pe, forwardRef as Vh, useContext as Wt, useRef as ge, useImperativeHandle as S0, useLayoutEffect as ao, useCallback as Qe, useMemo as Se, createContext as mo, memo as Tr, useEffect as pr, createElement as x0, Component as R0, isValidElement as ri, Children as Xo, PureComponent as ui, cloneElement as er } from "react";
import CN, { createPortal as $h } from "react-dom";
var Ei = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var xd = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
xd.exports;
(function(e, t) {
  (function() {
    var r, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", u = 500, d = "__lodash_placeholder__", h = 1, f = 2, p = 4, y = 1, C = 2, v = 1, w = 2, R = 4, b = 8, P = 16, S = 32, E = 64, A = 128, M = 256, I = 512, z = 30, k = "...", _ = 800, q = 16, j = 1, Q = 2, K = 3, Z = 1 / 0, te = 9007199254740991, se = 17976931348623157e292, W = NaN, U = 4294967295, X = U - 1, he = U >>> 1, ce = [
      ["ary", A],
      ["bind", v],
      ["bindKey", w],
      ["curry", b],
      ["curryRight", P],
      ["flip", I],
      ["partial", S],
      ["partialRight", E],
      ["rearg", M]
    ], me = "[object Arguments]", ve = "[object Array]", Pe = "[object AsyncFunction]", Re = "[object Boolean]", ee = "[object Date]", fe = "[object DOMException]", ye = "[object Error]", B = "[object Function]", Ae = "[object GeneratorFunction]", oe = "[object Map]", Me = "[object Number]", Je = "[object Null]", nt = "[object Object]", $r = "[object Promise]", Dr = "[object Proxy]", Nt = "[object RegExp]", Et = "[object Set]", Ut = "[object String]", Or = "[object Symbol]", Po = "[object Undefined]", on = "[object WeakMap]", yt = "[object WeakSet]", Ot = "[object ArrayBuffer]", Wi = "[object DataView]", Hg = "[object Float32Array]", Wg = "[object Float64Array]", Vg = "[object Int8Array]", $g = "[object Int16Array]", jg = "[object Int32Array]", Ug = "[object Uint8Array]", Kg = "[object Uint8ClampedArray]", qg = "[object Uint16Array]", Yg = "[object Uint32Array]", ND = /\b__p \+= '';/g, BD = /\b(__p \+=) '' \+/g, GD = /(__e\(.*?\)|\b__t\)) \+\n'';/g, bC = /&(?:amp|lt|gt|quot|#39);/g, SC = /[&<>"']/g, HD = RegExp(bC.source), WD = RegExp(SC.source), VD = /<%-([\s\S]+?)%>/g, $D = /<%([\s\S]+?)%>/g, xC = /<%=([\s\S]+?)%>/g, jD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, UD = /^\w*$/, KD = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Jg = /[\\^$.*+?()[\]{}|]/g, qD = RegExp(Jg.source), Xg = /^\s+/, YD = /\s/, JD = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, XD = /\{\n\/\* \[wrapped with (.+)\] \*/, QD = /,? & /, ZD = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, eO = /[()=,{}\[\]\/\s]/, tO = /\\(\\)?/g, rO = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, RC = /\w*$/, nO = /^[-+]0x[0-9a-f]+$/i, iO = /^0b[01]+$/i, oO = /^\[object .+?Constructor\]$/, sO = /^0o[0-7]+$/i, aO = /^(?:0|[1-9]\d*)$/, lO = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, eu = /($^)/, cO = /['\n\r\u2028\u2029\\]/g, tu = "\\ud800-\\udfff", uO = "\\u0300-\\u036f", dO = "\\ufe20-\\ufe2f", hO = "\\u20d0-\\u20ff", EC = uO + dO + hO, PC = "\\u2700-\\u27bf", AC = "a-z\\xdf-\\xf6\\xf8-\\xff", gO = "\\xac\\xb1\\xd7\\xf7", fO = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", pO = "\\u2000-\\u206f", mO = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", FC = "A-Z\\xc0-\\xd6\\xd8-\\xde", MC = "\\ufe0e\\ufe0f", TC = gO + fO + pO + mO, Qg = "['’]", vO = "[" + tu + "]", DC = "[" + TC + "]", ru = "[" + EC + "]", OC = "\\d+", yO = "[" + PC + "]", IC = "[" + AC + "]", kC = "[^" + tu + TC + OC + PC + AC + FC + "]", Zg = "\\ud83c[\\udffb-\\udfff]", CO = "(?:" + ru + "|" + Zg + ")", LC = "[^" + tu + "]", ef = "(?:\\ud83c[\\udde6-\\uddff]){2}", tf = "[\\ud800-\\udbff][\\udc00-\\udfff]", xs = "[" + FC + "]", _C = "\\u200d", zC = "(?:" + IC + "|" + kC + ")", wO = "(?:" + xs + "|" + kC + ")", NC = "(?:" + Qg + "(?:d|ll|m|re|s|t|ve))?", BC = "(?:" + Qg + "(?:D|LL|M|RE|S|T|VE))?", GC = CO + "?", HC = "[" + MC + "]?", bO = "(?:" + _C + "(?:" + [LC, ef, tf].join("|") + ")" + HC + GC + ")*", SO = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", xO = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", WC = HC + GC + bO, RO = "(?:" + [yO, ef, tf].join("|") + ")" + WC, EO = "(?:" + [LC + ru + "?", ru, ef, tf, vO].join("|") + ")", PO = RegExp(Qg, "g"), AO = RegExp(ru, "g"), rf = RegExp(Zg + "(?=" + Zg + ")|" + EO + WC, "g"), FO = RegExp([
      xs + "?" + IC + "+" + NC + "(?=" + [DC, xs, "$"].join("|") + ")",
      wO + "+" + BC + "(?=" + [DC, xs + zC, "$"].join("|") + ")",
      xs + "?" + zC + "+" + NC,
      xs + "+" + BC,
      xO,
      SO,
      OC,
      RO
    ].join("|"), "g"), MO = RegExp("[" + _C + tu + EC + MC + "]"), TO = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, DO = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], OO = -1, St = {};
    St[Hg] = St[Wg] = St[Vg] = St[$g] = St[jg] = St[Ug] = St[Kg] = St[qg] = St[Yg] = !0, St[me] = St[ve] = St[Ot] = St[Re] = St[Wi] = St[ee] = St[ye] = St[B] = St[oe] = St[Me] = St[nt] = St[Nt] = St[Et] = St[Ut] = St[on] = !1;
    var Ct = {};
    Ct[me] = Ct[ve] = Ct[Ot] = Ct[Wi] = Ct[Re] = Ct[ee] = Ct[Hg] = Ct[Wg] = Ct[Vg] = Ct[$g] = Ct[jg] = Ct[oe] = Ct[Me] = Ct[nt] = Ct[Nt] = Ct[Et] = Ct[Ut] = Ct[Or] = Ct[Ug] = Ct[Kg] = Ct[qg] = Ct[Yg] = !0, Ct[ye] = Ct[B] = Ct[on] = !1;
    var IO = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, kO = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, LO = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, _O = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, zO = parseFloat, NO = parseInt, VC = typeof Ei == "object" && Ei && Ei.Object === Object && Ei, BO = typeof self == "object" && self && self.Object === Object && self, nr = VC || BO || Function("return this")(), nf = t && !t.nodeType && t, Ao = nf && !0 && e && !e.nodeType && e, $C = Ao && Ao.exports === nf, of = $C && VC.process, sn = function() {
      try {
        var G = Ao && Ao.require && Ao.require("util").types;
        return G || of && of.binding && of.binding("util");
      } catch {
      }
    }(), jC = sn && sn.isArrayBuffer, UC = sn && sn.isDate, KC = sn && sn.isMap, qC = sn && sn.isRegExp, YC = sn && sn.isSet, JC = sn && sn.isTypedArray;
    function jr(G, ne, Y) {
      switch (Y.length) {
        case 0:
          return G.call(ne);
        case 1:
          return G.call(ne, Y[0]);
        case 2:
          return G.call(ne, Y[0], Y[1]);
        case 3:
          return G.call(ne, Y[0], Y[1], Y[2]);
      }
      return G.apply(ne, Y);
    }
    function GO(G, ne, Y, be) {
      for (var Le = -1, it = G == null ? 0 : G.length; ++Le < it; ) {
        var Kt = G[Le];
        ne(be, Kt, Y(Kt), G);
      }
      return be;
    }
    function an(G, ne) {
      for (var Y = -1, be = G == null ? 0 : G.length; ++Y < be && ne(G[Y], Y, G) !== !1; )
        ;
      return G;
    }
    function HO(G, ne) {
      for (var Y = G == null ? 0 : G.length; Y-- && ne(G[Y], Y, G) !== !1; )
        ;
      return G;
    }
    function XC(G, ne) {
      for (var Y = -1, be = G == null ? 0 : G.length; ++Y < be; )
        if (!ne(G[Y], Y, G))
          return !1;
      return !0;
    }
    function Vi(G, ne) {
      for (var Y = -1, be = G == null ? 0 : G.length, Le = 0, it = []; ++Y < be; ) {
        var Kt = G[Y];
        ne(Kt, Y, G) && (it[Le++] = Kt);
      }
      return it;
    }
    function nu(G, ne) {
      var Y = G == null ? 0 : G.length;
      return !!Y && Rs(G, ne, 0) > -1;
    }
    function sf(G, ne, Y) {
      for (var be = -1, Le = G == null ? 0 : G.length; ++be < Le; )
        if (Y(ne, G[be]))
          return !0;
      return !1;
    }
    function Pt(G, ne) {
      for (var Y = -1, be = G == null ? 0 : G.length, Le = Array(be); ++Y < be; )
        Le[Y] = ne(G[Y], Y, G);
      return Le;
    }
    function $i(G, ne) {
      for (var Y = -1, be = ne.length, Le = G.length; ++Y < be; )
        G[Le + Y] = ne[Y];
      return G;
    }
    function af(G, ne, Y, be) {
      var Le = -1, it = G == null ? 0 : G.length;
      for (be && it && (Y = G[++Le]); ++Le < it; )
        Y = ne(Y, G[Le], Le, G);
      return Y;
    }
    function WO(G, ne, Y, be) {
      var Le = G == null ? 0 : G.length;
      for (be && Le && (Y = G[--Le]); Le--; )
        Y = ne(Y, G[Le], Le, G);
      return Y;
    }
    function lf(G, ne) {
      for (var Y = -1, be = G == null ? 0 : G.length; ++Y < be; )
        if (ne(G[Y], Y, G))
          return !0;
      return !1;
    }
    var VO = cf("length");
    function $O(G) {
      return G.split("");
    }
    function jO(G) {
      return G.match(ZD) || [];
    }
    function QC(G, ne, Y) {
      var be;
      return Y(G, function(Le, it, Kt) {
        if (ne(Le, it, Kt))
          return be = it, !1;
      }), be;
    }
    function iu(G, ne, Y, be) {
      for (var Le = G.length, it = Y + (be ? 1 : -1); be ? it-- : ++it < Le; )
        if (ne(G[it], it, G))
          return it;
      return -1;
    }
    function Rs(G, ne, Y) {
      return ne === ne ? nI(G, ne, Y) : iu(G, ZC, Y);
    }
    function UO(G, ne, Y, be) {
      for (var Le = Y - 1, it = G.length; ++Le < it; )
        if (be(G[Le], ne))
          return Le;
      return -1;
    }
    function ZC(G) {
      return G !== G;
    }
    function ew(G, ne) {
      var Y = G == null ? 0 : G.length;
      return Y ? df(G, ne) / Y : W;
    }
    function cf(G) {
      return function(ne) {
        return ne == null ? r : ne[G];
      };
    }
    function uf(G) {
      return function(ne) {
        return G == null ? r : G[ne];
      };
    }
    function tw(G, ne, Y, be, Le) {
      return Le(G, function(it, Kt, pt) {
        Y = be ? (be = !1, it) : ne(Y, it, Kt, pt);
      }), Y;
    }
    function KO(G, ne) {
      var Y = G.length;
      for (G.sort(ne); Y--; )
        G[Y] = G[Y].value;
      return G;
    }
    function df(G, ne) {
      for (var Y, be = -1, Le = G.length; ++be < Le; ) {
        var it = ne(G[be]);
        it !== r && (Y = Y === r ? it : Y + it);
      }
      return Y;
    }
    function hf(G, ne) {
      for (var Y = -1, be = Array(G); ++Y < G; )
        be[Y] = ne(Y);
      return be;
    }
    function qO(G, ne) {
      return Pt(ne, function(Y) {
        return [Y, G[Y]];
      });
    }
    function rw(G) {
      return G && G.slice(0, sw(G) + 1).replace(Xg, "");
    }
    function Ur(G) {
      return function(ne) {
        return G(ne);
      };
    }
    function gf(G, ne) {
      return Pt(ne, function(Y) {
        return G[Y];
      });
    }
    function sl(G, ne) {
      return G.has(ne);
    }
    function nw(G, ne) {
      for (var Y = -1, be = G.length; ++Y < be && Rs(ne, G[Y], 0) > -1; )
        ;
      return Y;
    }
    function iw(G, ne) {
      for (var Y = G.length; Y-- && Rs(ne, G[Y], 0) > -1; )
        ;
      return Y;
    }
    function YO(G, ne) {
      for (var Y = G.length, be = 0; Y--; )
        G[Y] === ne && ++be;
      return be;
    }
    var JO = uf(IO), XO = uf(kO);
    function QO(G) {
      return "\\" + _O[G];
    }
    function ZO(G, ne) {
      return G == null ? r : G[ne];
    }
    function Es(G) {
      return MO.test(G);
    }
    function eI(G) {
      return TO.test(G);
    }
    function tI(G) {
      for (var ne, Y = []; !(ne = G.next()).done; )
        Y.push(ne.value);
      return Y;
    }
    function ff(G) {
      var ne = -1, Y = Array(G.size);
      return G.forEach(function(be, Le) {
        Y[++ne] = [Le, be];
      }), Y;
    }
    function ow(G, ne) {
      return function(Y) {
        return G(ne(Y));
      };
    }
    function ji(G, ne) {
      for (var Y = -1, be = G.length, Le = 0, it = []; ++Y < be; ) {
        var Kt = G[Y];
        (Kt === ne || Kt === d) && (G[Y] = d, it[Le++] = Y);
      }
      return it;
    }
    function ou(G) {
      var ne = -1, Y = Array(G.size);
      return G.forEach(function(be) {
        Y[++ne] = be;
      }), Y;
    }
    function rI(G) {
      var ne = -1, Y = Array(G.size);
      return G.forEach(function(be) {
        Y[++ne] = [be, be];
      }), Y;
    }
    function nI(G, ne, Y) {
      for (var be = Y - 1, Le = G.length; ++be < Le; )
        if (G[be] === ne)
          return be;
      return -1;
    }
    function iI(G, ne, Y) {
      for (var be = Y + 1; be--; )
        if (G[be] === ne)
          return be;
      return be;
    }
    function Ps(G) {
      return Es(G) ? sI(G) : VO(G);
    }
    function Fn(G) {
      return Es(G) ? aI(G) : $O(G);
    }
    function sw(G) {
      for (var ne = G.length; ne-- && YD.test(G.charAt(ne)); )
        ;
      return ne;
    }
    var oI = uf(LO);
    function sI(G) {
      for (var ne = rf.lastIndex = 0; rf.test(G); )
        ++ne;
      return ne;
    }
    function aI(G) {
      return G.match(rf) || [];
    }
    function lI(G) {
      return G.match(FO) || [];
    }
    var cI = function G(ne) {
      ne = ne == null ? nr : As.defaults(nr.Object(), ne, As.pick(nr, DO));
      var Y = ne.Array, be = ne.Date, Le = ne.Error, it = ne.Function, Kt = ne.Math, pt = ne.Object, pf = ne.RegExp, uI = ne.String, ln = ne.TypeError, su = Y.prototype, dI = it.prototype, Fs = pt.prototype, au = ne["__core-js_shared__"], lu = dI.toString, gt = Fs.hasOwnProperty, hI = 0, aw = function() {
        var c = /[^.]+$/.exec(au && au.keys && au.keys.IE_PROTO || "");
        return c ? "Symbol(src)_1." + c : "";
      }(), cu = Fs.toString, gI = lu.call(pt), fI = nr._, pI = pf(
        "^" + lu.call(gt).replace(Jg, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), uu = $C ? ne.Buffer : r, Ui = ne.Symbol, du = ne.Uint8Array, lw = uu ? uu.allocUnsafe : r, hu = ow(pt.getPrototypeOf, pt), cw = pt.create, uw = Fs.propertyIsEnumerable, gu = su.splice, dw = Ui ? Ui.isConcatSpreadable : r, al = Ui ? Ui.iterator : r, Fo = Ui ? Ui.toStringTag : r, fu = function() {
        try {
          var c = Io(pt, "defineProperty");
          return c({}, "", {}), c;
        } catch {
        }
      }(), mI = ne.clearTimeout !== nr.clearTimeout && ne.clearTimeout, vI = be && be.now !== nr.Date.now && be.now, yI = ne.setTimeout !== nr.setTimeout && ne.setTimeout, pu = Kt.ceil, mu = Kt.floor, mf = pt.getOwnPropertySymbols, CI = uu ? uu.isBuffer : r, hw = ne.isFinite, wI = su.join, bI = ow(pt.keys, pt), qt = Kt.max, lr = Kt.min, SI = be.now, xI = ne.parseInt, gw = Kt.random, RI = su.reverse, vf = Io(ne, "DataView"), ll = Io(ne, "Map"), yf = Io(ne, "Promise"), Ms = Io(ne, "Set"), cl = Io(ne, "WeakMap"), ul = Io(pt, "create"), vu = cl && new cl(), Ts = {}, EI = ko(vf), PI = ko(ll), AI = ko(yf), FI = ko(Ms), MI = ko(cl), yu = Ui ? Ui.prototype : r, dl = yu ? yu.valueOf : r, fw = yu ? yu.toString : r;
      function T(c) {
        if (It(c) && !ze(c) && !(c instanceof qe)) {
          if (c instanceof cn)
            return c;
          if (gt.call(c, "__wrapped__"))
            return pb(c);
        }
        return new cn(c);
      }
      var Ds = /* @__PURE__ */ function() {
        function c() {
        }
        return function(g) {
          if (!Mt(g))
            return {};
          if (cw)
            return cw(g);
          c.prototype = g;
          var m = new c();
          return c.prototype = r, m;
        };
      }();
      function Cu() {
      }
      function cn(c, g) {
        this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!g, this.__index__ = 0, this.__values__ = r;
      }
      T.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: VD,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: $D,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: xC,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: T
        }
      }, T.prototype = Cu.prototype, T.prototype.constructor = T, cn.prototype = Ds(Cu.prototype), cn.prototype.constructor = cn;
      function qe(c) {
        this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = U, this.__views__ = [];
      }
      function TI() {
        var c = new qe(this.__wrapped__);
        return c.__actions__ = Ir(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = Ir(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = Ir(this.__views__), c;
      }
      function DI() {
        if (this.__filtered__) {
          var c = new qe(this);
          c.__dir__ = -1, c.__filtered__ = !0;
        } else
          c = this.clone(), c.__dir__ *= -1;
        return c;
      }
      function OI() {
        var c = this.__wrapped__.value(), g = this.__dir__, m = ze(c), x = g < 0, F = m ? c.length : 0, D = $k(0, F, this.__views__), L = D.start, N = D.end, H = N - L, ae = x ? N : L - 1, le = this.__iteratees__, ue = le.length, we = 0, Ee = lr(H, this.__takeCount__);
        if (!m || !x && F == H && Ee == H)
          return Nw(c, this.__actions__);
        var Oe = [];
        e:
          for (; H-- && we < Ee; ) {
            ae += g;
            for (var Ge = -1, Ie = c[ae]; ++Ge < ue; ) {
              var Ue = le[Ge], Xe = Ue.iteratee, Yr = Ue.type, Cr = Xe(Ie);
              if (Yr == Q)
                Ie = Cr;
              else if (!Cr) {
                if (Yr == j)
                  continue e;
                break e;
              }
            }
            Oe[we++] = Ie;
          }
        return Oe;
      }
      qe.prototype = Ds(Cu.prototype), qe.prototype.constructor = qe;
      function Mo(c) {
        var g = -1, m = c == null ? 0 : c.length;
        for (this.clear(); ++g < m; ) {
          var x = c[g];
          this.set(x[0], x[1]);
        }
      }
      function II() {
        this.__data__ = ul ? ul(null) : {}, this.size = 0;
      }
      function kI(c) {
        var g = this.has(c) && delete this.__data__[c];
        return this.size -= g ? 1 : 0, g;
      }
      function LI(c) {
        var g = this.__data__;
        if (ul) {
          var m = g[c];
          return m === l ? r : m;
        }
        return gt.call(g, c) ? g[c] : r;
      }
      function _I(c) {
        var g = this.__data__;
        return ul ? g[c] !== r : gt.call(g, c);
      }
      function zI(c, g) {
        var m = this.__data__;
        return this.size += this.has(c) ? 0 : 1, m[c] = ul && g === r ? l : g, this;
      }
      Mo.prototype.clear = II, Mo.prototype.delete = kI, Mo.prototype.get = LI, Mo.prototype.has = _I, Mo.prototype.set = zI;
      function fi(c) {
        var g = -1, m = c == null ? 0 : c.length;
        for (this.clear(); ++g < m; ) {
          var x = c[g];
          this.set(x[0], x[1]);
        }
      }
      function NI() {
        this.__data__ = [], this.size = 0;
      }
      function BI(c) {
        var g = this.__data__, m = wu(g, c);
        if (m < 0)
          return !1;
        var x = g.length - 1;
        return m == x ? g.pop() : gu.call(g, m, 1), --this.size, !0;
      }
      function GI(c) {
        var g = this.__data__, m = wu(g, c);
        return m < 0 ? r : g[m][1];
      }
      function HI(c) {
        return wu(this.__data__, c) > -1;
      }
      function WI(c, g) {
        var m = this.__data__, x = wu(m, c);
        return x < 0 ? (++this.size, m.push([c, g])) : m[x][1] = g, this;
      }
      fi.prototype.clear = NI, fi.prototype.delete = BI, fi.prototype.get = GI, fi.prototype.has = HI, fi.prototype.set = WI;
      function pi(c) {
        var g = -1, m = c == null ? 0 : c.length;
        for (this.clear(); ++g < m; ) {
          var x = c[g];
          this.set(x[0], x[1]);
        }
      }
      function VI() {
        this.size = 0, this.__data__ = {
          hash: new Mo(),
          map: new (ll || fi)(),
          string: new Mo()
        };
      }
      function $I(c) {
        var g = Ou(this, c).delete(c);
        return this.size -= g ? 1 : 0, g;
      }
      function jI(c) {
        return Ou(this, c).get(c);
      }
      function UI(c) {
        return Ou(this, c).has(c);
      }
      function KI(c, g) {
        var m = Ou(this, c), x = m.size;
        return m.set(c, g), this.size += m.size == x ? 0 : 1, this;
      }
      pi.prototype.clear = VI, pi.prototype.delete = $I, pi.prototype.get = jI, pi.prototype.has = UI, pi.prototype.set = KI;
      function To(c) {
        var g = -1, m = c == null ? 0 : c.length;
        for (this.__data__ = new pi(); ++g < m; )
          this.add(c[g]);
      }
      function qI(c) {
        return this.__data__.set(c, l), this;
      }
      function YI(c) {
        return this.__data__.has(c);
      }
      To.prototype.add = To.prototype.push = qI, To.prototype.has = YI;
      function Mn(c) {
        var g = this.__data__ = new fi(c);
        this.size = g.size;
      }
      function JI() {
        this.__data__ = new fi(), this.size = 0;
      }
      function XI(c) {
        var g = this.__data__, m = g.delete(c);
        return this.size = g.size, m;
      }
      function QI(c) {
        return this.__data__.get(c);
      }
      function ZI(c) {
        return this.__data__.has(c);
      }
      function ek(c, g) {
        var m = this.__data__;
        if (m instanceof fi) {
          var x = m.__data__;
          if (!ll || x.length < i - 1)
            return x.push([c, g]), this.size = ++m.size, this;
          m = this.__data__ = new pi(x);
        }
        return m.set(c, g), this.size = m.size, this;
      }
      Mn.prototype.clear = JI, Mn.prototype.delete = XI, Mn.prototype.get = QI, Mn.prototype.has = ZI, Mn.prototype.set = ek;
      function pw(c, g) {
        var m = ze(c), x = !m && Lo(c), F = !m && !x && Xi(c), D = !m && !x && !F && Ls(c), L = m || x || F || D, N = L ? hf(c.length, uI) : [], H = N.length;
        for (var ae in c)
          (g || gt.call(c, ae)) && !(L && // Safari 9 has enumerable `arguments.length` in strict mode.
          (ae == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          F && (ae == "offset" || ae == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          D && (ae == "buffer" || ae == "byteLength" || ae == "byteOffset") || // Skip index properties.
          Ci(ae, H))) && N.push(ae);
        return N;
      }
      function mw(c) {
        var g = c.length;
        return g ? c[Mf(0, g - 1)] : r;
      }
      function tk(c, g) {
        return Iu(Ir(c), Do(g, 0, c.length));
      }
      function rk(c) {
        return Iu(Ir(c));
      }
      function Cf(c, g, m) {
        (m !== r && !Tn(c[g], m) || m === r && !(g in c)) && mi(c, g, m);
      }
      function hl(c, g, m) {
        var x = c[g];
        (!(gt.call(c, g) && Tn(x, m)) || m === r && !(g in c)) && mi(c, g, m);
      }
      function wu(c, g) {
        for (var m = c.length; m--; )
          if (Tn(c[m][0], g))
            return m;
        return -1;
      }
      function nk(c, g, m, x) {
        return Ki(c, function(F, D, L) {
          g(x, F, m(F), L);
        }), x;
      }
      function vw(c, g) {
        return c && Kn(g, Zt(g), c);
      }
      function ik(c, g) {
        return c && Kn(g, Lr(g), c);
      }
      function mi(c, g, m) {
        g == "__proto__" && fu ? fu(c, g, {
          configurable: !0,
          enumerable: !0,
          value: m,
          writable: !0
        }) : c[g] = m;
      }
      function wf(c, g) {
        for (var m = -1, x = g.length, F = Y(x), D = c == null; ++m < x; )
          F[m] = D ? r : ep(c, g[m]);
        return F;
      }
      function Do(c, g, m) {
        return c === c && (m !== r && (c = c <= m ? c : m), g !== r && (c = c >= g ? c : g)), c;
      }
      function un(c, g, m, x, F, D) {
        var L, N = g & h, H = g & f, ae = g & p;
        if (m && (L = F ? m(c, x, F, D) : m(c)), L !== r)
          return L;
        if (!Mt(c))
          return c;
        var le = ze(c);
        if (le) {
          if (L = Uk(c), !N)
            return Ir(c, L);
        } else {
          var ue = cr(c), we = ue == B || ue == Ae;
          if (Xi(c))
            return Hw(c, N);
          if (ue == nt || ue == me || we && !F) {
            if (L = H || we ? {} : sb(c), !N)
              return H ? Lk(c, ik(L, c)) : kk(c, vw(L, c));
          } else {
            if (!Ct[ue])
              return F ? c : {};
            L = Kk(c, ue, N);
          }
        }
        D || (D = new Mn());
        var Ee = D.get(c);
        if (Ee)
          return Ee;
        D.set(c, L), Lb(c) ? c.forEach(function(Ie) {
          L.add(un(Ie, g, m, Ie, c, D));
        }) : Ib(c) && c.forEach(function(Ie, Ue) {
          L.set(Ue, un(Ie, g, m, Ue, c, D));
        });
        var Oe = ae ? H ? Gf : Bf : H ? Lr : Zt, Ge = le ? r : Oe(c);
        return an(Ge || c, function(Ie, Ue) {
          Ge && (Ue = Ie, Ie = c[Ue]), hl(L, Ue, un(Ie, g, m, Ue, c, D));
        }), L;
      }
      function ok(c) {
        var g = Zt(c);
        return function(m) {
          return yw(m, c, g);
        };
      }
      function yw(c, g, m) {
        var x = m.length;
        if (c == null)
          return !x;
        for (c = pt(c); x--; ) {
          var F = m[x], D = g[F], L = c[F];
          if (L === r && !(F in c) || !D(L))
            return !1;
        }
        return !0;
      }
      function Cw(c, g, m) {
        if (typeof c != "function")
          throw new ln(s);
        return Cl(function() {
          c.apply(r, m);
        }, g);
      }
      function gl(c, g, m, x) {
        var F = -1, D = nu, L = !0, N = c.length, H = [], ae = g.length;
        if (!N)
          return H;
        m && (g = Pt(g, Ur(m))), x ? (D = sf, L = !1) : g.length >= i && (D = sl, L = !1, g = new To(g));
        e:
          for (; ++F < N; ) {
            var le = c[F], ue = m == null ? le : m(le);
            if (le = x || le !== 0 ? le : 0, L && ue === ue) {
              for (var we = ae; we--; )
                if (g[we] === ue)
                  continue e;
              H.push(le);
            } else D(g, ue, x) || H.push(le);
          }
        return H;
      }
      var Ki = Uw(Un), ww = Uw(Sf, !0);
      function sk(c, g) {
        var m = !0;
        return Ki(c, function(x, F, D) {
          return m = !!g(x, F, D), m;
        }), m;
      }
      function bu(c, g, m) {
        for (var x = -1, F = c.length; ++x < F; ) {
          var D = c[x], L = g(D);
          if (L != null && (N === r ? L === L && !qr(L) : m(L, N)))
            var N = L, H = D;
        }
        return H;
      }
      function ak(c, g, m, x) {
        var F = c.length;
        for (m = Be(m), m < 0 && (m = -m > F ? 0 : F + m), x = x === r || x > F ? F : Be(x), x < 0 && (x += F), x = m > x ? 0 : zb(x); m < x; )
          c[m++] = g;
        return c;
      }
      function bw(c, g) {
        var m = [];
        return Ki(c, function(x, F, D) {
          g(x, F, D) && m.push(x);
        }), m;
      }
      function ir(c, g, m, x, F) {
        var D = -1, L = c.length;
        for (m || (m = Yk), F || (F = []); ++D < L; ) {
          var N = c[D];
          g > 0 && m(N) ? g > 1 ? ir(N, g - 1, m, x, F) : $i(F, N) : x || (F[F.length] = N);
        }
        return F;
      }
      var bf = Kw(), Sw = Kw(!0);
      function Un(c, g) {
        return c && bf(c, g, Zt);
      }
      function Sf(c, g) {
        return c && Sw(c, g, Zt);
      }
      function Su(c, g) {
        return Vi(g, function(m) {
          return wi(c[m]);
        });
      }
      function Oo(c, g) {
        g = Yi(g, c);
        for (var m = 0, x = g.length; c != null && m < x; )
          c = c[qn(g[m++])];
        return m && m == x ? c : r;
      }
      function xw(c, g, m) {
        var x = g(c);
        return ze(c) ? x : $i(x, m(c));
      }
      function vr(c) {
        return c == null ? c === r ? Po : Je : Fo && Fo in pt(c) ? Vk(c) : rL(c);
      }
      function xf(c, g) {
        return c > g;
      }
      function lk(c, g) {
        return c != null && gt.call(c, g);
      }
      function ck(c, g) {
        return c != null && g in pt(c);
      }
      function uk(c, g, m) {
        return c >= lr(g, m) && c < qt(g, m);
      }
      function Rf(c, g, m) {
        for (var x = m ? sf : nu, F = c[0].length, D = c.length, L = D, N = Y(D), H = 1 / 0, ae = []; L--; ) {
          var le = c[L];
          L && g && (le = Pt(le, Ur(g))), H = lr(le.length, H), N[L] = !m && (g || F >= 120 && le.length >= 120) ? new To(L && le) : r;
        }
        le = c[0];
        var ue = -1, we = N[0];
        e:
          for (; ++ue < F && ae.length < H; ) {
            var Ee = le[ue], Oe = g ? g(Ee) : Ee;
            if (Ee = m || Ee !== 0 ? Ee : 0, !(we ? sl(we, Oe) : x(ae, Oe, m))) {
              for (L = D; --L; ) {
                var Ge = N[L];
                if (!(Ge ? sl(Ge, Oe) : x(c[L], Oe, m)))
                  continue e;
              }
              we && we.push(Oe), ae.push(Ee);
            }
          }
        return ae;
      }
      function dk(c, g, m, x) {
        return Un(c, function(F, D, L) {
          g(x, m(F), D, L);
        }), x;
      }
      function fl(c, g, m) {
        g = Yi(g, c), c = ub(c, g);
        var x = c == null ? c : c[qn(hn(g))];
        return x == null ? r : jr(x, c, m);
      }
      function Rw(c) {
        return It(c) && vr(c) == me;
      }
      function hk(c) {
        return It(c) && vr(c) == Ot;
      }
      function gk(c) {
        return It(c) && vr(c) == ee;
      }
      function pl(c, g, m, x, F) {
        return c === g ? !0 : c == null || g == null || !It(c) && !It(g) ? c !== c && g !== g : fk(c, g, m, x, pl, F);
      }
      function fk(c, g, m, x, F, D) {
        var L = ze(c), N = ze(g), H = L ? ve : cr(c), ae = N ? ve : cr(g);
        H = H == me ? nt : H, ae = ae == me ? nt : ae;
        var le = H == nt, ue = ae == nt, we = H == ae;
        if (we && Xi(c)) {
          if (!Xi(g))
            return !1;
          L = !0, le = !1;
        }
        if (we && !le)
          return D || (D = new Mn()), L || Ls(c) ? nb(c, g, m, x, F, D) : Hk(c, g, H, m, x, F, D);
        if (!(m & y)) {
          var Ee = le && gt.call(c, "__wrapped__"), Oe = ue && gt.call(g, "__wrapped__");
          if (Ee || Oe) {
            var Ge = Ee ? c.value() : c, Ie = Oe ? g.value() : g;
            return D || (D = new Mn()), F(Ge, Ie, m, x, D);
          }
        }
        return we ? (D || (D = new Mn()), Wk(c, g, m, x, F, D)) : !1;
      }
      function pk(c) {
        return It(c) && cr(c) == oe;
      }
      function Ef(c, g, m, x) {
        var F = m.length, D = F, L = !x;
        if (c == null)
          return !D;
        for (c = pt(c); F--; ) {
          var N = m[F];
          if (L && N[2] ? N[1] !== c[N[0]] : !(N[0] in c))
            return !1;
        }
        for (; ++F < D; ) {
          N = m[F];
          var H = N[0], ae = c[H], le = N[1];
          if (L && N[2]) {
            if (ae === r && !(H in c))
              return !1;
          } else {
            var ue = new Mn();
            if (x)
              var we = x(ae, le, H, c, g, ue);
            if (!(we === r ? pl(le, ae, y | C, x, ue) : we))
              return !1;
          }
        }
        return !0;
      }
      function Ew(c) {
        if (!Mt(c) || Xk(c))
          return !1;
        var g = wi(c) ? pI : oO;
        return g.test(ko(c));
      }
      function mk(c) {
        return It(c) && vr(c) == Nt;
      }
      function vk(c) {
        return It(c) && cr(c) == Et;
      }
      function yk(c) {
        return It(c) && Bu(c.length) && !!St[vr(c)];
      }
      function Pw(c) {
        return typeof c == "function" ? c : c == null ? _r : typeof c == "object" ? ze(c) ? Mw(c[0], c[1]) : Fw(c) : qb(c);
      }
      function Pf(c) {
        if (!yl(c))
          return bI(c);
        var g = [];
        for (var m in pt(c))
          gt.call(c, m) && m != "constructor" && g.push(m);
        return g;
      }
      function Ck(c) {
        if (!Mt(c))
          return tL(c);
        var g = yl(c), m = [];
        for (var x in c)
          x == "constructor" && (g || !gt.call(c, x)) || m.push(x);
        return m;
      }
      function Af(c, g) {
        return c < g;
      }
      function Aw(c, g) {
        var m = -1, x = kr(c) ? Y(c.length) : [];
        return Ki(c, function(F, D, L) {
          x[++m] = g(F, D, L);
        }), x;
      }
      function Fw(c) {
        var g = Wf(c);
        return g.length == 1 && g[0][2] ? lb(g[0][0], g[0][1]) : function(m) {
          return m === c || Ef(m, c, g);
        };
      }
      function Mw(c, g) {
        return $f(c) && ab(g) ? lb(qn(c), g) : function(m) {
          var x = ep(m, c);
          return x === r && x === g ? tp(m, c) : pl(g, x, y | C);
        };
      }
      function xu(c, g, m, x, F) {
        c !== g && bf(g, function(D, L) {
          if (F || (F = new Mn()), Mt(D))
            wk(c, g, L, m, xu, x, F);
          else {
            var N = x ? x(Uf(c, L), D, L + "", c, g, F) : r;
            N === r && (N = D), Cf(c, L, N);
          }
        }, Lr);
      }
      function wk(c, g, m, x, F, D, L) {
        var N = Uf(c, m), H = Uf(g, m), ae = L.get(H);
        if (ae) {
          Cf(c, m, ae);
          return;
        }
        var le = D ? D(N, H, m + "", c, g, L) : r, ue = le === r;
        if (ue) {
          var we = ze(H), Ee = !we && Xi(H), Oe = !we && !Ee && Ls(H);
          le = H, we || Ee || Oe ? ze(N) ? le = N : Bt(N) ? le = Ir(N) : Ee ? (ue = !1, le = Hw(H, !0)) : Oe ? (ue = !1, le = Ww(H, !0)) : le = [] : wl(H) || Lo(H) ? (le = N, Lo(N) ? le = Nb(N) : (!Mt(N) || wi(N)) && (le = sb(H))) : ue = !1;
        }
        ue && (L.set(H, le), F(le, H, x, D, L), L.delete(H)), Cf(c, m, le);
      }
      function Tw(c, g) {
        var m = c.length;
        if (m)
          return g += g < 0 ? m : 0, Ci(g, m) ? c[g] : r;
      }
      function Dw(c, g, m) {
        g.length ? g = Pt(g, function(D) {
          return ze(D) ? function(L) {
            return Oo(L, D.length === 1 ? D[0] : D);
          } : D;
        }) : g = [_r];
        var x = -1;
        g = Pt(g, Ur(De()));
        var F = Aw(c, function(D, L, N) {
          var H = Pt(g, function(ae) {
            return ae(D);
          });
          return { criteria: H, index: ++x, value: D };
        });
        return KO(F, function(D, L) {
          return Ik(D, L, m);
        });
      }
      function bk(c, g) {
        return Ow(c, g, function(m, x) {
          return tp(c, x);
        });
      }
      function Ow(c, g, m) {
        for (var x = -1, F = g.length, D = {}; ++x < F; ) {
          var L = g[x], N = Oo(c, L);
          m(N, L) && ml(D, Yi(L, c), N);
        }
        return D;
      }
      function Sk(c) {
        return function(g) {
          return Oo(g, c);
        };
      }
      function Ff(c, g, m, x) {
        var F = x ? UO : Rs, D = -1, L = g.length, N = c;
        for (c === g && (g = Ir(g)), m && (N = Pt(c, Ur(m))); ++D < L; )
          for (var H = 0, ae = g[D], le = m ? m(ae) : ae; (H = F(N, le, H, x)) > -1; )
            N !== c && gu.call(N, H, 1), gu.call(c, H, 1);
        return c;
      }
      function Iw(c, g) {
        for (var m = c ? g.length : 0, x = m - 1; m--; ) {
          var F = g[m];
          if (m == x || F !== D) {
            var D = F;
            Ci(F) ? gu.call(c, F, 1) : Of(c, F);
          }
        }
        return c;
      }
      function Mf(c, g) {
        return c + mu(gw() * (g - c + 1));
      }
      function xk(c, g, m, x) {
        for (var F = -1, D = qt(pu((g - c) / (m || 1)), 0), L = Y(D); D--; )
          L[x ? D : ++F] = c, c += m;
        return L;
      }
      function Tf(c, g) {
        var m = "";
        if (!c || g < 1 || g > te)
          return m;
        do
          g % 2 && (m += c), g = mu(g / 2), g && (c += c);
        while (g);
        return m;
      }
      function Ve(c, g) {
        return Kf(cb(c, g, _r), c + "");
      }
      function Rk(c) {
        return mw(_s(c));
      }
      function Ek(c, g) {
        var m = _s(c);
        return Iu(m, Do(g, 0, m.length));
      }
      function ml(c, g, m, x) {
        if (!Mt(c))
          return c;
        g = Yi(g, c);
        for (var F = -1, D = g.length, L = D - 1, N = c; N != null && ++F < D; ) {
          var H = qn(g[F]), ae = m;
          if (H === "__proto__" || H === "constructor" || H === "prototype")
            return c;
          if (F != L) {
            var le = N[H];
            ae = x ? x(le, H, N) : r, ae === r && (ae = Mt(le) ? le : Ci(g[F + 1]) ? [] : {});
          }
          hl(N, H, ae), N = N[H];
        }
        return c;
      }
      var kw = vu ? function(c, g) {
        return vu.set(c, g), c;
      } : _r, Pk = fu ? function(c, g) {
        return fu(c, "toString", {
          configurable: !0,
          enumerable: !1,
          value: np(g),
          writable: !0
        });
      } : _r;
      function Ak(c) {
        return Iu(_s(c));
      }
      function dn(c, g, m) {
        var x = -1, F = c.length;
        g < 0 && (g = -g > F ? 0 : F + g), m = m > F ? F : m, m < 0 && (m += F), F = g > m ? 0 : m - g >>> 0, g >>>= 0;
        for (var D = Y(F); ++x < F; )
          D[x] = c[x + g];
        return D;
      }
      function Fk(c, g) {
        var m;
        return Ki(c, function(x, F, D) {
          return m = g(x, F, D), !m;
        }), !!m;
      }
      function Ru(c, g, m) {
        var x = 0, F = c == null ? x : c.length;
        if (typeof g == "number" && g === g && F <= he) {
          for (; x < F; ) {
            var D = x + F >>> 1, L = c[D];
            L !== null && !qr(L) && (m ? L <= g : L < g) ? x = D + 1 : F = D;
          }
          return F;
        }
        return Df(c, g, _r, m);
      }
      function Df(c, g, m, x) {
        var F = 0, D = c == null ? 0 : c.length;
        if (D === 0)
          return 0;
        g = m(g);
        for (var L = g !== g, N = g === null, H = qr(g), ae = g === r; F < D; ) {
          var le = mu((F + D) / 2), ue = m(c[le]), we = ue !== r, Ee = ue === null, Oe = ue === ue, Ge = qr(ue);
          if (L)
            var Ie = x || Oe;
          else ae ? Ie = Oe && (x || we) : N ? Ie = Oe && we && (x || !Ee) : H ? Ie = Oe && we && !Ee && (x || !Ge) : Ee || Ge ? Ie = !1 : Ie = x ? ue <= g : ue < g;
          Ie ? F = le + 1 : D = le;
        }
        return lr(D, X);
      }
      function Lw(c, g) {
        for (var m = -1, x = c.length, F = 0, D = []; ++m < x; ) {
          var L = c[m], N = g ? g(L) : L;
          if (!m || !Tn(N, H)) {
            var H = N;
            D[F++] = L === 0 ? 0 : L;
          }
        }
        return D;
      }
      function _w(c) {
        return typeof c == "number" ? c : qr(c) ? W : +c;
      }
      function Kr(c) {
        if (typeof c == "string")
          return c;
        if (ze(c))
          return Pt(c, Kr) + "";
        if (qr(c))
          return fw ? fw.call(c) : "";
        var g = c + "";
        return g == "0" && 1 / c == -Z ? "-0" : g;
      }
      function qi(c, g, m) {
        var x = -1, F = nu, D = c.length, L = !0, N = [], H = N;
        if (m)
          L = !1, F = sf;
        else if (D >= i) {
          var ae = g ? null : Bk(c);
          if (ae)
            return ou(ae);
          L = !1, F = sl, H = new To();
        } else
          H = g ? [] : N;
        e:
          for (; ++x < D; ) {
            var le = c[x], ue = g ? g(le) : le;
            if (le = m || le !== 0 ? le : 0, L && ue === ue) {
              for (var we = H.length; we--; )
                if (H[we] === ue)
                  continue e;
              g && H.push(ue), N.push(le);
            } else F(H, ue, m) || (H !== N && H.push(ue), N.push(le));
          }
        return N;
      }
      function Of(c, g) {
        return g = Yi(g, c), c = ub(c, g), c == null || delete c[qn(hn(g))];
      }
      function zw(c, g, m, x) {
        return ml(c, g, m(Oo(c, g)), x);
      }
      function Eu(c, g, m, x) {
        for (var F = c.length, D = x ? F : -1; (x ? D-- : ++D < F) && g(c[D], D, c); )
          ;
        return m ? dn(c, x ? 0 : D, x ? D + 1 : F) : dn(c, x ? D + 1 : 0, x ? F : D);
      }
      function Nw(c, g) {
        var m = c;
        return m instanceof qe && (m = m.value()), af(g, function(x, F) {
          return F.func.apply(F.thisArg, $i([x], F.args));
        }, m);
      }
      function If(c, g, m) {
        var x = c.length;
        if (x < 2)
          return x ? qi(c[0]) : [];
        for (var F = -1, D = Y(x); ++F < x; )
          for (var L = c[F], N = -1; ++N < x; )
            N != F && (D[F] = gl(D[F] || L, c[N], g, m));
        return qi(ir(D, 1), g, m);
      }
      function Bw(c, g, m) {
        for (var x = -1, F = c.length, D = g.length, L = {}; ++x < F; ) {
          var N = x < D ? g[x] : r;
          m(L, c[x], N);
        }
        return L;
      }
      function kf(c) {
        return Bt(c) ? c : [];
      }
      function Lf(c) {
        return typeof c == "function" ? c : _r;
      }
      function Yi(c, g) {
        return ze(c) ? c : $f(c, g) ? [c] : fb(at(c));
      }
      var Mk = Ve;
      function Ji(c, g, m) {
        var x = c.length;
        return m = m === r ? x : m, !g && m >= x ? c : dn(c, g, m);
      }
      var Gw = mI || function(c) {
        return nr.clearTimeout(c);
      };
      function Hw(c, g) {
        if (g)
          return c.slice();
        var m = c.length, x = lw ? lw(m) : new c.constructor(m);
        return c.copy(x), x;
      }
      function _f(c) {
        var g = new c.constructor(c.byteLength);
        return new du(g).set(new du(c)), g;
      }
      function Tk(c, g) {
        var m = g ? _f(c.buffer) : c.buffer;
        return new c.constructor(m, c.byteOffset, c.byteLength);
      }
      function Dk(c) {
        var g = new c.constructor(c.source, RC.exec(c));
        return g.lastIndex = c.lastIndex, g;
      }
      function Ok(c) {
        return dl ? pt(dl.call(c)) : {};
      }
      function Ww(c, g) {
        var m = g ? _f(c.buffer) : c.buffer;
        return new c.constructor(m, c.byteOffset, c.length);
      }
      function Vw(c, g) {
        if (c !== g) {
          var m = c !== r, x = c === null, F = c === c, D = qr(c), L = g !== r, N = g === null, H = g === g, ae = qr(g);
          if (!N && !ae && !D && c > g || D && L && H && !N && !ae || x && L && H || !m && H || !F)
            return 1;
          if (!x && !D && !ae && c < g || ae && m && F && !x && !D || N && m && F || !L && F || !H)
            return -1;
        }
        return 0;
      }
      function Ik(c, g, m) {
        for (var x = -1, F = c.criteria, D = g.criteria, L = F.length, N = m.length; ++x < L; ) {
          var H = Vw(F[x], D[x]);
          if (H) {
            if (x >= N)
              return H;
            var ae = m[x];
            return H * (ae == "desc" ? -1 : 1);
          }
        }
        return c.index - g.index;
      }
      function $w(c, g, m, x) {
        for (var F = -1, D = c.length, L = m.length, N = -1, H = g.length, ae = qt(D - L, 0), le = Y(H + ae), ue = !x; ++N < H; )
          le[N] = g[N];
        for (; ++F < L; )
          (ue || F < D) && (le[m[F]] = c[F]);
        for (; ae--; )
          le[N++] = c[F++];
        return le;
      }
      function jw(c, g, m, x) {
        for (var F = -1, D = c.length, L = -1, N = m.length, H = -1, ae = g.length, le = qt(D - N, 0), ue = Y(le + ae), we = !x; ++F < le; )
          ue[F] = c[F];
        for (var Ee = F; ++H < ae; )
          ue[Ee + H] = g[H];
        for (; ++L < N; )
          (we || F < D) && (ue[Ee + m[L]] = c[F++]);
        return ue;
      }
      function Ir(c, g) {
        var m = -1, x = c.length;
        for (g || (g = Y(x)); ++m < x; )
          g[m] = c[m];
        return g;
      }
      function Kn(c, g, m, x) {
        var F = !m;
        m || (m = {});
        for (var D = -1, L = g.length; ++D < L; ) {
          var N = g[D], H = x ? x(m[N], c[N], N, m, c) : r;
          H === r && (H = c[N]), F ? mi(m, N, H) : hl(m, N, H);
        }
        return m;
      }
      function kk(c, g) {
        return Kn(c, Vf(c), g);
      }
      function Lk(c, g) {
        return Kn(c, ib(c), g);
      }
      function Pu(c, g) {
        return function(m, x) {
          var F = ze(m) ? GO : nk, D = g ? g() : {};
          return F(m, c, De(x, 2), D);
        };
      }
      function Os(c) {
        return Ve(function(g, m) {
          var x = -1, F = m.length, D = F > 1 ? m[F - 1] : r, L = F > 2 ? m[2] : r;
          for (D = c.length > 3 && typeof D == "function" ? (F--, D) : r, L && yr(m[0], m[1], L) && (D = F < 3 ? r : D, F = 1), g = pt(g); ++x < F; ) {
            var N = m[x];
            N && c(g, N, x, D);
          }
          return g;
        });
      }
      function Uw(c, g) {
        return function(m, x) {
          if (m == null)
            return m;
          if (!kr(m))
            return c(m, x);
          for (var F = m.length, D = g ? F : -1, L = pt(m); (g ? D-- : ++D < F) && x(L[D], D, L) !== !1; )
            ;
          return m;
        };
      }
      function Kw(c) {
        return function(g, m, x) {
          for (var F = -1, D = pt(g), L = x(g), N = L.length; N--; ) {
            var H = L[c ? N : ++F];
            if (m(D[H], H, D) === !1)
              break;
          }
          return g;
        };
      }
      function _k(c, g, m) {
        var x = g & v, F = vl(c);
        function D() {
          var L = this && this !== nr && this instanceof D ? F : c;
          return L.apply(x ? m : this, arguments);
        }
        return D;
      }
      function qw(c) {
        return function(g) {
          g = at(g);
          var m = Es(g) ? Fn(g) : r, x = m ? m[0] : g.charAt(0), F = m ? Ji(m, 1).join("") : g.slice(1);
          return x[c]() + F;
        };
      }
      function Is(c) {
        return function(g) {
          return af(Ub(jb(g).replace(PO, "")), c, "");
        };
      }
      function vl(c) {
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return new c();
            case 1:
              return new c(g[0]);
            case 2:
              return new c(g[0], g[1]);
            case 3:
              return new c(g[0], g[1], g[2]);
            case 4:
              return new c(g[0], g[1], g[2], g[3]);
            case 5:
              return new c(g[0], g[1], g[2], g[3], g[4]);
            case 6:
              return new c(g[0], g[1], g[2], g[3], g[4], g[5]);
            case 7:
              return new c(g[0], g[1], g[2], g[3], g[4], g[5], g[6]);
          }
          var m = Ds(c.prototype), x = c.apply(m, g);
          return Mt(x) ? x : m;
        };
      }
      function zk(c, g, m) {
        var x = vl(c);
        function F() {
          for (var D = arguments.length, L = Y(D), N = D, H = ks(F); N--; )
            L[N] = arguments[N];
          var ae = D < 3 && L[0] !== H && L[D - 1] !== H ? [] : ji(L, H);
          if (D -= ae.length, D < m)
            return Zw(
              c,
              g,
              Au,
              F.placeholder,
              r,
              L,
              ae,
              r,
              r,
              m - D
            );
          var le = this && this !== nr && this instanceof F ? x : c;
          return jr(le, this, L);
        }
        return F;
      }
      function Yw(c) {
        return function(g, m, x) {
          var F = pt(g);
          if (!kr(g)) {
            var D = De(m, 3);
            g = Zt(g), m = function(N) {
              return D(F[N], N, F);
            };
          }
          var L = c(g, m, x);
          return L > -1 ? F[D ? g[L] : L] : r;
        };
      }
      function Jw(c) {
        return yi(function(g) {
          var m = g.length, x = m, F = cn.prototype.thru;
          for (c && g.reverse(); x--; ) {
            var D = g[x];
            if (typeof D != "function")
              throw new ln(s);
            if (F && !L && Du(D) == "wrapper")
              var L = new cn([], !0);
          }
          for (x = L ? x : m; ++x < m; ) {
            D = g[x];
            var N = Du(D), H = N == "wrapper" ? Hf(D) : r;
            H && jf(H[0]) && H[1] == (A | b | S | M) && !H[4].length && H[9] == 1 ? L = L[Du(H[0])].apply(L, H[3]) : L = D.length == 1 && jf(D) ? L[N]() : L.thru(D);
          }
          return function() {
            var ae = arguments, le = ae[0];
            if (L && ae.length == 1 && ze(le))
              return L.plant(le).value();
            for (var ue = 0, we = m ? g[ue].apply(this, ae) : le; ++ue < m; )
              we = g[ue].call(this, we);
            return we;
          };
        });
      }
      function Au(c, g, m, x, F, D, L, N, H, ae) {
        var le = g & A, ue = g & v, we = g & w, Ee = g & (b | P), Oe = g & I, Ge = we ? r : vl(c);
        function Ie() {
          for (var Ue = arguments.length, Xe = Y(Ue), Yr = Ue; Yr--; )
            Xe[Yr] = arguments[Yr];
          if (Ee)
            var Cr = ks(Ie), Jr = YO(Xe, Cr);
          if (x && (Xe = $w(Xe, x, F, Ee)), D && (Xe = jw(Xe, D, L, Ee)), Ue -= Jr, Ee && Ue < ae) {
            var Gt = ji(Xe, Cr);
            return Zw(
              c,
              g,
              Au,
              Ie.placeholder,
              m,
              Xe,
              Gt,
              N,
              H,
              ae - Ue
            );
          }
          var Dn = ue ? m : this, Si = we ? Dn[c] : c;
          return Ue = Xe.length, N ? Xe = nL(Xe, N) : Oe && Ue > 1 && Xe.reverse(), le && H < Ue && (Xe.length = H), this && this !== nr && this instanceof Ie && (Si = Ge || vl(Si)), Si.apply(Dn, Xe);
        }
        return Ie;
      }
      function Xw(c, g) {
        return function(m, x) {
          return dk(m, c, g(x), {});
        };
      }
      function Fu(c, g) {
        return function(m, x) {
          var F;
          if (m === r && x === r)
            return g;
          if (m !== r && (F = m), x !== r) {
            if (F === r)
              return x;
            typeof m == "string" || typeof x == "string" ? (m = Kr(m), x = Kr(x)) : (m = _w(m), x = _w(x)), F = c(m, x);
          }
          return F;
        };
      }
      function zf(c) {
        return yi(function(g) {
          return g = Pt(g, Ur(De())), Ve(function(m) {
            var x = this;
            return c(g, function(F) {
              return jr(F, x, m);
            });
          });
        });
      }
      function Mu(c, g) {
        g = g === r ? " " : Kr(g);
        var m = g.length;
        if (m < 2)
          return m ? Tf(g, c) : g;
        var x = Tf(g, pu(c / Ps(g)));
        return Es(g) ? Ji(Fn(x), 0, c).join("") : x.slice(0, c);
      }
      function Nk(c, g, m, x) {
        var F = g & v, D = vl(c);
        function L() {
          for (var N = -1, H = arguments.length, ae = -1, le = x.length, ue = Y(le + H), we = this && this !== nr && this instanceof L ? D : c; ++ae < le; )
            ue[ae] = x[ae];
          for (; H--; )
            ue[ae++] = arguments[++N];
          return jr(we, F ? m : this, ue);
        }
        return L;
      }
      function Qw(c) {
        return function(g, m, x) {
          return x && typeof x != "number" && yr(g, m, x) && (m = x = r), g = bi(g), m === r ? (m = g, g = 0) : m = bi(m), x = x === r ? g < m ? 1 : -1 : bi(x), xk(g, m, x, c);
        };
      }
      function Tu(c) {
        return function(g, m) {
          return typeof g == "string" && typeof m == "string" || (g = gn(g), m = gn(m)), c(g, m);
        };
      }
      function Zw(c, g, m, x, F, D, L, N, H, ae) {
        var le = g & b, ue = le ? L : r, we = le ? r : L, Ee = le ? D : r, Oe = le ? r : D;
        g |= le ? S : E, g &= ~(le ? E : S), g & R || (g &= -4);
        var Ge = [
          c,
          g,
          F,
          Ee,
          ue,
          Oe,
          we,
          N,
          H,
          ae
        ], Ie = m.apply(r, Ge);
        return jf(c) && db(Ie, Ge), Ie.placeholder = x, hb(Ie, c, g);
      }
      function Nf(c) {
        var g = Kt[c];
        return function(m, x) {
          if (m = gn(m), x = x == null ? 0 : lr(Be(x), 292), x && hw(m)) {
            var F = (at(m) + "e").split("e"), D = g(F[0] + "e" + (+F[1] + x));
            return F = (at(D) + "e").split("e"), +(F[0] + "e" + (+F[1] - x));
          }
          return g(m);
        };
      }
      var Bk = Ms && 1 / ou(new Ms([, -0]))[1] == Z ? function(c) {
        return new Ms(c);
      } : sp;
      function eb(c) {
        return function(g) {
          var m = cr(g);
          return m == oe ? ff(g) : m == Et ? rI(g) : qO(g, c(g));
        };
      }
      function vi(c, g, m, x, F, D, L, N) {
        var H = g & w;
        if (!H && typeof c != "function")
          throw new ln(s);
        var ae = x ? x.length : 0;
        if (ae || (g &= -97, x = F = r), L = L === r ? L : qt(Be(L), 0), N = N === r ? N : Be(N), ae -= F ? F.length : 0, g & E) {
          var le = x, ue = F;
          x = F = r;
        }
        var we = H ? r : Hf(c), Ee = [
          c,
          g,
          m,
          x,
          F,
          le,
          ue,
          D,
          L,
          N
        ];
        if (we && eL(Ee, we), c = Ee[0], g = Ee[1], m = Ee[2], x = Ee[3], F = Ee[4], N = Ee[9] = Ee[9] === r ? H ? 0 : c.length : qt(Ee[9] - ae, 0), !N && g & (b | P) && (g &= -25), !g || g == v)
          var Oe = _k(c, g, m);
        else g == b || g == P ? Oe = zk(c, g, N) : (g == S || g == (v | S)) && !F.length ? Oe = Nk(c, g, m, x) : Oe = Au.apply(r, Ee);
        var Ge = we ? kw : db;
        return hb(Ge(Oe, Ee), c, g);
      }
      function tb(c, g, m, x) {
        return c === r || Tn(c, Fs[m]) && !gt.call(x, m) ? g : c;
      }
      function rb(c, g, m, x, F, D) {
        return Mt(c) && Mt(g) && (D.set(g, c), xu(c, g, r, rb, D), D.delete(g)), c;
      }
      function Gk(c) {
        return wl(c) ? r : c;
      }
      function nb(c, g, m, x, F, D) {
        var L = m & y, N = c.length, H = g.length;
        if (N != H && !(L && H > N))
          return !1;
        var ae = D.get(c), le = D.get(g);
        if (ae && le)
          return ae == g && le == c;
        var ue = -1, we = !0, Ee = m & C ? new To() : r;
        for (D.set(c, g), D.set(g, c); ++ue < N; ) {
          var Oe = c[ue], Ge = g[ue];
          if (x)
            var Ie = L ? x(Ge, Oe, ue, g, c, D) : x(Oe, Ge, ue, c, g, D);
          if (Ie !== r) {
            if (Ie)
              continue;
            we = !1;
            break;
          }
          if (Ee) {
            if (!lf(g, function(Ue, Xe) {
              if (!sl(Ee, Xe) && (Oe === Ue || F(Oe, Ue, m, x, D)))
                return Ee.push(Xe);
            })) {
              we = !1;
              break;
            }
          } else if (!(Oe === Ge || F(Oe, Ge, m, x, D))) {
            we = !1;
            break;
          }
        }
        return D.delete(c), D.delete(g), we;
      }
      function Hk(c, g, m, x, F, D, L) {
        switch (m) {
          case Wi:
            if (c.byteLength != g.byteLength || c.byteOffset != g.byteOffset)
              return !1;
            c = c.buffer, g = g.buffer;
          case Ot:
            return !(c.byteLength != g.byteLength || !D(new du(c), new du(g)));
          case Re:
          case ee:
          case Me:
            return Tn(+c, +g);
          case ye:
            return c.name == g.name && c.message == g.message;
          case Nt:
          case Ut:
            return c == g + "";
          case oe:
            var N = ff;
          case Et:
            var H = x & y;
            if (N || (N = ou), c.size != g.size && !H)
              return !1;
            var ae = L.get(c);
            if (ae)
              return ae == g;
            x |= C, L.set(c, g);
            var le = nb(N(c), N(g), x, F, D, L);
            return L.delete(c), le;
          case Or:
            if (dl)
              return dl.call(c) == dl.call(g);
        }
        return !1;
      }
      function Wk(c, g, m, x, F, D) {
        var L = m & y, N = Bf(c), H = N.length, ae = Bf(g), le = ae.length;
        if (H != le && !L)
          return !1;
        for (var ue = H; ue--; ) {
          var we = N[ue];
          if (!(L ? we in g : gt.call(g, we)))
            return !1;
        }
        var Ee = D.get(c), Oe = D.get(g);
        if (Ee && Oe)
          return Ee == g && Oe == c;
        var Ge = !0;
        D.set(c, g), D.set(g, c);
        for (var Ie = L; ++ue < H; ) {
          we = N[ue];
          var Ue = c[we], Xe = g[we];
          if (x)
            var Yr = L ? x(Xe, Ue, we, g, c, D) : x(Ue, Xe, we, c, g, D);
          if (!(Yr === r ? Ue === Xe || F(Ue, Xe, m, x, D) : Yr)) {
            Ge = !1;
            break;
          }
          Ie || (Ie = we == "constructor");
        }
        if (Ge && !Ie) {
          var Cr = c.constructor, Jr = g.constructor;
          Cr != Jr && "constructor" in c && "constructor" in g && !(typeof Cr == "function" && Cr instanceof Cr && typeof Jr == "function" && Jr instanceof Jr) && (Ge = !1);
        }
        return D.delete(c), D.delete(g), Ge;
      }
      function yi(c) {
        return Kf(cb(c, r, yb), c + "");
      }
      function Bf(c) {
        return xw(c, Zt, Vf);
      }
      function Gf(c) {
        return xw(c, Lr, ib);
      }
      var Hf = vu ? function(c) {
        return vu.get(c);
      } : sp;
      function Du(c) {
        for (var g = c.name + "", m = Ts[g], x = gt.call(Ts, g) ? m.length : 0; x--; ) {
          var F = m[x], D = F.func;
          if (D == null || D == c)
            return F.name;
        }
        return g;
      }
      function ks(c) {
        var g = gt.call(T, "placeholder") ? T : c;
        return g.placeholder;
      }
      function De() {
        var c = T.iteratee || ip;
        return c = c === ip ? Pw : c, arguments.length ? c(arguments[0], arguments[1]) : c;
      }
      function Ou(c, g) {
        var m = c.__data__;
        return Jk(g) ? m[typeof g == "string" ? "string" : "hash"] : m.map;
      }
      function Wf(c) {
        for (var g = Zt(c), m = g.length; m--; ) {
          var x = g[m], F = c[x];
          g[m] = [x, F, ab(F)];
        }
        return g;
      }
      function Io(c, g) {
        var m = ZO(c, g);
        return Ew(m) ? m : r;
      }
      function Vk(c) {
        var g = gt.call(c, Fo), m = c[Fo];
        try {
          c[Fo] = r;
          var x = !0;
        } catch {
        }
        var F = cu.call(c);
        return x && (g ? c[Fo] = m : delete c[Fo]), F;
      }
      var Vf = mf ? function(c) {
        return c == null ? [] : (c = pt(c), Vi(mf(c), function(g) {
          return uw.call(c, g);
        }));
      } : ap, ib = mf ? function(c) {
        for (var g = []; c; )
          $i(g, Vf(c)), c = hu(c);
        return g;
      } : ap, cr = vr;
      (vf && cr(new vf(new ArrayBuffer(1))) != Wi || ll && cr(new ll()) != oe || yf && cr(yf.resolve()) != $r || Ms && cr(new Ms()) != Et || cl && cr(new cl()) != on) && (cr = function(c) {
        var g = vr(c), m = g == nt ? c.constructor : r, x = m ? ko(m) : "";
        if (x)
          switch (x) {
            case EI:
              return Wi;
            case PI:
              return oe;
            case AI:
              return $r;
            case FI:
              return Et;
            case MI:
              return on;
          }
        return g;
      });
      function $k(c, g, m) {
        for (var x = -1, F = m.length; ++x < F; ) {
          var D = m[x], L = D.size;
          switch (D.type) {
            case "drop":
              c += L;
              break;
            case "dropRight":
              g -= L;
              break;
            case "take":
              g = lr(g, c + L);
              break;
            case "takeRight":
              c = qt(c, g - L);
              break;
          }
        }
        return { start: c, end: g };
      }
      function jk(c) {
        var g = c.match(XD);
        return g ? g[1].split(QD) : [];
      }
      function ob(c, g, m) {
        g = Yi(g, c);
        for (var x = -1, F = g.length, D = !1; ++x < F; ) {
          var L = qn(g[x]);
          if (!(D = c != null && m(c, L)))
            break;
          c = c[L];
        }
        return D || ++x != F ? D : (F = c == null ? 0 : c.length, !!F && Bu(F) && Ci(L, F) && (ze(c) || Lo(c)));
      }
      function Uk(c) {
        var g = c.length, m = new c.constructor(g);
        return g && typeof c[0] == "string" && gt.call(c, "index") && (m.index = c.index, m.input = c.input), m;
      }
      function sb(c) {
        return typeof c.constructor == "function" && !yl(c) ? Ds(hu(c)) : {};
      }
      function Kk(c, g, m) {
        var x = c.constructor;
        switch (g) {
          case Ot:
            return _f(c);
          case Re:
          case ee:
            return new x(+c);
          case Wi:
            return Tk(c, m);
          case Hg:
          case Wg:
          case Vg:
          case $g:
          case jg:
          case Ug:
          case Kg:
          case qg:
          case Yg:
            return Ww(c, m);
          case oe:
            return new x();
          case Me:
          case Ut:
            return new x(c);
          case Nt:
            return Dk(c);
          case Et:
            return new x();
          case Or:
            return Ok(c);
        }
      }
      function qk(c, g) {
        var m = g.length;
        if (!m)
          return c;
        var x = m - 1;
        return g[x] = (m > 1 ? "& " : "") + g[x], g = g.join(m > 2 ? ", " : " "), c.replace(JD, `{
/* [wrapped with ` + g + `] */
`);
      }
      function Yk(c) {
        return ze(c) || Lo(c) || !!(dw && c && c[dw]);
      }
      function Ci(c, g) {
        var m = typeof c;
        return g = g ?? te, !!g && (m == "number" || m != "symbol" && aO.test(c)) && c > -1 && c % 1 == 0 && c < g;
      }
      function yr(c, g, m) {
        if (!Mt(m))
          return !1;
        var x = typeof g;
        return (x == "number" ? kr(m) && Ci(g, m.length) : x == "string" && g in m) ? Tn(m[g], c) : !1;
      }
      function $f(c, g) {
        if (ze(c))
          return !1;
        var m = typeof c;
        return m == "number" || m == "symbol" || m == "boolean" || c == null || qr(c) ? !0 : UD.test(c) || !jD.test(c) || g != null && c in pt(g);
      }
      function Jk(c) {
        var g = typeof c;
        return g == "string" || g == "number" || g == "symbol" || g == "boolean" ? c !== "__proto__" : c === null;
      }
      function jf(c) {
        var g = Du(c), m = T[g];
        if (typeof m != "function" || !(g in qe.prototype))
          return !1;
        if (c === m)
          return !0;
        var x = Hf(m);
        return !!x && c === x[0];
      }
      function Xk(c) {
        return !!aw && aw in c;
      }
      var Qk = au ? wi : lp;
      function yl(c) {
        var g = c && c.constructor, m = typeof g == "function" && g.prototype || Fs;
        return c === m;
      }
      function ab(c) {
        return c === c && !Mt(c);
      }
      function lb(c, g) {
        return function(m) {
          return m == null ? !1 : m[c] === g && (g !== r || c in pt(m));
        };
      }
      function Zk(c) {
        var g = zu(c, function(x) {
          return m.size === u && m.clear(), x;
        }), m = g.cache;
        return g;
      }
      function eL(c, g) {
        var m = c[1], x = g[1], F = m | x, D = F < (v | w | A), L = x == A && m == b || x == A && m == M && c[7].length <= g[8] || x == (A | M) && g[7].length <= g[8] && m == b;
        if (!(D || L))
          return c;
        x & v && (c[2] = g[2], F |= m & v ? 0 : R);
        var N = g[3];
        if (N) {
          var H = c[3];
          c[3] = H ? $w(H, N, g[4]) : N, c[4] = H ? ji(c[3], d) : g[4];
        }
        return N = g[5], N && (H = c[5], c[5] = H ? jw(H, N, g[6]) : N, c[6] = H ? ji(c[5], d) : g[6]), N = g[7], N && (c[7] = N), x & A && (c[8] = c[8] == null ? g[8] : lr(c[8], g[8])), c[9] == null && (c[9] = g[9]), c[0] = g[0], c[1] = F, c;
      }
      function tL(c) {
        var g = [];
        if (c != null)
          for (var m in pt(c))
            g.push(m);
        return g;
      }
      function rL(c) {
        return cu.call(c);
      }
      function cb(c, g, m) {
        return g = qt(g === r ? c.length - 1 : g, 0), function() {
          for (var x = arguments, F = -1, D = qt(x.length - g, 0), L = Y(D); ++F < D; )
            L[F] = x[g + F];
          F = -1;
          for (var N = Y(g + 1); ++F < g; )
            N[F] = x[F];
          return N[g] = m(L), jr(c, this, N);
        };
      }
      function ub(c, g) {
        return g.length < 2 ? c : Oo(c, dn(g, 0, -1));
      }
      function nL(c, g) {
        for (var m = c.length, x = lr(g.length, m), F = Ir(c); x--; ) {
          var D = g[x];
          c[x] = Ci(D, m) ? F[D] : r;
        }
        return c;
      }
      function Uf(c, g) {
        if (!(g === "constructor" && typeof c[g] == "function") && g != "__proto__")
          return c[g];
      }
      var db = gb(kw), Cl = yI || function(c, g) {
        return nr.setTimeout(c, g);
      }, Kf = gb(Pk);
      function hb(c, g, m) {
        var x = g + "";
        return Kf(c, qk(x, iL(jk(x), m)));
      }
      function gb(c) {
        var g = 0, m = 0;
        return function() {
          var x = SI(), F = q - (x - m);
          if (m = x, F > 0) {
            if (++g >= _)
              return arguments[0];
          } else
            g = 0;
          return c.apply(r, arguments);
        };
      }
      function Iu(c, g) {
        var m = -1, x = c.length, F = x - 1;
        for (g = g === r ? x : g; ++m < g; ) {
          var D = Mf(m, F), L = c[D];
          c[D] = c[m], c[m] = L;
        }
        return c.length = g, c;
      }
      var fb = Zk(function(c) {
        var g = [];
        return c.charCodeAt(0) === 46 && g.push(""), c.replace(KD, function(m, x, F, D) {
          g.push(F ? D.replace(tO, "$1") : x || m);
        }), g;
      });
      function qn(c) {
        if (typeof c == "string" || qr(c))
          return c;
        var g = c + "";
        return g == "0" && 1 / c == -Z ? "-0" : g;
      }
      function ko(c) {
        if (c != null) {
          try {
            return lu.call(c);
          } catch {
          }
          try {
            return c + "";
          } catch {
          }
        }
        return "";
      }
      function iL(c, g) {
        return an(ce, function(m) {
          var x = "_." + m[0];
          g & m[1] && !nu(c, x) && c.push(x);
        }), c.sort();
      }
      function pb(c) {
        if (c instanceof qe)
          return c.clone();
        var g = new cn(c.__wrapped__, c.__chain__);
        return g.__actions__ = Ir(c.__actions__), g.__index__ = c.__index__, g.__values__ = c.__values__, g;
      }
      function oL(c, g, m) {
        (m ? yr(c, g, m) : g === r) ? g = 1 : g = qt(Be(g), 0);
        var x = c == null ? 0 : c.length;
        if (!x || g < 1)
          return [];
        for (var F = 0, D = 0, L = Y(pu(x / g)); F < x; )
          L[D++] = dn(c, F, F += g);
        return L;
      }
      function sL(c) {
        for (var g = -1, m = c == null ? 0 : c.length, x = 0, F = []; ++g < m; ) {
          var D = c[g];
          D && (F[x++] = D);
        }
        return F;
      }
      function aL() {
        var c = arguments.length;
        if (!c)
          return [];
        for (var g = Y(c - 1), m = arguments[0], x = c; x--; )
          g[x - 1] = arguments[x];
        return $i(ze(m) ? Ir(m) : [m], ir(g, 1));
      }
      var lL = Ve(function(c, g) {
        return Bt(c) ? gl(c, ir(g, 1, Bt, !0)) : [];
      }), cL = Ve(function(c, g) {
        var m = hn(g);
        return Bt(m) && (m = r), Bt(c) ? gl(c, ir(g, 1, Bt, !0), De(m, 2)) : [];
      }), uL = Ve(function(c, g) {
        var m = hn(g);
        return Bt(m) && (m = r), Bt(c) ? gl(c, ir(g, 1, Bt, !0), r, m) : [];
      });
      function dL(c, g, m) {
        var x = c == null ? 0 : c.length;
        return x ? (g = m || g === r ? 1 : Be(g), dn(c, g < 0 ? 0 : g, x)) : [];
      }
      function hL(c, g, m) {
        var x = c == null ? 0 : c.length;
        return x ? (g = m || g === r ? 1 : Be(g), g = x - g, dn(c, 0, g < 0 ? 0 : g)) : [];
      }
      function gL(c, g) {
        return c && c.length ? Eu(c, De(g, 3), !0, !0) : [];
      }
      function fL(c, g) {
        return c && c.length ? Eu(c, De(g, 3), !0) : [];
      }
      function pL(c, g, m, x) {
        var F = c == null ? 0 : c.length;
        return F ? (m && typeof m != "number" && yr(c, g, m) && (m = 0, x = F), ak(c, g, m, x)) : [];
      }
      function mb(c, g, m) {
        var x = c == null ? 0 : c.length;
        if (!x)
          return -1;
        var F = m == null ? 0 : Be(m);
        return F < 0 && (F = qt(x + F, 0)), iu(c, De(g, 3), F);
      }
      function vb(c, g, m) {
        var x = c == null ? 0 : c.length;
        if (!x)
          return -1;
        var F = x - 1;
        return m !== r && (F = Be(m), F = m < 0 ? qt(x + F, 0) : lr(F, x - 1)), iu(c, De(g, 3), F, !0);
      }
      function yb(c) {
        var g = c == null ? 0 : c.length;
        return g ? ir(c, 1) : [];
      }
      function mL(c) {
        var g = c == null ? 0 : c.length;
        return g ? ir(c, Z) : [];
      }
      function vL(c, g) {
        var m = c == null ? 0 : c.length;
        return m ? (g = g === r ? 1 : Be(g), ir(c, g)) : [];
      }
      function yL(c) {
        for (var g = -1, m = c == null ? 0 : c.length, x = {}; ++g < m; ) {
          var F = c[g];
          x[F[0]] = F[1];
        }
        return x;
      }
      function Cb(c) {
        return c && c.length ? c[0] : r;
      }
      function CL(c, g, m) {
        var x = c == null ? 0 : c.length;
        if (!x)
          return -1;
        var F = m == null ? 0 : Be(m);
        return F < 0 && (F = qt(x + F, 0)), Rs(c, g, F);
      }
      function wL(c) {
        var g = c == null ? 0 : c.length;
        return g ? dn(c, 0, -1) : [];
      }
      var bL = Ve(function(c) {
        var g = Pt(c, kf);
        return g.length && g[0] === c[0] ? Rf(g) : [];
      }), SL = Ve(function(c) {
        var g = hn(c), m = Pt(c, kf);
        return g === hn(m) ? g = r : m.pop(), m.length && m[0] === c[0] ? Rf(m, De(g, 2)) : [];
      }), xL = Ve(function(c) {
        var g = hn(c), m = Pt(c, kf);
        return g = typeof g == "function" ? g : r, g && m.pop(), m.length && m[0] === c[0] ? Rf(m, r, g) : [];
      });
      function RL(c, g) {
        return c == null ? "" : wI.call(c, g);
      }
      function hn(c) {
        var g = c == null ? 0 : c.length;
        return g ? c[g - 1] : r;
      }
      function EL(c, g, m) {
        var x = c == null ? 0 : c.length;
        if (!x)
          return -1;
        var F = x;
        return m !== r && (F = Be(m), F = F < 0 ? qt(x + F, 0) : lr(F, x - 1)), g === g ? iI(c, g, F) : iu(c, ZC, F, !0);
      }
      function PL(c, g) {
        return c && c.length ? Tw(c, Be(g)) : r;
      }
      var AL = Ve(wb);
      function wb(c, g) {
        return c && c.length && g && g.length ? Ff(c, g) : c;
      }
      function FL(c, g, m) {
        return c && c.length && g && g.length ? Ff(c, g, De(m, 2)) : c;
      }
      function ML(c, g, m) {
        return c && c.length && g && g.length ? Ff(c, g, r, m) : c;
      }
      var TL = yi(function(c, g) {
        var m = c == null ? 0 : c.length, x = wf(c, g);
        return Iw(c, Pt(g, function(F) {
          return Ci(F, m) ? +F : F;
        }).sort(Vw)), x;
      });
      function DL(c, g) {
        var m = [];
        if (!(c && c.length))
          return m;
        var x = -1, F = [], D = c.length;
        for (g = De(g, 3); ++x < D; ) {
          var L = c[x];
          g(L, x, c) && (m.push(L), F.push(x));
        }
        return Iw(c, F), m;
      }
      function qf(c) {
        return c == null ? c : RI.call(c);
      }
      function OL(c, g, m) {
        var x = c == null ? 0 : c.length;
        return x ? (m && typeof m != "number" && yr(c, g, m) ? (g = 0, m = x) : (g = g == null ? 0 : Be(g), m = m === r ? x : Be(m)), dn(c, g, m)) : [];
      }
      function IL(c, g) {
        return Ru(c, g);
      }
      function kL(c, g, m) {
        return Df(c, g, De(m, 2));
      }
      function LL(c, g) {
        var m = c == null ? 0 : c.length;
        if (m) {
          var x = Ru(c, g);
          if (x < m && Tn(c[x], g))
            return x;
        }
        return -1;
      }
      function _L(c, g) {
        return Ru(c, g, !0);
      }
      function zL(c, g, m) {
        return Df(c, g, De(m, 2), !0);
      }
      function NL(c, g) {
        var m = c == null ? 0 : c.length;
        if (m) {
          var x = Ru(c, g, !0) - 1;
          if (Tn(c[x], g))
            return x;
        }
        return -1;
      }
      function BL(c) {
        return c && c.length ? Lw(c) : [];
      }
      function GL(c, g) {
        return c && c.length ? Lw(c, De(g, 2)) : [];
      }
      function HL(c) {
        var g = c == null ? 0 : c.length;
        return g ? dn(c, 1, g) : [];
      }
      function WL(c, g, m) {
        return c && c.length ? (g = m || g === r ? 1 : Be(g), dn(c, 0, g < 0 ? 0 : g)) : [];
      }
      function VL(c, g, m) {
        var x = c == null ? 0 : c.length;
        return x ? (g = m || g === r ? 1 : Be(g), g = x - g, dn(c, g < 0 ? 0 : g, x)) : [];
      }
      function $L(c, g) {
        return c && c.length ? Eu(c, De(g, 3), !1, !0) : [];
      }
      function jL(c, g) {
        return c && c.length ? Eu(c, De(g, 3)) : [];
      }
      var UL = Ve(function(c) {
        return qi(ir(c, 1, Bt, !0));
      }), KL = Ve(function(c) {
        var g = hn(c);
        return Bt(g) && (g = r), qi(ir(c, 1, Bt, !0), De(g, 2));
      }), qL = Ve(function(c) {
        var g = hn(c);
        return g = typeof g == "function" ? g : r, qi(ir(c, 1, Bt, !0), r, g);
      });
      function YL(c) {
        return c && c.length ? qi(c) : [];
      }
      function JL(c, g) {
        return c && c.length ? qi(c, De(g, 2)) : [];
      }
      function XL(c, g) {
        return g = typeof g == "function" ? g : r, c && c.length ? qi(c, r, g) : [];
      }
      function Yf(c) {
        if (!(c && c.length))
          return [];
        var g = 0;
        return c = Vi(c, function(m) {
          if (Bt(m))
            return g = qt(m.length, g), !0;
        }), hf(g, function(m) {
          return Pt(c, cf(m));
        });
      }
      function bb(c, g) {
        if (!(c && c.length))
          return [];
        var m = Yf(c);
        return g == null ? m : Pt(m, function(x) {
          return jr(g, r, x);
        });
      }
      var QL = Ve(function(c, g) {
        return Bt(c) ? gl(c, g) : [];
      }), ZL = Ve(function(c) {
        return If(Vi(c, Bt));
      }), e3 = Ve(function(c) {
        var g = hn(c);
        return Bt(g) && (g = r), If(Vi(c, Bt), De(g, 2));
      }), t3 = Ve(function(c) {
        var g = hn(c);
        return g = typeof g == "function" ? g : r, If(Vi(c, Bt), r, g);
      }), r3 = Ve(Yf);
      function n3(c, g) {
        return Bw(c || [], g || [], hl);
      }
      function i3(c, g) {
        return Bw(c || [], g || [], ml);
      }
      var o3 = Ve(function(c) {
        var g = c.length, m = g > 1 ? c[g - 1] : r;
        return m = typeof m == "function" ? (c.pop(), m) : r, bb(c, m);
      });
      function Sb(c) {
        var g = T(c);
        return g.__chain__ = !0, g;
      }
      function s3(c, g) {
        return g(c), c;
      }
      function ku(c, g) {
        return g(c);
      }
      var a3 = yi(function(c) {
        var g = c.length, m = g ? c[0] : 0, x = this.__wrapped__, F = function(D) {
          return wf(D, c);
        };
        return g > 1 || this.__actions__.length || !(x instanceof qe) || !Ci(m) ? this.thru(F) : (x = x.slice(m, +m + (g ? 1 : 0)), x.__actions__.push({
          func: ku,
          args: [F],
          thisArg: r
        }), new cn(x, this.__chain__).thru(function(D) {
          return g && !D.length && D.push(r), D;
        }));
      });
      function l3() {
        return Sb(this);
      }
      function c3() {
        return new cn(this.value(), this.__chain__);
      }
      function u3() {
        this.__values__ === r && (this.__values__ = _b(this.value()));
        var c = this.__index__ >= this.__values__.length, g = c ? r : this.__values__[this.__index__++];
        return { done: c, value: g };
      }
      function d3() {
        return this;
      }
      function h3(c) {
        for (var g, m = this; m instanceof Cu; ) {
          var x = pb(m);
          x.__index__ = 0, x.__values__ = r, g ? F.__wrapped__ = x : g = x;
          var F = x;
          m = m.__wrapped__;
        }
        return F.__wrapped__ = c, g;
      }
      function g3() {
        var c = this.__wrapped__;
        if (c instanceof qe) {
          var g = c;
          return this.__actions__.length && (g = new qe(this)), g = g.reverse(), g.__actions__.push({
            func: ku,
            args: [qf],
            thisArg: r
          }), new cn(g, this.__chain__);
        }
        return this.thru(qf);
      }
      function f3() {
        return Nw(this.__wrapped__, this.__actions__);
      }
      var p3 = Pu(function(c, g, m) {
        gt.call(c, m) ? ++c[m] : mi(c, m, 1);
      });
      function m3(c, g, m) {
        var x = ze(c) ? XC : sk;
        return m && yr(c, g, m) && (g = r), x(c, De(g, 3));
      }
      function v3(c, g) {
        var m = ze(c) ? Vi : bw;
        return m(c, De(g, 3));
      }
      var y3 = Yw(mb), C3 = Yw(vb);
      function w3(c, g) {
        return ir(Lu(c, g), 1);
      }
      function b3(c, g) {
        return ir(Lu(c, g), Z);
      }
      function S3(c, g, m) {
        return m = m === r ? 1 : Be(m), ir(Lu(c, g), m);
      }
      function xb(c, g) {
        var m = ze(c) ? an : Ki;
        return m(c, De(g, 3));
      }
      function Rb(c, g) {
        var m = ze(c) ? HO : ww;
        return m(c, De(g, 3));
      }
      var x3 = Pu(function(c, g, m) {
        gt.call(c, m) ? c[m].push(g) : mi(c, m, [g]);
      });
      function R3(c, g, m, x) {
        c = kr(c) ? c : _s(c), m = m && !x ? Be(m) : 0;
        var F = c.length;
        return m < 0 && (m = qt(F + m, 0)), Gu(c) ? m <= F && c.indexOf(g, m) > -1 : !!F && Rs(c, g, m) > -1;
      }
      var E3 = Ve(function(c, g, m) {
        var x = -1, F = typeof g == "function", D = kr(c) ? Y(c.length) : [];
        return Ki(c, function(L) {
          D[++x] = F ? jr(g, L, m) : fl(L, g, m);
        }), D;
      }), P3 = Pu(function(c, g, m) {
        mi(c, m, g);
      });
      function Lu(c, g) {
        var m = ze(c) ? Pt : Aw;
        return m(c, De(g, 3));
      }
      function A3(c, g, m, x) {
        return c == null ? [] : (ze(g) || (g = g == null ? [] : [g]), m = x ? r : m, ze(m) || (m = m == null ? [] : [m]), Dw(c, g, m));
      }
      var F3 = Pu(function(c, g, m) {
        c[m ? 0 : 1].push(g);
      }, function() {
        return [[], []];
      });
      function M3(c, g, m) {
        var x = ze(c) ? af : tw, F = arguments.length < 3;
        return x(c, De(g, 4), m, F, Ki);
      }
      function T3(c, g, m) {
        var x = ze(c) ? WO : tw, F = arguments.length < 3;
        return x(c, De(g, 4), m, F, ww);
      }
      function D3(c, g) {
        var m = ze(c) ? Vi : bw;
        return m(c, Nu(De(g, 3)));
      }
      function O3(c) {
        var g = ze(c) ? mw : Rk;
        return g(c);
      }
      function I3(c, g, m) {
        (m ? yr(c, g, m) : g === r) ? g = 1 : g = Be(g);
        var x = ze(c) ? tk : Ek;
        return x(c, g);
      }
      function k3(c) {
        var g = ze(c) ? rk : Ak;
        return g(c);
      }
      function L3(c) {
        if (c == null)
          return 0;
        if (kr(c))
          return Gu(c) ? Ps(c) : c.length;
        var g = cr(c);
        return g == oe || g == Et ? c.size : Pf(c).length;
      }
      function _3(c, g, m) {
        var x = ze(c) ? lf : Fk;
        return m && yr(c, g, m) && (g = r), x(c, De(g, 3));
      }
      var z3 = Ve(function(c, g) {
        if (c == null)
          return [];
        var m = g.length;
        return m > 1 && yr(c, g[0], g[1]) ? g = [] : m > 2 && yr(g[0], g[1], g[2]) && (g = [g[0]]), Dw(c, ir(g, 1), []);
      }), _u = vI || function() {
        return nr.Date.now();
      };
      function N3(c, g) {
        if (typeof g != "function")
          throw new ln(s);
        return c = Be(c), function() {
          if (--c < 1)
            return g.apply(this, arguments);
        };
      }
      function Eb(c, g, m) {
        return g = m ? r : g, g = c && g == null ? c.length : g, vi(c, A, r, r, r, r, g);
      }
      function Pb(c, g) {
        var m;
        if (typeof g != "function")
          throw new ln(s);
        return c = Be(c), function() {
          return --c > 0 && (m = g.apply(this, arguments)), c <= 1 && (g = r), m;
        };
      }
      var Jf = Ve(function(c, g, m) {
        var x = v;
        if (m.length) {
          var F = ji(m, ks(Jf));
          x |= S;
        }
        return vi(c, x, g, m, F);
      }), Ab = Ve(function(c, g, m) {
        var x = v | w;
        if (m.length) {
          var F = ji(m, ks(Ab));
          x |= S;
        }
        return vi(g, x, c, m, F);
      });
      function Fb(c, g, m) {
        g = m ? r : g;
        var x = vi(c, b, r, r, r, r, r, g);
        return x.placeholder = Fb.placeholder, x;
      }
      function Mb(c, g, m) {
        g = m ? r : g;
        var x = vi(c, P, r, r, r, r, r, g);
        return x.placeholder = Mb.placeholder, x;
      }
      function Tb(c, g, m) {
        var x, F, D, L, N, H, ae = 0, le = !1, ue = !1, we = !0;
        if (typeof c != "function")
          throw new ln(s);
        g = gn(g) || 0, Mt(m) && (le = !!m.leading, ue = "maxWait" in m, D = ue ? qt(gn(m.maxWait) || 0, g) : D, we = "trailing" in m ? !!m.trailing : we);
        function Ee(Gt) {
          var Dn = x, Si = F;
          return x = F = r, ae = Gt, L = c.apply(Si, Dn), L;
        }
        function Oe(Gt) {
          return ae = Gt, N = Cl(Ue, g), le ? Ee(Gt) : L;
        }
        function Ge(Gt) {
          var Dn = Gt - H, Si = Gt - ae, Yb = g - Dn;
          return ue ? lr(Yb, D - Si) : Yb;
        }
        function Ie(Gt) {
          var Dn = Gt - H, Si = Gt - ae;
          return H === r || Dn >= g || Dn < 0 || ue && Si >= D;
        }
        function Ue() {
          var Gt = _u();
          if (Ie(Gt))
            return Xe(Gt);
          N = Cl(Ue, Ge(Gt));
        }
        function Xe(Gt) {
          return N = r, we && x ? Ee(Gt) : (x = F = r, L);
        }
        function Yr() {
          N !== r && Gw(N), ae = 0, x = H = F = N = r;
        }
        function Cr() {
          return N === r ? L : Xe(_u());
        }
        function Jr() {
          var Gt = _u(), Dn = Ie(Gt);
          if (x = arguments, F = this, H = Gt, Dn) {
            if (N === r)
              return Oe(H);
            if (ue)
              return Gw(N), N = Cl(Ue, g), Ee(H);
          }
          return N === r && (N = Cl(Ue, g)), L;
        }
        return Jr.cancel = Yr, Jr.flush = Cr, Jr;
      }
      var B3 = Ve(function(c, g) {
        return Cw(c, 1, g);
      }), G3 = Ve(function(c, g, m) {
        return Cw(c, gn(g) || 0, m);
      });
      function H3(c) {
        return vi(c, I);
      }
      function zu(c, g) {
        if (typeof c != "function" || g != null && typeof g != "function")
          throw new ln(s);
        var m = function() {
          var x = arguments, F = g ? g.apply(this, x) : x[0], D = m.cache;
          if (D.has(F))
            return D.get(F);
          var L = c.apply(this, x);
          return m.cache = D.set(F, L) || D, L;
        };
        return m.cache = new (zu.Cache || pi)(), m;
      }
      zu.Cache = pi;
      function Nu(c) {
        if (typeof c != "function")
          throw new ln(s);
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return !c.call(this);
            case 1:
              return !c.call(this, g[0]);
            case 2:
              return !c.call(this, g[0], g[1]);
            case 3:
              return !c.call(this, g[0], g[1], g[2]);
          }
          return !c.apply(this, g);
        };
      }
      function W3(c) {
        return Pb(2, c);
      }
      var V3 = Mk(function(c, g) {
        g = g.length == 1 && ze(g[0]) ? Pt(g[0], Ur(De())) : Pt(ir(g, 1), Ur(De()));
        var m = g.length;
        return Ve(function(x) {
          for (var F = -1, D = lr(x.length, m); ++F < D; )
            x[F] = g[F].call(this, x[F]);
          return jr(c, this, x);
        });
      }), Xf = Ve(function(c, g) {
        var m = ji(g, ks(Xf));
        return vi(c, S, r, g, m);
      }), Db = Ve(function(c, g) {
        var m = ji(g, ks(Db));
        return vi(c, E, r, g, m);
      }), $3 = yi(function(c, g) {
        return vi(c, M, r, r, r, g);
      });
      function j3(c, g) {
        if (typeof c != "function")
          throw new ln(s);
        return g = g === r ? g : Be(g), Ve(c, g);
      }
      function U3(c, g) {
        if (typeof c != "function")
          throw new ln(s);
        return g = g == null ? 0 : qt(Be(g), 0), Ve(function(m) {
          var x = m[g], F = Ji(m, 0, g);
          return x && $i(F, x), jr(c, this, F);
        });
      }
      function K3(c, g, m) {
        var x = !0, F = !0;
        if (typeof c != "function")
          throw new ln(s);
        return Mt(m) && (x = "leading" in m ? !!m.leading : x, F = "trailing" in m ? !!m.trailing : F), Tb(c, g, {
          leading: x,
          maxWait: g,
          trailing: F
        });
      }
      function q3(c) {
        return Eb(c, 1);
      }
      function Y3(c, g) {
        return Xf(Lf(g), c);
      }
      function J3() {
        if (!arguments.length)
          return [];
        var c = arguments[0];
        return ze(c) ? c : [c];
      }
      function X3(c) {
        return un(c, p);
      }
      function Q3(c, g) {
        return g = typeof g == "function" ? g : r, un(c, p, g);
      }
      function Z3(c) {
        return un(c, h | p);
      }
      function e_(c, g) {
        return g = typeof g == "function" ? g : r, un(c, h | p, g);
      }
      function t_(c, g) {
        return g == null || yw(c, g, Zt(g));
      }
      function Tn(c, g) {
        return c === g || c !== c && g !== g;
      }
      var r_ = Tu(xf), n_ = Tu(function(c, g) {
        return c >= g;
      }), Lo = Rw(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Rw : function(c) {
        return It(c) && gt.call(c, "callee") && !uw.call(c, "callee");
      }, ze = Y.isArray, i_ = jC ? Ur(jC) : hk;
      function kr(c) {
        return c != null && Bu(c.length) && !wi(c);
      }
      function Bt(c) {
        return It(c) && kr(c);
      }
      function o_(c) {
        return c === !0 || c === !1 || It(c) && vr(c) == Re;
      }
      var Xi = CI || lp, s_ = UC ? Ur(UC) : gk;
      function a_(c) {
        return It(c) && c.nodeType === 1 && !wl(c);
      }
      function l_(c) {
        if (c == null)
          return !0;
        if (kr(c) && (ze(c) || typeof c == "string" || typeof c.splice == "function" || Xi(c) || Ls(c) || Lo(c)))
          return !c.length;
        var g = cr(c);
        if (g == oe || g == Et)
          return !c.size;
        if (yl(c))
          return !Pf(c).length;
        for (var m in c)
          if (gt.call(c, m))
            return !1;
        return !0;
      }
      function c_(c, g) {
        return pl(c, g);
      }
      function u_(c, g, m) {
        m = typeof m == "function" ? m : r;
        var x = m ? m(c, g) : r;
        return x === r ? pl(c, g, r, m) : !!x;
      }
      function Qf(c) {
        if (!It(c))
          return !1;
        var g = vr(c);
        return g == ye || g == fe || typeof c.message == "string" && typeof c.name == "string" && !wl(c);
      }
      function d_(c) {
        return typeof c == "number" && hw(c);
      }
      function wi(c) {
        if (!Mt(c))
          return !1;
        var g = vr(c);
        return g == B || g == Ae || g == Pe || g == Dr;
      }
      function Ob(c) {
        return typeof c == "number" && c == Be(c);
      }
      function Bu(c) {
        return typeof c == "number" && c > -1 && c % 1 == 0 && c <= te;
      }
      function Mt(c) {
        var g = typeof c;
        return c != null && (g == "object" || g == "function");
      }
      function It(c) {
        return c != null && typeof c == "object";
      }
      var Ib = KC ? Ur(KC) : pk;
      function h_(c, g) {
        return c === g || Ef(c, g, Wf(g));
      }
      function g_(c, g, m) {
        return m = typeof m == "function" ? m : r, Ef(c, g, Wf(g), m);
      }
      function f_(c) {
        return kb(c) && c != +c;
      }
      function p_(c) {
        if (Qk(c))
          throw new Le(o);
        return Ew(c);
      }
      function m_(c) {
        return c === null;
      }
      function v_(c) {
        return c == null;
      }
      function kb(c) {
        return typeof c == "number" || It(c) && vr(c) == Me;
      }
      function wl(c) {
        if (!It(c) || vr(c) != nt)
          return !1;
        var g = hu(c);
        if (g === null)
          return !0;
        var m = gt.call(g, "constructor") && g.constructor;
        return typeof m == "function" && m instanceof m && lu.call(m) == gI;
      }
      var Zf = qC ? Ur(qC) : mk;
      function y_(c) {
        return Ob(c) && c >= -te && c <= te;
      }
      var Lb = YC ? Ur(YC) : vk;
      function Gu(c) {
        return typeof c == "string" || !ze(c) && It(c) && vr(c) == Ut;
      }
      function qr(c) {
        return typeof c == "symbol" || It(c) && vr(c) == Or;
      }
      var Ls = JC ? Ur(JC) : yk;
      function C_(c) {
        return c === r;
      }
      function w_(c) {
        return It(c) && cr(c) == on;
      }
      function b_(c) {
        return It(c) && vr(c) == yt;
      }
      var S_ = Tu(Af), x_ = Tu(function(c, g) {
        return c <= g;
      });
      function _b(c) {
        if (!c)
          return [];
        if (kr(c))
          return Gu(c) ? Fn(c) : Ir(c);
        if (al && c[al])
          return tI(c[al]());
        var g = cr(c), m = g == oe ? ff : g == Et ? ou : _s;
        return m(c);
      }
      function bi(c) {
        if (!c)
          return c === 0 ? c : 0;
        if (c = gn(c), c === Z || c === -Z) {
          var g = c < 0 ? -1 : 1;
          return g * se;
        }
        return c === c ? c : 0;
      }
      function Be(c) {
        var g = bi(c), m = g % 1;
        return g === g ? m ? g - m : g : 0;
      }
      function zb(c) {
        return c ? Do(Be(c), 0, U) : 0;
      }
      function gn(c) {
        if (typeof c == "number")
          return c;
        if (qr(c))
          return W;
        if (Mt(c)) {
          var g = typeof c.valueOf == "function" ? c.valueOf() : c;
          c = Mt(g) ? g + "" : g;
        }
        if (typeof c != "string")
          return c === 0 ? c : +c;
        c = rw(c);
        var m = iO.test(c);
        return m || sO.test(c) ? NO(c.slice(2), m ? 2 : 8) : nO.test(c) ? W : +c;
      }
      function Nb(c) {
        return Kn(c, Lr(c));
      }
      function R_(c) {
        return c ? Do(Be(c), -te, te) : c === 0 ? c : 0;
      }
      function at(c) {
        return c == null ? "" : Kr(c);
      }
      var E_ = Os(function(c, g) {
        if (yl(g) || kr(g)) {
          Kn(g, Zt(g), c);
          return;
        }
        for (var m in g)
          gt.call(g, m) && hl(c, m, g[m]);
      }), Bb = Os(function(c, g) {
        Kn(g, Lr(g), c);
      }), Hu = Os(function(c, g, m, x) {
        Kn(g, Lr(g), c, x);
      }), P_ = Os(function(c, g, m, x) {
        Kn(g, Zt(g), c, x);
      }), A_ = yi(wf);
      function F_(c, g) {
        var m = Ds(c);
        return g == null ? m : vw(m, g);
      }
      var M_ = Ve(function(c, g) {
        c = pt(c);
        var m = -1, x = g.length, F = x > 2 ? g[2] : r;
        for (F && yr(g[0], g[1], F) && (x = 1); ++m < x; )
          for (var D = g[m], L = Lr(D), N = -1, H = L.length; ++N < H; ) {
            var ae = L[N], le = c[ae];
            (le === r || Tn(le, Fs[ae]) && !gt.call(c, ae)) && (c[ae] = D[ae]);
          }
        return c;
      }), T_ = Ve(function(c) {
        return c.push(r, rb), jr(Gb, r, c);
      });
      function D_(c, g) {
        return QC(c, De(g, 3), Un);
      }
      function O_(c, g) {
        return QC(c, De(g, 3), Sf);
      }
      function I_(c, g) {
        return c == null ? c : bf(c, De(g, 3), Lr);
      }
      function k_(c, g) {
        return c == null ? c : Sw(c, De(g, 3), Lr);
      }
      function L_(c, g) {
        return c && Un(c, De(g, 3));
      }
      function __(c, g) {
        return c && Sf(c, De(g, 3));
      }
      function z_(c) {
        return c == null ? [] : Su(c, Zt(c));
      }
      function N_(c) {
        return c == null ? [] : Su(c, Lr(c));
      }
      function ep(c, g, m) {
        var x = c == null ? r : Oo(c, g);
        return x === r ? m : x;
      }
      function B_(c, g) {
        return c != null && ob(c, g, lk);
      }
      function tp(c, g) {
        return c != null && ob(c, g, ck);
      }
      var G_ = Xw(function(c, g, m) {
        g != null && typeof g.toString != "function" && (g = cu.call(g)), c[g] = m;
      }, np(_r)), H_ = Xw(function(c, g, m) {
        g != null && typeof g.toString != "function" && (g = cu.call(g)), gt.call(c, g) ? c[g].push(m) : c[g] = [m];
      }, De), W_ = Ve(fl);
      function Zt(c) {
        return kr(c) ? pw(c) : Pf(c);
      }
      function Lr(c) {
        return kr(c) ? pw(c, !0) : Ck(c);
      }
      function V_(c, g) {
        var m = {};
        return g = De(g, 3), Un(c, function(x, F, D) {
          mi(m, g(x, F, D), x);
        }), m;
      }
      function $_(c, g) {
        var m = {};
        return g = De(g, 3), Un(c, function(x, F, D) {
          mi(m, F, g(x, F, D));
        }), m;
      }
      var j_ = Os(function(c, g, m) {
        xu(c, g, m);
      }), Gb = Os(function(c, g, m, x) {
        xu(c, g, m, x);
      }), U_ = yi(function(c, g) {
        var m = {};
        if (c == null)
          return m;
        var x = !1;
        g = Pt(g, function(D) {
          return D = Yi(D, c), x || (x = D.length > 1), D;
        }), Kn(c, Gf(c), m), x && (m = un(m, h | f | p, Gk));
        for (var F = g.length; F--; )
          Of(m, g[F]);
        return m;
      });
      function K_(c, g) {
        return Hb(c, Nu(De(g)));
      }
      var q_ = yi(function(c, g) {
        return c == null ? {} : bk(c, g);
      });
      function Hb(c, g) {
        if (c == null)
          return {};
        var m = Pt(Gf(c), function(x) {
          return [x];
        });
        return g = De(g), Ow(c, m, function(x, F) {
          return g(x, F[0]);
        });
      }
      function Y_(c, g, m) {
        g = Yi(g, c);
        var x = -1, F = g.length;
        for (F || (F = 1, c = r); ++x < F; ) {
          var D = c == null ? r : c[qn(g[x])];
          D === r && (x = F, D = m), c = wi(D) ? D.call(c) : D;
        }
        return c;
      }
      function J_(c, g, m) {
        return c == null ? c : ml(c, g, m);
      }
      function X_(c, g, m, x) {
        return x = typeof x == "function" ? x : r, c == null ? c : ml(c, g, m, x);
      }
      var Wb = eb(Zt), Vb = eb(Lr);
      function Q_(c, g, m) {
        var x = ze(c), F = x || Xi(c) || Ls(c);
        if (g = De(g, 4), m == null) {
          var D = c && c.constructor;
          F ? m = x ? new D() : [] : Mt(c) ? m = wi(D) ? Ds(hu(c)) : {} : m = {};
        }
        return (F ? an : Un)(c, function(L, N, H) {
          return g(m, L, N, H);
        }), m;
      }
      function Z_(c, g) {
        return c == null ? !0 : Of(c, g);
      }
      function ez(c, g, m) {
        return c == null ? c : zw(c, g, Lf(m));
      }
      function tz(c, g, m, x) {
        return x = typeof x == "function" ? x : r, c == null ? c : zw(c, g, Lf(m), x);
      }
      function _s(c) {
        return c == null ? [] : gf(c, Zt(c));
      }
      function rz(c) {
        return c == null ? [] : gf(c, Lr(c));
      }
      function nz(c, g, m) {
        return m === r && (m = g, g = r), m !== r && (m = gn(m), m = m === m ? m : 0), g !== r && (g = gn(g), g = g === g ? g : 0), Do(gn(c), g, m);
      }
      function iz(c, g, m) {
        return g = bi(g), m === r ? (m = g, g = 0) : m = bi(m), c = gn(c), uk(c, g, m);
      }
      function oz(c, g, m) {
        if (m && typeof m != "boolean" && yr(c, g, m) && (g = m = r), m === r && (typeof g == "boolean" ? (m = g, g = r) : typeof c == "boolean" && (m = c, c = r)), c === r && g === r ? (c = 0, g = 1) : (c = bi(c), g === r ? (g = c, c = 0) : g = bi(g)), c > g) {
          var x = c;
          c = g, g = x;
        }
        if (m || c % 1 || g % 1) {
          var F = gw();
          return lr(c + F * (g - c + zO("1e-" + ((F + "").length - 1))), g);
        }
        return Mf(c, g);
      }
      var sz = Is(function(c, g, m) {
        return g = g.toLowerCase(), c + (m ? $b(g) : g);
      });
      function $b(c) {
        return rp(at(c).toLowerCase());
      }
      function jb(c) {
        return c = at(c), c && c.replace(lO, JO).replace(AO, "");
      }
      function az(c, g, m) {
        c = at(c), g = Kr(g);
        var x = c.length;
        m = m === r ? x : Do(Be(m), 0, x);
        var F = m;
        return m -= g.length, m >= 0 && c.slice(m, F) == g;
      }
      function lz(c) {
        return c = at(c), c && WD.test(c) ? c.replace(SC, XO) : c;
      }
      function cz(c) {
        return c = at(c), c && qD.test(c) ? c.replace(Jg, "\\$&") : c;
      }
      var uz = Is(function(c, g, m) {
        return c + (m ? "-" : "") + g.toLowerCase();
      }), dz = Is(function(c, g, m) {
        return c + (m ? " " : "") + g.toLowerCase();
      }), hz = qw("toLowerCase");
      function gz(c, g, m) {
        c = at(c), g = Be(g);
        var x = g ? Ps(c) : 0;
        if (!g || x >= g)
          return c;
        var F = (g - x) / 2;
        return Mu(mu(F), m) + c + Mu(pu(F), m);
      }
      function fz(c, g, m) {
        c = at(c), g = Be(g);
        var x = g ? Ps(c) : 0;
        return g && x < g ? c + Mu(g - x, m) : c;
      }
      function pz(c, g, m) {
        c = at(c), g = Be(g);
        var x = g ? Ps(c) : 0;
        return g && x < g ? Mu(g - x, m) + c : c;
      }
      function mz(c, g, m) {
        return m || g == null ? g = 0 : g && (g = +g), xI(at(c).replace(Xg, ""), g || 0);
      }
      function vz(c, g, m) {
        return (m ? yr(c, g, m) : g === r) ? g = 1 : g = Be(g), Tf(at(c), g);
      }
      function yz() {
        var c = arguments, g = at(c[0]);
        return c.length < 3 ? g : g.replace(c[1], c[2]);
      }
      var Cz = Is(function(c, g, m) {
        return c + (m ? "_" : "") + g.toLowerCase();
      });
      function wz(c, g, m) {
        return m && typeof m != "number" && yr(c, g, m) && (g = m = r), m = m === r ? U : m >>> 0, m ? (c = at(c), c && (typeof g == "string" || g != null && !Zf(g)) && (g = Kr(g), !g && Es(c)) ? Ji(Fn(c), 0, m) : c.split(g, m)) : [];
      }
      var bz = Is(function(c, g, m) {
        return c + (m ? " " : "") + rp(g);
      });
      function Sz(c, g, m) {
        return c = at(c), m = m == null ? 0 : Do(Be(m), 0, c.length), g = Kr(g), c.slice(m, m + g.length) == g;
      }
      function xz(c, g, m) {
        var x = T.templateSettings;
        m && yr(c, g, m) && (g = r), c = at(c), g = Hu({}, g, x, tb);
        var F = Hu({}, g.imports, x.imports, tb), D = Zt(F), L = gf(F, D), N, H, ae = 0, le = g.interpolate || eu, ue = "__p += '", we = pf(
          (g.escape || eu).source + "|" + le.source + "|" + (le === xC ? rO : eu).source + "|" + (g.evaluate || eu).source + "|$",
          "g"
        ), Ee = "//# sourceURL=" + (gt.call(g, "sourceURL") ? (g.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++OO + "]") + `
`;
        c.replace(we, function(Ie, Ue, Xe, Yr, Cr, Jr) {
          return Xe || (Xe = Yr), ue += c.slice(ae, Jr).replace(cO, QO), Ue && (N = !0, ue += `' +
__e(` + Ue + `) +
'`), Cr && (H = !0, ue += `';
` + Cr + `;
__p += '`), Xe && (ue += `' +
((__t = (` + Xe + `)) == null ? '' : __t) +
'`), ae = Jr + Ie.length, Ie;
        }), ue += `';
`;
        var Oe = gt.call(g, "variable") && g.variable;
        if (!Oe)
          ue = `with (obj) {
` + ue + `
}
`;
        else if (eO.test(Oe))
          throw new Le(a);
        ue = (H ? ue.replace(ND, "") : ue).replace(BD, "$1").replace(GD, "$1;"), ue = "function(" + (Oe || "obj") + `) {
` + (Oe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (N ? ", __e = _.escape" : "") + (H ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ue + `return __p
}`;
        var Ge = Kb(function() {
          return it(D, Ee + "return " + ue).apply(r, L);
        });
        if (Ge.source = ue, Qf(Ge))
          throw Ge;
        return Ge;
      }
      function Rz(c) {
        return at(c).toLowerCase();
      }
      function Ez(c) {
        return at(c).toUpperCase();
      }
      function Pz(c, g, m) {
        if (c = at(c), c && (m || g === r))
          return rw(c);
        if (!c || !(g = Kr(g)))
          return c;
        var x = Fn(c), F = Fn(g), D = nw(x, F), L = iw(x, F) + 1;
        return Ji(x, D, L).join("");
      }
      function Az(c, g, m) {
        if (c = at(c), c && (m || g === r))
          return c.slice(0, sw(c) + 1);
        if (!c || !(g = Kr(g)))
          return c;
        var x = Fn(c), F = iw(x, Fn(g)) + 1;
        return Ji(x, 0, F).join("");
      }
      function Fz(c, g, m) {
        if (c = at(c), c && (m || g === r))
          return c.replace(Xg, "");
        if (!c || !(g = Kr(g)))
          return c;
        var x = Fn(c), F = nw(x, Fn(g));
        return Ji(x, F).join("");
      }
      function Mz(c, g) {
        var m = z, x = k;
        if (Mt(g)) {
          var F = "separator" in g ? g.separator : F;
          m = "length" in g ? Be(g.length) : m, x = "omission" in g ? Kr(g.omission) : x;
        }
        c = at(c);
        var D = c.length;
        if (Es(c)) {
          var L = Fn(c);
          D = L.length;
        }
        if (m >= D)
          return c;
        var N = m - Ps(x);
        if (N < 1)
          return x;
        var H = L ? Ji(L, 0, N).join("") : c.slice(0, N);
        if (F === r)
          return H + x;
        if (L && (N += H.length - N), Zf(F)) {
          if (c.slice(N).search(F)) {
            var ae, le = H;
            for (F.global || (F = pf(F.source, at(RC.exec(F)) + "g")), F.lastIndex = 0; ae = F.exec(le); )
              var ue = ae.index;
            H = H.slice(0, ue === r ? N : ue);
          }
        } else if (c.indexOf(Kr(F), N) != N) {
          var we = H.lastIndexOf(F);
          we > -1 && (H = H.slice(0, we));
        }
        return H + x;
      }
      function Tz(c) {
        return c = at(c), c && HD.test(c) ? c.replace(bC, oI) : c;
      }
      var Dz = Is(function(c, g, m) {
        return c + (m ? " " : "") + g.toUpperCase();
      }), rp = qw("toUpperCase");
      function Ub(c, g, m) {
        return c = at(c), g = m ? r : g, g === r ? eI(c) ? lI(c) : jO(c) : c.match(g) || [];
      }
      var Kb = Ve(function(c, g) {
        try {
          return jr(c, r, g);
        } catch (m) {
          return Qf(m) ? m : new Le(m);
        }
      }), Oz = yi(function(c, g) {
        return an(g, function(m) {
          m = qn(m), mi(c, m, Jf(c[m], c));
        }), c;
      });
      function Iz(c) {
        var g = c == null ? 0 : c.length, m = De();
        return c = g ? Pt(c, function(x) {
          if (typeof x[1] != "function")
            throw new ln(s);
          return [m(x[0]), x[1]];
        }) : [], Ve(function(x) {
          for (var F = -1; ++F < g; ) {
            var D = c[F];
            if (jr(D[0], this, x))
              return jr(D[1], this, x);
          }
        });
      }
      function kz(c) {
        return ok(un(c, h));
      }
      function np(c) {
        return function() {
          return c;
        };
      }
      function Lz(c, g) {
        return c == null || c !== c ? g : c;
      }
      var _z = Jw(), zz = Jw(!0);
      function _r(c) {
        return c;
      }
      function ip(c) {
        return Pw(typeof c == "function" ? c : un(c, h));
      }
      function Nz(c) {
        return Fw(un(c, h));
      }
      function Bz(c, g) {
        return Mw(c, un(g, h));
      }
      var Gz = Ve(function(c, g) {
        return function(m) {
          return fl(m, c, g);
        };
      }), Hz = Ve(function(c, g) {
        return function(m) {
          return fl(c, m, g);
        };
      });
      function op(c, g, m) {
        var x = Zt(g), F = Su(g, x);
        m == null && !(Mt(g) && (F.length || !x.length)) && (m = g, g = c, c = this, F = Su(g, Zt(g)));
        var D = !(Mt(m) && "chain" in m) || !!m.chain, L = wi(c);
        return an(F, function(N) {
          var H = g[N];
          c[N] = H, L && (c.prototype[N] = function() {
            var ae = this.__chain__;
            if (D || ae) {
              var le = c(this.__wrapped__), ue = le.__actions__ = Ir(this.__actions__);
              return ue.push({ func: H, args: arguments, thisArg: c }), le.__chain__ = ae, le;
            }
            return H.apply(c, $i([this.value()], arguments));
          });
        }), c;
      }
      function Wz() {
        return nr._ === this && (nr._ = fI), this;
      }
      function sp() {
      }
      function Vz(c) {
        return c = Be(c), Ve(function(g) {
          return Tw(g, c);
        });
      }
      var $z = zf(Pt), jz = zf(XC), Uz = zf(lf);
      function qb(c) {
        return $f(c) ? cf(qn(c)) : Sk(c);
      }
      function Kz(c) {
        return function(g) {
          return c == null ? r : Oo(c, g);
        };
      }
      var qz = Qw(), Yz = Qw(!0);
      function ap() {
        return [];
      }
      function lp() {
        return !1;
      }
      function Jz() {
        return {};
      }
      function Xz() {
        return "";
      }
      function Qz() {
        return !0;
      }
      function Zz(c, g) {
        if (c = Be(c), c < 1 || c > te)
          return [];
        var m = U, x = lr(c, U);
        g = De(g), c -= U;
        for (var F = hf(x, g); ++m < c; )
          g(m);
        return F;
      }
      function eN(c) {
        return ze(c) ? Pt(c, qn) : qr(c) ? [c] : Ir(fb(at(c)));
      }
      function tN(c) {
        var g = ++hI;
        return at(c) + g;
      }
      var rN = Fu(function(c, g) {
        return c + g;
      }, 0), nN = Nf("ceil"), iN = Fu(function(c, g) {
        return c / g;
      }, 1), oN = Nf("floor");
      function sN(c) {
        return c && c.length ? bu(c, _r, xf) : r;
      }
      function aN(c, g) {
        return c && c.length ? bu(c, De(g, 2), xf) : r;
      }
      function lN(c) {
        return ew(c, _r);
      }
      function cN(c, g) {
        return ew(c, De(g, 2));
      }
      function uN(c) {
        return c && c.length ? bu(c, _r, Af) : r;
      }
      function dN(c, g) {
        return c && c.length ? bu(c, De(g, 2), Af) : r;
      }
      var hN = Fu(function(c, g) {
        return c * g;
      }, 1), gN = Nf("round"), fN = Fu(function(c, g) {
        return c - g;
      }, 0);
      function pN(c) {
        return c && c.length ? df(c, _r) : 0;
      }
      function mN(c, g) {
        return c && c.length ? df(c, De(g, 2)) : 0;
      }
      return T.after = N3, T.ary = Eb, T.assign = E_, T.assignIn = Bb, T.assignInWith = Hu, T.assignWith = P_, T.at = A_, T.before = Pb, T.bind = Jf, T.bindAll = Oz, T.bindKey = Ab, T.castArray = J3, T.chain = Sb, T.chunk = oL, T.compact = sL, T.concat = aL, T.cond = Iz, T.conforms = kz, T.constant = np, T.countBy = p3, T.create = F_, T.curry = Fb, T.curryRight = Mb, T.debounce = Tb, T.defaults = M_, T.defaultsDeep = T_, T.defer = B3, T.delay = G3, T.difference = lL, T.differenceBy = cL, T.differenceWith = uL, T.drop = dL, T.dropRight = hL, T.dropRightWhile = gL, T.dropWhile = fL, T.fill = pL, T.filter = v3, T.flatMap = w3, T.flatMapDeep = b3, T.flatMapDepth = S3, T.flatten = yb, T.flattenDeep = mL, T.flattenDepth = vL, T.flip = H3, T.flow = _z, T.flowRight = zz, T.fromPairs = yL, T.functions = z_, T.functionsIn = N_, T.groupBy = x3, T.initial = wL, T.intersection = bL, T.intersectionBy = SL, T.intersectionWith = xL, T.invert = G_, T.invertBy = H_, T.invokeMap = E3, T.iteratee = ip, T.keyBy = P3, T.keys = Zt, T.keysIn = Lr, T.map = Lu, T.mapKeys = V_, T.mapValues = $_, T.matches = Nz, T.matchesProperty = Bz, T.memoize = zu, T.merge = j_, T.mergeWith = Gb, T.method = Gz, T.methodOf = Hz, T.mixin = op, T.negate = Nu, T.nthArg = Vz, T.omit = U_, T.omitBy = K_, T.once = W3, T.orderBy = A3, T.over = $z, T.overArgs = V3, T.overEvery = jz, T.overSome = Uz, T.partial = Xf, T.partialRight = Db, T.partition = F3, T.pick = q_, T.pickBy = Hb, T.property = qb, T.propertyOf = Kz, T.pull = AL, T.pullAll = wb, T.pullAllBy = FL, T.pullAllWith = ML, T.pullAt = TL, T.range = qz, T.rangeRight = Yz, T.rearg = $3, T.reject = D3, T.remove = DL, T.rest = j3, T.reverse = qf, T.sampleSize = I3, T.set = J_, T.setWith = X_, T.shuffle = k3, T.slice = OL, T.sortBy = z3, T.sortedUniq = BL, T.sortedUniqBy = GL, T.split = wz, T.spread = U3, T.tail = HL, T.take = WL, T.takeRight = VL, T.takeRightWhile = $L, T.takeWhile = jL, T.tap = s3, T.throttle = K3, T.thru = ku, T.toArray = _b, T.toPairs = Wb, T.toPairsIn = Vb, T.toPath = eN, T.toPlainObject = Nb, T.transform = Q_, T.unary = q3, T.union = UL, T.unionBy = KL, T.unionWith = qL, T.uniq = YL, T.uniqBy = JL, T.uniqWith = XL, T.unset = Z_, T.unzip = Yf, T.unzipWith = bb, T.update = ez, T.updateWith = tz, T.values = _s, T.valuesIn = rz, T.without = QL, T.words = Ub, T.wrap = Y3, T.xor = ZL, T.xorBy = e3, T.xorWith = t3, T.zip = r3, T.zipObject = n3, T.zipObjectDeep = i3, T.zipWith = o3, T.entries = Wb, T.entriesIn = Vb, T.extend = Bb, T.extendWith = Hu, op(T, T), T.add = rN, T.attempt = Kb, T.camelCase = sz, T.capitalize = $b, T.ceil = nN, T.clamp = nz, T.clone = X3, T.cloneDeep = Z3, T.cloneDeepWith = e_, T.cloneWith = Q3, T.conformsTo = t_, T.deburr = jb, T.defaultTo = Lz, T.divide = iN, T.endsWith = az, T.eq = Tn, T.escape = lz, T.escapeRegExp = cz, T.every = m3, T.find = y3, T.findIndex = mb, T.findKey = D_, T.findLast = C3, T.findLastIndex = vb, T.findLastKey = O_, T.floor = oN, T.forEach = xb, T.forEachRight = Rb, T.forIn = I_, T.forInRight = k_, T.forOwn = L_, T.forOwnRight = __, T.get = ep, T.gt = r_, T.gte = n_, T.has = B_, T.hasIn = tp, T.head = Cb, T.identity = _r, T.includes = R3, T.indexOf = CL, T.inRange = iz, T.invoke = W_, T.isArguments = Lo, T.isArray = ze, T.isArrayBuffer = i_, T.isArrayLike = kr, T.isArrayLikeObject = Bt, T.isBoolean = o_, T.isBuffer = Xi, T.isDate = s_, T.isElement = a_, T.isEmpty = l_, T.isEqual = c_, T.isEqualWith = u_, T.isError = Qf, T.isFinite = d_, T.isFunction = wi, T.isInteger = Ob, T.isLength = Bu, T.isMap = Ib, T.isMatch = h_, T.isMatchWith = g_, T.isNaN = f_, T.isNative = p_, T.isNil = v_, T.isNull = m_, T.isNumber = kb, T.isObject = Mt, T.isObjectLike = It, T.isPlainObject = wl, T.isRegExp = Zf, T.isSafeInteger = y_, T.isSet = Lb, T.isString = Gu, T.isSymbol = qr, T.isTypedArray = Ls, T.isUndefined = C_, T.isWeakMap = w_, T.isWeakSet = b_, T.join = RL, T.kebabCase = uz, T.last = hn, T.lastIndexOf = EL, T.lowerCase = dz, T.lowerFirst = hz, T.lt = S_, T.lte = x_, T.max = sN, T.maxBy = aN, T.mean = lN, T.meanBy = cN, T.min = uN, T.minBy = dN, T.stubArray = ap, T.stubFalse = lp, T.stubObject = Jz, T.stubString = Xz, T.stubTrue = Qz, T.multiply = hN, T.nth = PL, T.noConflict = Wz, T.noop = sp, T.now = _u, T.pad = gz, T.padEnd = fz, T.padStart = pz, T.parseInt = mz, T.random = oz, T.reduce = M3, T.reduceRight = T3, T.repeat = vz, T.replace = yz, T.result = Y_, T.round = gN, T.runInContext = G, T.sample = O3, T.size = L3, T.snakeCase = Cz, T.some = _3, T.sortedIndex = IL, T.sortedIndexBy = kL, T.sortedIndexOf = LL, T.sortedLastIndex = _L, T.sortedLastIndexBy = zL, T.sortedLastIndexOf = NL, T.startCase = bz, T.startsWith = Sz, T.subtract = fN, T.sum = pN, T.sumBy = mN, T.template = xz, T.times = Zz, T.toFinite = bi, T.toInteger = Be, T.toLength = zb, T.toLower = Rz, T.toNumber = gn, T.toSafeInteger = R_, T.toString = at, T.toUpper = Ez, T.trim = Pz, T.trimEnd = Az, T.trimStart = Fz, T.truncate = Mz, T.unescape = Tz, T.uniqueId = tN, T.upperCase = Dz, T.upperFirst = rp, T.each = xb, T.eachRight = Rb, T.first = Cb, op(T, function() {
        var c = {};
        return Un(T, function(g, m) {
          gt.call(T.prototype, m) || (c[m] = g);
        }), c;
      }(), { chain: !1 }), T.VERSION = n, an(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
        T[c].placeholder = T;
      }), an(["drop", "take"], function(c, g) {
        qe.prototype[c] = function(m) {
          m = m === r ? 1 : qt(Be(m), 0);
          var x = this.__filtered__ && !g ? new qe(this) : this.clone();
          return x.__filtered__ ? x.__takeCount__ = lr(m, x.__takeCount__) : x.__views__.push({
            size: lr(m, U),
            type: c + (x.__dir__ < 0 ? "Right" : "")
          }), x;
        }, qe.prototype[c + "Right"] = function(m) {
          return this.reverse()[c](m).reverse();
        };
      }), an(["filter", "map", "takeWhile"], function(c, g) {
        var m = g + 1, x = m == j || m == K;
        qe.prototype[c] = function(F) {
          var D = this.clone();
          return D.__iteratees__.push({
            iteratee: De(F, 3),
            type: m
          }), D.__filtered__ = D.__filtered__ || x, D;
        };
      }), an(["head", "last"], function(c, g) {
        var m = "take" + (g ? "Right" : "");
        qe.prototype[c] = function() {
          return this[m](1).value()[0];
        };
      }), an(["initial", "tail"], function(c, g) {
        var m = "drop" + (g ? "" : "Right");
        qe.prototype[c] = function() {
          return this.__filtered__ ? new qe(this) : this[m](1);
        };
      }), qe.prototype.compact = function() {
        return this.filter(_r);
      }, qe.prototype.find = function(c) {
        return this.filter(c).head();
      }, qe.prototype.findLast = function(c) {
        return this.reverse().find(c);
      }, qe.prototype.invokeMap = Ve(function(c, g) {
        return typeof c == "function" ? new qe(this) : this.map(function(m) {
          return fl(m, c, g);
        });
      }), qe.prototype.reject = function(c) {
        return this.filter(Nu(De(c)));
      }, qe.prototype.slice = function(c, g) {
        c = Be(c);
        var m = this;
        return m.__filtered__ && (c > 0 || g < 0) ? new qe(m) : (c < 0 ? m = m.takeRight(-c) : c && (m = m.drop(c)), g !== r && (g = Be(g), m = g < 0 ? m.dropRight(-g) : m.take(g - c)), m);
      }, qe.prototype.takeRightWhile = function(c) {
        return this.reverse().takeWhile(c).reverse();
      }, qe.prototype.toArray = function() {
        return this.take(U);
      }, Un(qe.prototype, function(c, g) {
        var m = /^(?:filter|find|map|reject)|While$/.test(g), x = /^(?:head|last)$/.test(g), F = T[x ? "take" + (g == "last" ? "Right" : "") : g], D = x || /^find/.test(g);
        F && (T.prototype[g] = function() {
          var L = this.__wrapped__, N = x ? [1] : arguments, H = L instanceof qe, ae = N[0], le = H || ze(L), ue = function(Ue) {
            var Xe = F.apply(T, $i([Ue], N));
            return x && we ? Xe[0] : Xe;
          };
          le && m && typeof ae == "function" && ae.length != 1 && (H = le = !1);
          var we = this.__chain__, Ee = !!this.__actions__.length, Oe = D && !we, Ge = H && !Ee;
          if (!D && le) {
            L = Ge ? L : new qe(this);
            var Ie = c.apply(L, N);
            return Ie.__actions__.push({ func: ku, args: [ue], thisArg: r }), new cn(Ie, we);
          }
          return Oe && Ge ? c.apply(this, N) : (Ie = this.thru(ue), Oe ? x ? Ie.value()[0] : Ie.value() : Ie);
        });
      }), an(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
        var g = su[c], m = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru", x = /^(?:pop|shift)$/.test(c);
        T.prototype[c] = function() {
          var F = arguments;
          if (x && !this.__chain__) {
            var D = this.value();
            return g.apply(ze(D) ? D : [], F);
          }
          return this[m](function(L) {
            return g.apply(ze(L) ? L : [], F);
          });
        };
      }), Un(qe.prototype, function(c, g) {
        var m = T[g];
        if (m) {
          var x = m.name + "";
          gt.call(Ts, x) || (Ts[x] = []), Ts[x].push({ name: g, func: m });
        }
      }), Ts[Au(r, w).name] = [{
        name: "wrapper",
        func: r
      }], qe.prototype.clone = TI, qe.prototype.reverse = DI, qe.prototype.value = OI, T.prototype.at = a3, T.prototype.chain = l3, T.prototype.commit = c3, T.prototype.next = u3, T.prototype.plant = h3, T.prototype.reverse = g3, T.prototype.toJSON = T.prototype.valueOf = T.prototype.value = f3, T.prototype.first = T.prototype.head, al && (T.prototype[al] = d3), T;
    }, As = cI();
    Ao ? ((Ao.exports = As)._ = As, nf._ = As) : nr._ = As;
  }).call(Ei);
})(xd, xd.exports);
var je = xd.exports;
const ot = /* @__PURE__ */ bt(je), wN = (e, t) => fetch(e).then(async (n) => {
  const i = await n.json();
  t(i);
}), bN = (e) => ({ symbol: e });
function iE(e, t, r) {
  return e.map((n) => n === t ? r : n);
}
function oE(e, t, r) {
  return e.map((n, i) => i === t ? r : n);
}
function sE(e, t, r) {
  const n = ot.clone(e);
  return n[t] = r, n;
}
const aE = (e, t = []) => ot.pickBy(e, (r) => ![null, void 0, ...t].includes(r)), SN = (e, t, r, n) => e.map((o) => o.field === t ? { ...o, ...r } : { ...o, ...n }), xN = (e, t, r) => e.map((i) => i.field === t ? { ...i, ...r } : { ...i }), RN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  objWithoutNull: aE,
  replaceAtIdx: oE,
  replaceAtKey: sE,
  replaceAtMatch: xN,
  replaceInArr: iE,
  requestDf: wN,
  sym: bN,
  updateAtMatch: SN
}, Symbol.toStringTag, { value: "Module" })), EN = ({
  command: e,
  setCommand: t,
  columns: r,
  commandPatterns: n
}) => {
  if (e === void 0)
    return /* @__PURE__ */ $("span", {});
  const i = e[0].symbol, o = n[i];
  return ot.isArray(o) ? ot.isEqual(o, [null]) ? /* @__PURE__ */ $("div", { className: "operation-detail" }) : /* @__PURE__ */ $("div", { className: "operation-detail", children: /* @__PURE__ */ $(
    PN,
    {
      command: e,
      fullPattern: o,
      setCommand: t,
      columns: r
    }
  ) }) : /* @__PURE__ */ He("h2", { children: [
    "unknown command ",
    i
  ] });
}, PN = ({
  command: e,
  fullPattern: t,
  setCommand: r,
  columns: n
}) => {
  const i = (o) => {
    const s = o[0], a = e[s];
    return /* @__PURE__ */ $("div", { children: /* @__PURE__ */ $(
      AN,
      {
        argProps: o,
        renderKey: s,
        val: a,
        setter: (u) => {
          const d = oE(e, s, u);
          r(d);
        },
        columns: n
      }
    ) }, s);
  };
  return /* @__PURE__ */ $("div", { className: "arg-getters", children: t.map(i) });
}, AN = ({
  argProps: e,
  val: t,
  setter: r,
  columns: n,
  renderKey: i
}) => {
  const [o, s, a, l] = e, u = (d) => r(d.target.value);
  if (a === "enum" && ot.isArray(l))
    return /* @__PURE__ */ He("fieldset", { children: [
      /* @__PURE__ */ He("label", { children: [
        " ",
        s,
        " "
      ] }),
      /* @__PURE__ */ $("select", { defaultValue: t, onChange: u, children: l.map((d) => /* @__PURE__ */ $("option", { value: d, children: d }, d)) })
    ] }, i);
  if (a === "type")
    return l === "integer" ? /* @__PURE__ */ He("fieldset", { children: [
      /* @__PURE__ */ He("label", { children: [
        " ",
        s,
        " "
      ] }),
      /* @__PURE__ */ $(
        "input",
        {
          type: "number",
          defaultValue: t,
          step: "1",
          onChange: (h) => r(parseInt(h.target.value))
        }
      )
    ] }, i) : l === "float" ? /* @__PURE__ */ He("fieldset", { children: [
      /* @__PURE__ */ He("label", { children: [
        " ",
        s,
        " "
      ] }),
      /* @__PURE__ */ $(
        "input",
        {
          type: "number",
          step: "0.01",
          defaultValue: t,
          onChange: (h) => r(parseFloat(h.target.value))
        }
      )
    ] }, i) : l === "string" ? /* @__PURE__ */ He("fieldset", { children: [
      /* @__PURE__ */ He("label", { children: [
        " ",
        s,
        " "
      ] }),
      /* @__PURE__ */ $("input", { type: "text", defaultValue: t, onChange: (h) => r(h.target.value) })
    ] }, i) : /* @__PURE__ */ He("fieldset", { children: [
      /* @__PURE__ */ He("label", { children: [
        " ",
        s,
        " "
      ] }),
      /* @__PURE__ */ $("input", { value: "dont know" })
    ] }, i);
  if (a === "colEnum") {
    const d = n.map((h) => {
      const f = (y) => {
        const C = y.target.value;
        if (ot.isString(C)) {
          const v = sE(
            t,
            h,
            C
          );
          r(aE(v, ["null"]));
        }
      }, p = ot.get(t, h, "null");
      return ot.isArray(l) ? /* @__PURE__ */ $("td", { children: /* @__PURE__ */ $("select", { defaultValue: p, onChange: f, children: l.map((y) => /* @__PURE__ */ $("option", { value: y, children: y }, y)) }) }, i + h) : /* @__PURE__ */ $("h3", { children: " arg error" });
    });
    return /* @__PURE__ */ $("div", { className: "col-enum", children: /* @__PURE__ */ He("table", { children: [
      /* @__PURE__ */ $("thead", { children: /* @__PURE__ */ $("tr", { children: n.map((h) => /* @__PURE__ */ $("th", { children: h }, h)) }) }),
      /* @__PURE__ */ $("tbody", { children: /* @__PURE__ */ $("tr", { children: d }) })
    ] }) }, i);
  } else
    return /* @__PURE__ */ $("h3", { children: " unknown argtype " });
}, FN = {
  symbol: "df"
}, MN = {
  dropcol: [null],
  fillna: [[3, "fillVal", "type", "integer"]],
  remove_outliers: [[3, "tail", "type", "float"]],
  search: [[3, "needle", "type", "string"]],
  resample: [
    [3, "frequency", "enum", ["daily", "weekly", "monthly"]],
    [4, "colMap", "colEnum", ["null", "sum", "mean", "count"]]
  ]
}, TN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bakedArgSpecs: MN,
  symDf: FN
}, Symbol.toStringTag, { value: "Module" })), DN = (e, t) => t > e.length ? "no-key" : e[t][0].symbol + t.toString(), ON = ({ operations: e, setOperations: t, activeKey: r, setActiveKey: n }) => {
  const i = (s) => {
    const a = [...e];
    a.splice(s, 1), t(a);
  }, o = (s) => {
    const a = [...e], l = a[s], u = { ...l[0] };
    u.meta && (delete u.meta.auto_clean, Object.keys(u.meta).length === 0 && delete u.meta), a[s] = [u, ...l.slice(1)], t(a);
  };
  return /* @__PURE__ */ $("div", { className: "operations-list", children: e.map((s, a) => {
    var d, h;
    const l = DN(e, a), u = ((d = s[0].meta) == null ? void 0 : d.auto_clean) === !0;
    return /* @__PURE__ */ He(
      "div",
      {
        className: `operation-item default-operation ${r === l ? "active" : ""} ${u ? "auto_clean" : ""}`,
        onClick: () => n(l),
        children: [
          /* @__PURE__ */ He("div", { className: "operation-content", children: [
            /* @__PURE__ */ $("span", { className: "symbol", children: s[0].symbol }),
            /* @__PURE__ */ $("span", { className: "arg", children: s[2] }),
            ((h = s[0].meta) == null ? void 0 : h.clean_strategy) && /* @__PURE__ */ He("span", { className: "clean-strategy", children: [
              "Strategy: ",
              s[0].meta.clean_strategy
            ] }),
            u && /* @__PURE__ */ $(
              "button",
              {
                className: "preserve-button",
                onClick: (f) => {
                  f.stopPropagation(), o(a);
                },
                title: "Preserve this cleaning operation",
                children: "preserve"
              }
            )
          ] }),
          /* @__PURE__ */ $(
            "button",
            {
              className: "delete-button",
              onClick: (f) => {
                f.stopPropagation(), i(a);
              },
              children: "×"
            }
          )
        ]
      },
      a
    );
  }) });
}, IN = ({
  column: e,
  addOperationCb: t,
  defaultArgs: r
}) => {
  const n = (i) => () => {
    const o = r[i];
    t(iE(o, "col", e));
  };
  return /* @__PURE__ */ He("div", { className: "operation-adder", children: [
    /* @__PURE__ */ He("span", { className: "column-name", children: [
      " Column: ",
      e
    ] }),
    /* @__PURE__ */ $("fieldset", { children: ot.keys(r).map((i) => /* @__PURE__ */ He("button", { onClick: n(i), children: [
      " ",
      i,
      " "
    ] }, i)) })
  ] });
}, lE = ({
  operations: e,
  setOperations: t,
  activeColumn: r,
  allColumns: n,
  command_config: i
}) => {
  const o = (w, R) => R[0].symbol + w.toString(), s = ot.map(Array.from(e.entries()), ([w, R]) => {
    const b = {};
    return b[o(w, R)] = R, b;
  }), a = ot.merge({}, ...s), l = ot.map(Array.from(e.entries()), ([w, R]) => {
    const b = {};
    return b[o(w, R)] = w, b;
  }), u = ot.merge({}, ...l), [d, h] = pe("");
  function f(w) {
    return (R) => {
      const b = u[w], P = e.map((S, E) => E === b ? R : S);
      console.log("about to call setOperations", w, R), t(P);
    };
  }
  const p = (w) => ot.map(Array.from(w.entries()), ([R, b]) => b[0].symbol + R.toString()), y = (w) => {
    const R = [...e, w];
    t(R);
    const b = p(R)[R.length - 1];
    b !== void 0 && h(b);
  }, { argspecs: C, defaultArgs: v } = i;
  return /* @__PURE__ */ He("div", { className: "operations-viewer", children: [
    /* @__PURE__ */ $(
      IN,
      {
        column: r,
        addOperationCb: y,
        defaultArgs: v
      }
    ),
    /* @__PURE__ */ He("div", { className: "operations-box", children: [
      /* @__PURE__ */ $("h4", { children: " Operations " }),
      /* @__PURE__ */ $(
        ON,
        {
          operations: e,
          activeKey: d,
          setActiveKey: h,
          setOperations: t
        }
      )
    ] }),
    d && /* @__PURE__ */ $(
      EN,
      {
        command: a[d],
        setCommand: f(d),
        columns: n,
        commandPatterns: C
      }
    )
  ] });
}, cE = [
  "chart",
  "histogram",
  "linkify",
  "Base64PNGImageDisplayer",
  "SVGDisplayer"
];
function kN({
  filledOperations: e,
  style: t
}) {
  const n = { ...{ margin: "0", textAlign: "left" }, ...t };
  return /* @__PURE__ */ $("div", { className: "command-displayer", style: { width: "100%" }, children: /* @__PURE__ */ $("pre", { style: n, children: JSON.stringify(e) }) });
}
function Jb({
  style: e,
  generatedPyCode: t
}) {
  const n = { ...{ margin: "0", textAlign: "left" }, ...e };
  return /* @__PURE__ */ $("div", { className: "python-displayer", style: { width: "100%" }, children: /* @__PURE__ */ $("pre", { style: n, children: t }) });
}
function Xb({
  currentTab: e,
  _setTab: t,
  tabName: r
}) {
  return /* @__PURE__ */ $(
    "li",
    {
      onClick: () => {
        t(r);
      },
      className: e === r ? "active" : "",
      children: r
    }
  );
}
function uE({
  filledOperations: e,
  operation_result: t
}) {
  const [r, n] = pe("DataFrame"), i = { height: "45vh" };
  return /* @__PURE__ */ He("div", { className: "dependent-tabs", style: { width: "100%" }, children: [
    /* @__PURE__ */ He("ul", { className: "tabs", children: [
      /* @__PURE__ */ $(Xb, { currentTab: r, _setTab: n, tabName: "Python" }),
      /* @__PURE__ */ $(Xb, { currentTab: r, _setTab: n, tabName: "Operations" })
    ] }),
    /* @__PURE__ */ He("div", { className: "output-area", children: [
      t.transform_error ? /* @__PURE__ */ He("div", { children: [
        /* @__PURE__ */ $("h2", { children: " error " }),
        /* @__PURE__ */ $(
          Jb,
          {
            style: i,
            generatedPyCode: t.transform_error
          }
        )
      ] }) : /* @__PURE__ */ $("span", {}),
      {
        Operations: /* @__PURE__ */ $(kN, { style: i, filledOperations: e }),
        Python: /* @__PURE__ */ $(
          Jb,
          {
            style: i,
            generatedPyCode: t.generated_py_code
          }
        )
      }[r]
    ] })
  ] });
}
const Qb = (e) => (r) => /* @__PURE__ */ $("span", { children: e(r) }), LN = (e) => /* @__PURE__ */ $("a", { href: e.value, children: e.value }), _N = (e) => {
  const t = "data:image/png;base64," + e.value;
  return /* @__PURE__ */ $("img", { src: t });
}, zN = (e) => {
  const t = { __html: e.value };
  return /* @__PURE__ */ $(
    "div",
    {
      dangerouslySetInnerHTML: t
    }
  );
}, NN = [
  "#e65036",
  "#e65138",
  "#e75339",
  "#e7553a",
  "#e8563c",
  "#e8583d",
  "#e9593f",
  "#e95b40",
  "#e95c41",
  "#ea5e43",
  "#ea5f44",
  "#eb6046",
  "#eb6247",
  "#ec6349",
  "#ec654a",
  "#ec664b",
  "#ed684d",
  "#ed694e",
  "#ee6a50",
  "#ee6c51",
  "#ee6d52",
  "#ef6f54",
  "#ef7055",
  "#ef7157",
  "#f07358",
  "#f0745a",
  "#f1765b",
  "#f1775d",
  "#f1785e",
  "#f27a5f",
  "#f27b61",
  "#f27c62",
  "#f37e64",
  "#f37f65",
  "#f38067",
  "#f48268",
  "#f4836a",
  "#f4846b",
  "#f5866c",
  "#f5876e",
  "#f5886f",
  "#f58a71",
  "#f68b72",
  "#f68c74",
  "#f68d75",
  "#f78f77",
  "#f79078",
  "#f7917a",
  "#f7937b",
  "#f8947d",
  "#f8957e",
  "#f89780",
  "#f89881",
  "#f99983",
  "#f99a84",
  "#f99c86",
  "#f99d87",
  "#f99e89",
  "#faa08a",
  "#faa18c",
  "#faa28d",
  "#faa38f",
  "#faa590",
  "#fba692",
  "#fba793",
  "#fba995",
  "#fbaa96",
  "#fbab98",
  "#fbac99",
  "#fcae9b",
  "#fcaf9c",
  "#fcb09e",
  "#fcb19f",
  "#fcb3a1",
  "#fcb4a2",
  "#fcb5a4",
  "#fcb7a5",
  "#fdb8a7",
  "#fdb9a8",
  "#fdbaaa",
  "#fdbcac",
  "#fdbdad",
  "#fdbeaf",
  "#fdbfb0",
  "#fdc1b2",
  "#fdc2b3",
  "#fdc3b5",
  "#fdc4b6",
  "#fdc6b8",
  "#fdc7ba",
  "#fdc8bb",
  "#fdcabd",
  "#fdcbbe",
  "#fdccc0",
  "#fdcdc1",
  "#fdcfc3",
  "#fdd0c5",
  "#fdd1c6",
  "#fdd2c8",
  "#fdd4c9",
  "#fdd5cb",
  "#fdd6cc",
  "#fdd7ce",
  "#fdd9d0",
  "#fddad1",
  "#fddbd3",
  "#fddcd4",
  "#fdded6",
  "#fcdfd8",
  "#fce0d9",
  "#fce1db",
  "#fce3dc",
  "#fce4de",
  "#fce5e0",
  "#fce7e1",
  "#fce8e3",
  "#fbe9e5",
  "#fbeae6",
  "#fbece8",
  "#fbede9",
  "#fbeeeb",
  "#faefed",
  "#faf1ee",
  "#faf2f0",
  "#faf3f2",
  "#f9f4f3",
  "#f9f5f5",
  "#f8f6f6",
  "#f7f6f7",
  "#f6f6f8",
  "#f5f5f9",
  "#f4f4f9",
  "#f3f3f9",
  "#f1f2f9",
  "#f0f1f9",
  "#eff0f9",
  "#eeeffa",
  "#edeefa",
  "#ecedfa",
  "#eaecfa",
  "#e9ebfa",
  "#e8eafa",
  "#e7e9fa",
  "#e6e8fa",
  "#e5e7fa",
  "#e3e6fa",
  "#e2e5fa",
  "#e1e4fa",
  "#e0e3fa",
  "#dfe2fb",
  "#dde1fb",
  "#dce0fb",
  "#dbdffb",
  "#dadefb",
  "#d9ddfb",
  "#d7dcfb",
  "#d6dbfb",
  "#d5dafb",
  "#d4d9fb",
  "#d3d8fb",
  "#d1d7fb",
  "#d0d6fb",
  "#cfd5fb",
  "#ced4fb",
  "#cdd3fc",
  "#cbd2fc",
  "#cad1fc",
  "#c9d0fc",
  "#c8cffc",
  "#c6cefc",
  "#c5cdfc",
  "#c4ccfc",
  "#c3cbfc",
  "#c1cafc",
  "#c0c9fc",
  "#bfc8fc",
  "#bdc7fc",
  "#bcc7fc",
  "#bbc6fc",
  "#bac5fc",
  "#b8c4fc",
  "#b7c3fc",
  "#b6c2fc",
  "#b4c1fd",
  "#b3c0fd",
  "#b2bffd",
  "#b0befd",
  "#afbdfd",
  "#aebcfd",
  "#acbbfd",
  "#abbafd",
  "#aab9fd",
  "#a8b8fd",
  "#a7b7fd",
  "#a5b6fd",
  "#a4b5fd",
  "#a3b4fd",
  "#a1b3fd",
  "#a0b2fd",
  "#9eb2fd",
  "#9db1fd",
  "#9bb0fd",
  "#9aaffd",
  "#99aefd",
  "#97adfd",
  "#96acfd",
  "#94abfd",
  "#93aafd",
  "#91a9fd",
  "#90a8fd",
  "#8ea7fd",
  "#8ca6fd",
  "#8ba5fe",
  "#89a4fe",
  "#88a4fe",
  "#86a3fe",
  "#84a2fe",
  "#83a1fe",
  "#81a0fe",
  "#809ffe",
  "#7e9efe",
  "#7c9dfe",
  "#7a9cfe",
  "#799bfe",
  "#779afe",
  "#759afe",
  "#7399fe",
  "#7198fe",
  "#7097fe",
  "#6e96fe",
  "#6c95fe",
  "#6a94fe",
  "#6893fe",
  "#6692fe",
  "#6491fe",
  "#6291fe",
  "#5f90fe",
  "#5d8ffe",
  "#5b8efe",
  "#598dfe",
  "#568cfe",
  "#548bfe",
  "#518afe",
  "#4f8afe",
  "#4c89fe",
  "#4988fe",
  "#4787fe",
  "#4486fe",
  "#4085fe",
  "#3d84fe",
  "#3a83fe",
  "#3683fe",
  "#3282fe",
  "#2e81fe",
  "#2980fe",
  "#247ffe"
], BN = [
  "#0488fc",
  "#1089fb",
  "#1789fb",
  "#1d89fa",
  "#228afa",
  "#268af9",
  "#2a8af9",
  "#2e8af8",
  "#318bf7",
  "#348bf7",
  "#378bf6",
  "#3a8cf6",
  "#3c8cf5",
  "#3f8cf5",
  "#418df4",
  "#438df4",
  "#458df3",
  "#488df2",
  "#4a8ef2",
  "#4c8ef1",
  "#4d8ef1",
  "#4f8ff0",
  "#518ff0",
  "#538fef",
  "#5490ee",
  "#5690ee",
  "#5890ed",
  "#5991ed",
  "#5b91ec",
  "#5c91ec",
  "#5e92eb",
  "#5f92ea",
  "#6192ea",
  "#6292e9",
  "#6393e9",
  "#6593e8",
  "#6693e8",
  "#6794e7",
  "#6994e6",
  "#6a94e6",
  "#6b95e5",
  "#6c95e5",
  "#6e95e4",
  "#6f96e4",
  "#7096e3",
  "#7196e3",
  "#7297e2",
  "#7397e1",
  "#7497e1",
  "#7698e0",
  "#7798e0",
  "#7898df",
  "#7999df",
  "#7a99de",
  "#7b99dd",
  "#7c9add",
  "#7d9adc",
  "#7e9adc",
  "#7f9bdb",
  "#809bdb",
  "#819bda",
  "#829cd9",
  "#839cd9",
  "#849cd8",
  "#849dd8",
  "#859dd7",
  "#869dd7",
  "#879ed6",
  "#889ed5",
  "#899ed5",
  "#8a9fd4",
  "#8b9fd4",
  "#8c9fd3",
  "#8ca0d3",
  "#8da0d2",
  "#8ea0d1",
  "#8fa1d1",
  "#90a1d0",
  "#91a1d0",
  "#91a2cf",
  "#92a2ce",
  "#93a2ce",
  "#94a3cd",
  "#95a3cd",
  "#95a3cc",
  "#96a4cc",
  "#97a4cb",
  "#98a4ca",
  "#98a5ca",
  "#99a5c9",
  "#9aa5c9",
  "#9ba6c8",
  "#9ba6c8",
  "#9ca6c7",
  "#9da7c6",
  "#9ea7c6",
  "#9ea7c5",
  "#9fa8c5",
  "#a0a8c4",
  "#a0a9c3",
  "#a1a9c3",
  "#a2a9c2",
  "#a2aac2",
  "#a3aac1",
  "#a4aac1",
  "#a4abc0",
  "#a5abbf",
  "#a6abbf",
  "#a6acbe",
  "#a7acbe",
  "#a8acbd",
  "#a8adbc",
  "#a9adbc",
  "#aaadbb",
  "#aaaebb",
  "#abaeba",
  "#acafb9",
  "#acafb9",
  "#adafb8",
  "#adb0b8",
  "#aeb0b7",
  "#afb0b7",
  "#afb1b6",
  "#b0b1b5",
  "#b1b1b5",
  "#b1b2b4",
  "#b2b2b4",
  "#b2b2b3",
  "#b3b3b2",
  "#b4b3b2",
  "#b4b3b1",
  "#b5b4b1",
  "#b6b4b0",
  "#b7b4af",
  "#b7b5af",
  "#b8b5ae",
  "#b9b5ad",
  "#bab6ad",
  "#bab6ac",
  "#bbb6ac",
  "#bcb7ab",
  "#bcb7aa",
  "#bdb7aa",
  "#beb8a9",
  "#beb8a8",
  "#bfb8a8",
  "#c0b9a7",
  "#c0b9a7",
  "#c1b9a6",
  "#c2baa5",
  "#c2baa5",
  "#c3baa4",
  "#c4bba3",
  "#c4bba3",
  "#c5bba2",
  "#c6bca2",
  "#c6bca1",
  "#c7bca0",
  "#c8bca0",
  "#c8bd9f",
  "#c9bd9e",
  "#cabd9e",
  "#cabe9d",
  "#cbbe9c",
  "#ccbe9c",
  "#ccbf9b",
  "#cdbf9b",
  "#cdbf9a",
  "#cec099",
  "#cfc099",
  "#cfc098",
  "#d0c197",
  "#d1c197",
  "#d1c196",
  "#d2c295",
  "#d2c295",
  "#d3c294",
  "#d4c393",
  "#d4c393",
  "#d5c392",
  "#d5c491",
  "#d6c491",
  "#d7c490",
  "#d7c58f",
  "#d8c58f",
  "#d8c58e",
  "#d9c68d",
  "#dac68d",
  "#dac68c",
  "#dbc78b",
  "#dbc78b",
  "#dcc78a",
  "#dcc889",
  "#ddc889",
  "#dec888",
  "#dec987",
  "#dfc987",
  "#dfc986",
  "#e0ca85",
  "#e0ca85",
  "#e1ca84",
  "#e2cb83",
  "#e2cb83",
  "#e3cc82",
  "#e3cc81",
  "#e4cc80",
  "#e4cd80",
  "#e5cd7f",
  "#e6cd7e",
  "#e6ce7e",
  "#e7ce7d",
  "#e7ce7c",
  "#e8cf7b",
  "#e8cf7b",
  "#e9cf7a",
  "#e9d079",
  "#ead078",
  "#ead078",
  "#ebd177",
  "#ecd176",
  "#ecd176",
  "#edd275",
  "#edd274",
  "#eed273",
  "#eed373",
  "#efd372",
  "#efd371",
  "#f0d470",
  "#f0d46f",
  "#f1d46f",
  "#f1d56e",
  "#f2d56d",
  "#f2d56c",
  "#f3d66c",
  "#f3d66b",
  "#f4d66a",
  "#f5d769",
  "#f5d768",
  "#f6d868",
  "#f6d867",
  "#f7d866",
  "#f7d965",
  "#f8d964",
  "#f8d963",
  "#f9da63",
  "#f9da62",
  "#fada61",
  "#fadb60",
  "#fbdb5f",
  "#fbdb5e",
  "#fcdc5d",
  "#fcdc5d",
  "#fddc5c",
  "#fddd5b",
  "#fedd5a",
  "#fedd59"
], dE = (e) => e === "BLUE_TO_YELLOW" ? BN : e === "DIVERGING_RED_WHITE_BLUE" ? NN : e;
function GN(e, t) {
  const r = t.length;
  if (r === 0)
    return 0;
  for (let n = 0; n < t.length; n++)
    if (e <= t[n])
      return n;
  return e > t[r - 1] ? r - 1 : t.length;
}
function HN(e) {
  function t(r) {
    var y;
    const n = dE(e.map_name), i = { backgroundColor: "inherit" }, o = (y = r.context) == null ? void 0 : y.histogram_stats, s = e.val_column;
    if (s === void 0 || o === void 0)
      return console.log("66 couldn't find stats_col"), i;
    const a = o[s];
    if (a === void 0 || a.histogram_bins === void 0)
      return console.log("69 couldn't find summary_stats"), i;
    const l = a.histogram_bins;
    function u(C) {
      const v = GN(C, l), w = Math.round(v / l.length * n.length);
      return n[w];
    }
    const d = e.val_column && r.data ? r.data[e.val_column] : r.value, h = u(d);
    return {
      backgroundColor: r.node.rowPinned ? "inherit" : h
    };
  }
  return {
    cellStyle: t
  };
}
function WN(e) {
  const t = dE(e.map_name);
  function r(n) {
    const i = e.val_column && n.data ? n.data[e.val_column] : n.value;
    return {
      backgroundColor: n.node.rowPinned ? "inherit" : t[i]
    };
  }
  return {
    cellStyle: r
  };
}
function VN(e) {
  function t(n) {
    if (n.data === void 0)
      return { backgroundColor: "inherit" };
    const i = n.data[e.exist_column], o = i && i !== null, s = n.node.rowPinned;
    return {
      backgroundColor: o && !s ? e.conditional_color : "inherit"
    };
  }
  return {
    cellStyle: t
  };
}
function $N(e) {
  function t(r) {
    if (r.data === void 0)
      return { backgroundColor: "inherit" };
    const n = r.data[e.val_column], i = r.node.rowPinned;
    return {
      backgroundColor: n && !i ? n : "inherit"
    };
  }
  return {
    cellStyle: t
  };
}
function jN(e) {
  switch (e.color_rule) {
    case "color_map":
      return HN(e);
    case "color_categorical":
      return WN(e);
    case "color_from_column":
      return $N(e);
    case "color_not_null":
      return VN(e);
  }
}
var _a = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, r) {
    const n = t ? this.allAsyncListeners : this.allSyncListeners;
    let i = n.get(e);
    return !i && r && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, r = !1) {
    this.getListeners(e, r, !0).add(t);
  }
  removeEventListener(e, t, r = !1) {
    const n = this.getListeners(e, r, !1);
    n && (n.delete(t), n.size === 0 && (r ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const r = e.type;
    if (t && "event" in e) {
      const a = e.event;
      a instanceof Event && (e.eventPath = a.composedPath());
    }
    const n = (a, l) => a.forEach((u) => {
      if (!l.has(u))
        return;
      const d = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => u(e)) : () => u(e);
      t ? this.dispatchAsync(d) : d();
    }), i = this.getListeners(r, t, !1) ?? /* @__PURE__ */ new Set(), o = new Set(i);
    o.size > 0 && n(o, i), new Set(
      t ? this.globalAsyncListeners : this.globalSyncListeners
    ).forEach((a) => {
      const l = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => a(r, e)) : () => a(r, e);
      t ? this.dispatchAsync(l) : l();
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
}, vo = /* @__PURE__ */ ((e) => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(vo || {}), Zb = {};
function E0(e, t) {
  Zb[t] || (e(), Zb[t] = !0);
}
function Bn(e, ...t) {
  console.log("AG Grid: " + e, ...t);
}
function ie(e, ...t) {
  E0(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function tt(e, ...t) {
  E0(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function P0(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function UN(e) {
  KN(e, 400);
}
var cp = [], up = !1;
function eS(e) {
  cp.push(e), !up && (up = !0, window.setTimeout(() => {
    const t = cp.slice();
    cp.length = 0, up = !1, t.forEach((r) => r());
  }, 0));
}
function KN(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((r) => r()), t);
}
function Ar(e, t) {
  let r;
  return function(...n) {
    const i = this;
    window.clearTimeout(r), r = window.setTimeout(function() {
      e.apply(i, n);
    }, t);
  };
}
function tS(e, t) {
  let r = 0;
  return function(...n) {
    const i = this, o = (/* @__PURE__ */ new Date()).getTime();
    o - r < t || (r = o, e.apply(i, n));
  };
}
function qN(e, t, r = 100, n) {
  const i = (/* @__PURE__ */ new Date()).getTime();
  let o = null, s = !1;
  const a = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - i > r;
    (e() || l) && (t(), s = !0, o != null && (window.clearInterval(o), o = null));
  };
  a(), s || (o = window.setInterval(a, 10));
}
function Fi(e) {
  return e == null || e === "" ? null : e;
}
function de(e, t = !1) {
  return e != null && (e !== "" || t);
}
function Ke(e) {
  return !de(e);
}
function rn(e) {
  return e == null || e.length === 0;
}
function um(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function Qo(e) {
  if (e === void 0)
    return;
  if (e === null || e === "")
    return null;
  if (typeof e == "number")
    return isNaN(e) ? void 0 : e;
  const t = parseInt(e, 10);
  return isNaN(t) ? void 0 : t;
}
function dm(e) {
  if (e !== void 0)
    return e === null || e === "" ? !1 : hm(e);
}
function hm(e) {
  return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
}
function ec(e, t) {
  const r = e ? JSON.stringify(e) : null, n = t ? JSON.stringify(t) : null;
  return r === n;
}
function YN(e, t, r = !1) {
  const n = e == null, i = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), n && i)
    return 0;
  if (n)
    return -1;
  if (i)
    return 1;
  function o(s, a) {
    return s > a ? 1 : s < a ? -1 : 0;
  }
  if (typeof e != "string" || !r)
    return o(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return o(e, t);
  }
}
function fd(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = [];
    return e.forEach((r) => t.push(r)), t;
  }
  return Object.values(e);
}
function hE(e, t) {
  return e.get("rowModelType") === t;
}
function At(e) {
  return hE(e, "clientSide");
}
function yo(e) {
  return hE(e, "serverSide");
}
function ar(e, t) {
  return e.get("domLayout") === t;
}
function Rd(e) {
  return Ad(e) !== void 0;
}
function Ed(e) {
  return !e.get("suppressAsyncEvents");
}
function gE(e) {
  return typeof e.get("getRowHeight") == "function";
}
function JN(e, t) {
  return t ? !e.get("enableStrictPivotColumnOrder") : e.get("maintainColumnOrder");
}
function ho(e, t, r = !1, n) {
  if (n == null && (n = e.environment.getDefaultRowHeight()), gE(e)) {
    if (r)
      return { height: n, estimated: !0 };
    const s = {
      node: t,
      data: t.data
    }, a = e.getCallback("getRowHeight")(s);
    if (gm(a))
      return a === 0 && ie(
        "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."
      ), { height: Math.max(1, a), estimated: !1 };
  }
  if (t.detail && e.get("masterDetail"))
    return XN(e);
  const i = e.get("rowHeight");
  return { height: i && gm(i) ? i : n, estimated: !1 };
}
function XN(e) {
  if (e.get("detailRowAutoHeight"))
    return { height: 1, estimated: !1 };
  const t = e.get("detailRowHeight");
  return gm(t) ? { height: t, estimated: !1 } : { height: 300, estimated: !1 };
}
function Zo(e) {
  const { environment: t } = e, r = e.get("rowHeight");
  if (!r || Ke(r))
    return t.getDefaultRowHeight();
  const n = t.refreshRowHeightVariable();
  return n !== -1 ? n : (ie("row height must be a number if not using standard row model"), t.getDefaultRowHeight());
}
function gm(e) {
  return !isNaN(e) && typeof e == "number" && isFinite(e);
}
function tc(e, t, r) {
  const n = t[e.getDomDataKey()];
  return n ? n[r] : void 0;
}
function as(e, t, r, n) {
  const i = e.getDomDataKey();
  let o = t[i];
  Ke(o) && (o = {}, t[i] = o), o[r] = n;
}
function zt(e) {
  let t = null;
  const r = e.get("getDocument");
  return r && de(r) ? t = r() : e.eGridDiv && (t = e.eGridDiv.ownerDocument), t && de(t) ? t : document;
}
function fE(e) {
  return zt(e).defaultView || window;
}
function rc(e) {
  return e.eGridDiv.getRootNode();
}
function Dt(e) {
  return rc(e).activeElement;
}
function pE(e) {
  const t = zt(e), r = Dt(e);
  return r === null || r === t.body;
}
function Js(e) {
  return e.get("ensureDomOrder") ? !1 : e.get("animateRows");
}
function jh(e) {
  return !(e.get("paginateChildRows") || e.get("groupHideOpenParents") || ar(e, "print"));
}
function Zn(e) {
  const t = e.get("autoGroupColumnDef");
  return !(t != null && t.comparator) && !e.get("treeData");
}
function fm(e) {
  const t = e.get("groupAggFiltering");
  if (typeof t == "function")
    return e.getCallback("groupAggFiltering");
  if (t === !0)
    return () => !0;
}
function mE(e) {
  const t = e.get("grandTotalRow");
  if (t)
    return t;
  if (e.get("groupIncludeTotalFooter"))
    return "bottom";
}
function vE(e) {
  const t = e.get("groupTotalRow");
  if (typeof t == "function")
    return e.getCallback("groupTotalRow");
  if (t)
    return () => t;
  const r = e.get("groupIncludeFooter");
  if (typeof r == "function") {
    const n = e.getCallback("groupIncludeFooter");
    return (i) => n(i) ? "bottom" : void 0;
  }
  return () => r ? "bottom" : void 0;
}
function QN(e) {
  return e.exists("groupDisplayType") ? e.get("groupDisplayType") === "multipleColumns" : e.get("groupHideOpenParents");
}
function A0(e, t) {
  return t ? !1 : e.get("groupDisplayType") === "groupRows";
}
function za(e) {
  const t = e.getCallback("getRowId");
  return t === void 0 ? t : (r) => {
    let n = t(r);
    return typeof n != "string" && (ie("The getRowId callback must return a string. The ID ", n, " is being cast to a string."), n = String(n)), n;
  };
}
function na(e) {
  return (e == null ? void 0 : e.checkboxes) ?? !0;
}
function Pd(e) {
  return (e == null ? void 0 : e.mode) === "multiRow" && (e.headerCheckbox ?? !0);
}
function ZN(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? !1;
}
function eB(e) {
  return typeof e.get("rowSelection") != "string";
}
function tB(e) {
  return e.get("cellSelection") !== void 0;
}
function rB(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? (t == null ? void 0 : t.suppressMultiRanges) ?? !1 : !1 : e.get("suppressMultiRangeSelection");
}
function Ii(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? !!t : e.get("enableRangeSelection");
}
function nB(e) {
  var n;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((n = t.handle) == null ? void 0 : n.mode) === "range" : !1 : e.get("enableRangeHandle");
}
function rS(e) {
  var n;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((n = t.handle) == null ? void 0 : n.mode) === "fill" : !1 : e.get("enableFillHandle");
}
function yE(e) {
  const t = e.get("rowSelection") ?? "single";
  if (typeof t == "string") {
    const r = e.get("suppressRowClickSelection"), n = e.get("suppressRowDeselection");
    return r && n ? !1 : r ? "enableDeselection" : n ? "enableSelection" : !0;
  }
  return t.mode === "singleRow" || t.mode === "multiRow" ? t.enableClickSelection ?? !1 : !1;
}
function iB(e) {
  const t = yE(e);
  return t === !0 || t === "enableSelection";
}
function nS(e) {
  const t = yE(e);
  return t === !0 || t === "enableDeselection";
}
function F0(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("isRowSelectable") : t == null ? void 0 : t.isRowSelectable;
}
function Ad(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string")
    switch (t) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  return t == null ? void 0 : t.mode;
}
function CE(e) {
  return Ad(e) === "multiRow";
}
function oB(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("rowMultiSelectWithClick") : (t == null ? void 0 : t.enableSelectionWithoutKeys) ?? !1;
}
function M0(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") {
    const r = e.get("groupSelectsChildren"), n = e.get("groupSelectsFiltered");
    return r && n ? "filteredDescendants" : r ? "descendants" : "self";
  }
  return (t == null ? void 0 : t.mode) === "multiRow" ? t.groupSelects : void 0;
}
function ls(e) {
  const t = M0(e);
  return t === "descendants" || t === "filteredDescendants";
}
function dp(e) {
  return e.isModuleRegistered(
    "@ag-grid-enterprise/set-filter"
    /* SetFilterModule */
  ) && !e.get("suppressSetFilterByDefault");
}
function Ye(e) {
  if (!(!e || !e.length))
    return e[e.length - 1];
}
function Co(e, t, r) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((n, i) => r ? r(n, t[i]) : t[i] === n);
}
function sB(e) {
  return e.sort((t, r) => t - r);
}
function wE(e, t) {
  const r = e.indexOf(t);
  r >= 0 && (e[r] = e[e.length - 1], e.pop());
}
function Fr(e, t) {
  const r = e.indexOf(t);
  r >= 0 && e.splice(r, 1);
}
function aB(e, t) {
  for (let r = 0; r < t.length; r++)
    wE(e, t[r]);
}
function lB(e, t) {
  for (let r = 0; r < t.length; r++)
    Fr(e, t[r]);
}
function Fd(e, t, r) {
  e.splice(r, 0, t);
}
function bE(e, t, r) {
  lB(e, t), t.slice().reverse().forEach((n) => Fd(e, n, r));
}
function es(e, t) {
  return e.indexOf(t) > -1;
}
function cB(e) {
  return (e == null ? void 0 : e.flatMap((t) => t)) ?? [];
}
function iS(e, t) {
  t == null || e == null || t.forEach((r) => e.push(r));
}
var SE = "__ag_Grid_Stop_Propagation", uB = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], hp = {};
function ia(e) {
  e[SE] = !0;
}
function Mi(e) {
  return e[SE] === !0;
}
var xE = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (r) => {
    if (typeof hp[r] == "boolean")
      return hp[r];
    const n = document.createElement(e[r] || "div");
    return r = "on" + r, hp[r] = r in n;
  };
})();
function pm(e, t, r) {
  let n = t;
  for (; n; ) {
    const i = tc(e, n, r);
    if (i)
      return i;
    n = n.parentElement;
  }
  return null;
}
function dB(e, t) {
  return !t || !e ? !1 : gB(t).indexOf(e) >= 0;
}
function hB(e) {
  const t = [];
  let r = e.target;
  for (; r; )
    t.push(r), r = r.parentElement;
  return t;
}
function gB(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : hB(t);
}
function fB(e, t, r, n) {
  const o = es(uB, r) ? { passive: !0 } : void 0;
  e && e.addEventListener && e.addEventListener(t, r, n, o);
}
var J = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.frameworkOverrides = e.frameworkOverrides, this.stubContext = e.context, this.eventService = e.eventService, this.gos = e.gos, this.localeService = e.localeService;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  destroy() {
    for (let e = 0; e < this.destroyFunctions.length; e++)
      this.destroyFunctions[e]();
    this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventService to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t, r) {
    this.localEventService || (this.localEventService = new _a()), this.localEventService.addEventListener(e, t, r);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t, r) {
    this.localEventService && this.localEventService.removeEventListener(e, t, r);
  }
  dispatchLocalEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventService, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const r = [];
    for (const n in t) {
      const i = t[n];
      i && r.push(this._setupListener(e, n, i));
    }
    return r;
  }
  _setupListener(e, t, r) {
    if (this.destroyed)
      return () => null;
    e instanceof HTMLElement ? fB(this.getFrameworkOverrides(), e, t, r) : e.addEventListener(t, r);
    const n = () => (e.removeEventListener(t, r), null);
    return this.destroyFunctions.push(n), () => (n(), this.destroyFunctions = this.destroyFunctions.filter((i) => i !== n), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(e, t) {
    this.gos.addPropertyEventListener(e, t);
    const r = () => (this.gos.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(r), () => (r(), this.destroyFunctions = this.destroyFunctions.filter((n) => n !== r), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const r = e.join("-") + this.propertyListenerId++, n = (i) => {
      if (i.changeSet) {
        if (i.changeSet && i.changeSet.id === this.lastChangeSetIdLookup[r])
          return;
        this.lastChangeSetIdLookup[r] = i.changeSet.id;
      }
      const o = {
        type: "gridPropertyChanged",
        changeSet: i.changeSet,
        source: i.source
      };
      t(o);
    };
    e.forEach((i) => this.setupGridOptionListener(i, n));
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  createManagedBean(e, t) {
    const r = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), r;
  }
  createBean(e, t, r) {
    return (t || this.stubContext).createBean(e, r);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
};
function Er(e) {
  return e instanceof pd;
}
var pd = class extends J {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.expandable = !1, this.instanceId = PE(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = r, this.level = n;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      go(t) ? e.push(t) : Er(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, r = !1;
    const n = this.findChildrenRemovingPadding();
    for (let o = 0, s = n.length; o < s; o++) {
      const a = n[o];
      if (!a.isVisible())
        continue;
      const l = a.getColumnGroupShow();
      l === "open" ? (e = !0, r = !0) : l === "closed" ? (t = !0, r = !0) : (e = !0, t = !0);
    }
    const i = e && t && r;
    this.expandable !== i && (this.expandable = i, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (r) => {
      r.forEach((n) => {
        Er(n) && n.isPadding() ? t(n.children) : e.push(n);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, RE = "ag-Grid-ControlsColumn", pB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "controlsColService";
  }
  createControlsCols() {
    const { gos: e } = this, t = e.get("rowSelection");
    if (!t || typeof t != "object")
      return [];
    const r = na(t), n = Pd(t);
    if (r || n) {
      const i = e.get("selectionColumnDef"), s = {
        // overridable properties
        maxWidth: 50,
        resizable: !1,
        suppressHeaderMenuButton: !0,
        sortable: !1,
        suppressMovable: !0,
        lockPosition: e.get("enableRtl") ? "right" : "left",
        comparator(l, u, d, h) {
          const f = d.isSelected(), p = h.isSelected();
          return f && p ? 0 : f ? 1 : -1;
        },
        editable: !1,
        suppressFillHandle: !0,
        // overrides
        ...i,
        // non-overridable properties
        colId: `${RE}`
      }, a = new I0(s, null, s.colId, !1);
      return this.createBean(a), [a];
    }
    return [];
  }
}, Uh = "ag-Grid-AutoColumn";
function T0(e) {
  const t = [], r = (n) => {
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      go(o) ? t.push(o) : Er(o) && r(o.getChildren());
    }
  };
  return r(e), t;
}
function Ri(e) {
  return e.reduce((t, r) => t + r.getActualWidth(), 0);
}
function ro(e, t, r) {
  const n = {};
  if (!t)
    return;
  ki(null, t, (o) => {
    n[o.getInstanceId()] = o;
  }), r && ki(null, r, (o) => {
    n[o.getInstanceId()] = null;
  });
  const i = Object.values(n).filter((o) => o != null);
  e.destroyBeans(i);
}
function oS(e) {
  return e.getId().startsWith(Uh);
}
function Kh(e) {
  return e.getColId().startsWith(RE);
}
function md(e) {
  let t = [];
  return e instanceof Array ? e.some((n) => typeof n != "string") ? ie("if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : ie("colDef.type should be of type 'string' | 'string[]'"), t;
}
var D0 = class {
  constructor(e) {
    this.frameworkOverrides = e, this.wrappedListeners = /* @__PURE__ */ new Map(), this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
  }
  wrap(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r));
    }, this.wrappedListeners.set(e, t)), t;
  }
  wrapGlobal(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r, n) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r, n));
    }, this.wrappedGlobalListeners.set(e, t)), t;
  }
  unwrap(e) {
    return this.wrappedListeners.get(e) ?? e;
  }
  unwrapGlobal(e) {
    return this.wrappedGlobalListeners.get(e) ?? e;
  }
}, O0 = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function zn(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r++)
        t(r.toString(), e[r]);
      return;
    }
    for (const [r, n] of Object.entries(e))
      t(r, n);
  }
}
function EE(e) {
  const t = {}, r = Object.keys(e);
  for (let n = 0; n < r.length; n++) {
    if (O0.has(r[n]))
      continue;
    const i = r[n], o = e[i];
    t[i] = o;
  }
  return t;
}
function mm(e, t) {
  if (!e)
    return;
  const r = e, n = {};
  return Object.keys(r).forEach((i) => {
    if (t && t.indexOf(i) >= 0 || O0.has(i))
      return;
    const o = r[i];
    ym(o) && o.constructor === Object ? n[i] = mm(o) : n[i] = o;
  }), n;
}
function vm(e) {
  if (!e)
    return [];
  const t = Object;
  if (typeof t.values == "function")
    return t.values(e);
  const r = [];
  for (const n in e)
    e.hasOwnProperty(n) && e.propertyIsEnumerable(n) && r.push(e[n]);
  return r;
}
function Pr(e, t, r = !0, n = !1) {
  de(t) && zn(t, (i, o) => {
    if (O0.has(i))
      return;
    let s = e[i];
    s !== o && (n && s == null && o != null && typeof o == "object" && o.constructor === Object && (s = {}, e[i] = s), ym(o) && ym(s) && !Array.isArray(s) ? Pr(s, o, r, n) : (r || o !== void 0) && (e[i] = o));
  });
}
function Wl(e, t, r) {
  if (!t || !e)
    return;
  if (!r)
    return e[t];
  const n = t.split(".");
  let i = e;
  for (let o = 0; o < n.length; o++) {
    if (i == null)
      return;
    i = i[n[o]];
  }
  return i;
}
function ym(e) {
  return typeof e == "object" && e !== null;
}
var mB = {
  resizable: !0,
  sortable: !0
}, vB = 0;
function PE() {
  return vB++;
}
function go(e) {
  return e instanceof I0;
}
var I0 = class extends J {
  constructor(e, t, r, n) {
    super(), this.isColumn = !0, this.instanceId = PE(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.columnEventService = new _a(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = r, this.primary = n, this.setState(e);
  }
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(e) {
    e.sort !== void 0 ? (e.sort === "asc" || e.sort === "desc") && (this.sort = e.sort) : (e.initialSort === "asc" || e.initialSort === "desc") && (this.sort = e.initialSort);
    const t = e.sortIndex, r = e.initialSortIndex;
    t !== void 0 ? t !== null && (this.sortIndex = t) : r !== null && (this.sortIndex = r);
    const n = e.hide, i = e.initialHide;
    n !== void 0 ? this.visible = !n : this.visible = !i, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
    const o = e.flex, s = e.initialFlex;
    o !== void 0 ? this.flex = o : s !== void 0 && (this.flex = s);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, r) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.columnEventService.dispatchEvent(this.createColumnEvent("colDefChanged", r));
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(e) {
    this.parent = e;
  }
  getParent() {
    return this.parent;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const e = this.gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = de(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = de(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? this.gos.environment.getDefaultColumnMinWidth(), this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.tooltipEnabled = de(this.colDef.tooltipField) || de(this.colDef.tooltipValueGetter) || de(this.colDef.tooltipComponent);
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const r = Qo(e.width), n = Qo(e.initialWidth);
    return r != null ? t = r : n != null ? t = n : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    if (Ke(this.colDef) || Ke(this.colDef.showRowGroup))
      return !1;
    const t = this.colDef.showRowGroup === !0, r = this.colDef.showRowGroup === e;
    return t || r;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  addEventListener(e, t) {
    var n;
    this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.columnEventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new D0(this.frameworkOverrides));
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(t)) ?? t;
    this.columnEventService.addEventListener(e, r);
  }
  removeEventListener(e, t) {
    var n;
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.unwrap(t)) ?? t;
    this.columnEventService.removeEventListener(e, r);
  }
  createColumnFunctionCallbackParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    if (typeof this.colDef.suppressNavigable == "boolean")
      return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const t = this.createColumnFunctionCallbackParams(e), r = this.colDef.suppressNavigable;
      return r(t);
    }
    return !1;
  }
  isCellEditable(e) {
    if (e.group) {
      if (this.gos.get("treeData")) {
        if (!e.data && !this.gos.get("enableGroupEdit"))
          return !1;
      } else if (!this.gos.get("enableGroupEdit"))
        return !1;
    }
    return this.isColumnFunc(e, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    const t = this.gos.get("rowSelection");
    if (t && typeof t != "string") {
      const r = Kh(this) && na(t);
      return this.isColumnFunc(e, r);
    } else
      return this.isColumnFunc(e, this.colDef.checkboxSelection);
  }
  isSuppressPaste(e) {
    return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? mB[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const r = this.createColumnFunctionCallbackParams(e);
      return t(r);
    }
    return !1;
  }
  setHighlighted(e) {
    this.highlighted !== e && (this.highlighted = e, this.columnEventService.dispatchEvent(this.createColumnEvent("headerHighlightChanged", "uiColumnMoved")));
  }
  setMoving(e, t) {
    this.moving = e, this.columnEventService.dispatchEvent(this.createColumnEvent("movingChanged", t));
  }
  createColumnEvent(e, t) {
    return this.gos.addGridCommonParams({
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  setSort(e, t) {
    this.sort !== e && (this.sort = e, this.columnEventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort");
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return Ke(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return de(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(e) {
    this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setMenuVisible(e, t) {
    this.menuVisible !== e && (this.menuVisible = e, this.columnEventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  setAggFunc(e) {
    this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc");
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.columnEventService.dispatchEvent(this.createColumnEvent("leftChanged", t)));
  }
  isFilterActive() {
    return this.filterActive;
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setFilterActive(e, t, r) {
    this.filterActive !== e && (this.filterActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
    const n = this.createColumnEvent("filterChanged", t);
    r && Pr(n, r), this.columnEventService.dispatchEvent(n);
  }
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(e) {
    e === !0 || e === "left" ? this.pinned = "left" : e === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const r = e === !0;
    this.visible !== r && (this.visible = r, this.columnEventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    return !this.getColDef().suppressSpanHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let r = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        r = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: r };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (Ke(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.colSpan(t);
    return Math.max(r, 1);
  }
  getRowSpan(e) {
    if (Ke(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.rowSpan(t);
    return Math.max(r, 1);
  }
  setActualWidth(e, t, r = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), r || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.columnEventService.dispatchEvent(this.createColumnEvent("widthChanged", e));
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  // this method should only be used by the columnModel to
  // change flex when required by the applyColumnState method.
  setFlex(e) {
    this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(e) {
    this.setActualWidth(this.minWidth, e);
  }
  setRowGroupActive(e, t) {
    this.rowGroupActive !== e && (this.rowGroupActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(e, t) {
    this.pivotActive !== e && (this.pivotActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot");
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(e, t) {
    this.aggregationActive !== e && (this.aggregationActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)));
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchStateUpdatedEvent(e) {
    this.columnEventService.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
}, yB = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
}, CB = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = um(e);
    let r = 0;
    for (; ; ) {
      let n;
      if (e ? (n = e, r !== 0 && (n += "_" + r)) : t ? (n = t, r !== 0 && (n += "_" + r)) : n = r, !this.existingKeys[n])
        return this.existingKeys[n] = !0, String(n);
      r++;
    }
  }
}, wB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnFactory";
  }
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  createColumnTree(e, t, r, n) {
    const i = new CB(), { existingCols: o, existingGroups: s, existingColKeys: a } = this.extractExistingTreeData(r);
    i.addExistingKeys(a);
    const l = this.recursivelyCreateColumns(
      e,
      0,
      t,
      o,
      i,
      s,
      n
    ), u = this.findMaxDept(l, 0), d = this.balanceColumnTree(l, 0, u, i);
    return ki(null, d, (f, p) => {
      Er(f) && f.setupExpandable(), f.setOriginalParent(p);
    }), {
      columnTree: d,
      treeDept: u
    };
  }
  extractExistingTreeData(e) {
    const t = [], r = [], n = [];
    return e && ki(null, e, (i) => {
      if (Er(i)) {
        const o = i;
        r.push(o);
      } else {
        const o = i;
        n.push(o.getId()), t.push(o);
      }
    }), { existingCols: t, existingGroups: r, existingColKeys: n };
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(e, t) {
    const r = [], n = this.findDepth(t);
    return e.forEach((i) => {
      let o = i;
      for (let s = n - 1; s >= 0; s--) {
        const a = new pd(null, `FAKE_PATH_${i.getId()}}_${s}`, !0, s);
        this.createBean(a), a.setChildren([o]), o.setOriginalParent(a), o = a;
      }
      n === 0 && i.setOriginalParent(null), r.push(o);
    }), [r, n];
  }
  findDepth(e) {
    let t = 0, r = e;
    for (; r && r[0] && Er(r[0]); )
      t++, r = r[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, r, n) {
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const s = e[o];
      if (Er(s)) {
        const a = s, l = this.balanceColumnTree(
          a.getChildren(),
          t + 1,
          r,
          n
        );
        a.setChildren(l), i.push(a);
      } else {
        let a, l;
        for (let u = r - 1; u >= t; u--) {
          const d = n.getUniqueKey(null, null), h = this.createMergedColGroupDef(null), f = new pd(h, d, !0, t);
          this.createBean(f), l && l.setChildren([f]), l = f, a || (a = l);
        }
        if (a && l)
          if (i.push(a), e.some((d) => Er(d))) {
            l.setChildren([s]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        i.push(s);
      }
    }
    return i;
  }
  findMaxDept(e, t) {
    let r = t;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (Er(i)) {
        const o = i, s = this.findMaxDept(o.getChildren(), t + 1);
        r < s && (r = s);
      }
    }
    return r;
  }
  recursivelyCreateColumns(e, t, r, n, i, o, s) {
    if (!e)
      return [];
    const a = new Array(e.length);
    for (let l = 0; l < a.length; l++) {
      const u = e[l];
      this.isColumnGroup(u) ? a[l] = this.createColumnGroup(
        r,
        u,
        t,
        n,
        i,
        o,
        s
      ) : a[l] = this.createColumn(
        r,
        u,
        n,
        i,
        s
      );
    }
    return a;
  }
  createColumnGroup(e, t, r, n, i, o, s) {
    const a = this.createMergedColGroupDef(t), l = i.getUniqueKey(a.groupId || null, null), u = new pd(a, l, !1, r);
    this.createBean(u);
    const d = this.findExistingGroup(t, o);
    d && o.splice(d.idx, 1);
    const h = d == null ? void 0 : d.group;
    h && u.setExpanded(h.isExpanded());
    const f = this.recursivelyCreateColumns(
      a.children,
      r + 1,
      e,
      n,
      i,
      o,
      s
    );
    return u.setChildren(f), u;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, r, n, i) {
    var a;
    const o = this.findExistingColumn(t, r);
    o && (r == null || r.splice(o.idx, 1));
    let s = o == null ? void 0 : o.column;
    if (s) {
      const l = this.addColumnDefaultAndTypes(t, s.getColId());
      s.setColDef(l, t, i), this.applyColumnState(s, l, i);
    } else {
      const l = n.getUniqueKey(t.colId, t.field), u = this.addColumnDefaultAndTypes(t, l);
      s = new I0(u, t, l, e), this.createBean(s);
    }
    return (a = this.dataTypeService) == null || a.addColumnListeners(s), s;
  }
  applyColumnState(e, t, r) {
    const n = Qo(t.flex);
    if (n !== void 0 && e.setFlex(n), e.getFlex() <= 0) {
      const a = Qo(t.width);
      if (a != null)
        e.setActualWidth(a, r);
      else {
        const l = e.getActualWidth();
        e.setActualWidth(l, r);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort, r) : e.setSort(void 0, r));
    const o = Qo(t.sortIndex);
    o !== void 0 && e.setSortIndex(o);
    const s = dm(t.hide);
    s !== void 0 && e.setVisible(!s, r), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    if (t)
      for (let r = 0; r < t.length; r++) {
        const n = t[r].getUserProvidedColDef();
        if (!n)
          continue;
        if (e.colId != null) {
          if (t[r].getId() === e.colId)
            return { idx: r, column: t[r] };
          continue;
        }
        if (e.field != null) {
          if (n.field === e.field)
            return { idx: r, column: t[r] };
          continue;
        }
        if (n === e)
          return { idx: r, column: t[r] };
      }
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (i.getColGroupDef() && i.getId() === e.groupId)
          return { idx: n, group: i };
      }
  }
  addColumnDefaultAndTypes(e, t) {
    var a;
    const r = {}, n = this.gos.get("defaultColDef");
    Pr(r, n, !1, !0);
    const i = this.updateColDefAndGetColumnType(r, e, t);
    i && this.assignColumnTypes(i, r), Pr(r, e, !1, !0);
    const o = this.gos.get("autoGroupColumnDef"), s = Zn(this.gos);
    return e.rowGroup && o && s && Pr(
      r,
      { sort: o.sort, initialSort: o.initialSort },
      !1,
      !0
    ), (a = this.dataTypeService) == null || a.validateColDef(r), r;
  }
  updateColDefAndGetColumnType(e, t, r) {
    var o;
    const n = (o = this.dataTypeService) == null ? void 0 : o.updateColDefAndGetColumnType(
      e,
      t,
      r
    ), i = t.type ?? n ?? e.type;
    return e.type = i, i ? md(i) : void 0;
  }
  assignColumnTypes(e, t) {
    if (!e.length)
      return;
    const r = Object.assign({}, yB), n = this.gos.get("columnTypes") || {};
    zn(n, (i, o) => {
      i in r ? ie(`the column type '${i}' is a default column type and cannot be overridden.`) : (o.type && ie(
        "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."
      ), r[i] = o);
    }), e.forEach((i) => {
      const o = r[i.trim()];
      o ? Pr(t, o, !1, !0) : ie("colDef.type '" + i + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  // if object has children, we assume it's a group
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
function ki(e, t, r) {
  if (t)
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      Er(i) && ki(i, i.getChildren(), r), r(i, e);
    }
}
var bB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnModel", this.pivotMode = !1, this.autoHeightActiveAtLeastOnce = !1, this.ready = !1, this.changeEventsDispatching = !1, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  wireBeans(e) {
    this.context = e.context, this.ctrlsService = e.ctrlsService, this.columnFactory = e.columnFactory, this.columnSizeService = e.columnSizeService, this.visibleColsService = e.visibleColsService, this.columnViewportService = e.columnViewportService, this.pivotResultColsService = e.pivotResultColsService, this.columnAnimationService = e.columnAnimationService, this.autoColService = e.autoColService, this.controlsColService = e.controlsColService, this.valueCache = e.valueCache, this.columnDefFactory = e.columnDefFactory, this.columnApplyStateService = e.columnApplyStateService, this.columnGroupStateService = e.columnGroupStateService, this.eventDispatcher = e.columnEventDispatcher, this.columnMoveService = e.columnMoveService, this.columnAutosizeService = e.columnAutosizeService, this.funcColsService = e.funcColsService, this.quickFilterService = e.quickFilterService, this.showRowGroupColsService = e.showRowGroupColsService, this.environment = e.environment;
  }
  postConstruct() {
    const e = this.gos.get("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (t) => this.refreshAll(Wo(t.source))
    ), this.addManagedPropertyListener("rowSelection", (t) => {
      this.onSelectionOptionsChanged(t.currentValue, t.previousValue, Wo(t.source));
    }), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      (t) => this.onAutoGroupColumnDefChanged(Wo(t.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      (t) => this.recreateColumnDefs(Wo(t.source))
    ), this.addManagedPropertyListener(
      "pivotMode",
      (t) => this.setPivotMode(this.gos.get("pivotMode"), Wo(t.source))
    ), this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e) {
    var u, d, h;
    const t = this.colDefs ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(e) : void 0;
    this.valueCache.expire();
    const r = (u = this.colDefCols) == null ? void 0 : u.list, n = (d = this.colDefCols) == null ? void 0 : d.tree, i = this.columnFactory.createColumnTree(this.colDefs, !0, n, e);
    ro(this.context, (h = this.colDefCols) == null ? void 0 : h.tree, i.columnTree);
    const o = i.columnTree, s = i.treeDept, a = T0(o), l = {};
    a.forEach((f) => l[f.getId()] = f), this.colDefCols = { tree: o, treeDepth: s, list: a, map: l }, this.funcColsService.extractCols(e, r), this.ready = !0, this.refreshCols(!0), this.visibleColsService.refresh(e), this.columnViewportService.checkViewportColumns(), this.eventDispatcher.everythingChanged(e), t && (this.changeEventsDispatching = !0, t(), this.changeEventsDispatching = !1), this.eventDispatcher.newColumnsLoaded(e), e === "gridInitializing" && this.columnSizeService.applyAutosizeStrategy();
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultColsService.setPivotResultCols
  refreshCols(e) {
    var i, o, s;
    if (!this.colDefCols)
      return;
    const t = (i = this.cols) == null ? void 0 : i.tree;
    this.saveColOrder(), this.selectCols(), this.createAutoCols(), this.addAutoCols(), this.createControlsCols(), this.addControlsCols();
    const r = JN(this.gos, this.showingPivotResult);
    (!e || r) && this.restoreColOrder(), this.positionLockedCols(), (o = this.showRowGroupColsService) == null || o.refresh(), (s = this.quickFilterService) == null || s.refreshQuickFilterCols(), this.setColSpanActive(), this.setAutoHeightActive(), this.visibleColsService.clear(), this.columnViewportService.clear(), !Co(t, this.cols.tree) && this.eventDispatcher.gridColumns();
  }
  selectCols() {
    const e = this.pivotResultColsService.getPivotResultCols();
    if (this.showingPivotResult = e != null, e) {
      const { map: t, list: r, tree: n, treeDepth: i } = e;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      }, e.list.some((s) => {
        var a;
        return ((a = this.cols) == null ? void 0 : a.map[s.getColId()]) !== void 0;
      }) || (this.lastPivotOrder = null);
    } else {
      const { map: t, list: r, tree: n, treeDepth: i } = this.colDefCols;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      };
    }
  }
  getColsToShow() {
    const e = this.isPivotMode() && !this.isShowingPivotResult(), t = this.funcColsService.getValueColumns();
    return this.cols.list.filter((n) => {
      const i = oS(n);
      if (e) {
        const o = t && es(t, n);
        return i || o;
      } else
        return i || n.isVisible();
    });
  }
  addAutoCols() {
    this.autoCols != null && (this.cols.list = this.autoCols.list.concat(this.cols.list), this.cols.tree = this.autoCols.tree.concat(this.cols.tree), sS(this.cols));
  }
  createAutoCols() {
    var y;
    const e = A0(this.gos, this.pivotMode), t = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), r = this.funcColsService.getRowGroupColumns(), i = !(r.length > 0 || this.gos.get("treeData")) || t || e, o = () => {
      this.autoCols && (ro(this.context, this.autoCols.tree), this.autoCols = null);
    };
    if (i || !this.autoColService) {
      o();
      return;
    }
    const s = this.autoColService.createAutoCols(r) ?? [], a = lS(s, ((y = this.autoCols) == null ? void 0 : y.list) || null), l = this.cols.treeDepth, d = (this.autoCols ? this.autoCols.treeDepth : -1) == l;
    if (a && d)
      return;
    o();
    const [h, f] = this.columnFactory.balanceTreeForAutoCols(s, this.cols.tree);
    this.autoCols = {
      list: s,
      tree: h,
      treeDepth: f,
      map: {}
    };
    const p = (C) => {
      if (!C)
        return null;
      const v = C.filter((w) => !oS(w));
      return [...s, ...v];
    };
    this.lastOrder = p(this.lastOrder), this.lastPivotOrder = p(this.lastPivotOrder);
  }
  createControlsCols() {
    var u, d, h;
    const e = () => {
      var f;
      ro(this.context, (f = this.controlsCols) == null ? void 0 : f.tree), this.controlsCols = null;
    };
    this.controlsColService || e();
    const t = this.cols.treeDepth, n = (((u = this.controlsCols) == null ? void 0 : u.treeDepth) ?? -1) == t, i = ((d = this.controlsColService) == null ? void 0 : d.createControlsCols()) ?? [];
    if (lS(i, ((h = this.controlsCols) == null ? void 0 : h.list) ?? []) && n)
      return;
    e();
    const [s, a] = this.columnFactory.balanceTreeForAutoCols(i, this.cols.tree);
    this.controlsCols = {
      list: i,
      tree: s,
      treeDepth: a,
      map: {}
    };
    const l = (f) => {
      if (!f)
        return null;
      const p = f.filter((y) => !Kh(y));
      return [...i, ...p];
    };
    this.lastOrder = l(this.lastOrder), this.lastPivotOrder = l(this.lastPivotOrder);
  }
  addControlsCols() {
    this.controlsCols != null && (this.cols.list = this.controlsCols.list.concat(this.cols.list), this.cols.tree = this.controlsCols.tree.concat(this.cols.tree), sS(this.cols));
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.isReady() && (this.refreshCols(!1), this.visibleColsService.refresh(e));
  }
  setColsVisible(e, t = !1, r) {
    this.columnApplyStateService.applyColumnState(
      {
        state: e.map((n) => ({
          colId: typeof n == "string" ? n : n.getColId(),
          hide: !t
        }))
      },
      r
    );
  }
  setColsPinned(e, t, r) {
    if (!this.cols || rn(e))
      return;
    if (ar(this.gos, "print")) {
      ie("Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let n;
    t === !0 || t === "left" ? n = "left" : t === "right" ? n = "right" : n = null;
    const i = [];
    e.forEach((o) => {
      if (!o)
        return;
      const s = this.getCol(o);
      s && s.getPinned() !== n && (s.setPinned(n), i.push(s));
    }), i.length && (this.visibleColsService.refresh(r), this.eventDispatcher.columnPinned(i, r)), this.columnAnimationService.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, r) {
    let n;
    Er(e) ? n = e.getId() : n = e || "", this.columnGroupStateService.setColumnGroupState([{ groupId: n, open: t }], r);
  }
  getProvidedColGroup(e) {
    var r;
    let t = null;
    return ki(null, (r = this.cols) == null ? void 0 : r.tree, (n) => {
      Er(n) && n.getId() === e && (t = n);
    }), t;
  }
  isColGroupLocked(e) {
    const t = this.gos.get("groupLockGroupColumns");
    if (!e.isRowGroupActive() || t === 0)
      return !1;
    if (t === -1)
      return !0;
    const n = this.funcColsService.getRowGroupColumns().findIndex((i) => i.getColId() === e.getColId());
    return t > n;
  }
  isSuppressAutoCol() {
    return this.gos.get("groupDisplayType") === "custom" ? !0 : this.gos.get("treeDataDisplayType") === "custom";
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.cols.list.some((e) => e.isVisible() && e.isAutoHeight()), this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = !0, At(this.gos) || yo(this.gos) || ie("autoHeight columns only work with Client Side Row Model and Server Side Row Model."));
  }
  restoreColOrder() {
    const e = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!e)
      return;
    const t = new Map(e.map((l, u) => [l, u]));
    if (!this.cols.list.some((l) => t.has(l)))
      return;
    const n = new Map(this.cols.list.map((l) => [l, !0])), i = e.filter((l) => n.has(l)), o = new Map(i.map((l) => [l, !0])), s = this.cols.list.filter((l) => !o.has(l)), a = i.slice();
    s.forEach((l) => {
      let u = l.getOriginalParent();
      if (!u) {
        a.push(l);
        return;
      }
      const d = [];
      for (; !d.length && u; )
        u.getLeafColumns().forEach((y) => {
          const C = a.indexOf(y) >= 0, v = d.indexOf(y) < 0;
          C && v && d.push(y);
        }), u = u.getOriginalParent();
      if (!d.length) {
        a.push(l);
        return;
      }
      const h = d.map((p) => a.indexOf(p)), f = Math.max(...h);
      Fd(a, l, f + 1);
    }), this.cols.list = a;
  }
  sortColsLikeKeys(e) {
    if (this.cols == null)
      return;
    let t = [];
    const r = {};
    e.forEach((i) => {
      if (r[i])
        return;
      const o = this.cols.map[i];
      o && (t.push(o), r[i] = !0);
    });
    let n = 0;
    if (this.cols.list.forEach((i) => {
      const o = i.getColId();
      if (r[o] != null)
        return;
      o.startsWith(Uh) ? Fd(t, i, n++) : t.push(i);
    }), t = this.columnMoveService.placeLockedColumns(t), !this.columnMoveService.doesMovePassMarryChildren(t)) {
      ie(
        "Applying column order broke a group where columns should be married together. Applying new order has been discarded."
      );
      return;
    }
    this.cols.list = t;
  }
  // returns the provided cols sorted in same order as they appear in this.cols, eg if this.cols
  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
  sortColsLikeCols(e) {
    !e || e.length <= 1 || e.filter((r) => this.cols.list.indexOf(r) < 0).length > 0 || e.sort((r, n) => {
      const i = this.cols.list.indexOf(r), o = this.cols.list.indexOf(n);
      return i - o;
    });
  }
  resetColDefIntoCol(e, t) {
    const r = e.getUserProvidedColDef();
    if (!r)
      return !1;
    const n = this.columnFactory.addColumnDefaultAndTypes(r, e.getColId());
    return e.setColDef(n, r, t), !0;
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0;
  }
  isShouldQueueResizeOperations() {
    return this.shouldQueueResizeOperations;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  moveInCols(e, t, r) {
    var n;
    bE((n = this.cols) == null ? void 0 : n.list, e, t), this.visibleColsService.refresh(r);
  }
  positionLockedCols() {
    this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = (e = this.cols) == null ? void 0 : e.list : this.lastOrder = (t = this.cols) == null ? void 0 : t.list;
  }
  getColumnDefs() {
    if (!this.colDefCols)
      return;
    const e = this.colDefCols.list.slice();
    this.showingPivotResult ? e.sort((n, i) => this.lastOrder.indexOf(n) - this.lastOrder.indexOf(i)) : this.lastOrder && e.sort((n, i) => this.cols.list.indexOf(n) - this.cols.list.indexOf(i));
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns();
    return this.columnDefFactory.buildColumnDefs(e, t, r);
  }
  isShowingPivotResult() {
    return this.showingPivotResult;
  }
  // called by clientSideRowModel.refreshModel
  isChangeEventsDispatching() {
    return this.changeEventsDispatching;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  // used by Column Tool Panel
  isProvidedColGroupsPresent() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.treeDepth) > 0;
  }
  setColSpanActive() {
    this.colSpanActive = this.cols.list.some((e) => e.getColDef().colSpan != null);
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  // + gridPanel -> for resizing the body and setting top margin
  getHeaderRowCount() {
    return this.cols ? this.cols.treeDepth + 1 : -1;
  }
  isReady() {
    return this.ready;
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode) || (this.pivotMode = e, this.ready && (this.refreshCols(!1), this.visibleColsService.refresh(t), this.eventDispatcher.pivotModeChanged()));
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get("treeData") ? (ie("Pivot mode not available with treeData."), !1) : !0;
  }
  // + clientSideRowModel
  isPivotActive() {
    const e = this.funcColsService.getPivotColumns();
    return this.pivotMode && !rn(e);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    this.cols && (this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e), this.createColsFromColDefs(e));
  }
  setColumnDefs(e, t) {
    this.colDefs = e, this.createColsFromColDefs(t);
  }
  destroy() {
    var e, t, r;
    ro(this.context, (e = this.colDefCols) == null ? void 0 : e.tree), ro(this.context, (t = this.autoCols) == null ? void 0 : t.tree), ro(this.context, (r = this.controlsCols) == null ? void 0 : r.tree), super.destroy();
  }
  getColTree() {
    return this.cols.tree;
  }
  // + columnSelectPanel
  getColDefColTree() {
    return this.colDefCols.tree;
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return (e = this.colDefCols) != null && e.list ? this.colDefCols.list : null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  // returns colDefCols, pivotResultCols and autoCols
  getAllCols() {
    var r, n, i;
    const e = this.pivotResultColsService.getPivotResultCols(), t = e == null ? void 0 : e.list;
    return [
      ((r = this.colDefCols) == null ? void 0 : r.list) ?? [],
      ((n = this.autoCols) == null ? void 0 : n.list) ?? [],
      ((i = this.controlsCols) == null ? void 0 : i.list) ?? [],
      t ?? []
    ].flat();
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  getColFromCollection(e, t) {
    if (t == null)
      return null;
    const { map: r, list: n } = t;
    if (typeof e == "string" && r[e])
      return r[e];
    for (let i = 0; i < n.length; i++)
      if (aS(n[i], e))
        return n[i];
    return this.getAutoCol(e);
  }
  getAutoCol(e) {
    var t;
    return ((t = this.autoCols) == null ? void 0 : t.list.find((r) => aS(r, e))) ?? null;
  }
  getAutoCols() {
    var e;
    return ((e = this.autoCols) == null ? void 0 : e.list) ?? null;
  }
  setColHeaderHeight(e, t) {
    e.setAutoHeaderHeight(t) && (e.isColumn ? this.eventDispatcher.headerHeight(e) : this.eventDispatcher.groupHeaderHeight(e));
  }
  getGroupRowsHeight() {
    const e = [], t = this.ctrlsService.getHeaderRowContainerCtrls();
    for (const r of t) {
      if (!r)
        continue;
      const n = r.getGroupRowCount() || 0;
      for (let i = 0; i < n; i++) {
        const o = r.getGroupRowCtrlAtIndex(i), s = e[i];
        if (o) {
          const a = this.getColumnGroupHeaderRowHeight(o);
          (s == null || a > s) && (e[i] = a);
        }
      }
    }
    return e;
  }
  getColumnGroupHeaderRowHeight(e) {
    const t = this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
    let r = 0;
    const n = e.getHeaderCtrls();
    for (const i of n) {
      const o = i.getColumn();
      if (o.isAutoHeaderHeight()) {
        const s = o.getAutoHeaderHeight();
        s != null && s > r && (r = s);
      }
    }
    return Math.max(t, r);
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), r = this.visibleColsService.getAllCols().filter((n) => n.isAutoHeaderHeight()).map((n) => n.getAutoHeaderHeight() || 0);
    return Math.max(e, ...r);
  }
  getHeaderHeight() {
    return this.gos.get("headerHeight") ?? this.environment.getDefaultHeaderHeight();
  }
  getFloatingFiltersHeight() {
    return this.gos.get("floatingFiltersHeight") ?? this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    return this.gos.get("groupHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    return this.gos.get("pivotHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    return this.gos.get("pivotGroupHeaderHeight") ?? this.getGroupHeaderHeight();
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents")
      return;
    const { colIds: t, skipHeader: r } = e;
    setTimeout(() => {
      t ? this.columnAutosizeService.autoSizeCols({
        colKeys: t,
        skipHeader: r,
        source: "autosizeColumns"
      }) : this.columnAutosizeService.autoSizeAllColumns("autosizeColumns", r);
    });
  }
  onAutoGroupColumnDefChanged(e) {
    this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e);
  }
  onSelectionOptionsChanged(e, t, r) {
    const n = t && typeof t != "string" ? na(t) : void 0, i = e && typeof e != "string" ? na(e) : void 0, o = n !== i, s = t && typeof t != "string" ? Pd(t) : void 0, a = e && typeof e != "string" ? Pd(e) : void 0;
    (o || s !== a) && this.refreshAll(r);
  }
};
function Wo(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function sS(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function aS(e, t) {
  const r = e === t, n = e.getColDef() === t, i = e.getColId() == t;
  return r || n || i;
}
function lS(e, t) {
  return Co(e, t, (r, n) => r.getColId() === n.getColId());
}
var SB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnAutosizeService", this.timesDelayed = 0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.animationFrameService = e.animationFrameService, this.autoWidthCalculator = e.autoWidthCalculator, this.eventDispatcher = e.columnEventDispatcher, this.ctrlsService = e.ctrlsService, this.renderStatusService = e.renderStatusService;
  }
  autoSizeCols(e) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const { colKeys: t, skipHeader: r, skipHeaderGroups: n, stopAtGroup: i, source: o = "api" } = e;
    if (this.animationFrameService.flushAllFrames(), this.timesDelayed < 5 && this.renderStatusService && !this.renderStatusService.areHeaderCellsRendered()) {
      this.timesDelayed++, setTimeout(() => this.autoSizeCols(e));
      return;
    }
    this.timesDelayed = 0;
    const s = [];
    let a = -1;
    const l = r ?? this.gos.get("skipHeaderOnAutoSize"), u = n ?? l;
    for (; a !== 0; ) {
      a = 0;
      const d = [];
      t.forEach((h) => {
        if (!h)
          return;
        const f = this.columnModel.getCol(h);
        if (!f || s.indexOf(f) >= 0)
          return;
        const p = this.autoWidthCalculator.getPreferredWidthForColumn(f, l);
        if (p > 0) {
          const y = this.normaliseColumnWidth(f, p);
          f.setActualWidth(y, o), s.push(f), a++;
        }
        d.push(f);
      }), d.length && this.visibleColsService.refresh(o);
    }
    u || this.autoSizeColumnGroupsByColumns(t, o, i), this.eventDispatcher.columnResized(s, !0, "autosizeColumns");
  }
  autoSizeColumn(e, t, r) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: r, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    this.columnModel.getColsForKeys(e).forEach((a) => {
      let l = a.getParent();
      for (; l && l != r; )
        l.isPadding() || n.add(l), l = l.getParent();
    });
    let o;
    const s = [];
    for (const a of n) {
      for (const l of this.ctrlsService.getHeaderRowContainerCtrls())
        if (o = l.getHeaderCtrlForColumn(a), o)
          break;
      o && o.resizeLeafColumnsToFit(t);
    }
    return s;
  }
  autoSizeAllColumns(e, t) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const r = this.visibleColsService.getAllCols();
    this.autoSizeCols({ colKeys: r, skipHeader: t, source: e });
  }
  // returns the width we can set to this col, taking into consideration min and max widths
  normaliseColumnWidth(e, t) {
    const r = e.getMinWidth();
    t < r && (t = r);
    const n = e.getMaxWidth();
    return e.isGreaterThanMax(t) && (t = n), t;
  }
}, xB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "funcColsService", this.rowGroupCols = [], this.valueCols = [], this.pivotCols = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.aggFuncService = e.aggFuncService, this.visibleColsService = e.visibleColsService;
  }
  getModifyColumnsNoEventsCallbacks() {
    return {
      addGroupCol: (e) => this.rowGroupCols.push(e),
      removeGroupCol: (e) => Fr(this.rowGroupCols, e),
      addPivotCol: (e) => this.pivotCols.push(e),
      removePivotCol: (e) => Fr(this.pivotCols, e),
      addValueCol: (e) => this.valueCols.push(e),
      removeValueCol: (e) => Fr(this.valueCols, e)
    };
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    if (t === !0)
      return this.rowGroupCols.slice(0);
    const r = this.columnModel.getColDefCol(t);
    return r ? [r] : null;
  }
  sortRowGroupColumns(e) {
    this.rowGroupCols.sort(e);
  }
  sortPivotColumns(e) {
    this.pivotCols.sort(e);
  }
  // + rowController
  getValueColumns() {
    return this.valueCols ? this.valueCols : [];
  }
  // + rowController
  getPivotColumns() {
    return this.pivotCols ? this.pivotCols : [];
  }
  // + toolPanel
  getRowGroupColumns() {
    return this.rowGroupCols ? this.rowGroupCols : [];
  }
  isRowGroupEmpty() {
    return rn(this.rowGroupCols);
  }
  setColumnAggFunc(e, t, r) {
    if (!e)
      return;
    const n = this.columnModel.getColDefCol(e);
    n && (n.setAggFunc(t), this.eventDispatcher.columnChanged("columnValueChanged", [n], r));
  }
  setRowGroupColumns(e, t) {
    this.setColList(
      e,
      this.rowGroupCols,
      "columnRowGroupChanged",
      !0,
      !0,
      (r, n) => this.setRowGroupActive(r, n, t),
      t
    );
  }
  setRowGroupActive(e, t, r) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, r), e && !this.gos.get("suppressRowGroupHidesColumns") && this.columnModel.setColsVisible([t], !1, r), !e && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup") && this.columnModel.setColsVisible([t], !0, r));
  }
  addRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !0,
      !0,
      (r) => this.setRowGroupActive(!0, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  removeRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !1,
      !0,
      (r) => this.setRowGroupActive(!1, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  addPivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !0,
      !1,
      (r) => r.setPivotActive(!0, t),
      "columnPivotChanged",
      t
    );
  }
  setPivotColumns(e, t) {
    this.setColList(
      e,
      this.pivotCols,
      "columnPivotChanged",
      !0,
      !1,
      (r, n) => {
        n.setPivotActive(r, t);
      },
      t
    );
  }
  removePivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !1,
      !1,
      (r) => r.setPivotActive(!1, t),
      "columnPivotChanged",
      t
    );
  }
  setValueColumns(e, t) {
    this.setColList(
      e,
      this.valueCols,
      "columnValueChanged",
      !1,
      !1,
      (r, n) => this.setValueActive(r, n, t),
      t
    );
  }
  setValueActive(e, t, r) {
    if (e !== t.isValueActive() && (t.setValueActive(e, r), e && !t.getAggFunc() && this.aggFuncService)) {
      const n = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(n);
    }
  }
  addValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !0,
      !1,
      (r) => this.setValueActive(!0, r, t),
      "columnValueChanged",
      t
    );
  }
  removeValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !1,
      !1,
      (r) => this.setValueActive(!1, r, t),
      "columnValueChanged",
      t
    );
  }
  moveRowGroupColumn(e, t, r) {
    if (this.isRowGroupEmpty())
      return;
    const n = this.rowGroupCols[e], i = this.rowGroupCols.slice(e, t);
    this.rowGroupCols.splice(e, 1), this.rowGroupCols.splice(t, 0, n), this.eventDispatcher.rowGroupChanged(i, r);
  }
  setColList(e, t, r, n, i, o, s) {
    if (!this.columnModel.getCols())
      return;
    const a = /* @__PURE__ */ new Map();
    t.forEach((u, d) => a.set(u, d)), t.length = 0, de(e) && e.forEach((u) => {
      const d = this.columnModel.getColDefCol(u);
      d && t.push(d);
    }), t.forEach((u, d) => {
      const h = a.get(u);
      if (h === void 0) {
        a.set(u, 0);
        return;
      }
      n && h !== d || a.delete(u);
    }), (this.columnModel.getColDefCols() || []).forEach((u) => {
      const d = t.indexOf(u) >= 0;
      o(d, u);
    }), i && this.columnModel.refreshCols(!1), this.visibleColsService.refresh(s), this.eventDispatcher.columnChanged(r, [...a.keys()], s);
  }
  updateColList(e, t, r, n, i, o, s) {
    if (!e || rn(e))
      return;
    let a = !1;
    const l = /* @__PURE__ */ new Set();
    e.forEach((u) => {
      if (!u)
        return;
      const d = this.columnModel.getColDefCol(u);
      if (d) {
        if (l.add(d), r) {
          if (t.indexOf(d) >= 0)
            return;
          t.push(d);
        } else {
          const h = t.indexOf(d);
          if (h < 0)
            return;
          for (let f = h + 1; f < t.length; f++)
            l.add(t[f]);
          Fr(t, d);
        }
        i(d), a = !0;
      }
    }), a && (n && this.columnModel.refreshCols(!1), this.visibleColsService.refresh(s), this.eventDispatcher.genericColumnEvent(o, Array.from(l), s));
  }
  extractCols(e, t) {
    this.extractRowGroupCols(e, t), this.extractPivotCols(e, t), this.extractValueCols(e, t);
  }
  extractValueCols(e, t) {
    this.valueCols = this.extractColsCommon(
      t,
      this.valueCols,
      (r, n) => r.setValueActive(n, e),
      // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
      () => {
      },
      () => {
      },
      // aggFunc is a string, so return it's existence
      (r) => {
        const n = r.aggFunc;
        if (n === null || n === "")
          return null;
        if (n !== void 0)
          return !!n;
      },
      (r) => r.initialAggFunc != null && r.initialAggFunc != ""
    ), this.valueCols.forEach((r) => {
      const n = r.getColDef();
      n.aggFunc != null && n.aggFunc != "" ? r.setAggFunc(n.aggFunc) : r.getAggFunc() || r.setAggFunc(n.initialAggFunc);
    });
  }
  extractRowGroupCols(e, t) {
    this.rowGroupCols = this.extractColsCommon(
      t,
      this.rowGroupCols,
      (r, n) => r.setRowGroupActive(n, e),
      (r) => r.rowGroupIndex,
      (r) => r.initialRowGroupIndex,
      (r) => r.rowGroup,
      (r) => r.initialRowGroup
    );
  }
  extractPivotCols(e, t) {
    this.pivotCols = this.extractColsCommon(
      t,
      this.pivotCols,
      (r, n) => r.setPivotActive(n, e),
      (r) => r.pivotIndex,
      (r) => r.initialPivotIndex,
      (r) => r.pivot,
      (r) => r.initialPivot
    );
  }
  extractColsCommon(e = [], t = [], r, n, i, o, s) {
    const a = [], l = [];
    (this.columnModel.getColDefCols() || []).forEach((f) => {
      const p = e.indexOf(f) < 0, y = f.getColDef(), C = dm(o(y)), v = dm(s(y)), w = Qo(n(y)), R = Qo(i(y));
      let b;
      C !== void 0 ? b = C : w !== void 0 ? w === null ? b = !1 : b = w >= 0 : p ? v !== void 0 ? b = v : R !== void 0 ? b = R != null && R >= 0 : b = !1 : b = t.indexOf(f) >= 0, b && ((p ? w != null || R != null : w != null) ? a.push(f) : l.push(f));
    });
    const d = (f) => {
      const p = n(f.getColDef()), y = i(f.getColDef());
      return p ?? y;
    };
    a.sort((f, p) => {
      const y = d(f), C = d(p);
      return y === C ? 0 : y < C ? -1 : 1;
    });
    const h = [].concat(a);
    return t.forEach((f) => {
      l.indexOf(f) >= 0 && h.push(f);
    }), l.forEach((f) => {
      h.indexOf(f) < 0 && h.push(f);
    }), t.forEach((f) => {
      h.indexOf(f) < 0 && r(f, !1);
    }), h.forEach((f) => {
      t.indexOf(f) < 0 && r(f, !0);
    }), h;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const r = {}, n = (i, o, s, a, l, u) => {
      const d = this.columnModel.getColDefCols();
      if (!o.length || !d)
        return [];
      const h = Object.keys(i), f = new Set(h), p = new Set(h), y = new Set(
        o.map((E) => {
          const A = E.getColId();
          return p.delete(A), A;
        }).concat(h)
      ), C = [], v = {};
      let w = 0;
      for (let E = 0; E < d.length; E++) {
        const A = d[E].getColId();
        y.has(A) && (C.push(A), v[A] = w++);
      }
      let R = 1e3, b = !1, P = 0;
      const S = (E) => {
        const A = v[E];
        for (let M = P; M < A; M++) {
          const I = C[M];
          p.has(I) && (i[I][l] = R++, p.delete(I));
        }
        P = A;
      };
      o.forEach((E) => {
        const A = E.getColId();
        if (f.has(A))
          S(A), i[A][l] = R++;
        else {
          const M = E.getColDef();
          (M[l] === null || M[l] === void 0 && M[u] == null) && (b || (M[s] || M[s] === void 0 && M[a] ? S(A) : (p.forEach((k) => {
            i[k][l] = R + v[k];
          }), R += C.length, b = !0)), r[A] || (r[A] = { colId: A }), r[A][l] = R++);
        }
      });
    };
    return n(
      e,
      this.rowGroupCols,
      "rowGroup",
      "initialRowGroup",
      "rowGroupIndex",
      "initialRowGroupIndex"
    ), n(
      t,
      this.pivotCols,
      "pivot",
      "initialPivot",
      "pivotIndex",
      "initialPivotIndex"
    ), Object.values(r);
  }
}, RB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnApplyStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.sortController = e.sortController, this.columnGetStateService = e.columnGetStateService, this.funcColsService = e.funcColsService, this.visibleColsService = e.visibleColsService, this.columnAnimationService = e.columnAnimationService, this.pivotResultColsService = e.pivotResultColsService;
  }
  applyColumnState(e, t) {
    const r = this.columnModel.getColDefCols() || [];
    if (rn(r))
      return !1;
    if (e && e.state && !e.state.forEach)
      return ie(
        "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."
      ), !1;
    const n = this.funcColsService.getModifyColumnsNoEventsCallbacks(), i = (a, l, u) => {
      const d = this.compareColumnStatesAndDispatchEvents(t), h = l.slice(), f = {}, p = {}, y = [], C = [];
      let v = 0;
      const w = this.funcColsService.getRowGroupColumns().slice(), R = this.funcColsService.getPivotColumns().slice();
      a.forEach((E) => {
        const A = E.colId || "";
        if (A.startsWith(Uh)) {
          y.push(E), C.push(E);
          return;
        }
        const I = u(A);
        I ? (this.syncColumnWithStateItem(
          I,
          E,
          e.defaultState,
          f,
          p,
          !1,
          t,
          n
        ), Fr(h, I)) : (C.push(E), v += 1);
      });
      const b = (E) => this.syncColumnWithStateItem(
        E,
        null,
        e.defaultState,
        f,
        p,
        !1,
        t,
        n
      );
      h.forEach(b), this.funcColsService.sortRowGroupColumns(
        cS.bind(this, f, w)
      ), this.funcColsService.sortPivotColumns(cS.bind(this, p, R)), this.columnModel.refreshCols(!1);
      const S = (this.columnModel.getAutoCols() || []).slice();
      return y.forEach((E) => {
        const A = this.columnModel.getAutoCol(E.colId);
        Fr(S, A), this.syncColumnWithStateItem(
          A,
          E,
          e.defaultState,
          null,
          null,
          !0,
          t,
          n
        );
      }), S.forEach(b), this.orderLiveColsLikeState(e), this.visibleColsService.refresh(t), this.eventDispatcher.everythingChanged(t), d(), { unmatchedAndAutoStates: C, unmatchedCount: v };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates: o, unmatchedCount: s } = i(
      e.state || [],
      r,
      (a) => this.columnModel.getColDefCol(a)
    );
    if (o.length > 0 || de(e.defaultState)) {
      const a = this.pivotResultColsService.getPivotResultCols(), l = a == null ? void 0 : a.list;
      s = i(
        o,
        l || [],
        (u) => this.pivotResultColsService.getPivotResultCol(u)
      ).unmatchedCount;
    }
    return this.columnAnimationService.finish(), s === 0;
  }
  resetColumnState(e) {
    const t = this.columnModel.getColDefCols();
    if (rn(t))
      return;
    const r = this.columnModel.getColDefColTree(), n = T0(r), i = [];
    let o = 1e3, s = 1e3, a = [];
    const l = this.columnModel.getAutoCols();
    l && (a = a.concat(l)), n && (a = a.concat(n)), a.forEach((u) => {
      const d = this.getColumnStateFromColDef(u);
      Ke(d.rowGroupIndex) && d.rowGroup && (d.rowGroupIndex = o++), Ke(d.pivotIndex) && d.pivot && (d.pivotIndex = s++), i.push(d);
    }), this.applyColumnState({ state: i, applyOrder: !0 }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (y, C) => y ?? C ?? null, r = e.getColDef(), n = t(r.sort, r.initialSort), i = t(r.sortIndex, r.initialSortIndex), o = t(r.hide, r.initialHide), s = t(r.pinned, r.initialPinned), a = t(r.width, r.initialWidth), l = t(r.flex, r.initialFlex);
    let u = t(
      r.rowGroupIndex,
      r.initialRowGroupIndex
    ), d = t(r.rowGroup, r.initialRowGroup);
    u == null && (d == null || d == !1) && (u = null, d = null);
    let h = t(r.pivotIndex, r.initialPivotIndex), f = t(r.pivot, r.initialPivot);
    h == null && (f == null || f == !1) && (h = null, f = null);
    const p = t(r.aggFunc, r.initialAggFunc);
    return {
      colId: e.getColId(),
      sort: n,
      sortIndex: i,
      hide: o,
      pinned: s,
      width: a,
      flex: l,
      rowGroup: d,
      rowGroupIndex: u,
      pivot: f,
      pivotIndex: h,
      aggFunc: p
    };
  }
  syncColumnWithStateItem(e, t, r, n, i, o, s, a) {
    if (!e)
      return;
    const l = (P, S) => {
      const E = {
        value1: void 0,
        value2: void 0
      };
      let A = !1;
      return t && (t[P] !== void 0 && (E.value1 = t[P], A = !0), de(S) && t[S] !== void 0 && (E.value2 = t[S], A = !0)), !A && r && (r[P] !== void 0 && (E.value1 = r[P]), de(S) && r[S] !== void 0 && (E.value2 = r[S])), E;
    }, u = l("hide").value1;
    u !== void 0 && e.setVisible(!u, s);
    const d = l("pinned").value1;
    d !== void 0 && e.setPinned(d);
    const h = e.getColDef().minWidth ?? this.gos.environment.getDefaultColumnMinWidth(), f = l("flex").value1;
    if (f !== void 0 && e.setFlex(f), f == null) {
      const P = l("width").value1;
      P != null && h != null && P >= h && e.setActualWidth(P, s);
    }
    const p = l("sort").value1;
    p !== void 0 && (p === "desc" || p === "asc" ? e.setSort(p, s) : e.setSort(void 0, s));
    const y = l("sortIndex").value1;
    if (y !== void 0 && e.setSortIndex(y), o || !e.isPrimary())
      return;
    const C = l("aggFunc").value1;
    C !== void 0 && (typeof C == "string" ? (e.setAggFunc(C), e.isValueActive() || (e.setValueActive(!0, s), a.addValueCol(e))) : (de(C) && ie(
      "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."
    ), e.isValueActive() && (e.setValueActive(!1, s), a.removeValueCol(e))));
    const { value1: v, value2: w } = l("rowGroup", "rowGroupIndex");
    (v !== void 0 || w !== void 0) && (typeof w == "number" || v ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, s), a.addGroupCol(e)), n && typeof w == "number" && (n[e.getId()] = w)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, s), a.removeGroupCol(e)));
    const { value1: R, value2: b } = l("pivot", "pivotIndex");
    (R !== void 0 || b !== void 0) && (typeof b == "number" || R ? (e.isPivotActive() || (e.setPivotActive(!0, s), a.addPivotCol(e)), i && typeof b == "number" && (i[e.getId()] = b)) : e.isPivotActive() && (e.setPivotActive(!1, s), a.removePivotCol(e)));
  }
  orderLiveColsLikeState(e) {
    if (!e.applyOrder || !e.state)
      return;
    const t = [];
    e.state.forEach((r) => {
      r.colId != null && t.push(r.colId);
    }), this.columnModel.sortColsLikeKeys(t);
  }
  // calculates what events to fire between column state changes. gets used when:
  // a) apply column state
  // b) apply new column definitions (so changes from old cols)
  compareColumnStatesAndDispatchEvents(e) {
    const t = {
      rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(),
      pivotColumns: this.funcColsService.getPivotColumns().slice(),
      valueColumns: this.funcColsService.getValueColumns().slice()
    }, r = this.columnGetStateService.getColumnState(), n = {};
    return r.forEach((i) => {
      n[i.colId] = i;
    }), () => {
      const i = this.columnModel.getAllCols(), o = (C, v, w, R) => {
        const b = v.map(R), P = w.map(R);
        if (Co(b, P))
          return;
        const E = new Set(v);
        w.forEach((M) => {
          E.delete(M) || E.add(M);
        });
        const A = [...E];
        this.eventService.dispatchEvent({
          type: C,
          columns: A,
          column: A.length === 1 ? A[0] : null,
          source: e
        });
      }, s = (C) => {
        const v = [];
        return i.forEach((w) => {
          const R = n[w.getColId()];
          R && C(R, w) && v.push(w);
        }), v;
      }, a = (C) => C.getColId();
      o(
        "columnRowGroupChanged",
        t.rowGroupColumns,
        this.funcColsService.getRowGroupColumns(),
        a
      ), o(
        "columnPivotChanged",
        t.pivotColumns,
        this.funcColsService.getPivotColumns(),
        a
      );
      const u = s((C, v) => {
        const w = C.aggFunc != null, R = w != v.isValueActive(), b = w && C.aggFunc != v.getAggFunc();
        return R || b;
      });
      u.length > 0 && this.eventDispatcher.columnChanged("columnValueChanged", u, e);
      const d = (C, v) => C.width != v.getActualWidth();
      this.eventDispatcher.columnResized(s(d), !0, e);
      const h = (C, v) => C.pinned != v.getPinned();
      this.eventDispatcher.columnPinned(s(h), e);
      const f = (C, v) => C.hide == v.isVisible();
      this.eventDispatcher.columnVisible(s(f), e);
      const y = s((C, v) => C.sort != v.getSort() || C.sortIndex != v.getSortIndex());
      y.length > 0 && this.sortController.dispatchSortChangedEvents(e, y), this.normaliseColumnMovedEventForColumnState(r, e);
    };
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const r = this.columnGetStateService.getColumnState(), n = {};
    r.forEach((l) => n[l.colId] = l);
    const i = {};
    e.forEach((l) => {
      n[l.colId] && (i[l.colId] = !0);
    });
    const o = e.filter((l) => i[l.colId]), s = r.filter((l) => i[l.colId]), a = [];
    s.forEach((l, u) => {
      const d = o && o[u];
      if (d && d.colId !== l.colId) {
        const h = this.columnModel.getCol(d.colId);
        h && a.push(h);
      }
    }), a.length && this.eventDispatcher.columnMoved({ movedColumns: a, source: t, finished: !0 });
  }
}, cS = (e, t, r, n) => {
  const i = e[r.getId()], o = e[n.getId()], s = i != null, a = o != null;
  if (s && a)
    return i - o;
  if (s)
    return -1;
  if (a)
    return 1;
  const l = t.indexOf(r), u = t.indexOf(n), d = l >= 0, h = u >= 0;
  return d && h ? l - u : d ? -1 : 1;
}, EB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnMoveService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher;
  }
  moveColumnByIndex(e, t, r) {
    const n = this.columnModel.getCols();
    if (!n)
      return;
    const i = n[e];
    this.moveColumns([i], t, r);
  }
  moveColumns(e, t, r, n = !0) {
    const i = this.columnModel.getCols();
    if (!i)
      return;
    if (t > i.length - e.length) {
      ie("tried to insert columns in invalid location, toIndex = ", t), ie("remember that you should not count the moving columns when calculating the new index");
      return;
    }
    this.columnAnimationService.start();
    const o = this.columnModel.getColsForKeys(e);
    this.doesMovePassRules(o, t) && (this.columnModel.moveInCols(o, t, r), this.eventDispatcher.columnMoved({ movedColumns: o, source: r, toIndex: t, finished: n })), this.columnAnimationService.finish();
  }
  doesMovePassRules(e, t) {
    const r = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(r);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const n = this.columnModel.getCols().slice();
    return bE(n, e, t), n;
  }
  doesMovePassLockedPositions(e) {
    const t = (o) => o ? o === "left" || o === !0 ? -1 : 1 : 0, r = this.gos.get("enableRtl");
    let n = r ? 1 : -1, i = !0;
    return e.forEach((o) => {
      const s = t(o.getColDef().lockPosition);
      r ? s > n && (i = !1) : s < n && (i = !1), n = s;
    }), i;
  }
  doesMovePassMarryChildren(e) {
    let t = !0;
    const r = this.columnModel.getColTree();
    return ki(null, r, (n) => {
      if (!Er(n))
        return;
      const i = n, o = i.getColGroupDef();
      if (!(o && o.marryChildren))
        return;
      const a = [];
      i.getLeafColumns().forEach((f) => {
        const p = e.indexOf(f);
        a.push(p);
      });
      const l = Math.max.apply(Math, a), u = Math.min.apply(Math, a), d = l - u, h = i.getLeafColumns().length - 1;
      d > h && (t = !1);
    }), t;
  }
  placeLockedColumns(e) {
    const t = [], r = [], n = [];
    return e.forEach((o) => {
      const s = o.getColDef().lockPosition;
      s === "right" ? n.push(o) : s === "left" || s === !0 ? t.push(o) : r.push(o);
    }), this.gos.get("enableRtl") ? [...n, ...r, ...t] : [...t, ...r, ...n];
  }
}, PB = /[&<>"']/g, AB = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function ni(e, t) {
  if (e == null)
    return null;
  const r = e.toString().toString();
  return t ? r : r.replace(PB, (n) => AB[n]);
}
function FB(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, r = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(r, "$1 $2$3").replace(/\./g, " ").split(" ").map((i) => i.substring(0, 1).toUpperCase() + (i.length > 1 ? i.substring(1, i.length) : "")).join(" ");
}
var MB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnNameService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.funcColsService = e.funcColsService, this.columnModel = e.columnModel;
  }
  getDisplayNameForColumn(e, t, r = !1) {
    if (!e)
      return null;
    const n = this.getHeaderName(e.getColDef(), e, null, null, t);
    return r ? this.wrapHeaderNameWithAggFunc(e, n) : n;
  }
  getDisplayNameForProvidedColumnGroup(e, t, r) {
    const n = t ? t.getColGroupDef() : null;
    return n ? this.getHeaderName(n, null, e, t, r) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, r, n, i) {
    const o = e.headerValueGetter;
    if (o) {
      const s = this.gos.addGridCommonParams({
        colDef: e,
        column: t,
        columnGroup: r,
        providedColumnGroup: n,
        location: i
      });
      return typeof o == "function" ? o(s) : typeof o == "string" ? this.expressionService.evaluate(o, s) : (ie("headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return FB(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const r = e.getColDef().pivotValueColumn, n = de(r);
    let i = null, o;
    if (n) {
      const s = this.funcColsService.getValueColumns(), a = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && s.length === 1, l = e.getColDef().pivotTotalColumnIds !== void 0;
      if (a && !l)
        return t;
      i = r ? r.getAggFunc() : null, o = !0;
    } else {
      const s = e.isValueActive(), a = this.columnModel.isPivotMode() || !this.funcColsService.isRowGroupEmpty();
      s && a ? (i = e.getAggFunc(), o = !0) : o = !1;
    }
    if (o) {
      const s = typeof i == "string" ? i : "func";
      return `${this.localeService.getLocaleTextFunc()(s, s)}(${t})`;
    }
    return t;
  }
}, TB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "pivotResultColsService";
  }
  wireBeans(e) {
    this.context = e.context, this.columnModel = e.columnModel, this.columnFactory = e.columnFactory, this.visibleColsService = e.visibleColsService;
  }
  destroy() {
    var e;
    ro(this.context, (e = this.pivotResultCols) == null ? void 0 : e.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null)
      return null;
    const r = this.columnModel.getColDefCol(t);
    let n = null;
    return this.pivotResultCols.list.forEach((i) => {
      const o = i.getColDef().pivotKeys, s = i.getColDef().pivotValueColumn;
      Co(o, e) && s === r && (n = i);
    }), n;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.columnModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var r, n;
    if (this.columnModel.isReady() && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const i = this.columnFactory.createColumnTree(
          e,
          !1,
          ((r = this.pivotResultCols) == null ? void 0 : r.tree) || this.previousPivotResultCols || void 0,
          t
        );
        ro(this.context, (n = this.pivotResultCols) == null ? void 0 : n.tree, i.columnTree);
        const o = i.columnTree, s = i.treeDept, a = T0(o), l = {};
        this.pivotResultCols = { tree: o, treeDepth: s, list: a, map: l }, this.pivotResultCols.list.forEach((d) => this.pivotResultCols.map[d.getId()] = d);
        const u = !!this.previousPivotResultCols;
        this.previousPivotResultCols = null, this.columnModel.refreshCols(!u);
      } else
        this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null, this.columnModel.refreshCols(!1);
      this.visibleColsService.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), r = this.gos.get("processPivotResultColGroupDef");
    if (!t && !r)
      return;
    const n = (i) => {
      i.forEach((o) => {
        if (de(o.children)) {
          const a = o;
          r && r(a), n(a.children);
        } else
          t && t(o);
      });
    };
    e && n(e);
  }
}, DB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnSizeService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  setColumnWidths(e, t, r, n) {
    const i = [];
    e.forEach((o) => {
      const s = this.columnModel.getColDefCol(o.key) || this.columnModel.getCol(o.key);
      if (!s)
        return;
      if (i.push({
        width: o.newWidth,
        ratios: [1],
        columns: [s]
      }), this.gos.get("colResizeDefault") === "shift" && (t = !t), t) {
        const l = this.visibleColsService.getColAfter(s);
        if (!l)
          return;
        const u = s.getActualWidth() - o.newWidth, d = l.getActualWidth() + u;
        i.push({
          width: d,
          ratios: [1],
          columns: [l]
        });
      }
    }), i.length !== 0 && this.resizeColumnSets({
      resizeSets: i,
      finished: r,
      source: n
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: r, source: n } = e;
    if (!(!t || t.every((d) => this.checkMinAndMaxWidthsForSet(d)))) {
      if (r) {
        const d = t && t.length > 0 ? t[0].columns : null;
        this.eventDispatcher.columnResized(d, r, n);
      }
      return;
    }
    const o = [], s = [];
    t.forEach((d) => {
      const { width: h, columns: f, ratios: p } = d, y = {}, C = {};
      f.forEach((R) => s.push(R));
      let v = !0, w = 0;
      for (; v; ) {
        if (w++, w > 1e3) {
          tt("infinite loop in resizeColumnSets");
          break;
        }
        v = !1;
        const R = [];
        let b = 0, P = h;
        f.forEach((E, A) => {
          if (C[E.getId()])
            P -= y[E.getId()];
          else {
            R.push(E);
            const I = p[A];
            b += I;
          }
        });
        const S = 1 / b;
        R.forEach((E, A) => {
          const M = A === R.length - 1;
          let I;
          M ? I = P : (I = Math.round(p[A] * h * S), P -= I);
          const z = E.getMinWidth(), k = E.getMaxWidth();
          I < z ? (I = z, C[E.getId()] = !0, v = !0) : k > 0 && I > k && (I = k, C[E.getId()] = !0, v = !0), y[E.getId()] = I;
        });
      }
      f.forEach((R) => {
        const b = y[R.getId()];
        R.getActualWidth() !== b && (R.setActualWidth(b, n), o.push(R));
      });
    });
    const a = o.length > 0;
    let l = [];
    a && (l = this.refreshFlexedColumns({ resizingCols: s, skipSetLeft: !0 }), this.visibleColsService.setLeftValues(n), this.visibleColsService.updateBodyWidths(), this.columnViewportService.checkViewportColumns());
    const u = s.concat(l);
    (a || r) && this.eventDispatcher.columnResized(u, r, n, l);
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: r } = e;
    let n = 0, i = 0, o = !0;
    t.forEach((l) => {
      const u = l.getMinWidth();
      n += u || 0;
      const d = l.getMaxWidth();
      d > 0 ? i += d : o = !1;
    });
    const s = r >= n, a = !o || r <= i;
    return s && a;
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth)
      return [];
    const r = this.visibleColsService.getCenterCols();
    let n = -1;
    if (e.resizingCols) {
      const f = new Set(e.resizingCols);
      for (let p = r.length - 1; p >= 0; p--)
        if (f.has(r[p])) {
          n = p;
          break;
        }
    }
    let i = 0, o = [], s = 0, a = 0;
    for (let f = 0; f < r.length; f++)
      r[f].getFlex() && f > n ? (o.push(r[f]), a += r[f].getFlex(), s += r[f].getMinWidth()) : i += r[f].getActualWidth();
    if (!o.length)
      return [];
    let l = [];
    i + s > this.flexViewportWidth && (o.forEach((f) => f.setActualWidth(f.getMinWidth(), t)), l = o, o = []);
    const u = [];
    let d;
    e:
      for (; ; ) {
        d = this.flexViewportWidth - i;
        const f = d / a;
        for (let p = 0; p < o.length; p++) {
          const y = o[p], C = f * y.getFlex();
          let v = 0;
          const w = y.getMinWidth(), R = y.getMaxWidth();
          if (C < w ? v = w : C > R && (v = R), v) {
            y.setActualWidth(v, t), wE(o, y), a -= y.getFlex(), l.push(y), i += y.getActualWidth();
            continue e;
          }
          u[p] = Math.floor(C);
        }
        break;
      }
    let h = d;
    return o.forEach((f, p) => {
      const y = p < o.length - 1 ? Math.min(u[p], h) : (
        // ensure flex columns fill available width by growing the last column to fit available space if there is more available
        Math.max(u[p], h)
      );
      f.setActualWidth(y, t), l.push(f), h -= u[p];
    }), e.skipSetLeft || this.visibleColsService.setLeftValues(t), e.updateBodyWidths && this.visibleColsService.updateBodyWidths(), e.fireResizedEvent && this.eventDispatcher.columnResized(l, !0, t, o), o;
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", r, n) {
    var f;
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.sizeColumnsToFit(e, t, r, n));
      return;
    }
    const i = {};
    n && ((f = n == null ? void 0 : n.columnLimits) == null || f.forEach(({ key: p, ...y }) => {
      i[typeof p == "string" ? p : p.getColId()] = y;
    }));
    const o = this.visibleColsService.getAllCols(), s = e === Ri(o);
    if (e <= 0 || !o.length || s)
      return;
    const a = [], l = [];
    o.forEach((p) => {
      p.getColDef().suppressSizeToFit === !0 ? l.push(p) : a.push(p);
    });
    const u = a.slice(0);
    let d = !1;
    const h = (p) => {
      Fr(a, p), l.push(p);
    };
    for (a.forEach((p) => {
      p.resetActualWidth(t);
      const y = i == null ? void 0 : i[p.getId()], C = (y == null ? void 0 : y.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), v = (y == null ? void 0 : y.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), w = p.getActualWidth();
      typeof C == "number" && w < C ? p.setActualWidth(C, t, !0) : typeof v == "number" && w > v && p.setActualWidth(v, t, !0);
    }); !d; ) {
      d = !0;
      const p = e - Ri(l);
      if (p <= 0)
        a.forEach((y) => {
          var v;
          const C = ((v = i == null ? void 0 : i[y.getId()]) == null ? void 0 : v.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth);
          if (typeof C == "number") {
            y.setActualWidth(C, t, !0);
            return;
          }
          y.setMinimum(t);
        });
      else {
        const y = p / Ri(a);
        let C = p;
        for (let v = a.length - 1; v >= 0; v--) {
          const w = a[v], R = i == null ? void 0 : i[w.getId()], b = (R == null ? void 0 : R.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), P = (R == null ? void 0 : R.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), S = w.getMinWidth(), E = w.getMaxWidth(), A = typeof b == "number" && b > S ? b : S, M = typeof P == "number" && P < E ? P : E;
          let I = Math.round(w.getActualWidth() * y);
          I < A ? (I = A, h(w), d = !1) : I > M ? (I = M, h(w), d = !1) : v === 0 && (I = C), w.setActualWidth(I, t, !0), C -= I;
        }
      }
    }
    u.forEach((p) => {
      p.fireColumnWidthChangedEvent(t);
    }), this.visibleColsService.setLeftValues(t), this.visibleColsService.updateBodyWidths(), !r && this.eventDispatcher.columnResized(u, !0, t);
  }
  applyAutosizeStrategy() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e)
      return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: r, defaultMinWidth: n, defaultMaxWidth: i } = e, o = r == null ? void 0 : r.map(({ colId: s, minWidth: a, maxWidth: l }) => ({
          key: s,
          minWidth: a,
          maxWidth: l
        }));
        this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
          defaultMinWidth: n,
          defaultMaxWidth: i,
          columnLimits: o
        });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
};
function AE(e, t) {
  return e + "_" + t;
}
function $t(e) {
  return e instanceof FE;
}
var FE = class extends J {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.displayedChildren = [], this.autoHeaderHeight = null, this.parent = null, this.groupId = t, this.partId = r, this.providedColumnGroup = e, this.pinned = n;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(e) {
    this.parent = e;
  }
  getUniqueId() {
    return AE(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      $t(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = Ye(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    let e = 0;
    return this.displayedChildren && this.displayedChildren.forEach((t) => {
      e += t.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  isAutoHeaderHeight() {
    var e;
    return !!((e = this.getColGroupDef()) != null && e.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      go(t) ? e.push(t) : $t(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      go(t) ? e.push(t) : $t(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((r) => {
      if ($t(r) && (!r.displayedChildren || !r.displayedChildren.length))
        return;
      switch (r.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(r);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(r);
          break;
        default:
          this.displayedChildren.push(r);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, OB = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let r;
    return typeof t != "number" ? r = 0 : r = t + 1, this.existingIds[e] = r, r;
  }
}, IB = class extends J {
  constructor() {
    super(...arguments), this.beanName = "visibleColsService", this.colsAndGroupsMap = {}, this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher;
  }
  refresh(e, t = !1) {
    t || this.buildTrees(), this.updateOpenClosedVisibilityInColumnGroups(), this.columnsLeft = gp(this.treeLeft), this.columnsCenter = gp(this.treeCenter), this.columnsRight = gp(this.treeRight), this.joinColsAriaOrder(), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.columns.filter((r) => r.isAutoHeight()), this.columnSizeService.refreshFlexedColumns(), this.updateBodyWidths(), this.columnViewportService.checkViewportColumns(!1), this.setFirstRightAndLastLeftPinned(e), this.eventDispatcher.visibleCols(e);
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = Ri(this.columnsCenter), t = Ri(this.columnsLeft), r = Ri(this.columnsRight);
    this.bodyWidthDirty = this.bodyWidth !== e, (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== r) && (this.bodyWidth = e, this.leftWidth = t, this.rightWidth = r, this.eventService.dispatchEvent({
      type: "columnContainerWidthChanged"
    }), this.eventService.dispatchEvent({
      type: "displayedColumnsWidthChanged"
    }));
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, r;
    this.gos.get("enableRtl") ? (t = this.columnsLeft ? this.columnsLeft[0] : null, r = this.columnsRight ? Ye(this.columnsRight) : null) : (t = this.columnsLeft ? Ye(this.columnsLeft) : null, r = this.columnsRight ? this.columnsRight[0] : null), this.columnModel.getCols().forEach((n) => {
      n.setLastLeftPinned(n === t, e), n.setFirstRightPinned(n === r, e);
    });
  }
  buildTrees() {
    const e = this.columnModel.getColsToShow(), t = e.filter((o) => o.getPinned() == "left"), r = e.filter((o) => o.getPinned() == "right"), n = e.filter((o) => o.getPinned() != "left" && o.getPinned() != "right"), i = new OB();
    this.treeLeft = this.createGroups({
      columns: t,
      idCreator: i,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = this.createGroups({
      columns: r,
      idCreator: i,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = this.createGroups({
      columns: n,
      idCreator: i,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder() {
    const e = this.columnModel.getCols(), t = [], r = [], n = [];
    for (const i of e) {
      const o = i.getPinned();
      o ? o === !0 || o === "left" ? t.push(i) : n.push(i) : r.push(i);
    }
    this.ariaOrderColumns = t.concat(r).concat(n);
  }
  getAriaColIndex(e) {
    let t;
    return $t(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  getAllAutoHeightCols() {
    return this.autoHeightCols;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        $t(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    if (!this.columnModel.getColDefCols())
      return;
    const r = this.columnModel.getCols().slice(0), n = this.gos.get("enableRtl");
    [this.columnsLeft, this.columnsRight, this.columnsCenter].forEach((i) => {
      if (n) {
        let o = Ri(i);
        i.forEach((s) => {
          o -= s.getActualWidth(), s.setLeft(o, e);
        });
      } else {
        let o = 0;
        i.forEach((s) => {
          s.setLeft(o, e), o += s.getActualWidth();
        });
      }
      aB(r, i);
    }), r.forEach((i) => {
      i.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.columns = this.columnsRight.concat(this.columnsCenter).concat(this.columnsLeft) : this.columns = this.columnsLeft.concat(this.columnsCenter).concat(this.columnsRight);
  }
  getColsCenter() {
    return this.columnsCenter;
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // + headerRenderer -> setting pinned body width
  getTreeLeft() {
    return this.treeLeft;
  }
  // + headerRenderer -> setting pinned body width
  getTreeRight() {
    return this.treeRight;
  }
  // + headerRenderer -> setting pinned body width
  getTreeCenter() {
    return this.treeCenter;
  }
  // + csvCreator
  getAllCols() {
    return this.columns;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.getAllCols().indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsLeft) : this.columnsLeft;
  }
  getRightColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsRight) : this.columnsRight;
  }
  getColsForRow(e, t, r, n) {
    const i = [];
    let o = null;
    for (let s = 0; s < t.length; s++) {
      const a = t[s], l = t.length - s, u = Math.min(a.getColSpan(e), l), d = [a];
      if (u > 1) {
        const f = u - 1;
        for (let p = 1; p <= f; p++)
          d.push(t[s + p]);
        s += f;
      }
      let h;
      r ? (h = !1, d.forEach((f) => {
        r(f) && (h = !0);
      })) : h = !0, h && (i.length === 0 && o && (n && n(a)) && i.push(o), i.push(a)), o = a;
    }
    return i;
  }
  // used by:
  // + angularGrid -> for setting body width
  // + rowController -> setting main row widths (when inserting and resizing)
  // need to cache this
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  // + rowController -> while inserting rows
  getCenterCols() {
    return this.columnsCenter;
  }
  // + rowController -> while inserting rows
  getLeftCols() {
    return this.columnsLeft;
  }
  getRightCols() {
    return this.columnsRight;
  }
  getColBefore(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r > 0 ? t[r - 1] : null;
  }
  getGroupAtDirection(e, t) {
    const r = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), n = e.getDisplayedLeafColumns(), i = t === "After" ? Ye(n) : n[0], o = `getCol${t}`;
    for (; ; ) {
      const s = this[o](i);
      if (!s)
        return null;
      const a = this.getColGroupAtLevel(s, r);
      if (a !== e)
        return a;
    }
  }
  getColGroupAtLevel(e, t) {
    let r = e.getParent(), n, i;
    for (; n = r.getProvidedColumnGroup().getLevel(), i = r.getPaddingLevel(), !(n + i <= t); )
      r = r.getParent();
    return r;
  }
  isPinningLeft() {
    return this.columnsLeft.length > 0;
  }
  isPinningRight() {
    return this.columnsRight.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    Vo(this.treeCenter, !1, e), Vo(this.treeLeft, !1, e), Vo(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllTrees();
    Vo(e, !1, (t) => {
      $t(t) && t.calculateDisplayedColumns();
    });
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = [
      "getLeftCols",
      "getCenterCols",
      "getRightCols"
    ];
    e && t.reverse();
    for (let r = 0; r < t.length; r++) {
      const n = this[t[r]]();
      if (n.length)
        return e ? Ye(n) : n[0];
    }
    return null;
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if ($t(e))
      return e;
    const r = this.getAllTrees(), n = typeof t == "number";
    let i = null;
    return Vo(r, !1, (o) => {
      if ($t(o)) {
        const s = o;
        let a;
        n ? a = e === s.getGroupId() && t === s.getPartId() : a = e === s.getGroupId(), a && (i = s);
      }
    }), i;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r < t.length - 1 ? t[r + 1] : null;
  }
  isBodyWidthDirty() {
    return this.bodyWidthDirty;
  }
  setBodyWidthDirty() {
    this.bodyWidthDirty = !0;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return Ri(this.columnsLeft);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return Ri(this.columnsRight);
  }
  isColAtEdge(e, t) {
    const r = this.getAllCols();
    if (!r.length)
      return !1;
    const n = t === "first";
    let i;
    if ($t(e)) {
      const o = e.getDisplayedLeafColumns();
      if (!o.length)
        return !1;
      i = n ? o[0] : Ye(o);
    } else
      i = e;
    return (n ? r[0] : Ye(r)) === i;
  }
  createGroups(e) {
    const { columns: t, idCreator: r, pinned: n, oldDisplayedGroups: i, isStandaloneStructure: o } = e, s = this.mapOldGroupsById(i), a = [];
    let l = t;
    for (; l.length; ) {
      const u = l;
      l = [];
      let d = 0;
      const h = (f) => {
        const p = d;
        d = f;
        const y = u[p], v = ($t(y) ? y.getProvidedColumnGroup() : y).getOriginalParent();
        if (v == null) {
          for (let R = p; R < f; R++)
            a.push(u[R]);
          return;
        }
        const w = this.createColGroup(
          v,
          r,
          s,
          n,
          o
        );
        for (let R = p; R < f; R++)
          w.addChild(u[R]);
        l.push(w);
      };
      for (let f = 1; f < u.length; f++) {
        const p = u[f], C = ($t(p) ? p.getProvidedColumnGroup() : p).getOriginalParent(), v = u[d], R = ($t(v) ? v.getProvidedColumnGroup() : v).getOriginalParent();
        C !== R && h(f);
      }
      d < u.length && h(u.length);
    }
    return o || this.setupParentsIntoCols(a, null), a;
  }
  createColGroup(e, t, r, n, i) {
    const o = e.getGroupId(), s = t.getInstanceIdForKey(o), a = AE(o, s);
    let l = r[a];
    return l && l.getProvidedColumnGroup() !== e && (l = null), de(l) ? l.reset() : (l = new FE(e, o, s, n), i || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, r = (n) => {
      n.forEach((i) => {
        if ($t(i)) {
          const o = i;
          t[i.getUniqueId()] = o, r(o.getChildren());
        }
      });
    };
    return e && r(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((r) => {
      if (r.setParent(t), $t(r)) {
        const n = r;
        this.setupParentsIntoCols(n.getChildren(), n);
      }
    });
  }
};
function Vo(e, t, r) {
  if (e)
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if ($t(i)) {
        const o = t ? i.getDisplayedChildren() : i.getChildren();
        Vo(o, t, r);
      }
      r(i);
    }
}
function gp(e) {
  const t = [];
  return Vo(e, !0, (r) => {
    go(r) && t.push(r);
  }), t;
}
var ME = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel"
], kB = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "scrollGapChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnGroupHeaderHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged",
  "overlayExclusiveChanged"
], LB = [...ME, ...kB], _B = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  advancedFilterModel: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressAsyncEvents: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  dragAndDropImageComponent: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  suppressAggFuncInHeader: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  suppressGroupMaintainValueType: !0,
  groupLockGroupColumns: !0,
  rowGroupPanelSuppressSort: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  suppressServerSideInfiniteScroll: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0,
  suppressSetFilterByDefault: !0
}, hr = class {
};
hr.STRING_PROPERTIES = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
];
hr.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "theme",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterModel",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy",
  "cellSelection",
  "selectionColumnDef"
];
hr.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
hr.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
hr.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "suppressGroupMaintainValueType",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault"
];
hr.OTHER_PROPERTIES = [
  "suppressStickyTotalRow",
  // needs avoid coercion to boolean so that we can warn if it's unset
  "loadThemeGoogleFonts",
  "rowSelection"
];
hr.FUNCTION_PROPERTIES = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "groupIncludeFooter",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering",
  "chartMenuItems",
  "groupTotalRow"
];
hr.ALL_PROPERTIES = [
  ...hr.ARRAY_PROPERTIES,
  ...hr.OBJECT_PROPERTIES,
  ...hr.STRING_PROPERTIES,
  ...hr.NUMBER_PROPERTIES,
  ...hr.FUNCTION_PROPERTIES,
  ...hr.BOOLEAN_PROPERTIES,
  ...hr.OTHER_PROPERTIES
];
var nc = hr, Sn = class {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
};
Sn.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
Sn.PUBLIC_EVENTS = ME;
Sn.EVENT_CALLBACKS = LB.map((e) => Sn.getCallbackForEvent(e));
Sn.BOOLEAN_PROPERTIES = nc.BOOLEAN_PROPERTIES;
Sn.ALL_PROPERTIES = nc.ALL_PROPERTIES;
Sn.ALL_PROPERTIES_AND_CALLBACKS = [...Sn.ALL_PROPERTIES, ...Sn.EVENT_CALLBACKS];
Sn.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Sn.ALL_PROPERTIES_AND_CALLBACKS);
var ic = Sn;
function zB(e, t) {
  typeof e != "object" && (e = {});
  const r = { ...e };
  return ic.ALL_PROPERTIES_AND_CALLBACKS.forEach((i) => {
    const o = t[i];
    typeof o < "u" && o !== ic.VUE_OMITTED_PROPERTY && (r[i] = o);
  }), r;
}
function NB(e, t) {
  if (!e)
    return;
  const r = {};
  let n = !1;
  if (Object.keys(e).filter((s) => ic.ALL_PROPERTIES_AND_CALLBACKS_SET.has(s)).forEach((s) => {
    r[s] = e[s], n = !0;
  }), !n)
    return;
  const i = {
    type: "gridOptionsChanged",
    options: r
  };
  t.dispatchEvent(i);
  const o = {
    type: "componentStateChanged"
  };
  zn(r, (s, a) => {
    o[s] = a;
  }), t.dispatchEvent(o);
}
var Na = class extends J {
};
function Vc(e, t, r) {
  return r && e.addDestroyFunc(() => t.destroyBean(r)), r ?? e;
}
var $c = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.addCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const n = this.getGui();
      n && n.classList.add(e), this.cssClassStates[e] = !0;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.removeCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const n = this.getGui();
      n && n.classList.remove(e), this.cssClassStates[e] = !1;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const n = (e || "").split(" ");
      if (n.length > 1) {
        n.forEach((i) => this.addOrRemoveCssClass(i, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const n = this.getGui();
      n && n.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
};
function Ni(e, t, r) {
  r == null || typeof r == "string" && r == "" ? TE(e, t) : di(e, t, r);
}
function di(e, t, r) {
  e.setAttribute(DE(t), r.toString());
}
function TE(e, t) {
  e.removeAttribute(DE(t));
}
function DE(e) {
  return `aria-${e}`;
}
function Vn(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function BB(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function GB(e) {
  return e.getAttribute("aria-label");
}
function oa(e, t) {
  Ni(e, "label", t);
}
function oc(e, t) {
  Ni(e, "labelledby", t);
}
function OE(e, t) {
  Ni(e, "live", t);
}
function HB(e, t) {
  Ni(e, "atomic", t);
}
function WB(e, t) {
  Ni(e, "relevant", t);
}
function VB(e, t) {
  Ni(e, "disabled", t);
}
function IE(e, t) {
  Ni(e, "hidden", t);
}
function Md(e, t) {
  di(e, "expanded", t);
}
function $B(e, t) {
  di(e, "setsize", t);
}
function jB(e, t) {
  di(e, "posinset", t);
}
function UB(e, t) {
  di(e, "rowcount", t);
}
function KB(e, t) {
  di(e, "rowindex", t);
}
function qB(e, t) {
  di(e, "colcount", t);
}
function kE(e, t) {
  di(e, "colindex", t);
}
function YB(e, t) {
  di(e, "colspan", t);
}
function JB(e, t) {
  di(e, "sort", t);
}
function XB(e) {
  TE(e, "sort");
}
function Td(e, t) {
  Ni(e, "selected", t);
}
function QB(e, t) {
  Ni(e, "controls", t.id), oc(t, e.id);
}
function k0(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var fp, Wu, pp, mp, vp, yp, Cm, wm, Cp;
function ai() {
  return fp === void 0 && (fp = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), fp;
}
function LE() {
  if (Wu === void 0)
    if (ai()) {
      const e = navigator.userAgent.match(/version\/(\d+)/i);
      e && (Wu = e[1] != null ? parseFloat(e[1]) : 0);
    } else
      Wu = 0;
  return Wu;
}
function L0() {
  if (pp === void 0) {
    const e = window;
    pp = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return pp;
}
function _0() {
  return mp === void 0 && (mp = /(firefox)/i.test(navigator.userAgent)), mp;
}
function _E() {
  return vp === void 0 && (vp = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), vp;
}
function wo() {
  return yp === void 0 && (yp = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), yp;
}
function uS() {
  return !ai() || LE() >= 15;
}
function bm(e) {
  if (!e)
    return null;
  const t = e.tabIndex, r = e.getAttribute("tabIndex");
  return t === -1 && (r === null || r === "" && !_0()) ? null : t.toString();
}
function ZB() {
  if (Cp !== void 0)
    return Cp;
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = _0() ? 6e6 : 1e9, r = document.createElement("div");
  for (document.body.appendChild(r); ; ) {
    const n = e * 2;
    if (r.style.height = n + "px", n > t || r.clientHeight !== n)
      break;
    e = n;
  }
  return document.body.removeChild(r), Cp = e, e;
}
function e8() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientWidth) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientWidth) || -1);
}
function t8() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientHeight) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientHeight) || -1);
}
function r8() {
  return wm == null && zE(), wm;
}
function zE() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let r = t.offsetWidth - t.clientWidth;
  r === 0 && t.clientWidth === 0 && (r = null), t.parentNode && t.parentNode.removeChild(t), r != null && (wm = r, Cm = r === 0);
}
function NE() {
  return Cm == null && zE(), Cm;
}
var Vu, n8 = "[tabindex], input, select, button, textarea, [href]", BE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function z0(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, n = t.call(e, "input, select, button, textarea"), i = t.call(e, BE), o = li(e);
  return n && !i && o;
}
function Tt(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-hidden", !t), n || IE(e, !t);
}
function i8(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-invisible", !t), n || IE(e, !t);
}
function sc(e, t) {
  const r = "disabled", n = t ? (i) => i.setAttribute(r, "") : (i) => i.removeAttribute(r);
  n(e), VE(e.querySelectorAll("input"), (i) => n(i));
}
function Xs(e, t, r) {
  let n = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof r == "number") {
      if (++n > r)
        break;
    } else if (e === r)
      break;
  }
  return !1;
}
function fs(e) {
  const {
    height: t,
    width: r,
    borderTopWidth: n,
    borderRightWidth: i,
    borderBottomWidth: o,
    borderLeftWidth: s,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: u,
    paddingLeft: d,
    marginTop: h,
    marginRight: f,
    marginBottom: p,
    marginLeft: y,
    boxSizing: C
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(r || "0"),
    borderTopWidth: parseFloat(n || "0"),
    borderRightWidth: parseFloat(i || "0"),
    borderBottomWidth: parseFloat(o || "0"),
    borderLeftWidth: parseFloat(s || "0"),
    paddingTop: parseFloat(a || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(u || "0"),
    paddingLeft: parseFloat(d || "0"),
    marginTop: parseFloat(h || "0"),
    marginRight: parseFloat(f || "0"),
    marginBottom: parseFloat(p || "0"),
    marginLeft: parseFloat(y || "0"),
    boxSizing: C
  };
}
function N0(e) {
  const t = fs(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function jc(e) {
  const t = fs(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function GE(e) {
  const { height: t, marginBottom: r, marginTop: n } = fs(e);
  return Math.floor(t + r + n);
}
function Dd(e) {
  const { width: t, marginLeft: r, marginRight: n } = fs(e);
  return Math.floor(t + r + n);
}
function HE(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: r, borderLeftWidth: n, borderRightWidth: i, borderBottomWidth: o } = fs(e);
  return {
    top: t.top + (r || 0),
    left: t.left + (n || 0),
    right: t.right + (i || 0),
    bottom: t.bottom + (o || 0)
  };
}
function Od() {
  if (typeof Vu == "boolean")
    return Vu;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "10px", e.style.height = "5px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = /* html */
  `<div style="width: 20px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, Vu = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), Vu;
}
function Id(e, t) {
  let r = e.scrollLeft;
  return t && (r = Math.abs(r), L0() && !Od() && (r = e.scrollWidth - e.getBoundingClientRect().width - r)), r;
}
function kd(e, t, r) {
  r && (Od() ? t *= -1 : (ai() || L0()) && (t = e.scrollWidth - e.getBoundingClientRect().width - t)), e.scrollLeft = t;
}
function nn(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function cs(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function WE(e) {
  return !!e.offsetParent;
}
function li(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!WE(e) || window.getComputedStyle(e).visibility !== "visible");
}
function ac(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function o8(e) {
  return e.clientWidth < e.scrollWidth;
}
function s8(e) {
  return e.clientHeight < e.scrollHeight;
}
function Ld(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Hn(e, t);
}
function Hn(e, t) {
  t = B0(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function Vl(e, t) {
  t = B0(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function B0(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function G0(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function a8(e) {
  if (e == null)
    return [];
  const t = [];
  return VE(e, (r) => t.push(r)), t;
}
function l8(e, t) {
  if (e)
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      t(n.name, n.value);
    }
}
function xn(e, t, r) {
  r == null || r === "" ? e.removeAttribute(t) : e.setAttribute(t, r.toString());
}
function VE(e, t) {
  if (e != null)
    for (let r = 0; r < e.length; r++)
      t(e[r]);
}
var sa = class {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}, c8 = 1e3, u8 = 1e3, dS = 100, $E = class zo extends J {
  constructor(t, r, n, i) {
    super(), this.parentComp = t, this.tooltipShowDelayOverride = r, this.tooltipHideDelayOverride = n, this.shouldDisplayTooltip = i, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  wireBeans(t) {
    this.popupService = t.popupService, this.userComponentFactory = t.userComponentFactory;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const t = this.parentComp.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(t, {
      mouseenter: this.onMouseEnter.bind(this),
      mouseleave: this.onMouseLeave.bind(this)
    }), this.tooltipTrigger === 1 && this.addManagedListeners(t, {
      focusin: this.onFocusIn.bind(this),
      focusout: this.onFocusOut.bind(this)
    }), this.addManagedListeners(t, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(t, {
      mousedown: this.onMouseDown.bind(this),
      keydown: this.onKeyDown.bind(this)
    });
  }
  getGridOptionsTooltipDelay(t) {
    const r = this.gos.get(t);
    return r < 0 && ie(`${t} should not be lower than 0`), Math.max(200, r);
  }
  getTooltipDelay(t) {
    return t === "show" ? this.tooltipShowDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : this.tooltipHideDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const t = this.gos.get("tooltipTrigger");
    return !t || t === "hover" ? 0 : 1;
  }
  onMouseEnter(t) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !wo() && (zo.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(t);
    }, dS) : this.prepareToShowTooltip(t));
  }
  onMouseMove(t) {
    this.lastMouseEvent && (this.lastMouseEvent = t), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(t) {
    var o;
    const r = t.relatedTarget, n = this.parentComp.getGui(), i = (o = this.tooltipComp) == null ? void 0 : o.getGui();
    this.isInteractingWithTooltip || n.contains(r) || this.interactionEnabled && (i != null && i.contains(r)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.isInteractingWithTooltip && (this.isInteractingWithTooltip = !1), this.setToDoNothing();
  }
  prepareToShowTooltip(t) {
    if (this.state != 0 || zo.isLocked)
      return;
    let r = 0;
    t && (r = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), r), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    const t = (/* @__PURE__ */ new Date()).getTime(), r = zo.lastTooltipHideTime;
    return t - r < c8;
  }
  setToDoNothing(t) {
    !t && this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.onDocumentKeyDownCallback && (this.onDocumentKeyDownCallback(), this.onDocumentKeyDownCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    const t = {
      ...this.parentComp.getTooltipParams()
    };
    if (!de(t.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    this.state = 2, this.tooltipInstanceCount++;
    const r = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(t).newAgStackInstance().then(r);
  }
  hideTooltip(t) {
    !t && this.isInteractingWithTooltip || (this.tooltipComp && (this.destroyTooltipComp(), zo.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime()), this.eventService.dispatchEvent({
      type: "tooltipHide",
      parentGui: this.parentComp.getGui()
    }), t && (this.isInteractingWithTooltip = !1), this.setToDoNothing(!0));
  }
  newTooltipComponentCallback(t, r) {
    if (this.state !== 2 || this.tooltipInstanceCount !== t) {
      this.destroyBean(r);
      return;
    }
    const i = r.getGui();
    this.tooltipComp = r, i.classList.contains("ag-tooltip") || i.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && i.classList.add("ag-tooltip-animate"), this.interactionEnabled && i.classList.add("ag-tooltip-interactive");
    const o = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      eChild: i,
      ariaLabel: o("ariaLabelTooltip", "Tooltip")
    });
    if (s && (this.tooltipPopupDestroyFunc = s.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const a = () => this.setToDoNothing();
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
        bodyScroll: a,
        columnMoved: a
      });
    }
    this.interactionEnabled && ([this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(i, {
      mouseenter: this.onTooltipMouseEnter.bind(this),
      mouseleave: this.onTooltipMouseLeave.bind(this)
    }), [this.onDocumentKeyDownCallback] = this.addManagedElementListeners(zt(this.gos), {
      keydown: (a) => {
        i.contains(a == null ? void 0 : a.target) || this.onKeyDown();
      }
    }), this.tooltipTrigger === 1 && ([this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(i, {
      focusin: this.onTooltipFocusIn.bind(this),
      focusout: this.onTooltipFocusOut.bind(this)
    }))), this.eventService.dispatchEvent({
      type: "tooltipShow",
      tooltipGui: i,
      parentGui: this.parentComp.getGui()
    }), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, this.lockService());
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  isTooltipFocused() {
    var n;
    const t = (n = this.tooltipComp) == null ? void 0 : n.getGui(), r = Dt(this.gos);
    return !!t && t.contains(r);
  }
  onTooltipFocusOut(t) {
    const r = this.parentComp.getGui();
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, r.contains(t.relatedTarget) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    const t = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent({
      ...t,
      mouseEvent: this.lastMouseEvent
    }) : this.popupService.positionPopupByComponent({
      ...t,
      eventSource: this.parentComp.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const t = this.tooltipPopupDestroyFunc, r = this.tooltipComp, n = this.tooltipTrigger === 0 ? u8 : 0;
    window.setTimeout(() => {
      t(), this.destroyBean(r);
    }, n), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((t) => {
      t && t();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    zo.isLocked = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, dS);
  }
  unlockService() {
    zo.isLocked = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
$E.isLocked = !1;
var d8 = $E, Ba = class extends J {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.refreshToolTip();
  }
  setBrowserTooltip(e) {
    const t = "title", r = this.ctrl.getGui();
    r && (e != null && e != "" ? r.setAttribute(t, e) : r.removeAttribute(t));
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    var t, r, n, i;
    if (this.tooltipManager != null)
      return;
    const e = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.tooltipManager = this.createBean(
      new d8(
        e,
        (r = (t = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : r.call(t),
        (i = (n = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : i.call(n),
        this.ctrl.shouldDisplayTooltip
      ),
      this.beans.context
    );
  }
  refreshToolTip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  getTooltipParams() {
    var i, o, s, a, l;
    const e = this.ctrl, t = (i = e.getColumn) == null ? void 0 : i.call(e), r = (o = e.getColDef) == null ? void 0 : o.call(e), n = (s = e.getRowNode) == null ? void 0 : s.call(e);
    return {
      location: e.getLocation(),
      //'cell',
      colDef: r,
      column: t,
      rowIndex: (a = e.getRowIndex) == null ? void 0 : a.call(e),
      node: n,
      data: n == null ? void 0 : n.data,
      value: this.getTooltipText(),
      valueFormatted: (l = e.getValueFormatted) == null ? void 0 : l.call(e),
      hideTooltipCallback: () => {
        var u;
        return (u = this.tooltipManager) == null ? void 0 : u.hideTooltip(!0);
      }
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy();
  }
}, h8 = new sa(), Fe = null, vt = class jE extends J {
  constructor(t, r) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = h8.next(), this.cssClassManager = new $c(() => this.eGui), this.componentSelectors = new Map((r ?? []).map((n) => [n.selector, n])), t && this.setTemplate(t);
  }
  preWireBeans(t) {
    super.preWireBeans(t);
  }
  preConstruct() {
    this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips"), this.wireTemplate(this.getGui());
  }
  wireTemplate(t, r) {
    t && this.gos && (this.applyElementsToComponent(t), this.createChildComponentsFromTags(t, r));
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(t) {
    const { newTooltipText: r, showDelayOverride: n, hideDelayOverride: i, location: o, shouldDisplayTooltip: s } = t || {};
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== r && (this.tooltipText = r);
    const a = () => this.tooltipText;
    r != null && (this.tooltipFeature = this.createBean(
      new Ba({
        getTooltipValue: a,
        getGui: () => this.getGui(),
        getLocation: () => o ?? "UNKNOWN",
        getColDef: t == null ? void 0 : t.getColDef,
        getColumn: t == null ? void 0 : t.getColumn,
        getTooltipShowDelayOverride: n != null ? () => n : void 0,
        getTooltipHideDelayOverride: i != null ? () => i : void 0,
        shouldDisplayTooltip: s
      })
    ));
  }
  getDataRefAttribute(t) {
    return t.getAttribute ? t.getAttribute("data-ref") : null;
  }
  applyElementsToComponent(t, r, n, i = null) {
    if (r === void 0 && (r = this.getDataRefAttribute(t)), r) {
      const o = this[r];
      if (o === Fe)
        this[r] = i ?? t;
      else {
        const s = n && n[r];
        !this.suppressDataRefValidation && !s && ie(`Issue with data-ref: ${r} on ${this.constructor.name} with ${o}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(t, r) {
    a8(t.childNodes).forEach((i) => {
      if (!(i instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(
        i,
        (s) => {
          s.getGui() && this.copyAttributesFromNode(i, s.getGui());
        },
        r
      );
      if (o) {
        if (o.addItems && i.children.length) {
          this.createChildComponentsFromTags(i, r);
          const s = Array.prototype.slice.call(i.children);
          o.addItems(s);
        }
        this.swapComponentForNode(o, t, i);
      } else i.childNodes && this.createChildComponentsFromTags(i, r);
    });
  }
  createComponentFromElement(t, r, n) {
    const i = t.nodeName, o = this.getDataRefAttribute(t), s = i.indexOf("AG-") === 0, a = s ? this.componentSelectors.get(i) : null;
    let l = null;
    if (a) {
      jE.elementGettingCreated = t;
      const u = n && o ? n[o] : void 0;
      l = new a.component(u), l.setParentComponent(this), this.createBean(l, null, r);
    } else s && ie(`Missing selector: ${i}`);
    return this.applyElementsToComponent(t, o, n, l), l;
  }
  copyAttributesFromNode(t, r) {
    l8(t.attributes, (n, i) => r.setAttribute(n, i));
  }
  swapComponentForNode(t, r, n) {
    const i = t.getGui();
    r.replaceChild(i, n), r.insertBefore(document.createComment(n.nodeName), i), this.addDestroyFunc(this.destroyBean.bind(this, t));
  }
  activateTabIndex(t) {
    const r = this.gos.get("tabIndex");
    t || (t = []), t.length || t.push(this.getGui()), t.forEach((n) => n.setAttribute("tabindex", r.toString()));
  }
  setTemplate(t, r, n) {
    const i = ac(t);
    this.setTemplateFromElement(i, r, n);
  }
  setTemplateFromElement(t, r, n, i = !1) {
    if (this.eGui = t, this.suppressDataRefValidation = i, r)
      for (let o = 0; o < r.length; o++) {
        const s = r[o];
        this.componentSelectors.set(s.selector, s);
      }
    this.wireTemplate(t, n);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(t) {
    this.eGui = t;
  }
  queryForHtmlElement(t) {
    return this.eGui.querySelector(t);
  }
  getContainerAndElement(t, r) {
    let n = r;
    return t == null ? null : (n || (n = this.eGui), G0(t) ? {
      element: t,
      parent: n
    } : {
      element: t.getGui(),
      parent: n
    });
  }
  prependChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.insertAdjacentElement("afterbegin", n);
  }
  appendChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.appendChild(n);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(t, r = {}) {
    if (t !== this.visible) {
      this.visible = t;
      const { skipAriaHidden: n } = r;
      i8(this.eGui, t, { skipAriaHidden: n });
    }
  }
  setDisplayed(t, r = {}) {
    if (t !== this.displayed) {
      this.displayed = t;
      const { skipAriaHidden: n } = r;
      Tt(this.eGui, t, { skipAriaHidden: n });
      const i = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(i);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy();
  }
  addGuiEventListener(t, r, n) {
    this.eGui.addEventListener(t, r, n), this.addDestroyFunc(() => this.eGui.removeEventListener(t, r));
  }
  addCssClass(t) {
    this.cssClassManager.addCssClass(t);
  }
  removeCssClass(t) {
    this.cssClassManager.removeCssClass(t);
  }
  containsCssClass(t) {
    return this.cssClassManager.containsCssClass(t);
  }
  addOrRemoveCssClass(t, r) {
    this.cssClassManager.addOrRemoveCssClass(t, r);
  }
}, UE = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on drag and drop image component icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on drag and drop image component icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on drag and drop image component icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on drag and drop image component icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on drag and drop image component icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  menuAlt: "menu-alt",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none",
  // Builder button in Advanced Filter
  advancedFilterBuilder: "group",
  // drag handle used to pick up Advanced Filter Builder rows
  advancedFilterBuilderDrag: "grip",
  // Advanced Filter Builder row validation error
  advancedFilterBuilderInvalid: "not-allowed",
  // shown on Advanced Filter Builder rows to move them up
  advancedFilterBuilderMoveUp: "up",
  // shown on Advanced Filter Builder rows to move them down
  advancedFilterBuilderMoveDown: "down",
  // shown on Advanced Filter Builder rows to add new rows
  advancedFilterBuilderAdd: "plus",
  // shown on Advanced Filter Builder rows to remove row
  advancedFilterBuilderRemove: "minus",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus",
  // checked checkbox
  checkboxChecked: "checkbox-checked",
  // indeterminate checkbox
  checkboxIndeterminate: "checkbox-indeterminate",
  // unchecked checkbox
  checkboxUnchecked: "checkbox-unchecked",
  // radio button on
  radioButtonOn: "radio-button-on",
  // radio button off
  radioButtonOff: "radio-button-off"
}, g8 = (() => {
  const e = new Set(Object.values(UE));
  return e.add("eye"), e;
})();
function f8(e, t, r) {
  const n = tn(e, t, r);
  if (n) {
    const { className: o } = n;
    if (typeof o == "string" && o.indexOf("ag-icon") > -1 || typeof o == "object" && o["ag-icon"])
      return n;
  }
  const i = document.createElement("span");
  return i.appendChild(n), i;
}
function tn(e, t, r, n) {
  let i = null;
  const o = r && r.getColDef().icons;
  if (o && (i = o[e]), t && !i) {
    const s = t.get("icons");
    s && (i = s[e]);
  }
  if (i) {
    let s;
    if (typeof i == "function")
      s = i();
    else if (typeof i == "string")
      s = i;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof s == "string")
      return ac(s);
    if (G0(s))
      return s;
    ie("iconRenderer should return back a string or a dom object");
  } else {
    const s = document.createElement("span");
    let a = UE[e] ?? (g8.has(e) ? e : void 0);
    return a || (ie(`Did not find icon ${e}`), a = ""), s.setAttribute("class", `ag-icon ag-icon-${a}`), s.setAttribute("unselectable", "on"), Vn(s, "presentation"), s;
  }
}
var p8 = class extends vt {
  constructor() {
    super(...arguments), this.dragSource = null, this.eIcon = Fe, this.eLabel = Fe;
  }
  postConstruct() {
    const e = (t) => f8(t, this.gos, null);
    this.dropIconMap = {
      pinned: e("columnMovePin"),
      hide: e("columnMoveHide"),
      move: e("columnMoveMove"),
      left: e("columnMoveLeft"),
      right: e("columnMoveRight"),
      group: e("columnMoveGroup"),
      aggregate: e("columnMoveValue"),
      pivot: e("columnMovePivot"),
      notAllowed: e("dropNotAllowed")
    };
  }
  init(e) {
    this.dragSource = e.dragSource, this.setTemplate(
      /* html */
      `<div class="ag-dnd-ghost ag-unselectable">
                <span data-ref="eIcon" class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
                <div data-ref="eLabel" class="ag-dnd-ghost-label"></div>
            </div>`
    );
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    this.dragSource = null, super.destroy();
  }
  setIcon(e, t = !1) {
    var n, i;
    nn(this.eIcon);
    let r = null;
    e || (e = (n = this.dragSource) != null && n.getDefaultIconName ? (i = this.dragSource) == null ? void 0 : i.getDefaultIconName() : "notAllowed"), r = this.dropIconMap[e], this.eIcon.classList.toggle("ag-shake-left-to-right", t), !(r === this.dropIconMap.hide && this.gos.get("suppressDragLeaveHidesColumns")) && r && this.eIcon.appendChild(r);
  }
  setLabel(e) {
    this.eLabel.textContent = ni(e);
  }
};
function KE(e, t, r) {
  if (r === 0)
    return !1;
  const n = Math.abs(e.clientX - t.clientX), i = Math.abs(e.clientY - t.clientY);
  return Math.max(n, i) <= r;
}
var lo = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new _a(), this.eElement = e, this.preventMouseClick = t;
    const r = this.onTouchStart.bind(this), n = this.onTouchMove.bind(this), i = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", r, { passive: !0 }), this.eElement.addEventListener("touchmove", n, { passive: !0 }), this.eElement.addEventListener("touchend", i, { passive: !1 }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", r, { passive: !0 }), this.eElement.removeEventListener("touchmove", n, { passive: !0 }), this.eElement.removeEventListener("touchend", i, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const r = this.touchStart === t;
      if (this.touching && r && !this.moved) {
        this.moved = !0;
        const n = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(n);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !KE(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const r = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(r), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
};
function bl(e, t) {
  return (
    /* html */
    `<span data-ref="eSort${e}" class="ag-sort-indicator-icon ag-sort-${t} ag-hidden" aria-hidden="true"></span>`
  );
}
var m8 = (
  /* html */
  `<span class="ag-sort-indicator-container">
        ${bl("Order", "order")}
        ${bl("Asc", "ascending-icon")}
        ${bl("Desc", "descending-icon")}
        ${bl("Mixed", "mixed-icon")}
        ${bl("None", "none-icon")}
    </span>`
), H0 = class extends vt {
  constructor(e) {
    super(), this.eSortOrder = Fe, this.eSortAsc = Fe, this.eSortDesc = Fe, this.eSortMixed = Fe, this.eSortNone = Fe, e || this.setTemplate(m8);
  }
  wireBeans(e) {
    this.sortController = e.sortController;
  }
  attachCustomElements(e, t, r, n, i) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = r, this.eSortMixed = n, this.eSortNone = i;
  }
  setupSort(e, t = !1) {
    if (this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !this.column.isSortable() && !this.column.getColDef().showRowGroup)
      return;
    this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e);
    const r = this.updateIcons.bind(this), n = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", r), this.addManagedEventListeners({
      newColumnsLoaded: r,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: n,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: n
    }), this.onSortChanged();
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = tn(e, this.gos, r);
    n && t.appendChild(n);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const e = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const t = e === "asc";
      Tt(this.eSortAsc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortDesc) {
      const t = e === "desc";
      Tt(this.eSortDesc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortNone) {
      const t = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"), r = e == null;
      Tt(this.eSortNone, !t && r, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const e = this.column.getColDef().showRowGroup;
    Zn(this.gos) && e && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const e = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      Tt(this.eSortMixed, e, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    if (!this.eSortOrder)
      return;
    const e = this.sortController.getColumnsWithSortingOrdered(), t = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1, r = e.some(
      (i) => this.sortController.getDisplaySortIndexForColumn(i) ?? !1
    ), n = t >= 0 && r;
    Tt(this.eSortOrder, n, { skipAriaHidden: !0 }), t >= 0 ? this.eSortOrder.textContent = (t + 1).toString() : nn(this.eSortOrder);
  }
}, v8 = {
  selector: "AG-SORT-INDICATOR",
  component: H0
}, y8 = (
  /* html */
  `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`
), Sm = class extends vt {
  constructor() {
    super(...arguments), this.eFilter = Fe, this.eFilterButton = Fe, this.eSortIndicator = Fe, this.eMenu = Fe, this.eLabel = Fe, this.eText = Fe, this.eSortOrder = Fe, this.eSortAsc = Fe, this.eSortDesc = Fe, this.eSortMixed = Fe, this.eSortNone = Fe, this.lastMovingChanged = 0;
  }
  wireBeans(e) {
    this.sortController = e.sortController, this.menuService = e.menuService, this.funcColsService = e.funcColsService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon ? !1 : (this.setDisplayName(e), !0);
  }
  workOutTemplate() {
    let e = this.params.template ?? y8;
    return e = e && e.trim ? e.trim() : e, e;
  }
  init(e) {
    this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate, [v8]), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(e);
  }
  setDisplayName(e) {
    if (this.currentDisplayName != e.displayName) {
      this.currentDisplayName = e.displayName;
      const t = ni(this.currentDisplayName, !0);
      this.eText && (this.eText.textContent = t);
    }
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = tn(e, this.gos, r);
    n && t.appendChild(n);
  }
  setupTap() {
    const { gos: e } = this;
    if (e.get("suppressTouch"))
      return;
    const t = new lo(this.getGui(), !0), r = this.shouldSuppressMenuHide(), n = r && de(this.eMenu), i = n ? new lo(this.eMenu, !0) : t;
    if (this.params.enableMenu) {
      const o = n ? "tap" : "longTap", s = (a) => this.params.showColumnMenuAfterMouseClick(a.touchStart);
      this.addManagedListeners(i, { [o]: s });
    }
    if (this.params.enableSorting) {
      const o = (s) => {
        var l, u;
        const a = s.touchStart.target;
        r && ((l = this.eMenu) != null && l.contains(a) || (u = this.eFilterButton) != null && u.contains(a)) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted");
      };
      this.addManagedListeners(t, { tap: o });
    }
    if (this.params.enableFilterButton) {
      const o = new lo(this.eFilterButton, !0);
      this.addManagedListeners(o, {
        tap: () => this.params.showFilter(this.eFilterButton)
      }), this.addDestroyFunc(() => o.destroy());
    }
    this.addDestroyFunc(() => t.destroy()), n && this.addDestroyFunc(() => i.destroy());
  }
  workOutShowMenu() {
    return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      cs(this.eMenu), this.eMenu = void 0;
      return;
    }
    const e = this.menuService.isLegacyMenuEnabled();
    this.addInIcon(e ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !e), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedElementListeners(this.eMenu, { click: () => this.params.showColumnMenu(this.eMenu) }), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(e) {
    const t = this.params.column, r = this.menuService.isLegacyMenuEnabled();
    if (e && !r) {
      if (this.menuService.isFilterMenuInHeaderEnabled(t))
        return this.params.showFilter(this.eFilterButton ?? this.eMenu ?? this.getGui()), !0;
    } else if (this.params.enableMenu)
      return this.params.showColumnMenu(this.eMenu ?? this.eFilterButton ?? this.getGui()), !0;
    return !1;
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.createBean(new H0(!0)), this.eSortIndicator.attachCustomElements(
      this.eSortOrder,
      this.eSortAsc,
      this.eSortDesc,
      this.eSortMixed,
      this.eSortNone
    )), this.eSortIndicator.setupSort(this.params.column), !this.currentSort)
      return;
    this.addManagedListeners(this.params.column, {
      movingChanged: () => {
        this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }
    }), this.eLabel && this.addManagedElementListeners(this.eLabel, {
      click: (t) => {
        const r = this.params.column.isMoving(), i = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
        if (!(r || i)) {
          const a = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
          this.params.progressSort(a);
        }
      }
    });
    const e = () => {
      const t = this.params.column.getSort();
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", t === "asc"), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", t === "desc"), this.addOrRemoveCssClass("ag-header-cell-sorted-none", !t), this.params.column.getColDef().showRowGroup) {
        const r = this.funcColsService.getSourceColumnsForGroupColumn(
          this.params.column
        ), i = !(r == null ? void 0 : r.every(
          (o) => this.params.column.getSort() == o.getSort()
        ));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", i);
      }
    };
    this.addManagedEventListeners({
      sortChanged: e,
      columnRowGroupChanged: e
    });
  }
  setupFilterIcon() {
    this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
  }
  setupFilterButton() {
    if (!this.eFilterButton)
      return;
    this.configureFilter(
      this.params.enableFilterButton,
      this.eFilterButton,
      this.onFilterChangedButton.bind(this)
    ) ? this.addManagedElementListeners(this.eFilterButton, {
      click: () => this.params.showFilter(this.eFilterButton)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, r) {
    if (!e)
      return cs(t), !1;
    const n = this.params.column;
    return this.addInIcon("filter", t, n), this.addManagedListeners(n, { filterChanged: r }), r(), !0;
  }
  onFilterChangedIcon() {
    const e = this.params.column.isFilterActive();
    Tt(this.eFilter, e, { skipAriaHidden: !0 });
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    return e ? this.eFilterButton ?? this.eMenu ?? this.getGui() : this.eMenu ?? this.eFilterButton ?? this.getGui();
  }
}, C8 = class extends vt {
  constructor() {
    super(
      /* html */
      `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`
    ), this.agOpened = Fe, this.agClosed = Fe, this.agLabel = Fe;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && ie(
      "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)"
    );
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", this.agOpened), this.addInIcon("columnGroupClosed", this.agClosed);
    const e = (i) => {
      if (Mi(i))
        return;
      const o = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(
        this.params.columnGroup.getProvidedColumnGroup(),
        o,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(this.agClosed, e), this.addTouchAndClickListeners(this.agOpened, e);
    const t = (i) => {
      ia(i);
    };
    this.addManagedElementListeners(this.agClosed, { dblclick: t }), this.addManagedElementListeners(this.agOpened, { dblclick: t }), this.addManagedElementListeners(this.getGui(), { dblclick: e }), this.updateIconVisibility();
    const r = this.params.columnGroup.getProvidedColumnGroup(), n = this.updateIconVisibility.bind(this);
    this.addManagedListeners(r, {
      expandedChanged: n,
      expandableChanged: n
    });
  }
  addTouchAndClickListeners(e, t) {
    const r = new lo(e, !0);
    this.addManagedListeners(r, { tap: t }), this.addDestroyFunc(() => r.destroy()), this.addManagedElementListeners(e, { click: t });
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const t = this.params.columnGroup.isExpanded();
      Tt(this.agOpened, t), Tt(this.agClosed, !t);
    } else
      Tt(this.agOpened, !1), Tt(this.agClosed, !1);
  }
  addInIcon(e, t) {
    const r = tn(e, this.gos, null);
    r && t.appendChild(r);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      Tt(this.agOpened, !1), Tt(this.agClosed, !1);
      return;
    }
  }
  setupLabel() {
    var r;
    const { displayName: e, columnGroup: t } = this.params;
    if (de(e)) {
      const n = ni(e, !0);
      this.agLabel.textContent = n;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((r = t.getColGroupDef()) != null && r.suppressStickyLabel));
  }
}, w8 = "↑", b8 = "↓", S8 = class extends vt {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const r = document.createElement("span");
    r.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(r), this.setTemplateFromElement(e);
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0);
  }
  showDelta(e, t) {
    const r = Math.abs(t), n = e.formatValue(r), i = de(n) ? n : r, o = t >= 0;
    o ? this.eDelta.textContent = w8 + i : this.eDelta.textContent = b8 + i, this.eDelta.classList.toggle("ag-value-change-delta-up", o), this.eDelta.classList.toggle("ag-value-change-delta-down", !o);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), nn(this.eDelta);
  }
  refresh(e, t = !1) {
    var n;
    const r = e.value;
    if (r === this.lastValue || (de(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : de(e.value) ? this.eValue.textContent = r : nn(this.eValue), (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof r == "number" && typeof this.lastValue == "number") {
      const i = r - this.lastValue;
      this.showDelta(e, i);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = r, !0;
  }
}, x8 = class extends vt {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    var n;
    let r = e.value;
    return Ke(r) && (r = ""), r === this.lastValue || (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering() ? !1 : (t || this.addSlideAnimation(), this.lastValue = r, de(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : de(e.value) ? this.eCurrent.textContent = r : nn(this.eCurrent), !0);
  }
}, V = class {
};
V.BACKSPACE = "Backspace";
V.TAB = "Tab";
V.ENTER = "Enter";
V.ESCAPE = "Escape";
V.SPACE = " ";
V.LEFT = "ArrowLeft";
V.UP = "ArrowUp";
V.RIGHT = "ArrowRight";
V.DOWN = "ArrowDown";
V.DELETE = "Delete";
V.F2 = "F2";
V.PAGE_UP = "PageUp";
V.PAGE_DOWN = "PageDown";
V.PAGE_HOME = "Home";
V.PAGE_END = "End";
V.A = "KeyA";
V.C = "KeyC";
V.D = "KeyD";
V.V = "KeyV";
V.X = "KeyX";
V.Y = "KeyY";
V.Z = "KeyZ";
var R8 = class extends vt {
  constructor(e, t, r) {
    super(t, r), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: r, labelAlignment: n, disabled: i } = this.config;
    i != null && this.setDisabled(i), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), r != null && this.setLabelWidth(r), this.setLabelAlignment(n || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    nn(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (Tt(this.eLabel, !1), Vn(this.eLabel, "presentation")) : (Tt(this.eLabel, !0), Vn(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const r = this.getGui().classList;
    return r.toggle("ag-label-align-left", e === "left"), r.toggle("ag-label-align-right", e === "right"), r.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (Ld(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return sc(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, qE = class extends R8 {
  constructor(e, t, r, n) {
    super(e, t, r), this.className = n;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: r } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), r != null && this.onValueChange(r), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), r = this.getLabel();
    r == null || r == "" || GB(e) !== null ? oc(e, "") : oc(e, t ?? "");
  }
  setAriaLabel(e) {
    return oa(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Hn(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
}, Uo = class extends qE {
  constructor(e, t, r = "text", n = "input") {
    super(
      e,
      (e == null ? void 0 : e.template) ?? /* html */
      `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${n} data-ref="eInput" class="ag-input-field-input"></${n}>
                </div>
            </div>`,
      [],
      t
    ), this.inputType = r, this.displayFieldTag = n, this.eLabel = Fe, this.eWrapper = Fe, this.eInput = Fe;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName: e, inputWidth: t } = this.config;
    e != null && this.setInputName(e), t != null && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return Ld(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return xn(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return oa(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return sc(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      xn(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      xn(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, W0 = class extends Uo {
  constructor(e, t = "ag-checkbox", r = "checkbox") {
    super(e, t, r), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, r) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: r });
    const n = this.getInputElement();
    this.eventService.dispatchEvent({
      type: "checkboxChanged",
      id: n.id,
      name: n.name,
      selected: e,
      previousValue: t
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), r = this.selected = e.target.checked;
    this.refreshSelectedClass(r), this.dispatchChange(r, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === !0), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}, V0 = {
  selector: "AG-CHECKBOX",
  component: W0
}, E8 = class extends vt {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [V0]
    ), this.eCheckbox = Fe;
  }
  init(e) {
    this.refresh(e);
    const t = this.eCheckbox.getInputElement();
    t.setAttribute("tabindex", "-1"), OE(t, "polite"), this.addManagedListeners(t, {
      click: (r) => {
        if (ia(r), this.eCheckbox.isDisabled())
          return;
        const n = this.eCheckbox.getValue();
        this.onCheckboxChanged(n);
      },
      dblclick: (r) => {
        ia(r);
      }
    }), this.addManagedElementListeners(this.params.eGridCell, {
      keydown: (r) => {
        if (r.key === V.SPACE && !this.eCheckbox.isDisabled()) {
          this.params.eGridCell === Dt(this.gos) && this.eCheckbox.toggle();
          const n = this.eCheckbox.getValue();
          this.onCheckboxChanged(n), r.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    var a;
    let t, r = !0;
    if (e.node.group && e.column)
      if (typeof e.value == "boolean")
        t = e.value;
      else {
        const l = e.column.getColId();
        l.startsWith(Uh) ? t = e.value == null || e.value === "" ? void 0 : e.value === "true" : e.node.aggData && e.node.aggData[l] !== void 0 ? t = e.value ?? void 0 : r = !1;
      }
    else
      t = e.value ?? void 0;
    if (!r) {
      this.eCheckbox.setDisplayed(!1);
      return;
    }
    this.eCheckbox.setValue(t);
    const n = e.disabled != null ? e.disabled : !((a = e.column) != null && a.isCellEditable(e.node));
    this.eCheckbox.setDisabled(n);
    const i = this.localeService.getLocaleTextFunc(), o = k0(i, t), s = n ? o : `${i("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${o})`;
    this.eCheckbox.setInputAriaLabel(s);
  }
  onCheckboxChanged(e) {
    const { column: t, node: r, value: n } = this.params;
    this.eventService.dispatchEvent({
      type: "cellEditingStarted",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n
    });
    const i = this.params.node.setDataValue(this.params.column, e, "edit");
    this.eventService.dispatchEvent({
      type: "cellEditingStopped",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n,
      oldValue: n,
      newValue: e,
      valueChanged: i
    }), i || this.updateCheckbox(this.params);
  }
}, P8 = class extends vt {
  constructor() {
    super(
      /* html */
      `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`
    ), this.eLoadingIcon = Fe, this.eLoadingText = Fe;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = tn("groupLoading", this.gos, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, A8 = class extends vt {
  constructor() {
    super(
      /* html */
      '<div class="ag-skeleton-container"></div>'
    );
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => oc(e.eParentOfValue)), oc(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.getGui().innerText = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    oa(this.getGui(), t);
  }
  setupLoading(e) {
    const r = zt(this.gos).createElement("div");
    r.classList.add("ag-skeleton-effect");
    const n = e.node.rowIndex;
    if (n != null) {
      const s = 75 + 25 * (n % 2 === 0 ? Math.sin(n) : Math.cos(n));
      r.style.width = `${s}%`;
    }
    this.getGui().appendChild(r);
    const o = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    oa(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, YE = class extends vt {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, F8 = class extends YE {
  init() {
    var t;
    const e = Fi((t = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(
      e ?? /* html */
      '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>'
    ), !e) {
      const r = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = r("loadingOoo", "Loading...");
      });
    }
  }
}, M8 = class extends YE {
  init() {
    var t;
    const e = Fi((t = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? /* html */
    '<span class="ag-overlay-no-rows-center"></span>'), !e) {
      const r = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = r("noRowsToShow", "No Rows To Show");
      });
    }
  }
}, Ga = class extends vt {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, T8 = class extends Ga {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = ni(t, !0);
  }
};
function JE(e) {
  const { inputValue: t, allSuggestions: r, hideIrrelevant: n, filterByPercentageOfBestMatch: i, addSequentialWeight: o } = e;
  let s = r.map((u, d) => ({
    value: u,
    relevance: O8(t.toLowerCase(), u.toLocaleLowerCase(), o),
    idx: d
  }));
  if (s.sort((u, d) => d.relevance - u.relevance), n && (s = s.filter((u) => u.relevance !== 0)), s.length > 0 && i && i > 0) {
    const d = s[0].relevance * i;
    s = s.filter((h) => d - h.relevance < 0);
  }
  const a = [], l = [];
  for (const u of s)
    a.push(u.value), l.push(u.idx);
  return { values: a, indices: l };
}
function D8(e) {
  const t = [], r = e.length;
  for (let n = 1; n <= r; n++)
    for (let i = 0; i <= r - n; i++) {
      const o = i + n - 1;
      t.push(e.slice(i, o + 1));
    }
  return t;
}
function O8(e, t, r = !1) {
  const n = e.replace(/\s/g, ""), i = t.replace(/\s/g, ""), o = n.length, s = i.length, a = new Array(o + 1).fill(null).map(() => new Array(s + 1).fill(0));
  for (let h = 0; h <= o; h += 1)
    a[h][0] = h;
  for (let h = 0; h <= s; h += 1)
    a[0][h] = h;
  for (let h = 1; h <= o; h++)
    for (let f = 1; f <= s; f++)
      n[h - 1] === i[f - 1] ? a[h][f] = a[h - 1][f - 1] : a[h][f] = 1 + Math.min(a[h][f - 1], Math.min(a[h - 1][f], a[h - 1][f - 1]));
  const l = a[o][s];
  let d = Math.max(o, s) - l;
  if (r) {
    const h = D8(n);
    for (let f = 0; f < h.length; f++) {
      const p = h[f];
      i.indexOf(p) !== -1 && (d += 1, d *= p.length);
    }
  }
  return d;
}
var I8 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "userComponentRegistry", this.agGridDefaults = {
      // drag and drop
      agDragAndDropImage: p8,
      //header
      agColumnHeader: Sm,
      agColumnGroupHeader: C8,
      agSortIndicator: H0,
      // renderers
      agAnimateShowChangeCellRenderer: S8,
      agAnimateSlideCellRenderer: x8,
      agLoadingCellRenderer: P8,
      agSkeletonCellRenderer: A8,
      agCheckboxCellRenderer: E8,
      //overlays
      agLoadingOverlay: F8,
      agNoRowsOverlay: M8,
      // tooltips
      agTooltipComponent: T8
    }, this.agGridDefaultParams = {}, this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: "@ag-grid-enterprise/set-filter",
      agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
      agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
      agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
      agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
      agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
      agGroupCellRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail too but best guess is they are grouping
      agGroupRowRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail but best guess is they are grouping
      agRichSelect: "@ag-grid-enterprise/rich-select",
      agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
      agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
      agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
      /* SparklinesModule */
    }, this.jsComps = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    e != null && zn(e, (t, r) => this.registerJsComponent(t, r));
  }
  registerDefaultComponent(e, t, r) {
    this.agGridDefaults[e] = t, r && (this.agGridDefaultParams[e] = r);
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const r = (a, l, u) => ({
      componentFromFramework: l,
      component: a,
      params: u
    }), n = this.getFrameworkOverrides().frameworkComponent(
      t,
      this.gos.get("components")
    );
    if (n != null)
      return r(n, !0);
    const i = this.jsComps[t];
    if (i) {
      const a = this.getFrameworkOverrides().isFrameworkComponent(i);
      return r(i, a);
    }
    const o = this.agGridDefaults[t];
    if (o)
      return r(o, !1, this.agGridDefaultParams[t]);
    const s = this.enterpriseAgDefaultCompsModule[t];
    return s ? this.gos.assertModuleRegistered(s, `AG Grid '${e}' component: ${t}`) : E0(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const r = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(this.agGridDefaults).filter(
        (i) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(i)
      ),
      ...Object.keys(this.jsComps)
    ], n = JE({
      inputValue: t,
      allSuggestions: r,
      hideIrrelevant: !0,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    ie(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`
    ), n.length > 0 && ie(`         Did you mean: [${n.slice(0, 3)}]?`), ie(
      `If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`
    );
  }
}, _t = class _l {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (r) => this.onDone(r),
      (r) => this.onReject(r)
    );
  }
  static all(t) {
    return t.length ? new _l((r) => {
      let n = t.length;
      const i = new Array(n);
      t.forEach((o, s) => {
        o.then((a) => {
          i[s] = a, n--, n === 0 && r(i);
        });
      });
    }) : _l.resolve();
  }
  static resolve(t = null) {
    return new _l((r) => r(t));
  }
  then(t) {
    return new _l((r) => {
      this.status === 1 ? r(t(this.resolution)) : this.waiters.push((n) => r(t(n)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((r) => r(t));
  }
  onReject(t) {
  }
}, k8 = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, L8 = {
  propertyName: "dragAndDropImageComponent",
  cellRenderer: !1
}, _8 = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, z8 = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, hS = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, N8 = {
  propertyName: "cellRenderer",
  cellRenderer: !1
}, B8 = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, G8 = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, gS = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, H8 = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, W8 = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, V8 = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, $0 = {
  propertyName: "filter",
  cellRenderer: !1
}, $8 = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, j8 = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, U8 = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, K8 = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, q8 = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, Y8 = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, J8 = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
}, X8 = {
  propertyName: "menuItem",
  cellRenderer: !1
}, XE = class QE extends J {
  constructor() {
    super(...arguments), this.beanName = "userComponentFactory";
  }
  wireBeans(t) {
    this.agComponentUtils = t.agComponentUtils, this.componentMetadataProvider = t.componentMetadataProvider, this.userComponentRegistry = t.userComponentRegistry, this.frameworkComponentWrapper = t.frameworkComponentWrapper, this.gridOptions = t.gridOptions;
  }
  getDragAndDropImageCompDetails(t) {
    return this.getCompDetails(this.gridOptions, L8, "agDragAndDropImage", t, !0);
  }
  getHeaderCompDetails(t, r) {
    return this.getCompDetails(t, _8, "agColumnHeader", r);
  }
  getHeaderGroupCompDetails(t) {
    const r = t.columnGroup.getColGroupDef();
    return this.getCompDetails(r, z8, "agColumnGroupHeader", t);
  }
  // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
  // so we have to pass the type in.
  getFullWidthCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, K8, null, t, !0);
  }
  getFullWidthLoadingCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, q8, "agLoadingCellRenderer", t, !0);
  }
  getFullWidthGroupCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, Y8, "agGroupRowRenderer", t, !0);
  }
  getFullWidthDetailCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, J8, "agDetailCellRenderer", t, !0);
  }
  // CELL RENDERER
  getInnerRendererDetails(t, r) {
    return this.getCompDetails(t, gS, null, r);
  }
  getFullWidthGroupRowInnerCellRenderer(t, r) {
    return this.getCompDetails(t, gS, null, r);
  }
  getCellRendererDetails(t, r) {
    return this.getCompDetails(t, hS, null, r);
  }
  getEditorRendererDetails(t, r) {
    return this.getCompDetails(t, N8, null, r);
  }
  getLoadingCellRendererDetails(t, r) {
    return this.getCompDetails(t, B8, "agSkeletonCellRenderer", r, !0);
  }
  // CELL EDITOR
  getCellEditorDetails(t, r) {
    return this.getCompDetails(t, G8, "agCellEditor", r, !0);
  }
  // FILTER
  getFilterDetails(t, r, n) {
    return this.getCompDetails(t, $0, n, r, !0);
  }
  getDateCompDetails(t) {
    return this.getCompDetails(this.gridOptions, k8, "agDateInput", t, !0);
  }
  getLoadingOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, H8, "agLoadingOverlay", t, !0);
  }
  getNoRowsOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, W8, "agNoRowsOverlay", t, !0);
  }
  getTooltipCompDetails(t) {
    return this.getCompDetails(t.colDef, V8, "agTooltipComponent", t, !0);
  }
  getSetFilterCellRendererDetails(t, r) {
    return this.getCompDetails(t, hS, null, r);
  }
  getFloatingFilterCompDetails(t, r, n) {
    return this.getCompDetails(t, $8, n, r);
  }
  getToolPanelCompDetails(t, r) {
    return this.getCompDetails(t, j8, null, r, !0);
  }
  getStatusPanelCompDetails(t, r) {
    return this.getCompDetails(t, U8, null, r, !0);
  }
  getMenuItemCompDetails(t, r) {
    return this.getCompDetails(t, X8, "agMenuItem", r, !0);
  }
  getCompDetails(t, r, n, i, o = !1) {
    const { propertyName: s, cellRenderer: a } = r;
    let { compName: l, jsComp: u, fwComp: d, paramsFromSelector: h, popupFromSelector: f, popupPositionFromSelector: p } = QE.getCompKeys(this.frameworkOverrides, t, r, i), y;
    const C = (b) => {
      const P = this.userComponentRegistry.retrieve(s, b);
      P && (u = P.componentFromFramework ? void 0 : P.component, d = P.componentFromFramework ? P.component : void 0, y = P.params);
    };
    if (l != null && C(l), u == null && d == null && n != null && C(n), u && a && !this.agComponentUtils.doesImplementIComponent(u) && (u = this.agComponentUtils.adaptFunction(s, u)), !u && !d) {
      o && tt(`Could not find component ${l}, did you forget to configure this component?`);
      return;
    }
    const v = this.mergeParamsWithApplicationProvidedParams(
      t,
      r,
      i,
      h,
      y
    ), w = u == null, R = u || d;
    return {
      componentFromFramework: w,
      componentClass: R,
      params: v,
      type: r,
      popupFromSelector: f,
      popupPositionFromSelector: p,
      newAgStackInstance: () => this.newAgStackInstance(R, w, v, r)
    };
  }
  static getCompKeys(t, r, n, i) {
    const { propertyName: o } = n;
    let s, a, l, u, d, h;
    if (r) {
      const f = r, p = f[o + "Selector"], y = p ? p(i) : null, C = (v) => {
        typeof v == "string" ? s = v : v != null && v !== !0 && (t.isFrameworkComponent(v) ? l = v : a = v);
      };
      y ? (C(y.component), u = y.params, d = y.popup, h = y.popupPosition) : C(f[o]);
    }
    return { compName: s, jsComp: a, fwComp: l, paramsFromSelector: u, popupFromSelector: d, popupPositionFromSelector: h };
  }
  newAgStackInstance(t, r, n, i) {
    const o = i.propertyName, s = !r;
    let a;
    if (s)
      a = new t();
    else {
      const u = this.componentMetadataProvider.retrieve(o);
      a = this.frameworkComponentWrapper.wrap(
        t,
        u.mandatoryMethodList,
        u.optionalMethodList,
        i
      );
    }
    const l = this.initComponent(a, n);
    return l == null ? _t.resolve(a) : l.then(() => a);
  }
  // used by Floating Filter
  mergeParamsWithApplicationProvidedParams(t, r, n, i = null, o) {
    const s = this.gos.getGridCommonParams();
    Pr(s, n), o && Pr(s, o);
    const a = t, l = a && a[r.propertyName + "Params"];
    if (typeof l == "function") {
      const u = l(n);
      Pr(s, u);
    } else typeof l == "object" && Pr(s, l);
    return Pr(s, i), s;
  }
  initComponent(t, r) {
    if (this.createBean(t), t.init != null)
      return t.init(r);
  }
};
function $l(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var qh = class et {
  /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */
  static register(t) {
    et.__register(t, !0, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(t) {
    et.__registerModules(t, !0, void 0);
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __register(t, r, n) {
    et.runVersionChecks(t), n !== void 0 ? (et.areGridScopedModules = !0, et.gridModulesMap[n] === void 0 && (et.gridModulesMap[n] = {}), et.gridModulesMap[n][t.moduleName] = t) : et.globalModulesMap[t.moduleName] = t, et.setModuleBased(r);
  }
  /** AG GRID INTERNAL - Unregister grid scoped module. */
  static __unRegisterGridModules(t) {
    delete et.gridModulesMap[t];
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __registerModules(t, r, n) {
    et.setModuleBased(r), t && t.forEach((i) => et.__register(i, r, n));
  }
  static isValidModuleVersion(t) {
    const [r, n] = t.version.split(".") || [], [i, o] = et.currentModuleVersion.split(".") || [];
    return r === i && n === o;
  }
  static runVersionChecks(t) {
    et.currentModuleVersion || (et.currentModuleVersion = t.version);
    const r = (n) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${n} Please update all modules to the same version.`;
    if (t.version ? et.isValidModuleVersion(t) || tt(
      r(
        `'${t.moduleName}' is version ${t.version} but the other modules are version ${et.currentModuleVersion}.`
      )
    ) : tt(r(`'${t.moduleName}' is incompatible.`)), t.validate) {
      const n = t.validate();
      n.isValid || tt(`${n.message}`);
    }
  }
  static setModuleBased(t) {
    et.moduleBased === void 0 ? et.moduleBased = t : et.moduleBased !== t && (tt(
      "AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."
    ), tt("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information."));
  }
  /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */
  static __setIsBundled() {
    et.isBundled = !0;
  }
  /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
  static __assertRegistered(t, r, n) {
    var o;
    if (this.__isRegistered(t, n))
      return !0;
    let i;
    if (et.isBundled)
      i = `AG Grid: unable to use ${r} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (et.moduleBased || et.moduleBased === void 0) {
      const s = (o = Object.entries(vo).find(([a, l]) => l === t)) == null ? void 0 : o[0];
      i = `AG Grid: unable to use ${r} as the ${s} is not registered${et.areGridScopedModules ? ` for gridId: ${n}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${s} } from '${t}';
    
    ModuleRegistry.registerModules([ ${s} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else
      i = `AG Grid: unable to use ${r} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
    return tt(i), !1;
  }
  /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
  static __isRegistered(t, r) {
    var n;
    return !!et.globalModulesMap[t] || !!((n = et.gridModulesMap[r]) != null && n[t]);
  }
  /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
  static __getRegisteredModules(t) {
    return [...fd(et.globalModulesMap), ...fd(et.gridModulesMap[t] || {})];
  }
  /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
  static __getGridRegisteredModules(t) {
    return fd(et.gridModulesMap[t] ?? {}) || [];
  }
  /** INTERNAL */
  static __isPackageBased() {
    return !et.moduleBased;
  }
};
qh.globalModulesMap = {};
qh.gridModulesMap = {};
qh.areGridScopedModules = !1;
var Cn = qh, Q8 = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    Object.entries(e.providedBeanInstances).forEach(([r, n]) => {
      this.beans[r] = n;
    }), e.beanClasses.forEach((r) => {
      const n = new r();
      n.beanName ? this.beans[n.beanName] = n : console.error(`Bean ${r.name} is missing beanName`), this.createdBeans.push(n);
    }), (t = e.derivedBeans) == null || t.forEach((r) => {
      const { beanName: n, bean: i } = r(this);
      this.beans[n] = i, this.createdBeans.push(i);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e)
      throw Error("Can't wire to bean since it is null");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((r) => {
      var n, i;
      (n = r.preWireBeans) == null || n.call(r, this.beans), (i = r.wireBeans) == null || i.call(r, this.beans);
    }), e.forEach((r) => {
      var n;
      return (n = r.preConstruct) == null ? void 0 : n.call(r);
    }), t && e.forEach(t), e.forEach((r) => {
      var n;
      return (n = r.postConstruct) == null ? void 0 : n.call(r);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, Z8 = class extends Q8 {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, super.init(e);
  }
  destroy() {
    super.destroy(), Cn.__unRegisterGridModules(this.gridId);
  }
  getGridId() {
    return this.gridId;
  }
}, ZE = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(ZE || {}), eG = class extends J {
  constructor() {
    super(...arguments), this.beanName = "dragAndDropService", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.dragService = e.dragService, this.mouseEventService = e.mouseEventService, this.environment = e.environment, this.userComponentFactory = e.userComponentFactory;
  }
  addDragSource(e, t = !1) {
    const r = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: r, dragSource: e }), this.dragService.addDragSource(r);
  }
  getDragAndDropImageComponent() {
    const { dragAndDropImageComp: e } = this;
    return !e || !e.comp ? null : e.comp;
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((r) => r.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), Fr(this.dragSourceAndParamsList, t));
  }
  destroy() {
    this.dragSourceAndParamsList.forEach(
      (e) => this.dragService.removeDragSource(e.params)
    ), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0, this.clearDragAndDropProperties(), super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    var r, n;
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), (n = (r = this.dragSource).onDragStarted) == null || n.call(r), this.createDragAndDropImageComponent();
  }
  onDragStop(e) {
    var t, r, n;
    if ((r = (t = this.dragSource) == null ? void 0 : t.onDragStopped) == null || r.call(t), (n = this.lastDropTarget) != null && n.onDragStop) {
      const i = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
      this.lastDropTarget.onDragStop(i);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var e, t, r;
    (t = (e = this.dragSource) == null ? void 0 : e.onDragCancelled) == null || t.call(e), (r = this.lastDropTarget) != null && r.onDragCancel && this.lastDropTarget.onDragCancel(
      this.createDropTargetEvent(this.lastDropTarget, this.eventLastTime, null, null, !1)
    ), this.clearDragAndDropProperties();
  }
  clearDragAndDropProperties() {
    this.eventLastTime = null, this.dragging = !1, this.lastDropTarget = void 0, this.dragItem = null, this.dragSource = null, this.removeDragAndDropImageComponent();
  }
  onDragging(e, t = !1) {
    var s, a, l, u;
    const r = this.getHorizontalDirection(e), n = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionDragAndDropImageComp(e);
    const i = this.dropTargets.filter((d) => this.isMouseOnDropTarget(e, d)), o = this.findCurrentDropTarget(e, i);
    if (o !== this.lastDropTarget) {
      if (this.leaveLastTargetIfExists(e, r, n, t), this.lastDropTarget !== null && o === null && ((a = (s = this.dragSource) == null ? void 0 : s.onGridExit) == null || a.call(s, this.dragItem)), this.lastDropTarget === null && o !== null && ((u = (l = this.dragSource) == null ? void 0 : l.onGridEnter) == null || u.call(l, this.dragItem)), this.enterDragTargetIfExists(o, e, r, n, t), o && this.dragAndDropImageComp) {
        const { comp: d, promise: h } = this.dragAndDropImageComp;
        d ? d.setIcon(o.getIconName ? o.getIconName() : null) : h.then((f) => {
          f && f.setIcon(o.getIconName ? o.getIconName() : null);
        });
      }
      this.lastDropTarget = o;
    } else if (o && o.onDragging) {
      const d = this.createDropTargetEvent(o, e, r, n, t);
      o.onDragging(d);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, r = [[e.getContainer()]];
    return t ? r.concat(t) : r;
  }
  allContainersIntersect(e, t) {
    for (const r of t) {
      const { width: n, height: i, left: o, right: s, top: a, bottom: l } = r.getBoundingClientRect();
      if (n === 0 || i === 0)
        return !1;
      const u = e.clientX >= o && e.clientX < s, d = e.clientY >= a && e.clientY < l;
      if (!u || !d)
        return !1;
    }
    return !0;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const r = this.getAllContainersFromDropTarget(t);
    let n = !1;
    for (const s of r)
      if (this.allContainersIntersect(e, s)) {
        n = !0;
        break;
      }
    const { eElement: i, type: o } = this.dragSource;
    return t.targetContainsSource && !t.getContainer().contains(i) ? !1 : n && t.isInterestedIn(o, i);
  }
  findCurrentDropTarget(e, t) {
    const r = t.length;
    if (r === 0)
      return null;
    if (r === 1)
      return t[0];
    const i = rc(this.gos).elementsFromPoint(e.clientX, e.clientY);
    for (const o of i)
      for (const s of t)
        if (cB(this.getAllContainersFromDropTarget(s)).indexOf(o) !== -1)
          return s;
    return null;
  }
  enterDragTargetIfExists(e, t, r, n, i) {
    if (e && e.onDragEnter) {
      const o = this.createDropTargetEvent(
        e,
        t,
        r,
        n,
        i
      );
      e.onDragEnter(o);
    }
  }
  leaveLastTargetIfExists(e, t, r, n) {
    if (!this.lastDropTarget)
      return;
    if (this.lastDropTarget.onDragLeave) {
      const o = this.createDropTargetEvent(
        this.lastDropTarget,
        e,
        t,
        r,
        n
      );
      this.lastDropTarget.onDragLeave(o);
    }
    const i = this.getDragAndDropImageComponent();
    i && i.setIcon(null);
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((r) => r.external).find((r) => r.getContainer() === e.getContainer()) || null;
  }
  isDropZoneWithinThisGrid(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: n } = e;
    return r.contains(n);
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, r = e.clientX;
    return t === r ? null : t > r ? 0 : 1;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, r = e.clientY;
    return t === r ? null : t > r ? 0 : 1;
  }
  createDropTargetEvent(e, t, r, n, i) {
    const o = e.getContainer(), s = o.getBoundingClientRect(), { dragItem: a, dragSource: l } = this, u = t.clientX - s.left, d = t.clientY - s.top;
    return this.gos.addGridCommonParams({
      event: t,
      x: u,
      y: d,
      vDirection: n,
      hDirection: r,
      dragSource: l,
      fromNudge: i,
      dragItem: a,
      dropZoneTarget: o
    });
  }
  positionDragAndDropImageComp(e) {
    const t = this.getDragAndDropImageComponent();
    if (!t)
      return;
    const r = t.getGui(), i = r.getBoundingClientRect().height, o = e8() - 2, s = t8() - 2;
    if (!r.offsetParent)
      return;
    const l = HE(r.offsetParent), { clientY: u, clientX: d } = e;
    let h = u - l.top - i / 2, f = d - l.left - 10;
    const p = zt(this.gos), y = p.defaultView || window, C = y.pageYOffset || p.documentElement.scrollTop, v = y.pageXOffset || p.documentElement.scrollLeft;
    o > 0 && f + r.clientWidth > o + v && (f = o + v - r.clientWidth), f < 0 && (f = 0), s > 0 && h + r.clientHeight > s + C && (h = s + C - r.clientHeight), h < 0 && (h = 0), r.style.left = `${f}px`, r.style.top = `${h}px`;
  }
  removeDragAndDropImageComponent() {
    if (this.dragAndDropImageComp) {
      const { comp: e } = this.dragAndDropImageComp;
      if (e) {
        const t = e.getGui();
        this.dragAndDropImageParent && this.dragAndDropImageParent.removeChild(t), this.destroyBean(e);
      }
    }
    this.dragAndDropImageComp = null;
  }
  createDragAndDropImageComponent() {
    const { dragSource: e } = this;
    if (!e)
      return;
    const r = this.userComponentFactory.getDragAndDropImageCompDetails({
      dragSource: e
    }).newAgStackInstance();
    this.dragAndDropImageComp = {
      promise: r
    }, r.then((n) => {
      !n || !this.isAlive() || (this.processDragAndDropImageComponent(n), this.dragAndDropImageComp.comp = n);
    });
  }
  processDragAndDropImageComponent(e) {
    const { dragSource: t, mouseEventService: r, environment: n } = this;
    if (!t)
      return;
    const i = e.getGui();
    i.style.setProperty("position", "absolute"), i.style.setProperty("z-index", "9999"), r.stampTopLevelGridCompWithGridInstance(i), n.applyThemeClasses(i), e.setIcon(null);
    let { dragItemName: o } = t;
    P0(o) && (o = o()), e.setLabel(o || ""), i.style.top = "20px", i.style.left = "20px";
    const s = zt(this.gos);
    let a = null, l = null;
    try {
      a = s.fullscreenElement;
    } catch {
    } finally {
      a || (a = rc(this.gos));
      const u = a.querySelector("body");
      u ? l = u : a instanceof ShadowRoot ? l = a : a instanceof Document ? l = a == null ? void 0 : a.documentElement : l = a;
    }
    this.dragAndDropImageParent = l, l ? l.appendChild(i) : ie("Could not find document body, it is needed for drag and drop.");
  }
}, tG = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const r = t || this.shouldSkipVerticalScroll();
    if (r && this.shouldSkipHorizontalScroll())
      return;
    const n = this.scrollContainer.getBoundingClientRect(), i = this.scrollByTick;
    this.tickLeft = e.clientX < n.left + i, this.tickRight = e.clientX > n.right - i, this.tickUp = e.clientY < n.top + i && !r, this.tickDown = e.clientY > n.bottom - i && !r, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, zl = /* @__PURE__ */ ((e) => (e[e.Above = 0] = "Above", e[e.Below = 1] = "Below", e))(zl || {}), rG = class extends J {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.sortController = e.sortController, this.filterManager = e.filterManager, this.selectionService = e.selectionService, this.mouseEventService = e.mouseEventService, this.ctrlsService = e.ctrlsService, this.funcColsService = e.funcColsService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    At(this.gos) && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady(this, (e) => {
      const t = e.gridBodyCtrl;
      this.autoScrollService = new tG({
        scrollContainer: t.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (r) => t.getScrollFeature().setVerticalScrollPosition(r),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    var n;
    return !!(this.funcColsService.getRowGroupColumns().length || ((n = this.filterManager) == null ? void 0 : n.isAnyFilterPresent()) || this.sortController.isSortActive());
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const n = [...this.selectionService.getSelectedNodes()].sort((i, o) => i.rowIndex == null || o.rowIndex == null ? 0 : this.getRowIndexNumber(i) - this.getRowIndexNumber(o));
      if (n.indexOf(t) !== -1)
        return n;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent("rowDragEnter", e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent("rowDragMove", e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const r = this.isFromThisGrid(e), n = this.gos.get("rowDragManaged"), i = e.dragItem.rowNodes;
    n && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !r ? this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.clientSideRowModel.highlightRowAtPixel(i[0], t) : this.moveRows(i, t));
  }
  getRowIndexNumber(e) {
    const t = e.getRowIndexString();
    return parseInt(Ye(t.split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), r = t && t.highlighted === 1, n = this.mouseEventService.getNormalisedPosition(e).y, i = e.dragItem.rowNodes;
    let o = r ? 1 : 0;
    if (this.isFromThisGrid(e))
      i.forEach((s) => {
        s.rowTop < n && (o -= 1);
      }), this.moveRows(i, n, o);
    else {
      const s = za(this.gos);
      let a = this.clientSideRowModel.getRowIndexAtPixel(n) + 1;
      this.clientSideRowModel.getHighlightPosition(n) === 0 && a--, this.clientSideRowModel.updateRowData({
        add: i.filter(
          (l) => !this.clientSideRowModel.getRowNode(
            (s == null ? void 0 : s({ data: l.data, level: 0, rowPinned: l.rowPinned })) ?? l.data.id
          )
        ).map((l) => l.data),
        addIndex: a
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, r = 0) {
    var i;
    this.clientSideRowModel.ensureRowsAtPixel(e, t, r) && (this.focusService.clearFocusedCell(), (i = this.rangeService) == null || i.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      ie("addRowDropZone - A container target needs to be provided");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      ie(
        "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again."
      );
      return;
    }
    let t = {
      getContainer: e.getContainer
    };
    e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = (n) => {
      e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", n));
    }), e.onDragLeave && (t.onDragLeave = (n) => {
      e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", n));
    }), e.onDragging && (t.onDragging = (n) => {
      e.onDragging(this.draggingToRowDragEvent("rowDragMove", n));
    }), e.onDragStop && (t.onDragStop = (n) => {
      e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", n));
    }), e.onDragCancel && (t.onDragCancel = (n) => {
      e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", n));
    }));
    const r = {
      isInterestedIn: (n) => n === 2,
      getIconName: () => "move",
      external: !0,
      ...t
    };
    this.dragAndDropService.addDropTarget(r), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(r));
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), r = this.onDragEnter.bind(this), n = this.onDragLeave.bind(this), i = this.onDragging.bind(this), o = this.onDragStop.bind(this), s = this.onDragCancel.bind(this);
    let a;
    return e ? a = {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (l) => {
        r(l), e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", l));
      } : r,
      onDragLeave: e.onDragLeave ? (l) => {
        n(l), e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", l));
      } : n,
      onDragging: e.onDragging ? (l) => {
        i(l), e.onDragging(this.draggingToRowDragEvent("rowDragMove", l));
      } : i,
      onDragStop: e.onDragStop ? (l) => {
        o(l), e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", l));
      } : o,
      onDragCancel: e.onDragCancel ? (l) => {
        s(l), e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", l));
      } : s,
      fromGrid: !0
    } : a = {
      getContainer: t,
      onDragEnter: r,
      onDragLeave: n,
      onDragging: i,
      onDragStop: o,
      onDragCancel: s,
      /* @private */
      fromGrid: !0
    }, a;
  }
  draggingToRowDragEvent(e, t) {
    const r = this.mouseEventService.getNormalisedPosition(t).y, n = r > this.pageBoundsService.getCurrentPageHeight();
    let i = -1, o;
    n || (i = this.rowModel.getRowIndexAtPixel(r), o = this.rowModel.getRow(i));
    let s;
    switch (t.vDirection) {
      case 1:
        s = "down";
        break;
      case 0:
        s = "up";
        break;
      default:
        s = null;
        break;
    }
    return this.gos.addGridCommonParams({
      type: e,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: i,
      overNode: o,
      y: r,
      vDirection: s
    });
  }
  dispatchGridEvent(e, t) {
    const r = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(r);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent("rowDragEnd", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  onDragCancel(e) {
    this.dispatchGridEvent("rowDragCancel", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.clearRowHighlight();
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!1);
    });
  }
}, nG = class extends J {
  constructor() {
    super(...arguments), this.beanName = "dragService", this.dragEndFunctions = [], this.dragSources = [];
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService;
  }
  destroy() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, r = e.mouseDownListener;
    if (t.removeEventListener("mousedown", r), e.touchEnabled) {
      const n = e.touchStartListener;
      t.removeEventListener("touchstart", n, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((r) => r.dragSource === e);
    t && (this.removeListener(t), Fr(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: r, includeTouch: n, stopPropagationForTouch: i } = e;
    r.addEventListener("mousedown", t);
    let o = null;
    const s = this.gos.get("suppressTouch");
    n && !s && (o = (a) => {
      z0(a.target) || (i && a.stopPropagation(), this.onTouchStart(e, a));
    }, r.addEventListener("touchstart", o, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: o,
      touchEnabled: !!n
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const r = t.touches[0];
    this.touchLastTime = r, this.touchStart = r;
    const n = (l) => this.onTouchMove(l, e.eElement), i = (l) => this.onTouchUp(l, e.eElement), o = (l) => {
      l.cancelable && l.preventDefault();
    }, s = t.target, a = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: rc(this.gos),
        type: "touchmove",
        listener: o,
        options: { passive: !1 }
      },
      { target: s, type: "touchmove", listener: n, options: { passive: !0 } },
      { target: s, type: "touchend", listener: i, options: { passive: !0 } },
      { target: s, type: "touchcancel", listener: i, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onCommonMove(r, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const r = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || r._alreadyProcessedByDragService || (r._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const n = (u) => this.onMouseMove(u, e.eElement), i = (u) => this.onMouseUp(u, e.eElement), o = (u) => u.preventDefault(), s = (u) => {
      u.key === V.ESCAPE && this.cancelDrag(e.eElement);
    }, a = rc(this.gos), l = [
      { target: a, type: "mousemove", listener: n },
      { target: a, type: "mouseup", listener: i },
      { target: a, type: "contextmenu", listener: o },
      { target: a, type: "keydown", listener: s }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: r, type: n, listener: i, options: o } = t;
      r.addEventListener(n, i, o);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: r, type: n, listener: i, options: o } = t;
        r.removeEventListener(n, i, o);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: r } = this.currentDragParams, n = de(r) ? r : 4;
    return KE(e, t, n);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, r) {
    var n;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(e, t))
        return;
      if (this.dragging = !0, this.eventService.dispatchEvent({
        type: "dragStarted",
        target: r
      }), this.currentDragParams.onDragStart(t), !this.currentDragParams) {
        this.dragging = !1;
        return;
      }
      this.currentDragParams.onDragging(t);
    }
    (n = this.currentDragParams) == null || n.onDragging(e);
  }
  onTouchMove(e, t) {
    const r = this.getFirstActiveTouch(e.touches);
    r && this.onCommonMove(r, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var r;
    ai() && ((r = zt(this.gos).getSelection()) == null || r.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gos.get("enableCellTextSelection"), r = e.type === "mousemove";
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      t && r && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
    );
  }
  isOverFormFieldElement(e) {
    const t = e.target, r = t == null ? void 0 : t.tagName.toLocaleLowerCase();
    return !!(r != null && r.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let r = this.getFirstActiveTouch(e.changedTouches);
    r || (r = this.touchLastTime), this.onUpCommon(r, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    this.dragging && (this.dragging = !1, this.currentDragParams.onDragStop(e), this.eventService.dispatchEvent({
      type: "dragStopped",
      target: t
    })), this.resetDragProperties();
  }
  cancelDrag(e) {
    var t, r;
    this.eventService.dispatchEvent({
      type: "dragCancelled",
      target: e
    }), (r = (t = this.currentDragParams) == null ? void 0 : t.onDragCancel) == null || r.call(t), this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((e) => e()), this.dragEndFunctions.length = 0;
  }
}, xm = class extends vt {
  constructor(e, t, r, n, i, o) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = r, this.customGui = n, this.dragStartPixels = i, this.suppressVisibilityChange = o, this.dragSource = null;
  }
  wireBeans(e) {
    this.beans = e;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(tn("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gos.get("rowDragManaged") ? new oG(this, this.beans, this.rowNode, this.column) : new iG(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e, void 0, void 0, !0), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gos.get("rowDragMultiRow"))
      return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  // returns true if all compatibility items work out
  checkCompatibility() {
    const e = this.gos.get("rowDragManaged");
    this.gos.get("treeData") && e && ie("If using row drag with tree data, you cannot have rowDragManaged=true");
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, {
      mousedown: (n) => {
        n == null || n.preventDefault();
      }
    })[0]);
    const r = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: t,
      dragItemName: () => {
        var s;
        const n = this.getDragItem(), i = ((s = n.rowNodes) == null ? void 0 : s.length) || 1, o = this.getRowDragText(this.column);
        return o ? o(n, i) : i === 1 ? this.cellValueFn() : `${i} ${r("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
}, eP = class extends J {
  constructor(e, t, r) {
    super(), this.parent = e, this.rowNode = t, this.column = r;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let r = !0, n = !1;
      this.column && (r = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), n = P0(this.column.getColDef().rowDrag)), n ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(r, t)) : (this.parent.setDisplayed(r, t), this.parent.setVisible(!0, t));
    }
  }
}, iG = class extends eP {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: e }), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}, oG = class extends eP {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventService, {
      sortChanged: e,
      filterChanged: e,
      columnRowGroupChanged: e,
      newColumnsLoaded: e
    }), this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), r = t && t.shouldPreventRowMove(), n = this.gos.get("suppressRowDrag"), i = this.beans.dragAndDropService.hasExternalDropZones(), o = r && !i || n;
    this.setDisplayedOrVisible(o);
  }
}, sG = /* @__PURE__ */ new Set(["localEventService", "__objectId", "sticky", "__autoHeights", "checkAutoHeightsDebounced"]), Uc = class eo {
  constructor(t) {
    this.rowIndex = null, this.key = null, this.sourceRowIndex = -1, this.childrenMapped = {}, this.treeNode = null, this.treeNodeFlags = 0, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = eo.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = t;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(t) {
    this.setDataCommon(t, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(t) {
    this.setDataCommon(t, !0);
  }
  setDataCommon(t, r) {
    var o;
    const n = this.data;
    this.data = t, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const i = this.createDataChangedEvent(t, n, r);
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(t, r, n) {
    return {
      type: "dataChanged",
      node: this,
      oldData: r,
      newData: t,
      update: n
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (tt(
      "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid."
    ), null) : this.rowPinned === "top" ? eo.ID_PREFIX_TOP_PINNED + this.rowIndex : this.rowPinned === "bottom" ? eo.ID_PREFIX_BOTTOM_PINNED + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const t = new eo(this.beans);
    return t.id = this.id, t.data = this.data, t.__daemon = !0, t.selected = this.selected, t.level = this.level, t;
  }
  setDataAndId(t, r) {
    var s;
    const n = de(this.id) ? this.createDaemonNode() : null, i = this.data;
    this.data = t, this.updateDataOnDetailNode(), this.setId(r), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, n);
    const o = this.createDataChangedEvent(t, i, !1);
    (s = this.localEventService) == null || s.dispatchEvent(o);
  }
  checkRowSelectable() {
    const t = F0(this.beans.gos);
    this.setRowSelectable(t ? t(this) : !0);
  }
  setRowSelectable(t, r) {
    if (this.selectable !== t) {
      if (this.selectable = t, this.dispatchRowEvent("selectableChanged"), r)
        return;
      if (ls(this.beans.gos)) {
        const i = this.calculateSelectedFromChildren();
        this.setSelectedParams({
          newValue: i ?? !1,
          source: "selectableChanged"
        });
        return;
      }
      this.isSelected() && !this.selectable && this.setSelectedParams({
        newValue: !1,
        source: "selectableChanged"
      });
    }
  }
  setId(t) {
    var n;
    const r = za(this.beans.gos);
    if (r)
      if (this.data) {
        const i = ((n = this.parent) == null ? void 0 : n.getRoute()) ?? [];
        this.id = r({
          data: this.data,
          parentKeys: i.length > 0 ? i : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith(eo.ID_PREFIX_ROW_GROUP) && tt(
          `Row IDs cannot start with ${eo.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`
        );
      } else
        this.id = void 0;
    else
      this.id = t;
  }
  setRowTop(t) {
    this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.dispatchRowEvent("topChanged"), this.setDisplayed(t !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setHovered(t) {
    this.hovered = t;
  }
  isHovered() {
    return this.hovered;
  }
  setMaster(t) {
    this.master !== t && (this.master && !t && (this.expanded = !1), this.master = t, this.dispatchRowEvent("masterChanged"));
  }
  setGroup(t) {
    this.group !== t && (this.group && !t && (this.expanded = !1), this.group = t, this.updateHasChildren(), this.checkRowSelectable(), this.dispatchRowEvent("groupChanged"));
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(t, r = !1) {
    this.rowHeight = t, this.rowHeightEstimated = r, this.dispatchRowEvent("heightChanged");
  }
  setRowAutoHeight(t, r) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[r.getId()] = t, t != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = Ar(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    var a;
    let t = !1, r = !0, n = 0;
    const i = this.__autoHeights;
    if (i == null || (this.beans.visibleColsService.getAllAutoHeightCols().forEach((l) => {
      let u = i[l.getId()];
      if (u == null)
        if (this.beans.columnModel.isColSpanActive()) {
          let d = [];
          switch (l.getPinned()) {
            case "left":
              d = this.beans.visibleColsService.getLeftColsForRow(this);
              break;
            case "right":
              d = this.beans.visibleColsService.getRightColsForRow(this);
              break;
            case null:
              d = this.beans.columnViewportService.getColsWithinViewport(this);
              break;
          }
          if (d.includes(l)) {
            t = !0;
            return;
          }
          u = -1;
        } else {
          t = !0;
          return;
        }
      else
        r = !1;
      u > n && (n = u);
    }), t) || ((r || n < 10) && (n = ho(this.beans.gos, this).height), n == this.rowHeight))
      return;
    this.setRowHeight(n);
    const s = this.beans.rowModel;
    (a = s.onRowHeightChangedDebounced) == null || a.call(s);
  }
  /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */
  setExpanded(t, r, n) {
    if (this.expanded === t)
      return;
    this.expanded = t, this.dispatchRowEvent("expandedChanged");
    const i = { ...this.createGlobalRowEvent("rowGroupOpened"), expanded: t, event: r || null };
    this.beans.rowNodeEventThrottle.dispatchExpanded(i, n), this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(t) {
    return this.beans.gos.addGridCommonParams({
      type: t,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned
    });
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(t, r, n) {
    const o = typeof t != "string" ? t : this.beans.columnModel.getCol(t) ?? this.beans.columnModel.getColDefCol(t), s = this.beans.valueService.getValueForDisplay(o, this);
    if (this.beans.gos.get("readOnlyEdit"))
      return this.beans.eventService.dispatchEvent({
        type: "cellEditRequest",
        event: null,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned,
        column: o,
        colDef: o.getColDef(),
        data: this.data,
        node: this,
        oldValue: s,
        newValue: r,
        value: r,
        source: n
      }), !1;
    const a = this.beans.valueService.setValue(this, o, r, n);
    return this.dispatchCellChangedEvent(o, r, s), this.checkRowSelectable(), a;
  }
  setGroupValue(t, r) {
    const n = this.beans.columnModel.getCol(t);
    Ke(this.groupData) && (this.groupData = {});
    const i = n.getColId(), o = this.groupData[i];
    o !== r && (this.groupData[i] = r, this.dispatchCellChangedEvent(n, r, o));
  }
  // sets the data for an aggregation
  setAggData(t) {
    const r = this.aggData;
    if (this.aggData = t, this.localEventService) {
      const n = (i) => {
        const o = this.aggData ? this.aggData[i] : void 0, s = r ? r[i] : void 0;
        if (o === s)
          return;
        const a = this.beans.columnModel.getCol(i);
        a && this.dispatchCellChangedEvent(a, o, s);
      };
      for (const i in r)
        n(i);
      for (const i in t)
        (!r || !(i in r)) && n(i);
    }
  }
  updateHasChildren() {
    let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (yo(this.beans.gos)) {
      const n = this.beans.gos.get("treeData"), i = this.beans.gos.get("isServerSideGroup");
      t = !this.stub && !this.footer && (n ? !!i && i(this.data) : !!this.group);
    }
    t !== this.__hasChildren && (this.__hasChildren = !!t, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  dispatchCellChangedEvent(t, r, n) {
    var o;
    const i = {
      type: "cellChanged",
      node: this,
      column: t,
      newValue: r,
      oldValue: n
    };
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    return this.footer ? !1 : this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(t) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((r) => r.depthFirstSearch(t)), t(this);
  }
  // + selectionController.calculatedSelectedForAllGroupNodes()
  calculateSelectedFromChildren() {
    var n;
    let t = !1, r = !1;
    if (!((n = this.childrenAfterGroup) != null && n.length))
      return this.selectable ? this.selected : null;
    for (let i = 0; i < this.childrenAfterGroup.length; i++) {
      const o = this.childrenAfterGroup[i];
      let s = o.isSelected();
      if (!o.selectable) {
        const a = o.calculateSelectedFromChildren();
        if (a === null)
          continue;
        s = a;
      }
      switch (s) {
        case !0:
          t = !0;
          break;
        case !1:
          r = !0;
          break;
        default:
          return;
      }
    }
    if (!(t && r))
      return t ? !0 : r ? !1 : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(t) {
    this.selected = t;
  }
  dispatchRowEvent(t) {
    var r;
    (r = this.localEventService) == null || r.dispatchEvent({
      type: t,
      node: this
    });
  }
  selectThisNode(t, r, n = "api") {
    const i = !this.selectable && t, o = this.selected === t;
    if (i || o)
      return !1;
    this.selected = t, this.dispatchRowEvent("rowSelected");
    const s = this.sibling;
    return s && s.footer && s.localEventService && s.dispatchRowEvent("rowSelected"), this.beans.eventService.dispatchEvent({
      ...this.createGlobalRowEvent("rowSelected"),
      event: r || null,
      source: n
    }), !0;
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(t, r = !1, n = "api") {
    if (typeof n == "boolean") {
      ie(
        "since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead."
      );
      return;
    }
    this.setSelectedParams({
      newValue: t,
      clearSelection: r,
      rangeSelect: !1,
      source: n
    });
  }
  // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
  setSelectedParams(t) {
    return this.rowPinned ? (ie("cannot select pinned rows"), 0) : this.id === void 0 ? (ie("cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected({ ...t, nodes: [this.footer ? this.sibling : this] });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return !!this.rowPinned;
  }
  /** Add an event listener. */
  addEventListener(t, r) {
    var i;
    this.localEventService || (this.localEventService = new _a()), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new D0(this.beans.frameworkOverrides));
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.wrap(r)) ?? r;
    this.localEventService.addEventListener(t, n);
  }
  /** Remove event listener. */
  removeEventListener(t, r) {
    var i;
    if (!this.localEventService)
      return;
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(r)) ?? r;
    this.localEventService.removeEventListener(t, n), this.localEventService.noRegisteredListenersExist() && (this.localEventService = null);
  }
  onMouseEnter() {
    this.dispatchRowEvent("mouseEnter");
  }
  onMouseLeave() {
    this.dispatchRowEvent("mouseLeave");
  }
  /**
   * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
   *
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (ie(
      "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option."
    ), this.detail)
      return !0;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of keys to the row node. Returns undefined if the node has no key.
   */
  getRoute() {
    if (this.level === -1)
      return [];
    if (this.key == null)
      return;
    const t = [];
    let r = this;
    for (; r && r.key != null; )
      t.push(r.key), r = r.parent;
    return t.reverse();
  }
  createFooter() {
    if (this.sibling)
      return;
    const t = new eo(this.beans);
    Object.keys(this).forEach((r) => {
      sG.has(r) || (t[r] = this[r]);
    }), t.footer = !0, t.setRowTop(null), t.setRowIndex(null), t.oldRowTop = null, t.id = "rowGroupFooter_" + this.id, t.sibling = this, this.sibling = t;
  }
  destroyFooter() {
    this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0);
  }
  setFirstChild(t) {
    this.firstChild !== t && (this.firstChild = t, this.dispatchRowEvent("firstChildChanged"));
  }
  setLastChild(t) {
    this.lastChild !== t && (this.lastChild = t, this.dispatchRowEvent("lastChildChanged"));
  }
  setChildIndex(t) {
    this.childIndex !== t && (this.childIndex = t, this.dispatchRowEvent("childIndexChanged"));
  }
  setDisplayed(t) {
    this.displayed !== t && (this.displayed = t, this.dispatchRowEvent("displayedChanged"));
  }
  setDragging(t) {
    this.dragging !== t && (this.dragging = t, this.dispatchRowEvent("draggingChanged"));
  }
  setHighlighted(t) {
    this.highlighted !== t && (this.highlighted = t, this.dispatchRowEvent("rowHighlightChanged"));
  }
  setAllChildrenCount(t) {
    this.allChildrenCount !== t && (this.allChildrenCount = t, this.dispatchRowEvent("allChildrenCountChanged"));
  }
  setRowIndex(t) {
    this.rowIndex !== t && (this.rowIndex = t, this.dispatchRowEvent("rowIndexChanged"));
  }
  setUiLevel(t) {
    this.uiLevel !== t && (this.uiLevel = t, this.dispatchRowEvent("uiLevelChanged"));
  }
};
Uc.ID_PREFIX_ROW_GROUP = "row-group-";
Uc.ID_PREFIX_TOP_PINNED = "t-";
Uc.ID_PREFIX_BOTTOM_PINNED = "b-";
Uc.OBJECT_ID_SEQUENCE = 0;
var Ti = Uc, aG = class extends J {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advancedFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.dataTypeService = e.dataTypeService, this.quickFilterService = e.quickFilterService, this.advancedFilterService = e.advancedFilterService, this.columnFilterService = e.columnFilterService;
  }
  postConstruct() {
    const e = this.refreshFiltersForAggregations.bind(this), t = this.updateAdvancedFilterColumns.bind(this);
    this.addManagedEventListeners({
      columnValueChanged: e,
      columnPivotChanged: e,
      columnPivotModeChanged: e,
      newColumnsLoaded: t,
      columnVisible: t,
      advancedFilterEnabledChanged: ({ enabled: r }) => this.onAdvancedFilterEnabledChanged(r),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.addManagedPropertyListener(
      "advancedFilterModel",
      (r) => this.setAdvancedFilterModel(r.currentValue)
    ), this.quickFilterService && this.addManagedListeners(this.quickFilterService, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : !1;
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : !1;
  }
  setFilterModel(e, t = "api") {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    (r = this.columnFilterService) == null || r.setFilterModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.columnFilterService) == null ? void 0 : e.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isAggregateFilterPresent());
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  isAdvancedFilterPresent() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
  }
  onAdvancedFilterEnabledChanged(e) {
    var t, r;
    e ? (t = this.columnFilterService) != null && t.disableColumnFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (r = this.advancedFilterService) != null && r.isFilterPresent() && (this.advancedFilterService.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvancedFilterEnabled() {
    var e;
    return !!((e = this.advancedFilterService) != null && e.isEnabled());
  }
  isAdvancedFilterHeaderActive() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  resetQuickFilterCache() {
    var e;
    (e = this.quickFilterService) == null || e.resetQuickFilterCache();
  }
  refreshFiltersForAggregations() {
    fm(this.gos) && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: r, columns: n = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.columnFilterService ? this.columnFilterService.updateBeforeFilterChanged(e) : _t.resolve()).then(() => {
      var o;
      const i = {
        source: t,
        type: "filterChanged",
        columns: n
      };
      r && Pr(i, r), this.eventService.dispatchEvent(i), (o = this.columnFilterService) == null || o.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilterService) != null && e.isQuickFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!fm(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.columnFilterService.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.columnFilterService.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip) || this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode));
  }
  isFilterActive(e) {
    var t;
    return !!((t = this.columnFilterService) != null && t.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var t;
    return ((t = this.columnFilterService) == null ? void 0 : t.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.columnFilterService.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.columnFilterService.createFilterParams(e, t);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? !1 : !!((t = this.columnFilterService) != null && t.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var r;
    return (r = this.columnFilterService) == null ? void 0 : r.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getCurrentFloatingFilterParentModel(e);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var r;
    (r = this.columnFilterService) == null || r.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var r;
    return !!((r = this.columnFilterService) != null && r.areFilterCompsDifferent(e, t));
  }
  getAdvancedFilterModel() {
    return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
  }
  setAdvancedFilterModel(e) {
    var t;
    if (this.isAdvancedFilterEnabled()) {
      if ((t = this.dataTypeService) != null && t.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilterService.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  toggleAdvancedFilterBuilder(e, t) {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder({ source: t, force: e });
  }
  updateAdvancedFilterColumns() {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvancedFilterEnabled() ? !1 : !!((e = this.columnFilterService) != null && e.hasFloatingFilters());
  }
  getFilterInstance(e, t) {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    return (r = this.columnFilterService) == null ? void 0 : r.getFilterInstance(e, t);
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve(void 0)) : ((t = this.columnFilterService) == null ? void 0 : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvancedFilters() {
    ie("Column Filter API methods have been disabled as Advanced Filters are enabled.");
  }
  setupAdvancedFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilterService) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvancedFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advancedFilterModelUpdateQueue.forEach((e) => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var r;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve()) : ((r = this.columnFilterService) == null ? void 0 : r.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
  setColDefPropertiesForDataType(e, t, r) {
    var n;
    (n = this.columnFilterService) == null || n.setColDefPropertiesForDataType(e, t, r);
  }
}, lG = class extends vt {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-filter"></div>'
    ), this.column = e, this.source = t, this.filterWrapper = null;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.columnModel = e.columnModel;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e;
    return ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null;
  }
  afterInit() {
    var e, t;
    return ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) ?? _t.resolve();
  }
  afterGuiAttached(e) {
    var t, r;
    (r = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || r.then((n) => {
      var i;
      (i = n == null ? void 0 : n.afterGuiAttached) == null || i.call(n, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((r) => {
      var n;
      (n = r == null ? void 0 : r.afterGuiDetached) == null || n.call(r);
    });
  }
  createFilter(e) {
    var n, i;
    const { column: t, source: r } = this;
    this.filterWrapper = ((n = this.filterManager) == null ? void 0 : n.getOrCreateFilterWrapper(t)) ?? null, (i = this.filterWrapper) != null && i.filterPromise && this.filterWrapper.filterPromise.then((o) => {
      const s = o.getGui();
      de(s) || ie(`getGui method from filter returned ${s}; it should be a DOM element.`), this.appendChild(s), e && this.eventService.dispatchEvent({
        type: "filterOpened",
        column: t,
        source: r,
        eGui: this.getGui()
      });
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.columnModel.getColDefCol(this.column) && (nn(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, tP = "ag-resizer-wrapper", Qi = (e, t) => `<div data-ref="${e}Resizer" class="ag-resizer ag-resizer-${t}"></div>`, cG = (
  /* html */
  `<div class="${tP}">
        ${Qi("eTopLeft", "topLeft")}
        ${Qi("eTop", "top")}
        ${Qi("eTopRight", "topRight")}
        ${Qi("eRight", "right")}
        ${Qi("eBottomRight", "bottomRight")}
        ${Qi("eBottom", "bottom")}
        ${Qi("eBottomLeft", "bottomLeft")}
        ${Qi("eLeft", "left")}
    </div>`
), uG = class extends J {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.resizeObserverService = e.resizeObserverService, this.dragService = e.dragService;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, r = t / 2 - this.getWidth() / 2, n = e / 2 - this.getHeight() / 2;
    this.offsetElement(r, n);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: r, width: n, minHeight: i, height: o, x: s, y: a } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, u = 0;
    const d = li(this.element);
    if (d) {
      const h = this.findBoundaryElement(), f = window.getComputedStyle(h);
      if (f.minWidth != null) {
        const p = h.offsetWidth - this.element.offsetWidth;
        u = parseInt(f.minWidth, 10) - p;
      }
      if (f.minHeight != null) {
        const p = h.offsetHeight - this.element.offsetHeight;
        l = parseInt(f.minHeight, 10) - p;
      }
    }
    if (this.minHeight = i || l, this.minWidth = r || u, n && this.setWidth(n), o && this.setHeight(o), (!n || !o) && this.refreshSize(), e)
      this.center();
    else if (s || a)
      this.offsetElement(s, a);
    else if (d && t) {
      let h = this.boundaryEl, f = !0;
      if (h || (h = this.findBoundaryElement(), f = !1), h) {
        const p = parseFloat(h.style.top), y = parseFloat(h.style.left);
        f ? this.offsetElement(isNaN(y) ? 0 : y, isNaN(p) ? 0 : p) : this.setPosition(y, p);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const r = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      const n = !!e[t], i = this.getResizerElement(t), o = {
        dragStartPixels: 0,
        eElement: i,
        onDragStart: (s) => this.onResizeStart(s, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (s) => this.onResizeEnd(s, t)
      };
      (n || !this.isAlive() && !n) && (n ? (this.dragService.addDragSource(o), this.resizeListeners.push(o), i.style.pointerEvents = "all") : i.style.pointerEvents = "none", this.resizable[t] = n);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, r = this.element;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Vl(r, e), e = GE(r), n = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const i = this.getAvailableHeight();
      i && e > i && (e = i);
    }
    this.getHeight() !== e && (n ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : t ? Vl(r, e) : (r.style.height = `${e}px`, r.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: r } = this.offsetParent;
    if (!r)
      return null;
    const n = this.element.getBoundingClientRect(), i = this.offsetParent.getBoundingClientRect(), o = e ? this.position.y : n.top, s = e ? 0 : i.top;
    let a = 0;
    if (t) {
      const u = this.element.parentElement;
      if (u) {
        const { bottom: d } = u.getBoundingClientRect();
        a = d - n.bottom;
      }
    }
    return r + s - o - a;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: r } = this.config;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Hn(t, e), e = Dd(t), n = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: i } = this.offsetParent, o = r ? this.position.x : this.element.getBoundingClientRect().left;
      i && e + o > i && (e = i - o);
    }
    this.getWidth() !== e && (n ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Hn(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: r } = this.config, n = r ? this.boundaryEl : this.element;
    n && (this.popupService.positionPopup({
      ePopup: n,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(n.style.left), parseFloat(n.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const r = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${r}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(
      this.popupService.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: r, isTop: n, anywhereWithin: i, topBuffer: o } = e, s = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!r, !!i, s) ? 0 : s, u = this.shouldSkipY(t, !!n, o, a) ? 0 : a;
    return { movementX: l, movementY: u };
  }
  shouldSkipX(e, t, r, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), s = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.x : i.left;
    let l = a <= 0 && o.left >= e.clientX || o.right <= e.clientX && o.right <= s.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    n < 0 && e.clientX > a + o.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    n > 0 && e.clientX < a + o.left : r ? l = n < 0 && e.clientX > s.right || n > 0 && e.clientX < a + o.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    n < 0 && e.clientX > s.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    n > 0 && e.clientX < s.right, l);
  }
  shouldSkipY(e, t, r = 0, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), s = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.y : i.top;
    let l = a <= 0 && o.top >= e.clientY || o.bottom <= e.clientY && o.bottom <= s.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    n < 0 && e.clientY > a + o.top + r || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    n > 0 && e.clientY < a + o.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    n < 0 && e.clientY > s.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    n > 0 && e.clientY < s.bottom, l);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[data-ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[data-ref=eTopResizer]") },
      topRight: { element: e.querySelector("[data-ref=eTopRightResizer]") },
      right: { element: e.querySelector("[data-ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[data-ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[data-ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[data-ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[data-ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const r = new DOMParser().parseFromString(cG, "text/html").body;
    e.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${tP}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: r, forcePopupParentAsOffsetParent: n } = this.config;
    !r && !n && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((r) => !r.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, r = 0;
    for (let n = 0; n < e.length; n++) {
      const i = e[n], o = !!i.style.flex && i.style.flex !== "0 0 auto";
      if (i === this.element)
        continue;
      let s = this.minHeight || 0, a = this.minWidth || 0;
      if (o) {
        const l = window.getComputedStyle(i);
        l.minHeight && (s = parseInt(l.minHeight, 10)), l.minWidth && (a = parseInt(l.minWidth, 10));
      } else
        s = i.offsetHeight, a = i.offsetWidth;
      t += s, r += a;
    }
    return { height: t, width: r };
  }
  applySizeToSiblings(e) {
    let t = null;
    const r = this.getSiblings();
    if (r) {
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        i !== t && (e ? i.style.height = `${i.offsetHeight}px` : i.style.width = `${i.offsetWidth}px`, i.style.flex = "0 0 auto", i === this.element && (t = r[n + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: r } = this.config, { isTop: n, isRight: i, isBottom: o, isLeft: s } = this.currentResizer, a = i || s, l = o || n, { movementX: u, movementY: d } = this.calculateMouseMovement({ e, isLeft: s, isTop: n }), h = this.position.x, f = this.position.y;
    let p = 0, y = 0;
    if (a && u) {
      const C = s ? -1 : 1, v = this.getWidth(), w = v + u * C;
      let R = !1;
      s && (p = v - w, (h + p <= 0 || w <= this.minWidth) && (R = !0, p = 0)), R || this.setWidth(w);
    }
    if (l && d) {
      const C = n ? -1 : 1, v = this.getHeight(), w = v + d * C;
      let R = !1;
      n ? (y = v - w, (f + y <= 0 || w <= this.minHeight) && (R = !0, y = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && v < w && this.getMinSizeOfSiblings().height + w > this.element.parentElement.offsetHeight && (R = !0), R || this.setHeight(w);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || r) && p || y) && this.offsetElement(h + p, f + y);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: r } = this.position;
    let n;
    this.config.calculateTopBuffer && (n = this.config.calculateTopBuffer());
    const { movementX: i, movementY: o } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: n
    });
    this.offsetElement(t + i, r + o), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, rP = class nP extends J {
  constructor(t, r = {}) {
    super(), this.eFocusableElement = t, this.callbacks = r, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (n) => {
        if (n.defaultPrevented)
          return;
        const i = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, n.shiftKey);
        i && (i.focus(), n.preventDefault());
      },
      ...r
    };
  }
  wireBeans(t) {
    this.focusService = t.focusService;
  }
  postConstruct() {
    this.eFocusableElement.classList.add(nP.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedElementListeners(this.eFocusableElement, { focusin: this.callbacks.onFocusIn }), this.callbacks.onFocusOut && this.addManagedElementListeners(this.eFocusableElement, { focusout: this.callbacks.onFocusOut });
  }
  addKeyDownListeners(t) {
    this.addManagedElementListeners(t, {
      keydown: (r) => {
        if (!(r.defaultPrevented || Mi(r))) {
          if (this.callbacks.shouldStopEventPropagation(r)) {
            ia(r);
            return;
          }
          r.key === V.TAB ? this.callbacks.onTabKeyDown(r) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(r);
        }
      }
    });
  }
};
rP.FOCUS_MANAGED_CLASS = "ag-focus-managed";
var ps = rP, iP = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
function j0(e, t) {
  return _d(e) ? (e.debounceMs != null && ie("debounceMs is ignored when apply button is present"), 0) : e.debounceMs != null ? e.debounceMs : t;
}
function _d(e) {
  return !!e.buttons && e.buttons.indexOf("apply") >= 0;
}
var dG = class extends vt {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.eFilterBody = Fe, this.buttonListeners = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(
      new ps(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = new uG(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const r = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(r, this.getAgComponents(), e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.providedFilterParams = e, this.applyActive = _d(e), this.resetButtonsPanel(e);
  }
  updateParams(e) {
    this.providedFilterParams = e, this.applyActive = _d(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel(e, t) {
    const { buttons: r, readOnly: n } = t ?? {}, { buttons: i, readOnly: o } = e;
    if (n === o && ec(r, i))
      return;
    const s = i && i.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (nn(this.eButtonsPanel), this.buttonListeners.forEach((u) => u()), this.buttonListeners = []) : s && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !s) {
      this.eButtonsPanel && cs(this.eButtonsPanel);
      return;
    }
    const a = document.createDocumentFragment(), l = (u) => {
      let d, h;
      switch (u) {
        case "apply":
          d = this.translate("applyFilter"), h = (y) => this.onBtApply(!1, !1, y);
          break;
        case "clear":
          d = this.translate("clearFilter"), h = () => this.onBtClear();
          break;
        case "reset":
          d = this.translate("resetFilter"), h = () => this.onBtReset();
          break;
        case "cancel":
          d = this.translate("cancelFilter"), h = (y) => {
            this.onBtCancel(y);
          };
          break;
        default:
          ie("Unknown button type specified");
          return;
      }
      const p = ac(
        /* html */
        `<button
                    type="${u === "apply" ? "submit" : "button"}"
                    data-ref="${u}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${d}
                </button>`
      );
      this.buttonListeners.push(...this.addManagedElementListeners(p, { click: h })), a.append(p);
    };
    i.forEach((u) => l(u)), this.eButtonsPanel.append(a), this.getGui().appendChild(this.eButtonsPanel);
  }
  // subclasses can override this to provide alternative debounce defaults
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const e = j0(this.providedFilterParams, this.getDefaultDebounceMs()), t = Ar(this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.providedFilterParams.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const r = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(r) : this.resetUiToDefaults().then(r);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const r = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(r, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, r) {
    r && r.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: n } = this.providedFilterParams;
    n && this.applyActive && !e && !t && this.close(r);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, r = t && t.key;
    let n;
    (r === "Enter" || r === "Space") && (n = { keyboardEvent: t }), this.hidePopup(n), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const r = this.isModelValid(this.getModelFromUi()), n = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      n && sc(n, !r);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    if (!this.positionableFeature || e === "toolPanel")
      return;
    const t = e === "floatingFilter" || e === "columnFilter", { positionableFeature: r, gos: n } = this;
    t ? (r.restoreLastSize(), r.setResizable(
      n.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1);
  }
  refresh(e) {
    const t = this.providedFilterParams;
    return this.providedFilterParams = e, this.resetButtonsPanel(e, t), !0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.localeService.getLocaleTextFunc()(e, iP[e]);
  }
  getCellValue(e) {
    return this.providedFilterParams.getValue(e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
}, hG = class extends W0 {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0);
  }
}, gG = class extends vt {
  constructor(e = "default", t = !1) {
    super(
      /* html */
      `<div class="ag-list ag-${e}-list" role="listbox"></div>`
    ), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case V.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const r = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(r);
        }
        break;
      case V.DOWN:
      case V.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case V.PAGE_DOWN:
      case V.PAGE_UP:
      case V.PAGE_HOME:
      case V.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === V.DOWN;
    let r;
    if (!this.highlightedEl)
      r = this.itemEls[t ? 0 : this.itemEls.length - 1];
    else {
      let i = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1);
      i = Math.min(Math.max(i, 0), this.itemEls.length - 1), r = this.itemEls[i];
    }
    this.highlightItem(r);
  }
  navigateToPage(e) {
    if (!this.highlightedEl || this.itemEls.length === 0)
      return;
    const t = this.itemEls.indexOf(this.highlightedEl), r = this.options.length - 1, n = this.itemEls[0].clientHeight, i = Math.floor(this.getGui().clientHeight / n);
    let o = -1;
    e === V.PAGE_HOME ? o = 0 : e === V.PAGE_END ? o = r : e === V.PAGE_DOWN ? o = Math.min(t + i, r) : e === V.PAGE_UP && (o = Math.max(t - i, 0)), o !== -1 && this.highlightItem(this.itemEls[o]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: r } = e, n = r || t;
    return this.options.push({ value: t, text: n }), this.renderOption(t, n), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((e) => {
      cs(e);
    }), this.itemEls = [];
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, r) => {
      jB(t, r + 1), $B(t, e.length);
    });
  }
  renderOption(e, t) {
    const r = zt(this.gos), n = r.createElement("div");
    Vn(n, "option"), n.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const i = r.createElement("span");
    n.appendChild(i), i.textContent = t, this.unFocusable || (n.tabIndex = -1), this.itemEls.push(n), this.addManagedListeners(n, {
      mouseover: () => this.highlightItem(n),
      mousedown: (o) => {
        o.preventDefault(), o.stopPropagation(), this.setValue(e);
      }
    }), this.createManagedBean(
      new Ba({
        getTooltipValue: () => t,
        getGui: () => n,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => i.scrollWidth > i.clientWidth
      })
    ), this.getGui().appendChild(n);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const r = this.options.findIndex((n) => n.value === e);
    if (r !== -1) {
      const n = this.options[r];
      this.value = n.value, this.displayValue = n.text, this.highlightItem(this.itemEls[r]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!li(e))
      return;
    this.clearHighlighted(), this.highlightedEl = e, this.highlightedEl.classList.add(this.activeClass), Td(this.highlightedEl, !0);
    const t = this.getGui(), { scrollTop: r, clientHeight: n } = t, { offsetTop: i, offsetHeight: o } = e;
    (i + o > r + n || i < r) && this.highlightedEl.scrollIntoView({ block: "nearest" }), this.unFocusable || this.highlightedEl.focus();
  }
  clearHighlighted() {
    !this.highlightedEl || !li(this.highlightedEl) || (this.highlightedEl.classList.remove(this.activeClass), Td(this.highlightedEl, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, fG = class extends qE {
  constructor(e) {
    if (super(
      e,
      (e == null ? void 0 : e.template) || /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      (e == null ? void 0 : e.agComponents) || [],
      e == null ? void 0 : e.className
    ), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = Fe, this.eWrapper = Fe, this.eDisplayField = Fe, this.eIcon = Fe, this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: r, variableWidth: n, minPickerWidth: i, maxPickerWidth: o } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!n, r != null && this.setPickerMaxHeight(r), i != null && this.setPickerMinWidth(i), o != null && this.setPickerMaxWidth(o);
  }
  wireBeans(e) {
    this.popupService = e.popupService;
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: r, inputWidth: n } = this.config;
    if (r) {
      const i = tn(r, this.gos);
      i && this.eIcon.appendChild(i);
    }
    n != null && this.setInputWidth(n);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), Md(e, !1), this.ariaRole && Vn(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case V.UP:
      case V.DOWN:
      case V.ENTER:
      case V.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case V.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const t = this.localeService.getLocaleTextFunc(), { pickerAriaLabelKey: r, pickerAriaLabelValue: n, modalPicker: i = !0 } = this.config, o = {
      modal: i,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = pE(this.gos);
        this.beforeHidePicker(), f && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: t(r, n),
      anchorToElement: this.eWrapper
    };
    e.style.position = "absolute";
    const s = this.popupService.addPopup(o), { maxPickerHeight: a, minPickerWidth: l, maxPickerWidth: u, variableWidth: d } = this;
    d ? (l && (e.style.minWidth = l), e.style.width = B0(Dd(this.eWrapper)), u && (e.style.maxWidth = u)) : Ld(e, u ?? Dd(this.eWrapper));
    const h = a ?? `${N0(this.popupService.getPopupParent())}px`;
    return e.style.setProperty("max-height", h), this.alignPickerToComponent(), s.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const { pickerType: e } = this.config, { pickerGap: t } = this, r = this.gos.get("enableRtl") ? "right" : "left";
    this.popupService.positionPopupByComponent({
      type: e,
      eventSource: this.eWrapper,
      ePopup: this.pickerComponent.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: t
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    Md(t, e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && this.hideCurrentPicker();
  }
  setInputWidth(e) {
    return Ld(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, U0 = class extends fG {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "smallDown",
      ariaRole: "combobox",
      ...e
    });
  }
  postConstruct() {
    super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: r } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), r && t == null && (this.eDisplayField.textContent = r), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    this.listComponent = this.createBean(new gG("select", !0)), this.listComponent.setParentComponent(this);
    const e = this.listComponent.getAriaElement(), t = `ag-select-list-${this.listComponent.getCompId()}`;
    e.setAttribute("id", t), QB(this.getAriaElement(), e), this.listComponent.addManagedListeners(this.listComponent, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      }
    }), this.listComponent.addManagedListeners(this.listComponent, {
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var r;
    const { key: t } = e;
    switch (t === V.TAB && this.hidePicker(), t) {
      case V.ENTER:
      case V.UP:
      case V.DOWN:
      case V.PAGE_UP:
      case V.PAGE_DOWN:
      case V.PAGE_HOME:
      case V.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (r = this.listComponent) == null || r.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case V.ESCAPE:
        super.onKeyDown(e);
        break;
      case V.SPACE:
        this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this;
  }
  setValue(e, t, r) {
    if (this.value === e || !this.listComponent)
      return this;
    if (r || this.listComponent.setValue(e, !0), this.listComponent.getValue() === this.getValue())
      return this;
    let i = this.listComponent.getDisplayValue();
    return i == null && this.config.placeholder && (i = this.config.placeholder), this.eDisplayField.textContent = i, this.setTooltip({
      newTooltipText: i ?? null,
      shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
    }), super.setValue(e, t);
  }
  destroy() {
    this.listComponent && (this.listComponent = this.destroyBean(this.listComponent)), super.destroy();
  }
}, pG = {
  selector: "AG-SELECT",
  component: U0
}, oP = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string")
        return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], r = (n) => n.some((i) => e[i] != null) ? !0 : (ie(`ignoring FilterOptionDef as it doesn't contain one of '${n}'`), !1);
      if (!t.every(r)) {
        this.filterOptions = this.filterOptions.filter((n) => n === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : ie("invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else
      ie("no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}, sP = class extends dG {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: n } = t;
      return n ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, r) => {
      r === 0 ? t.setValue(e, !0) : t.setValue(this.optionsFactory.getDefaultOption(), !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.getFilterType(),
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const r = !e.operator, n = !t.operator;
    if (!r && n || r && !n)
      return !1;
    let o;
    if (r) {
      const s = e, a = t;
      o = this.areSimpleModelsEqual(s, a);
    } else {
      const s = e, a = t;
      o = s.operator === a.operator && Co(
        s.conditions,
        a.conditions,
        (l, u) => this.areSimpleModelsEqual(l, u)
      );
    }
    return o;
  }
  shouldRefresh(e) {
    var o;
    const t = this.getModel(), r = t ? t.conditions ?? [t] : null, n = ((o = e.filterOptions) == null ? void 0 : o.map((s) => typeof s == "string" ? s : s.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!r || r.every((s) => n.find((a) => a === s.type) !== void 0)) || typeof e.maxNumConditions == "number" && r && r.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? !1 : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const r = e;
      let n = r.conditions;
      n == null && (n = [], ie("Filter model is missing 'conditions'"));
      const i = this.validateAndUpdateConditions(n), o = this.getNumConditions();
      if (i < o)
        this.removeConditionsAndOperators(i);
      else if (i > o)
        for (let a = o; a < i; a++)
          this.createJoinOperatorPanel(), this.createOption();
      const s = r.operator === "OR";
      this.eJoinOperatorsAnd.forEach((a) => a.setValue(!s, !0)), this.eJoinOperatorsOr.forEach((a) => a.setValue(s, !0)), n.forEach((a, l) => {
        this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l);
      });
    } else {
      const r = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(r.type, !0), this.setConditionIntoUi(r, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), _t.resolve();
  }
  validateAndUpdateConditions(e) {
    let t = e.length;
    return t > this.maxNumConditions && (e.splice(this.maxNumConditions), ie(
      'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'
    ), t = this.maxNumConditions), t;
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null)
      return !0;
    const { operator: r } = t, n = [];
    if (r) {
      const o = t;
      n.push(...o.conditions ?? []);
    } else
      n.push(t);
    return n[r && r === "OR" ? "some" : "every"]((o) => this.individualConditionPasses(e, o));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new oP(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    this.maxNumConditions = e.maxNumConditions ?? 2, this.maxNumConditions < 1 && (ie('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = e.numAlwaysVisibleConditions ?? 1, this.numAlwaysVisibleConditions < 1 && (ie('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (ie(
      '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'
    ), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const e = this.createManagedBean(new U0());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const r = this.getNumConditions() - 1;
    this.forEachPositionInput(r, (n) => this.resetInput(n)), this.addChangedListeners(e, r);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), r = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const n = this.eJoinOperatorPanels.length - 1, i = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, n, i), this.resetJoinOperatorOr(r, n, i), this.isReadOnly() || (t.onValueChange(this.listener), r.onValueChange(this.listener));
  }
  createJoinOperator(e, t, r) {
    const n = this.createManagedBean(new hG());
    return e.push(n), n.addCssClass("ag-filter-condition-operator"), n.addCssClass(`ag-filter-condition-operator-${r}`), t.appendChild(n.getGui()), n;
  }
  getDefaultJoinOperator(e) {
    return e === "AND" || e === "OR" ? e : "AND";
  }
  createFilterListOptions() {
    const e = this.optionsFactory.getFilterOptions();
    this.filterListOptions = e.map(
      (t) => typeof t == "string" ? this.createBoilerplateListOption(t) : this.createCustomListOption(t)
    );
  }
  putOptionsIntoDropdown(e) {
    this.filterListOptions.forEach((t) => {
      e.addOption(t);
    }), e.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, r = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: r ? this.localeService.getLocaleTextFunc()(r.displayKey, r.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let r = 0; r < this.getNumConditions(); r++)
      this.isConditionUiComplete(r) ? e = r : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const r = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < r) {
        this.removeConditionsAndOperators(r + 1);
        const n = e + 1, i = r - n;
        i > 0 && this.removeConditionsAndOperators(n, i), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((n, i) => {
      const o = this.isConditionDisabled(i, e);
      n.setDisabled(o || this.filterListOptions.length <= 1), i === 1 && (sc(this.eJoinOperatorPanels[0], o), this.eJoinOperatorsAnd[0].setDisabled(o), this.eJoinOperatorsOr[0].setDisabled(o));
    }), this.eConditionBodies.forEach((n, i) => {
      Tt(n, this.isConditionBodyVisible(i));
    });
    const r = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((n) => {
      n.setValue(!r, !0);
    }), this.eJoinOperatorsOr.forEach((n) => {
      n.setValue(r, !0);
    }), this.forEachInput((n, i, o, s) => {
      this.setElementDisplayed(n, i < s), this.setElementDisabled(n, this.isConditionDisabled(o, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
    const r = Math.max(e - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, r, t), this.removeComponents(this.eJoinOperatorsAnd, r, t), this.removeComponents(this.eJoinOperatorsOr, r, t);
  }
  removeElements(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => cs(i));
  }
  removeComponents(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => {
      cs(i.getGui()), this.destroyBean(i);
    });
  }
  removeItems(e, t, r) {
    return r == null ? e.splice(t) : e.splice(t, r);
  }
  afterGuiAttached(e) {
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus))
      if (this.isReadOnly())
        this.eFilterBody.focus();
      else {
        const t = this.getInputs(0)[0];
        if (!t)
          return;
        t instanceof Uo && t.getInputElement().focus();
      }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, r = -1, n = !1;
    const i = this.getJoinOperator();
    for (let s = this.getNumConditions() - 1; s >= 0; s--)
      if (this.isConditionUiComplete(s))
        t === -1 && (t = s, r = s);
      else {
        const a = s >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(s - 1), l = s < t;
        (a || l) && (this.removeConditionsAndOperators(s, 1), n = !0, l && r--);
      }
    let o = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), o = !0), this.shouldAddNewConditionAtEnd(r === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), o = !0), o && this.updateConditionStatusesAndValues(r, i), n && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = r;
  }
  getPlaceholderText(e, t) {
    let r = this.translate(e);
    if (P0(this.filterPlaceholder)) {
      const n = this.filterPlaceholder, i = this.eTypes[t].getValue(), o = this.translate(i);
      r = n({
        filterOptionKey: i,
        filterOption: o,
        placeholder: r
      });
    } else typeof this.filterPlaceholder == "string" && (r = this.filterPlaceholder);
    return r;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc();
    this.forEachInput((t, r, n, i) => {
      if (!(t instanceof Uo))
        return;
      const o = r === 0 && i > 1 ? "inRangeStart" : r === 0 ? "filterOoo" : "inRangeEnd", s = r === 0 && i > 1 ? e("ariaFilterFromValue", "Filter from value") : r === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(o, n)), t.setInputAriaLabel(s);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, r) {
    e instanceof Uo && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof vt && Tt(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof vt && sc(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof Uo && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, r) => {
      this.forEachPositionTypeInput(r, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const r = this.getConditionType(e);
    this.forEachPositionTypeInput(e, r, t);
  }
  forEachPositionTypeInput(e, t, r) {
    const n = this.getNumberOfInputs(t), i = this.getInputs(e);
    for (let o = 0; o < i.length; o++) {
      const s = i[o];
      s != null && r(s, o, e, n);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((r) => r == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach(
      (t, r) => this.resetJoinOperatorAnd(t, r, this.joinOperatorId + r)
    ), this.eJoinOperatorsOr.forEach(
      (t, r) => this.resetJoinOperatorOr(t, r, this.joinOperatorId + r)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), _t.resolve();
  }
  resetType(e) {
    const r = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(r).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("AND"),
      this.translate("andCondition"),
      r
    );
  }
  resetJoinOperatorOr(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("OR"),
      this.translate("orCondition"),
      r
    );
  }
  resetJoinOperator(e, t, r, n, i) {
    this.updateJoinOperatorDisabled(
      e.setValue(r, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${i}`).setLabel(n),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t));
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const r = this.mapValuesFromModel(e);
    this.forEachInput((n, i, o) => {
      o === t && this.setElementValue(n, r[i] != null ? r[i] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, r, n) => {
      this.setElementValue(t, r === 0 && n === 0 ? e : null, !0);
    });
  }
  isDefaultOperator(e) {
    return e === this.defaultJoinOperator;
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (r) => {
      this.attachElementOnChange(r, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const r = this.getCellValue(e.node), n = this.mapValuesFromModel(t), i = this.optionsFactory.getCustomOption(t.type), o = this.evaluateCustomFilter(i, n, r);
    return o ?? (r == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(n, r, t, e));
  }
  evaluateCustomFilter(e, t, r) {
    if (e == null)
      return;
    const { predicate: n } = e;
    if (n != null && !t.some((i) => i == null))
      return n(t, r);
  }
  isBlank(e) {
    return e == null || typeof e == "string" && e.trim().length === 0;
  }
  hasInvalidInputs() {
    return !1;
  }
}, aP = class extends sP {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    switch (e) {
      case "equals":
        if (this.scalarFilterParams.includeBlanksInEquals)
          return !0;
        break;
      case "notEqual":
        if (this.scalarFilterParams.includeBlanksInNotEqual)
          return !0;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInGreaterThan)
          return !0;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInLessThan)
          return !0;
        break;
      case "inRange":
        if (this.scalarFilterParams.includeBlanksInRange)
          return !0;
        break;
      case "blank":
        return !0;
      case "notBlank":
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, r) {
    const n = this.comparator(), i = e[0] != null ? n(e[0], t) : 0;
    switch (r.type) {
      case "equals":
        return i === 0;
      case "notEqual":
        return i !== 0;
      case "greaterThan":
        return i > 0;
      case "greaterThanOrEqual":
        return i >= 0;
      case "lessThan":
        return i < 0;
      case "lessThanOrEqual":
        return i <= 0;
      case "inRange": {
        const o = n(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? i >= 0 && o <= 0 : i > 0 && o < 0;
      }
      case "blank":
        return this.isBlank(t);
      case "notBlank":
        return !this.isBlank(t);
      default:
        return ie(
          'Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'
        ), !0;
    }
  }
}, mG = 65, vG = 67, yG = 86, CG = 68, wG = 90, bG = 89;
function lP(e) {
  var r;
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : ((r = e.key) == null ? void 0 : r.length) === 1;
}
function Rm(e, t, r, n, i) {
  const o = n ? n.getColDef().suppressKeyboardEvent : void 0;
  if (!o)
    return !1;
  const s = e.addGridCommonParams({
    event: t,
    editing: i,
    column: n,
    node: r,
    data: r.data,
    colDef: n.getColDef()
  });
  return !!(o && o(s));
}
function SG(e, t, r, n) {
  const i = n.getDefinition(), o = i && i.suppressHeaderKeyboardEvent;
  if (!de(o))
    return !1;
  const s = e.addGridCommonParams({
    colDef: i,
    column: n,
    headerRowIndex: r,
    event: t
  });
  return !!o(s);
}
function xG(e) {
  const { keyCode: t } = e;
  let r;
  switch (t) {
    case mG:
      r = V.A;
      break;
    case vG:
      r = V.C;
      break;
    case yG:
      r = V.V;
      break;
    case CG:
      r = V.D;
      break;
    case wG:
      r = V.Z;
      break;
    case bG:
      r = V.Y;
      break;
    default:
      r = e.code;
  }
  return r;
}
function RG(e, t = !1) {
  return e === V.DELETE ? !0 : !t && e === V.BACKSPACE ? _E() : !1;
}
var ms = class extends Uo {
  constructor(e, t = "ag-text-field", r = "text") {
    super(e, t, r);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    return this.eInput.value !== e && (this.eInput.value = de(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (r) => {
      lP(r) && r.key && !e.test(r.key) && r.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (r) => {
        var i;
        const n = (i = r.clipboardData) == null ? void 0 : i.getData("text");
        n && n.split("").some((o) => !e.test(o)) && r.preventDefault();
      }
    });
  }
}, Yh = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: ms
}, K0 = class extends ms {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListeners(this.eInput, {
      blur: () => {
        const i = parseFloat(this.eInput.value), o = isNaN(i) ? "" : this.normalizeValue(i.toString());
        this.value !== o && this.setValue(o);
      },
      wheel: this.onWheel.bind(this)
    }), this.eInput.step = "any";
    const { precision: e, min: t, max: r, step: n } = this.config;
    typeof e == "number" && this.setPrecision(e), typeof t == "number" && this.setMin(t), typeof r == "number" && this.setMax(r), typeof n == "number" && this.setStep(n);
  }
  onWheel(e) {
    Dt(this.gos) === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null)
      return e;
    if (t) {
      const n = parseFloat(e).toFixed(this.precision);
      return parseFloat(n).toString();
    }
    const r = String(e).split(".");
    if (r.length > 1) {
      if (r[1].length <= this.precision)
        return e;
      if (this.precision > 0)
        return `${r[0]}.${r[1].slice(0, this.precision)}`;
    }
    return r[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, xn(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, xn(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, xn(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue(
      (r) => super.setValue(r, t),
      () => this,
      e
    );
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, r) {
    if (de(r)) {
      let n = this.isScientificNotation(r);
      if (n && this.eInput.validity.valid)
        return e(r);
      if (!n) {
        r = this.adjustPrecision(r);
        const i = this.normalizeValue(r);
        n = r != i;
      }
      if (n)
        return t(r);
    }
    return e(r);
  }
  getValue() {
    if (!this.eInput.validity.valid)
      return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, EG = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: K0
}, cP = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
], q0 = class {
  constructor(e, t, r) {
    this.localeService = e, this.optionsFactory = t, this.valueFormatter = r;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, r = this.localeService.getLocaleTextFunc();
    if (t) {
      const n = e, o = (n.conditions ?? []).map((a) => this.getModelAsString(a)), s = n.operator === "AND" ? "andCondition" : "orCondition";
      return o.join(
        ` ${r(s, iP[s])} `
      );
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return r(e.type, e.type);
      {
        const n = e, i = this.optionsFactory.getCustomOption(n.type), { displayKey: o, displayName: s, numberOfInputs: a } = i || {};
        return o && s && a === 0 ? (r(o, s), s) : this.conditionToString(n, i);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    return this.valueFormatter ? this.valueFormatter(e ?? null) ?? "" : String(e);
  }
}, uP = class extends q0 {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : e.filter != null ? this.formatValue(e.filter) : `${e.type}`;
  }
};
function Em(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var PG = class extends aP {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  refresh(e) {
    return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern ? !1 : super.refresh(e);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [this.processValue(t), this.processValue(r)].slice(0, this.getNumberOfInputs(n));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new uP(
      this.localeService,
      this.optionsFactory,
      this.numberFilterParams.numberFormatter
    );
  }
  getDefaultFilterOptions() {
    return cP;
  }
  setElementValue(e, t, r) {
    const n = !r && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(t ?? null) : t;
    super.setElementValue(e, n);
  }
  createValueElement() {
    const e = Em(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), Vn(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, r, n) {
    const i = this.createManagedBean(
      n ? new ms({ allowedCharPattern: n }) : new K0()
    );
    i.addCssClass(`ag-filter-${r}`), i.addCssClass("ag-filter-filter"), t.push(i), e.appendChild(i.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(this.processValue(this.stringToFloat(r.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = Fi(e);
    return t != null && t.trim() === "" && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValues(e);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}, dP = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], hP = class extends q0 {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
};
function gP(e) {
  const t = e && e.trim();
  return t === "" ? e : t;
}
var AG = class extends sP {
  constructor() {
    super("textFilter"), this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: r }) => {
      if (r == null)
        return !1;
      switch (e) {
        case "contains":
          return t.indexOf(r) >= 0;
        case "notContains":
          return t.indexOf(r) < 0;
        case "equals":
          return t === r;
        case "notEqual":
          return t != r;
        case "startsWith":
          return t.indexOf(r) === 0;
        case "endsWith": {
          const n = t.lastIndexOf(r);
          return n >= 0 && n === t.length - r.length;
        }
        default:
          return !1;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [];
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new hP(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator;
    return e ? (ie("textCustomComparator is deprecated, use textMatcher instead."), ({ filterOption: t, value: r, filterText: n }) => e(t, r, n)) : this.textFilterParams.textMatcher || this.defaultMatcher;
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValuesWithSideEffects(e, !0);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1);
  }
  getValuesWithSideEffects(e, t) {
    const r = [];
    return this.forEachPositionInput(e, (n, i, o, s) => {
      if (i < s) {
        let a = Fi(n.getValue());
        t && this.textFilterParams.trimInput && (a = gP(a) ?? null, n.setValue(a, !0)), r.push(a);
      }
    }), r;
  }
  getDefaultFilterOptions() {
    return dP;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), Vn(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, r) {
    const n = this.createManagedBean(new ms());
    n.addCssClass(`ag-filter-${r}`), n.addCssClass("ag-filter-filter"), t.push(n), e.appendChild(n.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [t || null, r || null].slice(0, this.getNumberOfInputs(n));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, r, n) {
    const i = e.map((f) => this.formatter(f)) || [], o = this.formatter(t), { api: s, colDef: a, column: l, context: u, textFormatter: d } = this.textFilterParams;
    if (r.type === "blank")
      return this.isBlank(t);
    if (r.type === "notBlank")
      return !this.isBlank(t);
    const h = {
      api: s,
      colDef: a,
      column: l,
      context: u,
      node: n.node,
      data: n.data,
      filterOption: r.type,
      value: o,
      textFormatter: d
    };
    return i.some((f) => this.matcher({ ...h, filterText: f }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
};
function fP(e) {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = parseInt(e);
    return isNaN(t) ? void 0 : t;
  }
}
function Yn(e, t = Number.MAX_VALUE) {
  return (r) => {
    const n = fP(r);
    if (!(n == null || n < e || n > t))
      return n;
  };
}
function jl(e, t) {
  return e.toString().padStart(t, "0");
}
function FG(e, t) {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push(n);
  return r;
}
function MG(e, t, r) {
  return typeof e != "number" ? "" : e.toString().replace(".", r).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`);
}
function Rn(e, t = !0, r = "-") {
  if (!e)
    return null;
  let n = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((i) => jl(i, 2)).join(r);
  return t && (n += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((i) => jl(i, 2)).join(":")), n;
}
var wp = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function Ul(e, t = "YYYY-MM-DD") {
  const r = jl(e.getFullYear(), 4), n = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], i = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], o = {
    YYYY: () => r.slice(r.length - 4, r.length),
    YY: () => r.slice(r.length - 2, r.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => n[e.getMonth()],
    MMM: () => n[e.getMonth()].slice(0, 3),
    MM: () => jl(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${wp(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${wp(e.getDate())}`,
    DD: () => jl(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => i[e.getDay()],
    ddd: () => i[e.getDay()].slice(0, 3),
    dd: () => i[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${wp(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, s = new RegExp(Object.keys(o).join("|"), "g");
  return t.replace(s, (a) => a in o ? o[a]() : a);
}
function Br(e) {
  if (!e)
    return null;
  const [t, r] = e.split(" ");
  if (!t)
    return null;
  const n = t.split("-").map((h) => parseInt(h, 10));
  if (n.filter((h) => !isNaN(h)).length !== 3)
    return null;
  const [i, o, s] = n, a = new Date(i, o - 1, s);
  if (a.getFullYear() !== i || a.getMonth() !== o - 1 || a.getDate() !== s)
    return null;
  if (!r || r === "00:00:00")
    return a;
  const [l, u, d] = r.split(":").map((h) => parseInt(h, 10));
  return l >= 0 && l < 24 && a.setHours(l), u >= 0 && u < 60 && a.setMinutes(u), d >= 0 && d < 60 && a.setSeconds(d), a;
}
var pP = class {
  constructor(e, t, r, n, i) {
    this.alive = !0, this.context = e, this.eParent = n, t.getDateCompDetails(r).newAgStackInstance().then((a) => {
      if (!this.alive) {
        e.destroyBean(a);
        return;
      }
      this.dateComp = a, a && (n.appendChild(a.getGui()), a.afterGuiAttached && a.afterGuiAttached(), this.tempValue && a.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled), i == null || i(this));
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    Tt(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  updateParams(e) {
    var r, n;
    let t = !1;
    (r = this.dateComp) != null && r.refresh && typeof this.dateComp.refresh == "function" && this.dateComp.refresh(e) !== null && (t = !0), !t && ((n = this.dateComp) != null && n.onParamsUpdated) && typeof this.dateComp.onParamsUpdated == "function" && this.dateComp.onParamsUpdated(e) !== null && ie("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}, mP = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
], vP = class extends q0 {
  constructor(e, t, r) {
    super(t, r), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: r } = e, { numberOfInputs: n } = t || {}, i = r == "inRange" || n === 2, o = Br(e.dateFrom), s = Br(e.dateTo), a = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (i) {
      const l = o !== null ? Ul(o, a) : "null", u = s !== null ? Ul(s, a) : "null";
      return `${l}-${u}`;
    }
    return o != null ? Ul(o, a) : `${r}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, fS = 1e3, pS = 1 / 0, TG = class extends aP {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = fS, this.maxValidYear = pS, this.minValidDate = null, this.maxValidDate = null;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: r, type: n } = e || {};
    return [
      t && Br(t) || null,
      r && Br(r) || null
    ].slice(0, this.getNumberOfInputs(n));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(e, t) {
    const r = t;
    return t == null || r < e ? -1 : r > e ? 1 : 0;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (r, n) => {
      if (e[r] != null)
        if (isNaN(e[r]))
          ie(`DateFilter ${r} is not a number`);
        else
          return e[r] == null ? n : Number(e[r]);
      return n;
    };
    this.minValidYear = t("minValidYear", fS), this.maxValidYear = t("maxValidYear", pS), this.minValidYear > this.maxValidYear && ie("DateFilter minValidYear should be <= maxValidYear"), e.minValidDate ? this.minValidDate = e.minValidDate instanceof Date ? e.minValidDate : Br(e.minValidDate) : this.minValidDate = null, e.maxValidDate ? this.maxValidDate = e.maxValidDate instanceof Date ? e.maxValidDate : Br(e.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && ie("DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new vP(
      this.dateFilterParams,
      this.localeService,
      this.optionsFactory
    );
  }
  createDateCompWrapper(e) {
    const t = new pP(
      this.context,
      this.userComponentFactory,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams
      },
      e
    );
    return this.addDestroyFunc(() => t.destroy()), t;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return mP;
  }
  createValueElement() {
    const t = zt(this.gos).createElement("div");
    return t.classList.add("ag-filter-body"), this.createFromToElement(t, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(t, this.eConditionPanelsTo, this.dateConditionToComps, "to"), t;
  }
  createFromToElement(e, t, r, n) {
    const o = zt(this.gos).createElement("div");
    o.classList.add(`ag-filter-${n}`), o.classList.add(`ag-filter-date-${n}`), t.push(o), e.appendChild(o), r.push(this.createDateCompWrapper(o));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => i.destroy());
  }
  isValidDateValue(e) {
    if (e === null)
      return !1;
    if (this.minValidDate) {
      if (e < this.minValidDate)
        return !1;
    } else if (e.getUTCFullYear() < this.minValidYear)
      return !1;
    if (this.maxValidDate) {
      if (e > this.maxValidDate)
        return !1;
    } else if (e.getUTCFullYear() > this.maxValidYear)
      return !1;
    return !0;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    let t = !0;
    return this.forEachInput((r, n, i, o) => {
      i !== e || !t || n >= o || (t = t && this.isValidDateValue(r.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {}, n = this.getValues(e);
    return n.length > 0 && (r.dateFrom = Rn(n[0])), n.length > 1 && (r.dateTo = Rn(n[1])), {
      dateFrom: null,
      dateTo: null,
      filterType: this.getFilterType(),
      type: t,
      ...r
    };
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), r = e("ariaFilterValue", "Filter Value");
    this.forEachInput((n) => {
      n.setInputPlaceholder(t), n.setInputAriaLabel(r);
    });
  }
  getInputs(e) {
    return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(r.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, Y0 = class extends J {
  constructor(e, t, r, n) {
    super(), this.columnOrGroup = e, this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = n, this.beans = r;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? Ye(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const e = this.beans.gos.get("suppressColumnMoveAnimation"), t = de(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), r = e.getOldLeft(), n = this.modifyLeftForPrintLayout(e, r), i = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(n), this.actualLeft = i, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === i && this.setLeft(i);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!ar(this.beans.gos, "print") || e.getPinned() === "left")
      return t;
    const n = this.beans.visibleColsService.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const i = this.beans.visibleColsService.getBodyContainerWidth();
      return n + i + t;
    }
    return n + t;
  }
  setLeft(e) {
    if (de(e) && (this.eCell.style.left = `${e}px`), $t(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && YB(this.ariaEl, t.length);
    }
  }
}, DG = "ag-column-first", OG = "ag-column-last";
function yP(e, t, r, n) {
  return Ke(e) ? [] : kG(e.headerClass, e, t, r, n);
}
function CP(e, t, r) {
  e.addOrRemoveCssClass(DG, r.isColAtEdge(t, "first")), e.addOrRemoveCssClass(OG, r.isColAtEdge(t, "last"));
}
function IG(e, t, r, n) {
  return t.addGridCommonParams({
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: r,
    columnGroup: n
  });
}
function kG(e, t, r, n, i) {
  if (Ke(e))
    return [];
  let o;
  if (typeof e == "function") {
    const s = IG(t, r, n, i);
    o = e(s);
  } else
    o = e;
  return typeof o == "string" ? [o] : Array.isArray(o) ? [...o] : [];
}
var LG = 0, wP = class bP extends J {
  constructor(t, r, n) {
    super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = t, this.parentRowCtrl = n, this.beans = r, this.instanceId = t.getUniqueId() + "-" + LG++;
  }
  wireBeans(t) {
    this.pinnedWidthService = t.pinnedWidthService, this.focusService = t.focusService, this.userComponentFactory = t.userComponentFactory, this.ctrlsService = t.ctrlsService, this.dragAndDropService = t.dragAndDropService, this.menuService = t.menuService;
  }
  postConstruct() {
    const t = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], t), this.addManagedEventListeners({
      overlayExclusiveChanged: t
    });
  }
  shouldStopEventPropagation(t) {
    const { headerRowIndex: r, column: n } = this.focusService.getFocusedHeader();
    return SG(this.gos, t, r, n);
  }
  getWrapperHasFocus() {
    return Dt(this.gos) === this.eGui;
  }
  setGui(t, r) {
    this.eGui = t, this.addDomData(r), r.addManagedListeners(this.beans.eventService, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), r.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onGuiFocus() {
    this.eventService.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(t) {
    const { wrapperElement: r, checkMeasuringCallback: n, compBean: i } = t, { animationFrameService: o, resizeObserverService: s, columnModel: a, gos: l } = this.beans, u = (C) => {
      if (!this.isAlive() || !i.isAlive())
        return;
      const { paddingTop: v, paddingBottom: w, borderBottomWidth: R, borderTopWidth: b } = fs(this.getGui()), P = v + w + R + b, E = r.offsetHeight + P;
      if (C < 5) {
        const A = zt(l), M = !A || !A.contains(r), I = E == 0;
        if (M || I) {
          o.requestAnimationFrame(() => u(C + 1));
          return;
        }
      }
      a.setColHeaderHeight(this.column, E);
    };
    let d = !1, h;
    const f = () => {
      const C = this.column.isAutoHeaderHeight();
      C && !d && p(), !C && d && y();
    }, p = () => {
      d = !0, u(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), h = s.observeResize(r, () => u(0));
    }, y = () => {
      d = !1, h && h(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), h = void 0;
    };
    f(), i.addDestroyFunc(() => y()), i.addManagedListeners(this.column, { widthChanged: () => d && u(0) }), i.addManagedEventListeners({
      sortChanged: () => {
        d && window.setTimeout(() => u(0));
      }
    }), n && n(f);
  }
  onDisplayedColumnsChanged() {
    const { comp: t, column: r, beans: n, eGui: i } = this;
    !t || !r || !i || (CP(t, r, n.visibleColsService), kE(i, n.visibleColsService.getAriaColIndex(r)));
  }
  addResizeAndMoveKeyboardListeners(t) {
    this.resizeFeature && t.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const t = this.focusService.isHeaderFocusSuppressed();
    this.eGui && xn(this.eGui, "tabindex", t ? null : "-1");
  }
  onGuiKeyDown(t) {
    var s;
    const r = Dt(this.gos), n = t.key === V.LEFT || t.key === V.RIGHT;
    if (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    r !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !t.shiftKey && !t.altKey || ((this.isResizing || n) && (t.preventDefault(), t.stopImmediatePropagation()), !n))
      return;
    const i = t.key === V.LEFT !== this.gos.get("enableRtl"), o = ZE[i ? "Left" : "Right"];
    if (t.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const a = this.getViewportAdjustedResizeDiff(t);
      this.resizeHeader(a, t.shiftKey), (s = this.resizeFeature) == null || s.toggleColumnResizing(!0);
    } else
      this.moveHeader(o);
  }
  getViewportAdjustedResizeDiff(t) {
    let r = this.getResizeDiff(t);
    if (this.column.getPinned()) {
      const i = this.pinnedWidthService.getPinnedLeftWidth(), o = this.pinnedWidthService.getPinnedRightWidth(), s = jc(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (i + o + r > s)
        if (s > i + o)
          r = s - i - o;
        else
          return 0;
    }
    return r;
  }
  getResizeDiff(t) {
    let r = t.key === V.LEFT !== this.gos.get("enableRtl");
    const n = this.column.getPinned(), i = this.gos.get("enableRtl");
    return n && i !== (n === "right") && (r = !r), (r ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var t;
      (t = this.resizeFeature) == null || t.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(t) {
    const r = this.getWrapperHasFocus();
    switch (t.key) {
      case V.PAGE_DOWN:
      case V.PAGE_UP:
      case V.PAGE_HOME:
      case V.PAGE_END:
        r && t.preventDefault();
    }
  }
  addDomData(t) {
    const r = bP.DOM_DATA_KEY_HEADER_CTRL;
    as(this.gos, this.eGui, r, this), t.addDestroyFunc(() => as(this.gos, this.eGui, r, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(t) {
    return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
  removeDragSource() {
    this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(t, r, n) {
    const i = t ?? r;
    this.gos.get("preventDefaultOnContextMenu") && i.preventDefault(), this.menuService.isHeaderContextMenuEnabled(n) && this.menuService.showHeaderContextMenu(n, t, r), this.dispatchColumnMouseEvent("columnHeaderContextMenu", n);
  }
  dispatchColumnMouseEvent(t, r) {
    this.eventService.dispatchEvent({
      type: t,
      column: r
    });
  }
  clearComponent() {
    this.removeDragSource(), this.resizeFeature = null, this.comp = null, this.eGui = null;
  }
  destroy() {
    super.destroy(), this.column = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null;
  }
};
wP.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var Jh = wP, J0 = class extends J {
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListeners(this.element, {
      mouseout: this.onMouseOut.bind(this),
      mouseover: this.onMouseOver.bind(this)
    });
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
}, _G = class extends Jh {
  constructor(e, t, r) {
    super(e, t, r), this.iconCreated = !1, this.column = e;
  }
  setComp(e, t, r, n, i) {
    this.comp = e, i = Vc(this, this.beans.context, i), this.eButtonShowMainFilter = r, this.eFloatingFilterBody = n, this.setGui(t, i), this.setupActive(), this.setupWidth(i), this.setupLeft(i), this.setupHover(i), this.setupFocus(i), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(i), this.setupUi(), i.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(i), i.addManagedListeners(this.column, { colDefChanged: () => this.onColDefChanged(i) }), i.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.clearComponent();
    });
  }
  // empty abstract method
  resizeHeader() {
  }
  // empty abstract method
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, r = !!e.floatingFilter;
    this.active = t && r;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = tn("filter", this.gos, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus(e) {
    e.createManagedBean(
      new ps(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    oa(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (Dt(this.gos) === this.eGui)
      return;
    const n = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (n) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), n.focus();
      return;
    }
    const i = this.findNextColumnWithFloatingFilter(e.shiftKey);
    i && this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: i
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleColsService;
    let r = this.column;
    do
      if (r = e ? t.getColBefore(r) : t.getColAfter(r), !r)
        break;
    while (!r.getColDef().filter || !r.getColDef().floatingFilter);
    return r;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case V.UP:
      case V.DOWN:
        t || e.preventDefault();
      case V.LEFT:
      case V.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case V.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case V.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const r = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), n = !!e.relatedTarget && Xs(e.relatedTarget, "ag-floating-filter");
    if (r && n && e.target === this.eGui) {
      const o = this.lastFocusEvent, s = !!(o && o.key === V.TAB);
      if (o && s) {
        const a = o.shiftKey;
        this.focusService.focusInto(this.eGui, a);
      }
    }
    const i = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(i, this.column);
  }
  setupHover(e) {
    e.createManagedBean(new J0([this.column], this.eGui));
    const t = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const r = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", r);
    };
    e.addManagedEventListeners({ columnHoverChanged: t }), t();
  }
  setupLeft(e) {
    const t = new Y0(this.column, this.eGui, this.beans);
    e.createManagedBean(t);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.filterManager) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuService.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter(e) {
    if (!this.active)
      return;
    const { filterManager: t } = this.beans, r = (n) => {
      if ((n == null ? void 0 : n.source) === "filterDestroyed" && !this.isAlive())
        return;
      const i = this.comp.getFloatingFilterComp();
      i && i.then((o) => {
        if (o) {
          const s = t == null ? void 0 : t.getCurrentFloatingFilterParentModel(this.column), a = n ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...n,
            columns: n.columns ?? [],
            source: n.source === "api" ? "api" : "columnFilter"
          } : null;
          o.onParentModelChanged(s, a);
        }
      });
    };
    [this.destroySyncListener] = e.addManagedListeners(this.column, { filterChanged: r }), t != null && t.isFilterActive(this.column) && r(null);
  }
  setupWidth(e) {
    const t = () => {
      const r = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(r);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupFilterChangedListener(e) {
    this.active && ([this.destroyFilterChangedListener] = e.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged(e) {
    var o;
    const t = this.active;
    this.setupActive();
    const r = !t && this.active;
    t && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const n = this.active ? (o = this.beans.filterManager) == null ? void 0 : o.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, i = this.comp.getFloatingFilterComp();
    !i || !n ? this.updateCompDetails(e, n, r) : i.then((s) => {
      var a;
      !s || (a = this.beans.filterManager) != null && a.areFilterCompsDifferent(this.userCompDetails ?? null, n) ? this.updateCompDetails(e, n, r) : this.updateFloatingFilterParams(n);
    });
  }
  updateCompDetails(e, t, r) {
    this.isAlive() && (this.setCompDetails(t), this.setupFilterButton(), this.setupUi(), r && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)));
  }
  updateFloatingFilterParams(e) {
    var r;
    if (!e)
      return;
    const t = e.params;
    (r = this.comp.getFloatingFilterComp()) == null || r.then((n) => {
      let i = !1;
      n != null && n.refresh && typeof n.refresh == "function" && n.refresh(t) !== null && (i = !0), !i && (n != null && n.onParamsUpdated) && typeof n.onParamsUpdated == "function" && n.onParamsUpdated(t) !== null && ie("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
    });
  }
  destroy() {
    super.destroy(), this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
};
var Te = "32.3.5";
function zG(e) {
  var t, r;
  return !!((t = e.filterManager) != null && t.isColumnFilterPresent()) || !!((r = e.filterManager) != null && r.isAggregateFilterPresent());
}
function NG(e, t, r) {
  var n;
  return (n = e.filterManager) == null ? void 0 : n.getFilterInstance(t, r);
}
function BG(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function GG(e, t) {
  var n;
  const r = e.columnModel.getColDefCol(t);
  if (r)
    return (n = e.filterManager) == null ? void 0 : n.destroyFilter(r, "api");
}
function HG(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var r;
    return (r = e.filterManager) == null ? void 0 : r.setFilterModel(t);
  });
}
function WG(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function VG(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterModel(t)) ?? null;
}
function $G(e, t, r) {
  var n;
  return ((n = e.filterManager) == null ? void 0 : n.setColumnFilterModel(t, r)) ?? Promise.resolve();
}
function jG(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    tt(`column '${t}' not found`);
    return;
  }
  e.menuService.showFilterMenu({
    column: r,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
function UG(e, t, r) {
  if (t == null)
    return null;
  let n = null;
  const { compName: i, jsComp: o, fwComp: s } = XE.getCompKeys(e, t, $0);
  return i ? n = {
    set: "agSetColumnFloatingFilter",
    agSetColumnFilter: "agSetColumnFloatingFilter",
    multi: "agMultiColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    group: "agGroupColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    number: "agNumberColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    date: "agDateColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    text: "agTextColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[i] : o == null && s == null && t.filter === !0 && (n = r()), n;
}
var mS = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, vS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], KG = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnFilterService", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.userComponentFactory = e.userComponentFactory, this.rowRenderer = e.rowRenderer, this.dataTypeService = e.dataTypeService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    var e, t;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      rowDataUpdated: () => this.onNewRowsLoaded("rowDataUpdated"),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.initialFilterModel = {
      ...((t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) ?? {}
    };
  }
  setFilterModel(e, t = "api") {
    var i;
    if ((i = this.dataTypeService) != null && i.isPendingInference()) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const r = [], n = this.getFilterModel(!0);
    if (e) {
      const o = new Set(Object.keys(e));
      this.allColumnFilters.forEach((s, a) => {
        const l = e[a];
        r.push(this.setModelOnFilterWrapper(s.filterPromise, l)), o.delete(a);
      }), o.forEach((s) => {
        const a = this.columnModel.getColDefCol(s) || this.columnModel.getCol(s);
        if (!a) {
          ie("setFilterModel() - no column found for colId: " + s);
          return;
        }
        if (!a.isFilterAllowed()) {
          ie("setFilterModel() - unable to fully apply model, filtering disabled for colId: " + s);
          return;
        }
        const l = this.getOrCreateFilterWrapper(a);
        if (!l) {
          ie(
            "setFilterModel() - unable to fully apply model, unable to create filter for colId: " + s
          );
          return;
        }
        r.push(this.setModelOnFilterWrapper(l.filterPromise, e[s]));
      });
    } else
      this.allColumnFilters.forEach((o) => {
        r.push(this.setModelOnFilterWrapper(o.filterPromise, null));
      });
    _t.all(r).then(() => {
      var a;
      const o = this.getFilterModel(!0), s = [];
      this.allColumnFilters.forEach((l, u) => {
        const d = n ? n[u] : null, h = o ? o[u] : null;
        ec(d, h) || s.push(l.column);
      }), s.length > 0 && ((a = this.filterManager) == null || a.onFilterChanged({ columns: s, source: t }));
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new _t((r) => {
      e.then((n) => {
        typeof n.setModel != "function" && (ie("filter missing setModel method, which is needed for setFilterModel"), r()), (n.setModel(t) || _t.resolve()).then(() => r());
      });
    });
  }
  getFilterModel(e) {
    const t = {}, { allColumnFilters: r, initialFilterModel: n } = this;
    return r.forEach((i, o) => {
      const s = this.getModelFromFilterWrapper(i);
      de(s) && (t[o] = s);
    }), e || Object.entries(n).forEach(([i, o]) => {
      var s;
      de(o) && !r.has(i) && ((s = this.columnModel.getCol(i)) != null && s.isFilterAllowed()) && (t[i] = o);
    }), t;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (ie("filter API missing getModel method, which is needed for getFilterModel"), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    return this.allColumnFilters.size ? (this.allColumnFilters.forEach(
      (e) => this.disposeFilterWrapper(e, "advancedFilterEnabled")
    ), !0) : !1;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  updateActiveFilters() {
    const e = (o) => o ? o.isFilterActive ? o.isFilterActive() : (ie("Filter is missing isFilterActive() method"), !1) : !1, t = !!fm(this.gos), r = (o) => {
      if (!o.isPrimary())
        return !0;
      const a = !this.columnModel.isPivotActive();
      return !o.isValueActive() || !a ? !1 : this.columnModel.isPivotMode() ? !0 : t;
    }, n = [], i = [];
    return this.forEachColumnFilter((o, s) => {
      e(o) && (r(s.column) ? n.push(o) : i.push(o));
    }).then(() => {
      this.activeAggregateFilters = n, this.activeColumnFilters = i;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter(
      (r, n) => n.column.setFilterActive(r.isFilterActive(), e, t)
    );
  }
  forEachColumnFilter(e) {
    return _t.all(
      Array.from(this.allColumnFilters.values()).map(
        (t) => t.filterPromise.then((r) => e(r, t))
      )
    );
  }
  doColumnFiltersPass(e, t, r) {
    const { data: n, aggData: i } = e, o = r ? this.activeAggregateFilters : this.activeColumnFilters, s = r ? i : n;
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function")
          throw new Error("Filter is missing method doesFilterPass");
        if (!l.doesFilterPass({ node: e, data: s }))
          return !1;
      }
    }
    return !0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const t = () => {
      var r;
      return (r = this.filterManager) == null ? void 0 : r.onFilterChanged(e);
    };
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: r } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", r).then(() => {
        this.allColumnFilters.forEach((n) => {
          n.filterPromise && n.filterPromise.then((i) => {
            i && i !== t && i.onAnyFilterChanged && i.onAnyFilterChanged();
          });
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      t.onNewRowsLoaded && t.onNewRowsLoaded();
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 })).then(() => this.updateActiveFilters());
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, !0);
  }
  createGetValue(e) {
    return (t, r) => {
      const n = r ? this.columnModel.getCol(r) : e;
      return n ? this.valueService.getValue(n, t, !0) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed())
      return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    var r;
    let t;
    if (dp(this.gos))
      t = "agSetColumnFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    var r;
    let t;
    if (dp(this.gos))
      t = "agSetColumnFloatingFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFloatingFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const r = this.getDefaultFilter(e), n = e.getColDef();
    let i;
    const o = {
      ...this.createFilterParams(e, n),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(i, e)(),
      filterChangedCallback: (a) => this.filterChangedCallbackFactory(i, e)(a),
      doesRowPassOtherFilter: (a) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(i, a) : !0
    }, s = this.userComponentFactory.getFilterDetails(n, o, r);
    return s ? {
      filterPromise: () => {
        const a = s.newAgStackInstance();
        return a != null && a.then((l) => {
          i = l, t && (t.filter = l);
        }), a;
      },
      compDetails: s
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({
      column: e,
      colDef: EE(t),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(e),
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e) {
    const t = {
      column: e,
      filterPromise: null,
      compiledElement: null,
      compDetails: null
    }, { filterPromise: r, compDetails: n } = this.createFilterInstance(e, t);
    return t.filterPromise = (r == null ? void 0 : r()) ?? null, t.compDetails = n, t;
  }
  onColumnsChanged() {
    var r;
    const e = [];
    this.allColumnFilters.forEach((n, i) => {
      let o;
      n.column.isPrimary() ? o = this.columnModel.getColDefCol(i) : o = this.columnModel.getCol(i), !(o && o === n.column) && (e.push(n.column), this.disposeFilterWrapper(n, "columnChanged"), this.disposeColumnListener(i));
    });
    const t = e.every(
      (n) => n.getColDef().filter === "agGroupColumnFilter"
    );
    e.length > 0 && !t ? (r = this.filterManager) == null || r.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    const e = this.columnModel.getAutoCols();
    e == null || e.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t);
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const { filter: r } = this.allColumnFilters.get(e.getColId()) ?? {};
    return r && typeof (r == null ? void 0 : r.isFilterAllowed) == "function" ? r.isFilterAllowed() : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const r = (l) => {
      var d;
      const u = (d = this.getOrCreateFilterWrapper(e)) == null ? void 0 : d.filterPromise;
      u != null && u.then((h) => {
        l($l(h));
      });
    }, n = e.getColDef(), i = {
      ...this.createFilterParams(e, n),
      filterChangedCallback: () => r(
        (l) => this.filterChangedCallbackFactory(l, e)()
      )
    }, o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(
      n,
      $0,
      i
    );
    let s = UG(
      this.frameworkOverrides,
      n,
      () => this.getDefaultFloatingFilter(e)
    );
    s == null && (s = "agReadOnlyFloatingFilter");
    const a = {
      column: e,
      filterParams: o,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: r,
      showParentFilter: t,
      suppressFilterButton: !1
      // This one might be overridden from the colDef
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(n, a, s);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var i;
    const r = e.getColId(), n = this.allColumnFilters.get(r);
    this.disposeColumnListener(r), delete this.initialFilterModel[r], n && (this.disposeFilterWrapper(n, t), (i = this.filterManager) == null || i.onFilterChanged({
      columns: [e],
      source: "api"
    }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((r) => {
      this.destroyBean(r), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId()), this.eventService.dispatchEvent({
        type: "filterDestroyed",
        source: t,
        column: e.column
      });
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      this.eventService.dispatchEvent({
        type: "filterModified",
        column: t,
        filterInstance: e
      });
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (r) => {
      const n = (r == null ? void 0 : r.source) ?? "columnFilter", i = {
        filter: e,
        additionalEventAttributes: r,
        columns: [t],
        source: n
      };
      this.callOnFilterChangedOutsideRenderCycle(i);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const r = t.column, { compDetails: n } = r.isFilterAllowed() ? this.createFilterInstance(r) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, n)) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    const i = r.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    t.filterPromise.then((o) => {
      (o != null && o.refresh ? o.refresh({
        ...this.createFilterParams(r, r.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(o, r),
        filterChangedCallback: this.filterChangedCallbackFactory(o, r),
        doesRowPassOtherFilter: (a) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(o, a) : !0,
        ...i
      }) : !0) === !1 && this.destroyFilter(r, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const r = e.getColId();
    this.allColumnFilters.set(r, t), this.allColumnListeners.set(
      r,
      this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(r) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: r } = e, { componentClass: n } = t;
    return !(r === n || // react hooks returns new wrappers, so check nested render method
    (r == null ? void 0 : r.render) && (n == null ? void 0 : n.render) && r.render === n.render);
  }
  hasFloatingFilters() {
    return this.columnModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e, t) {
    t && this.getFilterInstanceImpl(e).then((r) => {
      const n = $l(r);
      t(n);
    });
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((r) => {
        t($l(r));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var n;
    const t = this.columnModel.getColDefCol(e);
    return t ? ((n = this.getOrCreateFilterWrapper(t)) == null ? void 0 : n.filterPromise) ?? _t.resolve(null) : _t.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: r }) => {
      this.setColumnFilterModel(e, t).then(() => r());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    var o;
    if ((o = this.dataTypeService) != null && o.isPendingInference()) {
      let s = () => {
      };
      const a = new Promise((l) => {
        s = l;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: s }), a;
    }
    const r = this.columnModel.getColDefCol(e), n = r ? this.getOrCreateFilterWrapper(r) : null;
    return n ? ((s) => new Promise((a) => {
      s.then((l) => a(l));
    }))(this.setModelOnFilterWrapper(n.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.columnModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  setColDefPropertiesForDataType(e, t, r) {
    const n = dp(this.gos), i = this.localeService.getLocaleTextFunc(), o = (s) => {
      const { filterParams: a } = e;
      e.filterParams = typeof a == "object" ? {
        ...a,
        ...s
      } : s;
    };
    switch (t.baseDataType) {
      case "number": {
        n && o({
          comparator: (s, a) => {
            const l = s == null ? 0 : parseInt(s), u = a == null ? 0 : parseInt(a);
            return l === u ? 0 : l > u ? 1 : -1;
          }
        });
        break;
      }
      case "boolean": {
        o(n ? {
          valueFormatter: (s) => de(s.value) ? i(String(s.value), s.value ? "True" : "False") : i("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (s, a) => a,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (s, a) => a === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        n && o({
          valueFormatter: (s) => {
            const a = r(s);
            return de(a) ? a : i("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (s, a) => {
            if (a === 1 && s != null) {
              const l = vS[Number(s) - 1];
              return i(l, mS[l]);
            }
            return s ?? i("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        const s = t.dateParser;
        o(n ? {
          valueFormatter: (a) => {
            const l = r(a);
            return de(l) ? l : i("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (a) => {
            const l = s(a ?? void 0);
            return l ? [String(l.getFullYear()), String(l.getMonth() + 1), String(l.getDate())] : null;
          },
          treeListFormatter: (a, l) => {
            if (l === 1 && a != null) {
              const u = vS[Number(a) - 1];
              return i(u, mS[u]);
            }
            return a ?? i("blanks", "(Blanks)");
          }
        } : {
          comparator: (a, l) => {
            const u = s(l);
            return l == null || u < a ? -1 : u > a ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        n ? o({
          valueFormatter: (s) => {
            const a = r(s);
            return de(a) ? a : i("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (s) => r({
          column: s.column,
          node: s.node,
          value: this.valueService.getValue(s.column, s.node)
        });
        break;
      }
    }
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function qG(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function YG(e, t = "api") {
  var r;
  (r = e.filterManager) == null || r.onFilterChanged({ source: t });
}
var JG = class extends vt {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [Yh]
    ), this.eFloatingFilterText = Fe;
  }
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${r("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const r = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(r);
      }
    });
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.init(e);
  }
}, SP = class extends vt {
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  getDefaultDebounceMs() {
    return 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let r;
    t ? r = e.conditions[0] : r = e, this.lastType = r.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const r = e;
    return this.isTypeEditable(r.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    this.optionsFactory = new oP(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
    const r = this.isTypeEditable(this.optionsFactory.getDefaultOption());
    this.setEditable(r);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: r } = t || {};
    return r == null || r == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    return `${t} ${r("ariaFilterInput", "Filter Input")}`;
  }
}, XG = class extends SP {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
      [Yh]
    ), this.eReadOnlyText = Fe, this.eDateWrapper = Fe;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  getDefaultFilterOptions() {
    return mP;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new vP(
      this.filterParams,
      this.localeService,
      this.optionsFactory
    );
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({
      optionsFactory: this.optionsFactory,
      dateFilterParams: this.filterParams
    }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      if (e) {
        const r = e;
        this.dateComp.setDate(Br(r.dateFrom));
      } else
        this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    Tt(this.eDateWrapper, e), Tt(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Rn(e);
    this.params.parentFilterInstance((r) => {
      if (r) {
        const n = Br(t);
        r.onFloatingFilterChanged(this.getLastType() || null, n);
      }
    });
  }
  getDateComponentParams() {
    const e = j0(this.params.filterParams, this.getDefaultDebounceMs());
    return {
      onDateChanged: Ar(this.onDateChanged.bind(this), e),
      filterParams: this.params.column.getColDef().filterParams
    };
  }
  createDateComponent() {
    this.dateComp = new pP(
      this.context,
      this.userComponentFactory,
      this.getDateComponentParams(),
      this.eDateWrapper,
      (e) => {
        e.setInputAriaLabel(this.getAriaLabel(this.params));
      }
    ), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  updateDateComponent() {
    const e = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(e);
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
}, QG = class extends vt {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
      [Yh]
    ), this.eDateInput = Fe;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus();
      },
      input: (r) => {
        r.target === Dt(this.gos) && (this.eDateInput.isDisabled() || this.params.onDateChanged());
      }
    });
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), r = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = r && ai(), t.type = r ? "date" : "text";
    const { minValidYear: n, maxValidYear: i, minValidDate: o, maxValidDate: s } = e.filterParams || {};
    if (o && n && ie(
      "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."
    ), s && i && ie(
      "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."
    ), o && s) {
      const [a, l] = [o, s].map(
        (u) => u instanceof Date ? u : Br(u)
      );
      a && l && a.getTime() > l.getTime() && ie(
        "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate."
      );
    }
    o ? o instanceof Date ? t.min = Ul(o) : t.min = o : n && (t.min = `${n}-01-01`), s ? s instanceof Date ? t.max = Ul(s) : t.max = s : i && (t.max = `${i}-12-31`);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return Br(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Rn(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : L0() || _0() || ai() && LE() >= 14.1;
  }
}, xP = class extends J {
  constructor(e) {
    super(), this.params = e, this.eFloatingFilterTextInput = Fe, this.valueChangedListener = () => {
    };
  }
  setupGui(e) {
    var n;
    this.eFloatingFilterTextInput = this.createManagedBean(new ms((n = this.params) == null ? void 0 : n.config));
    const t = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t);
    const r = (i) => this.valueChangedListener(i);
    this.addManagedListeners(t, {
      input: r,
      keydown: r
    });
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  setAutoComplete(e) {
    this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, RP = class extends SP {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = Fe;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? !1;
    if (this.floatingFilterInputService.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = _d(this.params.filterParams), !this.isReadOnly()) {
      const r = j0(this.params.filterParams, this.getDefaultDebounceMs()), n = Ar(
        this.syncUpWithParentFilter.bind(this),
        r
      );
      this.floatingFilterInputService.setValueChangedListener(n);
    }
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const t = this.floatingFilterInputService.getValue();
    nn(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === V.ENTER;
    if (this.applyActive && !t)
      return;
    let r = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (r = gP(r), this.floatingFilterInputService.setValue(r, !0)), this.params.parentFilterInstance((n) => {
      n && n.onFloatingFilterChanged(this.getLastType() || null, r || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
}, ZG = class extends J {
  constructor() {
    super(...arguments), this.valueChangedListener = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new K0()), this.eFloatingFilterTextInput = this.createManagedBean(new ms()), this.eFloatingFilterTextInput.setDisabled(!0);
    const t = this.eFloatingFilterNumberInput.getGui(), r = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t), e.appendChild(r), this.setupListeners(t, (n) => this.valueChangedListener(n)), this.setupListeners(r, (n) => this.valueChangedListener(n));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, {
      input: t,
      keydown: t
    });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, e4 = class extends RP {
  init(e) {
    var t;
    super.init(e), this.filterModelFormatter = new uP(
      this.localeService,
      this.optionsFactory,
      (t = e.filterParams) == null ? void 0 : t.numberFormatter
    );
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    Em(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return cP;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = Em(e.filterParams), this.allowedCharPattern ? this.createManagedBean(
      new xP({
        config: { allowedCharPattern: this.allowedCharPattern }
      })
    ) : this.createManagedBean(new ZG());
  }
}, t4 = class extends RP {
  init(e) {
    super.init(e), this.filterModelFormatter = new hP(this.localeService, this.optionsFactory);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return dP;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new xP());
  }
};
function r4(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isQuickFilterPresent());
}
function n4(e) {
  return e.gos.get("quickFilterText");
}
function i4(e) {
  var t;
  (t = e.filterManager) == null || t.resetQuickFilterCache();
}
var o4 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "quickFilterService", this.quickFilter = null, this.quickFilterParts = null;
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.pivotResultColsService = e.pivotResultColsService;
  }
  postConstruct() {
    const e = this.resetQuickFilterCache.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: e,
      columnRowGroupChanged: e,
      columnVisible: () => {
        this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
      }
    }), this.addManagedPropertyListener("quickFilterText", (t) => this.setQuickFilter(t.currentValue)), this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onQuickFilterColumnConfigChanged()
    ), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(
      ["quickFilterMatcher", "quickFilterParser"],
      () => this.setQuickFilterParserAndMatcher()
    );
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshQuickFilterCols() {
    var i;
    const e = this.columnModel.isPivotMode(), t = this.columnModel.getAutoCols(), r = this.columnModel.getColDefCols();
    let n = (e && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? (i = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : i.list : r) ?? [];
    t && (n = n.concat(t)), this.colsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? n : n.filter((o) => o.isVisible() || o.isRowGroupActive());
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every(
      (r) => t ? this.doesRowPassQuickFilterCache(e, r) : this.doesRowPassQuickFilterNoCache(e, r)
    );
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setQuickFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseQuickFilter(e) {
    return de(e) ? At(this.gos) ? e.toUpperCase() : (ie("Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      ie(`Grid option quickFilterText only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setQuickFilterParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), r = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, r && (this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onQuickFilterColumnConfigChanged() {
    this.refreshQuickFilterCols(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.colsForQuickFilter.some((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      return de(n) && n.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilterMatcher(e, t) {
    let r;
    e ? (this.checkGenerateQuickFilterAggregateText(t), r = t.quickFilterAggregateText) : r = this.getQuickFilterAggregateText(t);
    const { quickFilterParts: n, matcher: i } = this;
    return i(n, r);
  }
  checkGenerateQuickFilterAggregateText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e));
  }
  getQuickFilterTextForColumn(e, t) {
    let r = this.valueService.getValue(e, t, !0);
    const n = e.getColDef();
    if (n.getQuickFilterText) {
      const i = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t.data,
        column: e,
        colDef: n
      });
      r = n.getQuickFilterText(i);
    }
    return de(r) ? r.toString().toUpperCase() : null;
  }
  getQuickFilterAggregateText(e) {
    const t = [];
    return this.colsForQuickFilter.forEach((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      de(n) && t.push(n);
    }), t.join(`
`);
  }
}, X0 = {
  version: Te,
  moduleName: "@ag-grid-community/filter-core",
  beans: [aG]
}, s4 = {
  version: Te,
  moduleName: "@ag-grid-community/filter-api",
  apiFunctions: {
    isAnyFilterPresent: qG,
    onFilterChanged: YG
  },
  dependantModules: [X0]
}, Q0 = {
  version: Te,
  moduleName: "@ag-grid-community/column-filter",
  beans: [KG],
  dependantModules: [X0]
}, a4 = {
  version: Te,
  moduleName: "@ag-grid-community/column-filter-api",
  apiFunctions: {
    isColumnFilterPresent: zG,
    getFilterInstance: NG,
    getColumnFilterInstance: BG,
    destroyFilter: GG,
    setFilterModel: HG,
    getFilterModel: WG,
    getColumnFilterModel: VG,
    setColumnFilterModel: $G,
    showColumnFilter: jG
  },
  dependantModules: [Q0, s4]
}, EP = {
  version: Te,
  moduleName: "@ag-grid-community/floating-filter-core",
  controllers: [{ name: "headerFilterCell", classImp: _G }],
  dependantModules: [Q0]
}, l4 = {
  version: Te,
  moduleName: "@ag-grid-community/read-only-floating-filter",
  userComponents: [{ name: "agReadOnlyFloatingFilter", classImp: JG }],
  dependantModules: [EP]
}, c4 = {
  version: Te,
  moduleName: "@ag-grid-community/simple-filter",
  dependantModules: [Q0],
  userComponents: [
    { name: "agTextColumnFilter", classImp: AG },
    { name: "agNumberColumnFilter", classImp: PG },
    { name: "agDateColumnFilter", classImp: TG },
    { name: "agDateInput", classImp: QG }
  ]
}, u4 = {
  version: Te,
  moduleName: "@ag-grid-community/simple-floating-filter",
  dependantModules: [c4, EP],
  userComponents: [
    { name: "agTextColumnFloatingFilter", classImp: t4 },
    { name: "agNumberColumnFloatingFilter", classImp: e4 },
    { name: "agDateColumnFloatingFilter", classImp: XG }
  ]
}, PP = {
  version: Te,
  moduleName: "@ag-grid-community/quick-filter-core",
  beans: [o4],
  dependantModules: [X0]
}, d4 = {
  version: Te,
  moduleName: "@ag-grid-community/quick-filter-api",
  apiFunctions: {
    isQuickFilterPresent: r4,
    getQuickFilter: n4,
    resetQuickFilter: i4
  },
  dependantModules: [PP]
}, h4 = {
  version: Te,
  moduleName: "@ag-grid-community/quick-filter",
  dependantModules: [PP, d4]
}, g4 = {
  version: Te,
  moduleName: "@ag-grid-community/filter",
  dependantModules: [
    u4,
    l4,
    h4,
    a4
  ]
}, Pm = /* @__PURE__ */ ((e) => (e.COLUMN_GROUP = "group", e.COLUMN = "column", e.FLOATING_FILTER = "filter", e))(Pm || {}), f4 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "headerNavigationService", this.currentHeaderRowWithoutSpan = -1;
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.headerPositionUtils = e.headerPositionUtils, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.visibleColService = e.visibleColsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (t) => {
      this.gridBodyCon = t.gridBodyCtrl;
    });
    const e = zt(this.gos);
    this.addManagedElementListeners(e, { mousedown: () => this.setCurrentHeaderRowWithoutSpan(-1) });
  }
  getHeaderRowCount() {
    var e;
    return ((e = this.ctrlsService.getHeaderRowContainerCtrl()) == null ? void 0 : e.getRowCount()) ?? 0;
  }
  getHeaderPositionForColumn(e, t) {
    let r;
    if (typeof e == "string" ? (r = this.columnModel.getCol(e), r || (r = this.visibleColService.getColumnGroup(e))) : r = e, !r)
      return null;
    const n = this.ctrlsService.getHeaderRowContainerCtrl(), i = n == null ? void 0 : n.getAllCtrls(), o = Ye(i || []).getType() === "filter", s = this.getHeaderRowCount() - 1;
    let a = -1, l = r;
    for (; l; )
      a++, l = l.getParent();
    let u = a;
    return t && o && u === s - 1 && u++, u === -1 ? null : {
      headerRowIndex: u,
      column: r
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, r) {
    if (t || (t = this.focusService.getFocusedHeader()), !t)
      return !1;
    const { headerRowIndex: n } = t, i = t.column, o = this.getHeaderRowCount(), s = e === 0;
    let {
      headerRowIndex: a,
      column: l,
      // eslint-disable-next-line prefer-const
      headerRowIndexWithoutSpan: u
    } = s ? this.headerPositionUtils.getColumnVisibleParent(i, n) : this.headerPositionUtils.getColumnVisibleChild(i, n), d = !1;
    return a < 0 && (a = 0, l = i, d = !0), a >= o ? (a = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : u !== void 0 && (this.currentHeaderRowWithoutSpan = u), !d && !l ? !1 : this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: a, column: l },
      allowUserOverride: !0,
      event: r
    });
  }
  setCurrentHeaderRowWithoutSpan(e) {
    this.currentHeaderRowWithoutSpan = e;
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, r) {
    const n = this.focusService.getFocusedHeader(), i = e === 2, o = this.gos.get("enableRtl");
    let s, a;
    if (this.currentHeaderRowWithoutSpan !== -1 ? n.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = n.headerRowIndex, i !== o ? (a = "Before", s = this.headerPositionUtils.findHeader(n, a)) : (a = "After", s = this.headerPositionUtils.findHeader(n, a)), s || !t)
      return this.focusService.focusHeaderPosition({
        headerPosition: s,
        direction: a,
        fromTab: t,
        allowUserOverride: !0,
        event: r
      });
    if (t) {
      const l = this.gos.getCallback("tabToNextHeader");
      if (l)
        return this.focusService.focusHeaderPositionFromUserFunc({
          userFunc: l,
          headerPosition: s,
          direction: a
        });
    }
    return this.focusNextHeaderRow(n, a, r);
  }
  focusNextHeaderRow(e, t, r) {
    const n = e.headerRowIndex;
    let i = null, o;
    if (t === "Before" ? n > 0 && (o = n - 1, this.currentHeaderRowWithoutSpan -= 1, i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "end")) : (o = n + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "start")), !i)
      return !1;
    const { column: s, headerRowIndex: a } = this.headerPositionUtils.getHeaderIndexToFocus(
      i.column,
      i == null ? void 0 : i.headerRowIndex
    );
    return this.focusService.focusHeaderPosition({
      headerPosition: { column: s, headerRowIndex: a },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: r
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let r;
    if ($t(e)) {
      const n = e.getDisplayedLeafColumns();
      r = t === "Before" ? Ye(n) : n[0];
    } else
      r = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(r);
  }
}, p4 = class extends J {
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.headerNavigationService = e.headerNavigationService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService, this.filterManager = e.filterManager, this.menuService = e.menuService;
  }
  setComp(e, t, r) {
    this.comp = e, this.eGui = t, this.createManagedBean(
      new ps(r, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), this.onPivotModeChanged(), this.setupHeaderHeight();
    const n = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: n }), this.mockContextMenuForIPad(n), this.ctrlsService.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    ), this.addManagedEventListeners({
      displayedColumnsChanged: e,
      columnHeaderHeightChanged: e,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => this.animationFrameService.requestAnimationFrame(() => e()),
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    var o;
    const { columnModel: e } = this;
    let t = 0;
    const r = this.columnModel.getGroupRowsHeight().reduce((s, a) => s + a, 0), n = this.columnModel.getColumnHeaderRowHeight();
    if ((o = this.filterManager) != null && o.hasFloatingFilters() && (t += e.getFloatingFiltersHeight()), t += r, t += n, this.headerHeight === t)
      return;
    this.headerHeight = t;
    const i = `${t + 1}px`;
    this.comp.setHeightAndMinHeight(i), this.eventService.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.visibleColsService.getAllCols().some((r) => r.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), r = e.shiftKey, n = r !== t ? 2 : 3;
    (this.headerNavigationService.navigateHorizontally(n, !0, e) || !r && this.focusService.focusOverlay(!1) || this.focusService.focusNextGridCoreContainer(r, !0)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case V.LEFT:
        t = 2;
      case V.RIGHT: {
        de(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, !1, e) && e.preventDefault();
        break;
      }
      case V.UP:
        t = 0;
      case V.DOWN: {
        de(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e;
    !t && this.eGui.contains(Dt(this.gos)) || this.eGui.contains(t) || this.focusService.clearFocusedHeader();
  }
  onHeaderContextMenu(e, t, r) {
    var i;
    if (!e && !r || !this.menuService.isHeaderContextMenuEnabled())
      return;
    const { target: n } = e ?? t;
    (n === this.eGui || n === ((i = this.ctrlsService.getHeaderRowContainerCtrl()) == null ? void 0 : i.getViewportElement())) && this.menuService.showHeaderContextMenu(void 0, e, r);
  }
  mockContextMenuForIPad(e) {
    if (!wo())
      return;
    const t = new lo(this.eGui), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
}, Z0 = class extends J {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = ar(this.gos, "print"), t = this.visibleColsService.getBodyContainerWidth(), r = this.visibleColsService.getColsLeftWidth(), n = this.visibleColsService.getDisplayedColumnsRightWidth();
    let i;
    e ? i = t + r + n : (i = t, this.addSpacer && (this.gos.get("enableRtl") ? r : n) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (i += this.scrollVisibleService.getScrollbarWidth())), this.callback(i);
  }
}, m4 = class extends J {
  constructor(e) {
    super(), this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  wireBeans(e) {
    this.funcColsService = e.funcColsService;
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((r) => {
      r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? this.columnsToAggregate.push(r) : r.isAllowRowGroup() ? this.columnsToGroup.push(r) : r.isAllowPivot() && this.columnsToPivot.push(r)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.funcColsService.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.funcColsService.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.funcColsService.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function AP(e) {
  const {
    isFromHeader: t,
    fromLeft: r,
    xPosition: n,
    fromEnter: i,
    fakeEvent: o,
    pinned: s,
    gos: a,
    columnModel: l,
    columnMoveService: u,
    visibleColsService: d
  } = e;
  let { allMovingColumns: h } = e;
  if (t) {
    const S = [];
    h.forEach((E) => {
      var I;
      let A = null, M = E.getParent();
      for (; M != null && M.getDisplayedLeafColumns().length === 1; )
        A = M, M = M.getParent();
      A != null ? (!!((I = A.getColGroupDef()) != null && I.marryChildren) ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        A.getProvidedColumnGroup().getLeafColumns()
      ) : A.getLeafColumns()).forEach((_) => {
        S.includes(_) || S.push(_);
      }) : S.includes(E) || S.push(E);
    }), h = S;
  }
  const f = h.slice();
  l.sortColsLikeCols(f);
  const p = w4({
    movingCols: f,
    draggingRight: r,
    xPosition: n,
    pinned: s,
    gos: a,
    columnModel: l,
    visibleColsService: d
  }), y = v4(f, l);
  if (p.length === 0)
    return;
  const C = p[0];
  let v = y !== null && !i;
  if (t && (v = y !== null), v && !o && (!r && C >= y || r && C <= y))
    return;
  const w = d.getAllCols(), R = [];
  let b = null;
  for (let S = 0; S < p.length; S++) {
    const E = p[S], A = u.getProposedColumnOrder(f, E);
    if (!u.doesOrderPassRules(A))
      continue;
    const M = A.filter((z) => w.includes(z));
    if (b === null)
      b = M;
    else if (!Co(M, b))
      break;
    const I = y4(A);
    R.push({ move: E, fragCount: I });
  }
  if (R.length === 0)
    return;
  R.sort((S, E) => S.fragCount - E.fragCount);
  const P = R[0].move;
  if (!(P > l.getCols().length - h.length))
    return { columns: h, toIndex: P };
}
function ey(e) {
  const { columns: t, toIndex: r } = AP(e) || {}, { finished: n, columnMoveService: i } = e;
  return !t || r == null ? null : (i.moveColumns(t, r, "uiColumnMoved", n), n ? null : { columns: t, toIndex: r });
}
function v4(e, t) {
  const r = t.getCols(), n = sB(e.map((l) => r.indexOf(l))), i = n[0];
  return Ye(n) - i !== n.length - 1 ? null : i;
}
function y4(e) {
  function t(n) {
    const i = [];
    let o = n.getOriginalParent();
    for (; o != null; )
      i.push(o), o = o.getOriginalParent();
    return i;
  }
  let r = 0;
  for (let n = 0; n < e.length - 1; n++) {
    let i = t(e[n]), o = t(e[n + 1]);
    [i, o] = i.length > o.length ? [i, o] : [o, i], i.forEach((s) => {
      o.indexOf(s) === -1 && r++;
    });
  }
  return r;
}
function C4(e, t) {
  switch (t) {
    case "left":
      return e.getLeftCols();
    case "right":
      return e.getRightCols();
    default:
      return e.getCenterCols();
  }
}
function w4(e) {
  const { movingCols: t, draggingRight: r, xPosition: n, pinned: i, gos: o, columnModel: s, visibleColsService: a } = e;
  if (o.get("suppressMovableColumns") || t.some((b) => b.getColDef().suppressMovable))
    return [];
  const u = C4(a, i), d = s.getCols(), h = u.filter((b) => es(t, b)), f = u.filter((b) => !es(t, b)), p = d.filter((b) => !es(t, b));
  let y = 0, C = n;
  if (r) {
    let b = 0;
    h.forEach((P) => b += P.getActualWidth()), C -= b;
  }
  if (C > 0) {
    for (let b = 0; b < f.length; b++) {
      const P = f[b];
      if (C -= P.getActualWidth(), C < 0)
        break;
      y++;
    }
    r && y++;
  }
  let v;
  if (y > 0) {
    const b = f[y - 1];
    v = p.indexOf(b) + 1;
  } else
    v = p.indexOf(f[0]), v === -1 && (v = 0);
  const w = [v], R = (b, P) => b - P;
  if (r) {
    let b = v + 1;
    const P = d.length - 1;
    for (; b <= P; )
      w.push(b), b++;
    w.sort(R);
  } else {
    let b = v;
    const P = d.length - 1;
    let S = d[b];
    for (; b <= P && u.indexOf(S) < 0; )
      b++, w.push(b), S = d[b];
    b = v - 1;
    const E = 0;
    for (; b >= E; )
      w.push(b), b--;
    w.sort(R).reverse();
  }
  return w;
}
function zd(e) {
  var u;
  const { pinned: t, fromKeyboard: r, gos: n, ctrlsService: i, useHeaderRow: o, skipScrollPadding: s } = e;
  let a = (u = i.getHeaderRowContainerCtrl(t)) == null ? void 0 : u.getViewportElement(), { x: l } = e;
  return a ? (r && (l -= a.getBoundingClientRect().left), n.get("enableRtl") && (o && (a = a.querySelector(".ag-header-row")), l = a.clientWidth - l), t == null && !s && (l += i.get("center").getCenterViewportScrollLeft()), l) : 0;
}
function Qs(e, t) {
  for (const r of e)
    r.setMoving(t, "uiColumnMoved");
}
var yS = 7, Am = 100, $u = Am / 2, b4 = 5, S4 = 100, x4 = class extends J {
  constructor(e) {
    super(), this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !de(e);
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnMoveService = e.columnMoveService, this.dragAndDropService = e.dragAndDropService, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    var t;
    const e = ((t = this.lastDraggingEvent) == null ? void 0 : t.dragItem.columns) ?? [];
    for (const r of e) {
      const n = r.getPinned();
      if (r.getColDef().lockPinned) {
        if (n == this.pinned)
          return "move";
        continue;
      }
      if (n === this.pinned || !this.pinned)
        return "move";
      if (!n && this.pinned)
        return "pinned";
    }
    return "notAllowed";
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(t, !0, "uiColumnDragged");
    else {
      const n = e.dragItem.visibleState, i = (t || []).filter((o) => n[o.getId()]);
      this.setColumnsVisible(i, !0, "uiColumnDragged");
    }
    this.gos.get("suppressMoveWhenColumnDragging") || this.attemptToPinColumns(t, this.pinned), this.onDragging(e, !0, !0);
  }
  onDragging(e = this.lastDraggingEvent, t = !1, r = !1, n = !1) {
    const i = this.gos.get("suppressMoveWhenColumnDragging");
    if (n && !i) {
      this.finishColumnMoving();
      return;
    }
    if (this.lastDraggingEvent = e, !e || !n && Ke(e.hDirection))
      return;
    const { pinned: o, gos: s, ctrlsService: a } = this, l = zd({
      x: e.x,
      pinned: o,
      gos: s,
      ctrlsService: a
    });
    t || this.checkCenterForScrolling(l), i ? this.handleColumnDragWhileSuppressingMovement(e, t, r, l, n) : this.handleColumnDragWhileAllowingMovement(e, t, r, l, n);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.clearHighlighted(), this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted(), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, r) {
    if (!e)
      return;
    const n = e.filter((i) => !i.getColDef().lockVisible);
    this.columnModel.setColsVisible(n, t, r);
  }
  finishColumnMoving() {
    if (this.clearHighlighted(), !this.lastMovedInfo)
      return;
    const { columns: e, toIndex: t } = this.lastMovedInfo;
    this.columnMoveService.moveColumns(e, t, "uiColumnMoved", !0);
  }
  handleColumnDragWhileSuppressingMovement(e, t, r, n, i) {
    const o = this.getAllMovingColumns(e, !0);
    if (i) {
      const s = this.isAttemptingToPin(o);
      s && this.attemptToPinColumns(o, void 0, !0);
      const { fromLeft: a, xPosition: l } = this.getNormalisedXPositionInfo(o, s) || {};
      if (a == null || l == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns: o,
        xPosition: l,
        fromEnter: t,
        fakeEvent: r,
        fromLeft: a
      });
    } else {
      if (!this.dragAndDropService.isDropZoneWithinThisGrid(e))
        return;
      this.highlightHoveredColumn(o, n);
    }
  }
  handleColumnDragWhileAllowingMovement(e, t, r, n, i) {
    const o = this.getAllMovingColumns(e), s = this.normaliseDirection(e.hDirection) === 1, a = e.dragSource.type === 1, l = this.getMoveColumnParams({
      allMovingColumns: o,
      isFromHeader: a,
      xPosition: n,
      fromLeft: s,
      fromEnter: t,
      fakeEvent: r
    }), u = ey({ ...l, finished: i });
    u && (this.lastMovedInfo = u);
  }
  getAllMovingColumns(e, t = !1) {
    const r = e.dragSource.getDragItem();
    let n = null;
    t ? (n = r.columnsInSplit, n || (n = r.columns)) : n = r.columns;
    const i = (o) => o.getColDef().lockPinned ? o.getPinned() == this.pinned : !0;
    return n ? n.filter(i) : [];
  }
  getMoveColumnParams(e) {
    const { allMovingColumns: t, isFromHeader: r, xPosition: n, fromLeft: i, fromEnter: o, fakeEvent: s } = e, { pinned: a, gos: l, columnModel: u, columnMoveService: d, visibleColsService: h } = this;
    return {
      allMovingColumns: t,
      isFromHeader: r,
      fromLeft: i,
      xPosition: n,
      pinned: a,
      fromEnter: o,
      fakeEvent: s,
      gos: l,
      columnModel: u,
      columnMoveService: d,
      visibleColsService: h
    };
  }
  findFirstAndLastMovingColumns(e) {
    const t = e.length;
    let r, n;
    for (let i = 0; i <= t; i++) {
      if (!r) {
        const o = e[i];
        o.getLeft() != null && (r = o);
      }
      if (!n) {
        const o = e[t - 1 - i];
        o.getLeft() != null && (n = o);
      }
      if (r && n)
        break;
    }
    return { firstMovingCol: r, lastMovingCol: n };
  }
  highlightHoveredColumn(e, t) {
    var d;
    const { gos: r, columnModel: n } = this, i = r.get("enableRtl"), o = n.getCols().filter((h) => h.isVisible() && h.getPinned() === this.pinned);
    let s = null, a = null, l = null;
    for (const h of o) {
      if (a = h.getActualWidth(), s = this.getNormalisedColumnLeft(h, 0, i), s != null) {
        const f = s + a;
        if (s <= t && f >= t) {
          l = h;
          break;
        }
      }
      s = null, a = null;
    }
    if (l)
      e.indexOf(l) !== -1 && (l = null);
    else {
      for (let h = o.length - 1; h >= 0; h--) {
        const f = o[h], p = o[h].getParent();
        if (!p) {
          l = f;
          break;
        }
        const y = p == null ? void 0 : p.getDisplayedLeafColumns();
        if (y.length) {
          l = Ye(y);
          break;
        }
      }
      if (!l)
        return;
      s = this.getNormalisedColumnLeft(l, 0, i), a = l.getActualWidth();
    }
    if (((d = this.lastHighlightedColumn) == null ? void 0 : d.column) !== l && this.clearHighlighted(), l == null || s == null || a == null)
      return;
    let u;
    t - s < a / 2 !== i ? u = 0 : u = 1, l.setHighlighted(u), this.lastHighlightedColumn = { column: l, position: u };
  }
  getNormalisedXPositionInfo(e, t) {
    const { gos: r, visibleColsService: n } = this, i = r.get("enableRtl"), { firstMovingCol: o, column: s, position: a } = this.getColumnMoveAndTargetInfo(
      e,
      t,
      i
    );
    if (!o || !s || a == null)
      return;
    const l = n.getAllCols(), u = l.indexOf(o), d = l.indexOf(s), h = a === 0 !== i, f = u < d || u === d && !h;
    let p = 0;
    if (h ? f && (p -= 1) : f || (p += 1), d + p === u)
      return;
    const y = l[d + p];
    if (!y)
      return;
    const C = this.getNormalisedColumnLeft(y, 20, i);
    return { fromLeft: f, xPosition: C };
  }
  getColumnMoveAndTargetInfo(e, t, r) {
    const n = this.lastHighlightedColumn || {}, { firstMovingCol: i, lastMovingCol: o } = this.findFirstAndLastMovingColumns(e);
    if (!i || !o || n.column || !t)
      return {
        firstMovingCol: i,
        ...n
      };
    const a = this.getPinDirection() === "left";
    return {
      firstMovingCol: i,
      position: a ? 1 : 0,
      column: a !== r ? i : o
    };
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case 0:
          return 1;
        case 1:
          return 0;
      }
    return e;
  }
  getNormalisedColumnLeft(e, t, r) {
    const { gos: n, ctrlsService: i } = this, o = e.getLeft();
    if (o == null)
      return null;
    const s = e.getActualWidth();
    return zd({
      x: r ? o + s - t : o + t,
      pinned: e.getPinned(),
      useHeaderRow: r,
      skipScrollPadding: !0,
      gos: n,
      ctrlsService: i
    });
  }
  isAttemptingToPin(e) {
    const t = this.needToMoveLeft || this.needToMoveRight, r = this.failedMoveAttempts > yS;
    return t && r || e.some((n) => n.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(e) {
    const { allMovingColumns: t, xPosition: r, fromEnter: n, fakeEvent: i, fromLeft: o } = e, s = this.getMoveColumnParams({
      allMovingColumns: t,
      isFromHeader: !0,
      xPosition: r,
      fromLeft: o,
      fromEnter: n,
      fakeEvent: i
    }), { columns: a, toIndex: l } = AP(s) || {};
    a && l != null && (this.lastMovedInfo = {
      columns: a,
      toIndex: l
    }), this.finishColumnMoving();
  }
  clearHighlighted() {
    this.lastHighlightedColumn && (this.lastHighlightedColumn.column.setHighlighted(null), this.lastHighlightedColumn = null);
  }
  checkCenterForScrolling(e) {
    if (!this.isCenterContainer)
      return;
    const t = this.ctrlsService.get("center"), r = t.getCenterViewportScrollLeft(), n = r + t.getCenterWidth();
    this.gos.get("enableRtl") ? (this.needToMoveRight = e < r + $u, this.needToMoveLeft = e > n - $u) : (this.needToMoveLeft = e < r + $u, this.needToMoveRight = e > n - $u), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
  }
  ensureIntervalStarted() {
    var e;
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), S4), (e = this.dragAndDropService.getDragAndDropImageComponent()) == null || e.setIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    var e;
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.failedMoveAttempts = 0, (e = this.dragAndDropService.getDragAndDropImageComponent()) == null || e.setIcon(this.getIconName()));
  }
  moveInterval() {
    var n, i;
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * b4, e > Am && (e = Am);
    let t = null;
    const r = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = r.scrollHorizontally(-e) : this.needToMoveRight && (t = r.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      if (this.failedMoveAttempts++, this.failedMoveAttempts <= yS + 1)
        return;
      if ((n = this.dragAndDropService.getDragAndDropImageComponent()) == null || n.setIcon("pinned"), !this.gos.get("suppressMoveWhenColumnDragging")) {
        const o = (i = this.lastDraggingEvent) == null ? void 0 : i.dragItem.columns;
        this.attemptToPinColumns(o, void 0, !0);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left")
      return "left";
    if (this.needToMoveRight || this.pinned === "right")
      return "right";
  }
  attemptToPinColumns(e, t, r = !1) {
    const n = (e || []).filter((i) => !i.getColDef().lockPinned);
    return n.length ? (r && (t = this.getPinDirection()), this.columnModel.setColsPinned(n, t, "uiColumnDragged"), r && this.dragAndDropService.nudge(), n.length) : 0;
  }
  destroy() {
    super.destroy(), this.lastDraggingEvent = null, this.clearHighlighted(), this.lastMovedInfo = null;
  }
}, R4 = class extends J {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()],
            [e.bottomLeft.getContainerElement()],
            [e.topLeft.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()],
            [e.bottomRight.getContainerElement()],
            [e.topRight.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()],
            [e.bottomCenter.getViewportElement()],
            [e.topCenter.getViewportElement()]
          ];
          break;
      }
    }), this.moveColumnFeature = this.createManagedBean(new x4(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new m4(this.pinned)), this.dragAndDropService.addDropTarget(this), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(this));
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
}, E4 = class extends J {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.pinnedWidthService = e.pinnedWidthService, this.ctrlsService = e.ctrlsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n, i) {
    super(), this.pinned = e, this.column = t, this.eResize = r, this.comp = n, this.ctrl = i;
  }
  postConstruct() {
    const e = [];
    let t, r;
    const n = () => {
      if (Tt(this.eResize, t), !t)
        return;
      const s = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (e.push(s), r) {
        const a = this.gos.get("skipHeaderOnAutoSize"), l = () => {
          this.columnAutosizeService.autoSizeColumn(this.column, "uiColumnResized", a);
        };
        this.eResize.addEventListener("dblclick", l);
        const u = new lo(this.eResize);
        u.addEventListener("doubleTap", l), e.push(() => {
          this.eResize.removeEventListener("dblclick", l), u.removeEventListener("doubleTap", l), u.destroy();
        });
      }
    }, i = () => {
      e.forEach((s) => s()), e.length = 0;
    }, o = () => {
      const s = this.column.isResizable(), a = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (s !== t || a !== r) && (t = s, r = a, i(), n());
    };
    o(), this.addDestroyFunc(i), this.ctrl.setRefreshFunction("resize", o);
  }
  onResizing(e, t) {
    const { column: r, lastResizeAmount: n, resizeStartWidth: i } = this, o = this.normaliseResizeAmount(t), s = i + o, a = [{ key: r, newWidth: s }];
    if (this.column.getPinned()) {
      const l = this.pinnedWidthService.getPinnedLeftWidth(), u = this.pinnedWidthService.getPinnedRightWidth(), d = jc(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (l + u + (o - n) > d)
        return;
    }
    this.lastResizeAmount = o, this.columnSizeService.setColumnWidths(a, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const r = this.pinned !== "left", n = this.pinned === "right";
    return this.gos.get("enableRtl") ? r && (t *= -1) : n && (t *= -1), t;
  }
}, P4 = class extends J {
  constructor(e) {
    super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(Dt(this.gos)) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new W0()), this.cbSelectAll.addCssClass("ag-header-select-all"), Vn(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedEventListeners({
      newColumnsLoaded: this.onNewColumnsLoaded.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: this.onSelectionChanged.bind(this),
      paginationChanged: this.onSelectionChanged.bind(this),
      modelUpdated: this.onModelChanged.bind(this)
    }), this.addManagedListeners(this.cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) }), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onNewColumnsLoaded() {
    this.showOrHideSelectAll();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setValue(e);
    const t = this.selectionService.hasNodesToSelect(
      this.isFilteredOnly(),
      this.isCurrentPageOnly()
    );
    this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), r = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), n = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${n} (${r})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(e("ariaHeaderSelection", "Column with Header Selection")), this.headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(e) {
    return CE(this.gos) ? !0 : (ie(`${e} is only available if using 'multiRow' selection mode.`), !1);
  }
  checkRightRowModelType(e) {
    return At(this.gos) || yo(this.gos) ? !0 : (ie(
      `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${this.rowModel.getType()}.`
    ), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.isFilteredOnly(), r = this.isCurrentPageOnly();
    let n = "uiSelectAll";
    r ? n = "uiSelectAllCurrentPage" : t && (n = "uiSelectAllFiltered");
    const i = {
      source: n,
      justFiltered: t,
      justCurrentPage: r
    };
    e ? this.selectionService.selectAllRowNodes(i) : this.selectionService.deselectAllRowNodes(i);
  }
  /**
   * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
   * or `headerCheckboxSelection` is enabled in the legacy API.
   */
  isCheckboxSelection() {
    const e = this.gos.get("rowSelection"), t = typeof e == "object" && Pd(e) && Kh(this.column), r = this.column.getColDef().headerCheckboxSelection;
    let n = !1;
    return t ? n = !0 : typeof r == "function" ? n = r(
      this.gos.addGridCommonParams({
        column: this.column,
        colDef: this.column.getColDef()
      })
    ) : n = !!r, n && this.checkRightRowModelType(t ? "headerCheckbox" : "headerCheckboxSelection") && this.checkSelectionType(t ? "headerCheckbox" : "headerCheckboxSelection");
  }
  isFilteredOnly() {
    const e = this.gos.get("rowSelection");
    return typeof e == "object" ? e.mode === "multiRow" && e.selectAll === "filtered" : !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
  }
  isCurrentPageOnly() {
    const e = this.gos.get("rowSelection");
    return typeof e == "object" ? e.mode === "multiRow" && e.selectAll === "currentPage" : !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
  }
}, A4 = class extends Jh {
  constructor(e, t, r) {
    super(e, t, r), this.refreshFunctions = {}, this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, r, n, i) {
    this.comp = e, i = Vc(this, this.beans.context, i), this.setGui(t, i), this.updateState(), this.setupWidth(i), this.setupMovingCss(i), this.setupMenuClass(i), this.setupSortableClass(i), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight({
      wrapperElement: n,
      checkMeasuringCallback: (s) => this.setRefreshFunction("measuring", s),
      compBean: i
    }), this.addColumnHoverListener(i), this.setupFilterClass(i), this.setupClassesFromColDef(), this.setupTooltip(i), this.addActiveHeaderMouseListeners(i), this.setupSelectAll(i), this.setupUserComp(i), this.refreshAria(), this.resizeFeature = i.createManagedBean(
      new E4(this.getPinned(), this.column, r, e, this)
    ), i.createManagedBean(new J0([this.column], t)), i.createManagedBean(new Y0(this.column, t, this.beans)), i.createManagedBean(
      new ps(t, {
        shouldStopEventPropagation: (s) => this.shouldStopEventPropagation(s),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(i), i.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"],
      () => this.refresh(i)
    ), i.addManagedListeners(this.column, { colDefChanged: () => this.refresh(i) }), i.addManagedListeners(this.column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const o = () => this.checkDisplayName(i);
    i.addManagedEventListeners({
      columnValueChanged: o,
      columnRowGroupChanged: o,
      columnPivotChanged: o,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    }), i.addDestroyFunc(() => {
      this.refreshFunctions = {}, this.selectAllFeature = null, this.dragSourceElement = void 0, this.userCompDetails = null, this.userHeaderClasses.clear(), this.ariaDescriptionProperties.clear(), this.clearComponent();
    });
  }
  resizeHeader(e, t) {
    if (!this.column.isResizable())
      return;
    const r = this.column.getActualWidth(), n = this.column.getMinWidth(), i = this.column.getMaxWidth(), o = Math.min(Math.max(r + e, n), i);
    this.beans.columnSizeService.setColumnWidths(
      [{ key: this.column, newWidth: o }],
      t,
      !0,
      "uiColumnResized"
    );
  }
  moveHeader(e) {
    const { eGui: t, beans: r, column: n, ctrlsService: i } = this, { gos: o, columnModel: s, columnMoveService: a, visibleColsService: l } = r, u = this.getPinned(), d = t.getBoundingClientRect().left, h = n.getActualWidth(), f = o.get("enableRtl"), y = zd({
      x: e === 0 !== f ? d - 20 : d + h + 20,
      pinned: u,
      fromKeyboard: !0,
      gos: o,
      ctrlsService: i
    }), C = this.focusService.getFocusedHeader();
    ey({
      allMovingColumns: [n],
      isFromHeader: !0,
      fromLeft: e === 1,
      xPosition: y,
      pinned: u,
      fromEnter: !1,
      fakeEvent: !1,
      gos: o,
      columnModel: s,
      columnMoveService: a,
      visibleColsService: l,
      finished: !0
    }), i.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(n, "auto"), (!this.isAlive() || this.beans.gos.get("ensureDomOrder")) && C && this.restoreFocus(C);
  }
  restoreFocus(e) {
    this.focusService.focusHeaderPosition({
      headerPosition: {
        ...e,
        column: this.column
      }
    });
  }
  setupUserComp(e) {
    const t = this.lookupUserCompDetails(e);
    this.setCompDetails(t);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails(e) {
    const t = this.createParams(e), r = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(r, t);
  }
  createParams(e) {
    return this.gos.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
      enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
      showColumnMenu: (r) => {
        this.menuService.showColumnMenu({
          column: this.column,
          buttonElement: r,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (r) => {
        this.menuService.showColumnMenu({
          column: this.column,
          mouseEvent: r,
          positionBy: "mouse"
        });
      },
      showFilter: (r) => {
        this.menuService.showFilterMenu({
          column: this.column,
          buttonElement: r,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (r) => {
        this.beans.sortController.progressSort(this.column, !!r, "uiColumnSorted");
      },
      setSort: (r, n) => {
        this.beans.sortController.setSortForColumn(this.column, r, !!n, "uiColumnSorted");
      },
      eGridHeader: this.getGui(),
      setTooltip: (r, n) => {
        this.setupTooltip(e, r, n);
      }
    });
  }
  setupSelectAll(e) {
    this.selectAllFeature = e.createManagedBean(new P4(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === V.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === V.ENTER && this.onEnterKeyDown(e), e.key === V.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey)
      this.showMenuOnKeyPress(e, !0);
    else if (this.sortable) {
      const t = e.shiftKey;
      this.beans.sortController.progressSort(this.column, t, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, t) {
    const r = this.comp.getUserCompInstance();
    !r || !(r instanceof Sm) || r.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column), this.announceAriaDescription();
    }
    this.focusService.isKeyboardMode() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t, r) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const n = this.gos.get("tooltipShowMode") === "whenTruncated", i = this.eGui, o = this.column.getColDef();
    !r && n && !o.headerComponent && (r = () => {
      const l = i.querySelector(".ag-header-cell-text");
      return l ? l.scrollWidth > l.clientWidth : !0;
    });
    const s = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => i,
      getLocation: () => "header",
      getTooltipValue: () => t ?? this.column.getColDef().headerTooltip,
      shouldDisplayTooltip: r
    }, a = e.createManagedBean(new Ba(s));
    this.setRefreshFunction("tooltip", () => a.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), r = yP(t, this.gos, this.column, null), n = this.userHeaderClasses;
      this.userHeaderClasses = new Set(r), r.forEach((i) => {
        n.has(i) ? n.delete(i) : this.comp.addOrRemoveCssClass(i, !0);
      }), n.forEach((i) => this.comp.addOrRemoveCssClass(i, !1));
    };
    this.setRefreshFunction("headerClasses", e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable)
      return;
    const { column: t, beans: r, displayName: n, dragAndDropService: i, gos: o } = this, { columnModel: s } = r;
    let a = !this.gos.get("suppressDragLeaveHidesColumns");
    const l = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => a ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(t),
      dragItemName: n,
      onDragStarted: () => {
        a = !o.get("suppressDragLeaveHidesColumns"), Qs([t], !0);
      },
      onDragStopped: () => Qs([t], !1),
      onDragCancelled: () => Qs([t], !1),
      onGridEnter: (u) => {
        var d;
        if (a) {
          const h = ((d = u == null ? void 0 : u.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          s.setColsVisible(h, !0, "uiColumnMoved");
        }
      },
      onGridExit: (u) => {
        var d;
        if (a) {
          const h = ((d = u == null ? void 0 : u.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          s.setColsVisible(h, !1, "uiColumnMoved");
        }
      }
    };
    i.addDragSource(l, !0);
  }
  createDragItem(e) {
    const t = {};
    return t[e.getId()] = e.isVisible(), {
      columns: [e],
      visibleState: t
    };
  }
  updateState() {
    this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(e, t) {
    this.refreshFunctions[e] = t;
  }
  refresh(e) {
    this.updateState(), this.refreshHeaderComp(e), this.refreshAria(), Object.values(this.refreshFunctions).forEach((t) => t());
  }
  refreshHeaderComp(e) {
    const t = this.lookupUserCompDetails(e);
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == t.componentClass ? this.attemptHeaderCompRefresh(t.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(t);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.columnNameService.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName(e) {
    this.displayName !== this.calculateDisplayName() && this.refresh(e);
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  setupWidth(e) {
    const t = () => {
      const r = this.column.getActualWidth();
      this.comp.setWidth(`${r}px`);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupMovingCss(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    e.addManagedListeners(this.column, { movingChanged: t }), t();
  }
  setupMenuClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    e.addManagedListeners(this.column, { menuVisibleChanged: t }), t();
  }
  setupSortableClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    t(), this.setRefreshFunction("updateSortable", t), e.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(e) {
    const t = () => {
      const r = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", r), this.refreshAria();
    };
    e.addManagedListeners(this.column, { filterActiveChanged: t }), t();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.setRefreshFunction("wrapText", e);
  }
  onHeaderHighlightChanged() {
    const e = this.column.getHighlighted(), t = e === 0, r = e === 1;
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", t), this.comp.addOrRemoveCssClass("ag-header-highlight-after", r);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: r, beans: n } = this, i = this.beans.columnModel.getGroupRowsHeight(), o = i.reduce((h, f) => h += f, 0) === 0;
    if (r.addOrRemoveCssClass("ag-header-parent-hidden", o), !t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), r.addOrRemoveCssClass("ag-header-span-height", !1), r.addOrRemoveCssClass("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: s, isSpanningTotal: a } = this.column.getColumnGroupPaddingInfo();
    r.addOrRemoveCssClass("ag-header-span-height", s > 0);
    const { columnModel: l } = n, u = l.getColumnHeaderRowHeight();
    if (s === 0) {
      r.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${u}px`);
      return;
    }
    r.addOrRemoveCssClass("ag-header-span-total", a);
    let d = 0;
    for (let h = 0; h < s; h++)
      d += i[i.length - 1 - h];
    e.style.setProperty("top", `${-d}px`), e.style.setProperty("height", `${u + d}px`);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(BB(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.localeService.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    if (!this.eGui.contains(Dt(this.beans.gos)))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((t, r) => t === "filter" ? -1 : r.charCodeAt(0) - t.charCodeAt(0)).map((t) => this.ariaDescriptionProperties.get(t)).join(". ");
    this.beans.ariaAnnouncementService.announceValue(e, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener(e) {
    const t = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const r = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", r);
    };
    e.addManagedEventListeners({ columnHoverChanged: t }), t();
  }
  getColId() {
    return this.column.getColId();
  }
  addActiveHeaderMouseListeners(e) {
    const t = (i) => this.handleMouseOverChange(i.type === "mouseenter"), r = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column), n = (i) => this.handleContextMenuMouseEvent(i, void 0, this.column);
    e.addManagedListeners(this.getGui(), {
      mouseenter: t,
      mouseleave: t,
      click: r,
      contextmenu: n
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e), this.eventService.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return t instanceof Sm ? t.getAnchorElementForMenu(e) : this.getGui();
  }
  destroy() {
    super.destroy();
  }
}, F4 = class extends J {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.autoWidthCalculator = e.autoWidthCalculator, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n) {
    super(), this.eResize = t, this.comp = e, this.pinned = r, this.columnGroup = n;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
      const t = this.gos.get("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const r = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((i) => {
          i.getColDef().suppressAutoSize || r.push(i.getColId());
        }), r.length > 0 && this.columnAutosizeService.autoSizeCols({
          colKeys: r,
          skipHeader: t,
          stopAtGroup: this.columnGroup,
          source: "uiColumnResized"
        }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    const t = this.getInitialValues(e);
    this.storeLocalValues(t), this.toggleColumnResizing(!0);
  }
  onResizing(e, t, r = "uiColumnResized") {
    const n = this.normaliseDragChange(t), i = this.resizeStartWidth + n;
    this.resizeColumnsFromLocalValues(i, r, e);
  }
  getInitialValues(e) {
    const t = this.getColumnsToResize(), r = this.getInitialSizeOfColumns(t), n = this.getSizeRatiosOfColumns(t, r), i = {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n
    };
    let o = null;
    if (e && (o = this.visibleColsService.getGroupAtDirection(this.columnGroup, "After")), o) {
      const s = o.getDisplayedLeafColumns(), a = i.groupAfterColumns = s.filter(
        (u) => u.isResizable()
      ), l = i.groupAfterStartWidth = this.getInitialSizeOfColumns(a);
      i.groupAfterRatios = this.getSizeRatiosOfColumns(a, l);
    } else
      i.groupAfterColumns = void 0, i.groupAfterStartWidth = void 0, i.groupAfterRatios = void 0;
    return i;
  }
  storeLocalValues(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n,
      groupAfterColumns: i,
      groupAfterStartWidth: o,
      groupAfterRatios: s
    } = e;
    this.resizeCols = t, this.resizeStartWidth = r, this.resizeRatios = n, this.resizeTakeFromCols = i, this.resizeTakeFromStartWidth = o, this.resizeTakeFromRatios = s;
  }
  clearLocalValues() {
    this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup), r = this.getInitialValues();
    t > r.resizeStartWidth && this.resizeColumns(r, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, r = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const n = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols ?? void 0,
      groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0,
      groupAfterRatios: this.resizeTakeFromRatios ?? void 0
    };
    this.resizeColumns(n, e, t, r);
  }
  resizeColumns(e, t, r, n = !0) {
    const {
      columnsToResize: i,
      resizeStartWidth: o,
      resizeRatios: s,
      groupAfterColumns: a,
      groupAfterStartWidth: l,
      groupAfterRatios: u
    } = e, d = [];
    if (d.push({
      columns: i,
      ratios: s,
      width: t
    }), a) {
      const h = t - o;
      d.push({
        columns: a,
        ratios: u,
        width: l - h
      });
    }
    this.columnSizeService.resizeColumnSets({
      resizeSets: d,
      finished: n,
      source: r
    }), n && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  getInitialSizeOfColumns(e) {
    return e.reduce((t, r) => t + r.getActualWidth(), 0);
  }
  getSizeRatiosOfColumns(e, t) {
    return e.map((r) => r.getActualWidth() / t);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.clearLocalValues();
  }
}, M4 = class extends J {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}, T4 = class extends Jh {
  constructor(e, t, r) {
    super(e, t, r), this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving())
        this.removeDragSource();
      else if (!this.dragSource) {
        const n = this.getGui();
        this.setDragSource(n);
      }
    }, this.column = e;
  }
  setComp(e, t, r, n, i) {
    this.comp = e, i = Vc(this, this.beans.context, i), this.setGui(t, i), this.displayName = this.beans.columnNameService.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(i), this.setupExpandable(i), this.setupTooltip(i), this.setupAutoHeight({
      wrapperElement: n,
      compBean: i
    }), this.setupUserComp(i), this.addHeaderMouseListeners(i), this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this)), this.refreshMaxHeaderHeight();
    const o = this.getParentRowCtrl().getPinned(), s = this.column.getProvidedColumnGroup().getLeafColumns();
    i.createManagedBean(new J0(s, t)), i.createManagedBean(new Y0(this.column, t, this.beans)), i.createManagedBean(new M4(e, this.column)), this.resizeFeature = i.createManagedBean(new F4(e, r, o, this.column)), i.createManagedBean(
      new ps(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addHighlightListeners(i, s), i.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners(i), i.addDestroyFunc(() => this.clearComponent());
  }
  refreshMaxHeaderHeight() {
    const { gos: e, comp: t } = this, r = e.get("groupHeaderHeight");
    r != null ? r === 0 ? t.setHeaderWrapperHidden(!0) : t.setHeaderWrapperMaxHeight(r) : (t.setHeaderWrapperHidden(!1), t.setHeaderWrapperMaxHeight(null));
  }
  addHighlightListeners(e, t) {
    if (this.beans.gos.get("suppressMoveWhenColumnDragging"))
      for (const r of t)
        e.addManagedListeners(r, {
          headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, r)
        });
  }
  onLeafColumnHighlightChanged(e) {
    const t = this.column.getDisplayedLeafColumns(), r = t[0] === e, n = Ye(t) === e;
    if (!r && !n)
      return;
    const i = e.getHighlighted(), o = !!this.getParentRowCtrl().findHeaderCellCtrl((l) => l.getColumnGroupChild().isMoving());
    let s = !1, a = !1;
    if (o) {
      const l = this.beans.gos.get("enableRtl"), u = i === 1, d = i === 0;
      r && (l ? a = u : s = d), n && (l ? s = d : a = u);
    }
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", s), this.comp.addOrRemoveCssClass("ag-header-highlight-after", a);
  }
  getColumn() {
    return this.column;
  }
  resizeHeader(e, t) {
    if (!this.resizeFeature)
      return;
    const r = this.resizeFeature.getInitialValues(t);
    this.resizeFeature.resizeColumns(
      r,
      r.resizeStartWidth + e,
      "uiColumnResized",
      !0
    );
  }
  moveHeader(e) {
    const { beans: t, eGui: r, column: n, ctrlsService: i } = this, { gos: o, columnModel: s, columnMoveService: a, visibleColsService: l } = t, u = o.get("enableRtl"), d = e === 0, h = this.getPinned(), f = r.getBoundingClientRect(), p = f.left, y = f.width, C = zd({
      x: d !== u ? p - 20 : p + y + 20,
      pinned: h,
      fromKeyboard: !0,
      gos: o,
      ctrlsService: i
    }), v = n.getGroupId(), w = this.focusService.getFocusedHeader();
    ey({
      allMovingColumns: this.column.getLeafColumns(),
      isFromHeader: !0,
      fromLeft: e === 1,
      xPosition: C,
      pinned: h,
      fromEnter: !1,
      fakeEvent: !1,
      gos: o,
      columnModel: s,
      columnMoveService: a,
      visibleColsService: l,
      finished: !0
    });
    const R = n.getDisplayedLeafColumns(), b = d ? R[0] : Ye(R);
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(b, "auto"), (!this.isAlive() || this.beans.gos.get("ensureDomOrder")) && w && this.restoreFocus(v, n, w);
  }
  restoreFocus(e, t, r) {
    const n = t.getLeafColumns();
    if (!n.length)
      return;
    const i = n[0].getParent();
    if (!i)
      return;
    const o = this.findGroupWidthId(i, e);
    o && this.focusService.focusHeaderPosition({
      headerPosition: {
        ...r,
        column: o
      }
    });
  }
  findGroupWidthId(e, t) {
    for (; e; ) {
      if (e.getGroupId() === t)
        return e;
      e = e.getParent();
    }
    return null;
  }
  resizeLeafColumnsToFit(e) {
    this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp(e) {
    const t = this.gos.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (n) => {
        this.beans.columnModel.setColumnGroupOpened(
          this.column.getProvidedColumnGroup(),
          n,
          "gridInitializing"
        );
      },
      setTooltip: (n, i) => {
        this.setupTooltip(e, n, i);
      }
    }), r = this.userComponentFactory.getHeaderGroupCompDetails(t);
    this.comp.setUserCompDetails(r);
  }
  addHeaderMouseListeners(e) {
    const t = (i) => this.handleMouseOverChange(i.type === "mouseenter"), r = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), n = (i) => this.handleContextMenuMouseEvent(i, void 0, this.column.getProvidedColumnGroup());
    e.addManagedListeners(this.getGui(), {
      mouseenter: t,
      mouseleave: t,
      click: r,
      contextmenu: n
    });
  }
  handleMouseOverChange(e) {
    this.eventService.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(e, t, r) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const n = this.column.getColGroupDef(), i = this.gos.get("tooltipShowMode") === "whenTruncated", o = this.eGui;
    !r && i && !(n != null && n.headerGroupComponent) && (r = () => {
      const a = o.querySelector(".ag-header-group-text");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const s = {
      getColumn: () => this.column,
      getGui: () => o,
      getLocation: () => "headerGroup",
      getTooltipValue: () => t ?? (n && n.headerTooltip),
      shouldDisplayTooltip: r
    };
    n && (s.getColDef = () => n), e.createManagedBean(new Ba(s));
  }
  setupExpandable(e) {
    const t = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const r = this.refreshExpanded.bind(this);
    e.addManagedListeners(t, {
      expandedChanged: r,
      expandableChanged: r
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  getColId() {
    return this.column.getUniqueId();
  }
  addClasses() {
    const e = this.column.getColGroupDef(), t = yP(e, this.gos, null, this.column);
    this.column.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.column.getLeafColumns().every((n) => n.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : (t.push("ag-header-group-cell-with-group"), e != null && e.wrapHeaderText && t.push("ag-header-cell-wrap-text")), t.forEach((r) => this.comp.addOrRemoveCssClass(r, !0));
  }
  setupMovingCss(e) {
    const r = this.column.getProvidedColumnGroup().getLeafColumns(), n = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    r.forEach((i) => {
      e.addManagedListeners(i, { movingChanged: n });
    }), n();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.column);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === V.ENTER) {
      const r = this.column, n = !r.isExpanded();
      this.beans.columnModel.setColumnGroupOpened(
        r.getProvidedColumnGroup(),
        n,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    if (!this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), !e))
      return;
    const { beans: t, column: r, displayName: n, gos: i, dragAndDropService: o } = this, { columnModel: s } = t, a = r.getProvidedColumnGroup().getLeafColumns();
    let l = !i.get("suppressDragLeaveHidesColumns");
    const u = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => l ? "hide" : "notAllowed",
      dragItemName: n,
      // we add in the original group leaf columns, so we move both visible and non-visible items
      getDragItem: () => this.getDragItemForGroup(r),
      onDragStarted: () => {
        l = !i.get("suppressDragLeaveHidesColumns"), Qs(a, !0);
      },
      onDragStopped: () => Qs(a, !1),
      onDragCancelled: () => Qs(a, !1),
      onGridEnter: (d) => {
        if (l) {
          const { columns: h = [], visibleState: f } = d ?? {}, p = h.filter(
            (y) => !y.getColDef().lockVisible && (!f || f[y.getColId()])
          );
          s.setColsVisible(p, !0, "uiColumnMoved");
        }
      },
      onGridExit: (d) => {
        var h;
        if (l) {
          const f = ((h = d == null ? void 0 : d.columns) == null ? void 0 : h.filter((p) => !p.getColDef().lockVisible)) || [];
          s.setColsVisible(f, !1, "uiColumnMoved");
        }
      }
    };
    o.addDragSource(u, !0);
  }
  // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
  // and in the order they are currently in the screen.
  getDragItemForGroup(e) {
    const t = e.getProvidedColumnGroup().getLeafColumns(), r = {};
    t.forEach((s) => r[s.getId()] = s.isVisible());
    const n = [];
    this.beans.visibleColsService.getAllCols().forEach((s) => {
      t.indexOf(s) >= 0 && (n.push(s), Fr(t, s));
    }), t.forEach((s) => n.push(s));
    const i = [], o = e.getLeafColumns();
    for (const s of n)
      o.indexOf(s) !== -1 && i.push(s);
    return {
      columns: n,
      columnsInSplit: i,
      visibleState: r
    };
  }
  isSuppressMoving() {
    let e = !1;
    return this.column.getLeafColumns().forEach((r) => {
      (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (e = !0);
    }), e || this.gos.get("suppressMovableColumns");
  }
  destroy() {
    super.destroy();
  }
}, D4 = 0, bp = class extends J {
  constructor(e, t, r) {
    super(), this.instanceId = D4++, this.rowIndex = e, this.pinned = t, this.type = r;
    const n = r == "group" ? "ag-header-row-column-group" : r == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${n}`;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.isPrintLayout = ar(this.gos, "print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.getHeaderCellCtrls().every((e) => e.getGui() != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t, r = !0) {
    this.comp = e, t = Vc(this, this.beans.context, t), r && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners(t);
  }
  getHeaderRowClass() {
    return this.headerRowClass;
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(e) {
    const t = this.onRowHeightChanged.bind(this);
    e.addManagedEventListeners({
      columnResized: this.onColumnResized.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: (r) => this.onVirtualColumnsChanged(r.afterScroll),
      columnGroupHeaderHeightChanged: t,
      columnHeaderHeightChanged: t,
      gridStylesChanged: t,
      advancedFilterEnabledChanged: t
    }), e.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), e.addManagedPropertyListener("ensureDomOrder", (r) => this.isEnsureDomOrder = r.currentValue), e.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      t
    );
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls)
      return fd(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = ar(this.gos, "print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleColsService: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { columnModel: e, filterManager: t } = this.beans, r = [], n = e.getGroupRowsHeight(), i = e.getColumnHeaderRowHeight();
    r.push(...n), r.push(i), t != null && t.hasFloatingFilters() && r.push(e.getFloatingFiltersHeight());
    let o = 0;
    for (let a = 0; a < this.rowIndex; a++)
      o += r[a];
    const s = r[this.rowIndex];
    return { topOffset: o, rowHeight: s };
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getHeaderCtrls(), r = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, r, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const n of t)
      this.recycleAndCreateHeaderCtrls(n, e);
    const r = (n) => {
      const { focusService: i, visibleColsService: o } = this.beans;
      return i.isHeaderWrapperFocused(n) ? o.isVisible(n.getColumnGroupChild()) : !1;
    };
    if (e)
      for (const [n, i] of e)
        r(i) ? this.headerCellCtrls.set(n, i) : this.destroyBean(i);
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    var e;
    return Array.from(((e = this.headerCellCtrls) == null ? void 0 : e.values()) ?? []);
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup())
      return;
    const r = e.getUniqueId();
    let n;
    if (t && (n = t.get(r), t.delete(r)), n && n.getColumnGroupChild() != e && (this.destroyBean(n), n = void 0), n == null)
      switch (this.type) {
        case "filter": {
          n = this.createBean(
            this.beans.ctrlsFactory.getInstance(
              "headerFilterCell",
              e,
              this.beans,
              this
            )
          );
          break;
        }
        case "group":
          n = this.createBean(
            new T4(e, this.beans, this)
          );
          break;
        default:
          n = this.createBean(new A4(e, this.beans, this));
          break;
      }
    this.headerCellCtrls.set(r, n);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { columnViewportService: r } = this.beans;
    return ["left", null, "right"].forEach((n) => {
      const i = r.getHeadersToRender(n, t);
      e = e.concat(i);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.columnViewportService.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(e) {
    if (!this.headerCellCtrls)
      return;
    const t = this.getHeaderCellCtrls();
    let r;
    return typeof e == "function" ? r = t.find(e) : r = t.find((n) => n.getColumnGroupChild() == e), r;
  }
  focusHeader(e, t) {
    const r = this.findHeaderCellCtrl(e);
    return r ? r.focus(t) : !1;
  }
  destroy() {
    var e;
    (e = this.headerCellCtrls) == null || e.forEach((t) => {
      this.destroyBean(t);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
}, O4 = class extends J {
  constructor(e) {
    super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.focusService = e.focusService, this.filterManager = e.filterManager;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport);
    const r = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: r,
      advancedFilterEnabledChanged: r
    });
    const n = `${typeof this.pinned == "string" ? this.pinned : "center"}Header`;
    this.ctrlsService.register(n, this), this.columnModel.isReady() && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const t = new sa(), r = this.focusService.getFocusHeaderToUseAfterRefresh(), n = () => {
      const a = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let l = 0; l < a; l++) {
        const u = this.createBean(
          new bp(
            t.next(),
            this.pinned,
            "group"
            /* COLUMN_GROUP */
          )
        );
        this.groupsRowCtrls.push(u);
      }
    }, i = () => {
      const a = t.next(), l = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== a);
      (l || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), l && (this.columnsRowCtrl = this.createBean(new bp(
        a,
        this.pinned,
        "column"
        /* COLUMN */
      )));
    }, o = () => {
      var u;
      this.includeFloatingFilter = !!((u = this.filterManager) != null && u.hasFloatingFilters()) && !this.hidden;
      const a = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        a();
        return;
      }
      const l = t.next();
      if (this.filtersRowCtrl) {
        const d = this.filtersRowCtrl.getRowIndex() !== l;
        (!e || d) && a();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(
        new bp(
          l,
          this.pinned,
          "filter"
          /* FLOATING_FILTER */
        )
      ));
    };
    n(), i(), o();
    const s = this.getAllCtrls();
    this.comp.setCtrls(s), this.restoreFocusOnHeader(r);
  }
  getHeaderCtrlForColumn(e) {
    var t;
    if (go(e))
      return (t = this.columnsRowCtrl) == null ? void 0 : t.getHeaderCellCtrl(e);
    if (this.groupsRowCtrls.length !== 0)
      for (let r = 0; r < this.groupsRowCtrls.length; r++) {
        const n = this.groupsRowCtrls[r].getHeaderCellCtrl(e);
        if (n)
          return n;
      }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const r = this.getAllCtrls()[e];
    return r ? r.getType() : void 0;
  }
  focusHeader(e, t, r) {
    const i = this.getAllCtrls()[e];
    return i ? i.focusHeader(t, r) : !1;
  }
  getViewportElement() {
    return this.eViewport;
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(e) {
    return this.groupsRowCtrls[e];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
  setupDragAndDrop(e) {
    const t = new R4(this.pinned, e);
    this.createManagedBean(t);
  }
  restoreFocusOnHeader(e) {
    if (!e)
      return;
    const { column: t } = e;
    t.getPinned() == this.pinned && this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged() {
    var t;
    const e = ((t = this.filterManager) == null ? void 0 : t.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new Z0((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
  setupPinnedWidth() {
    if (this.pinned == null)
      return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = !0;
    const r = () => {
      const n = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (n == null)
        return;
      const i = n == 0, o = this.hidden !== i, s = this.gos.get("enableRtl"), a = this.scrollVisibleService.getScrollbarWidth(), u = this.scrollVisibleService.isVerticalScrollShowing() && (s && e || !s && t) ? n + a : n;
      this.comp.setPinnedContainerWidth(`${u}px`), this.comp.setDisplayed(!i), o && (this.hidden = i, this.refresh());
    };
    this.addManagedEventListeners({
      leftPinnedWidthChanged: r,
      rightPinnedWidthChanged: r,
      scrollVisibilityChanged: r,
      scrollbarWidthChanged: r
    });
  }
}, ty = class extends J {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, r = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
    this.view.updateLayoutClasses(r, t);
  }
  // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
  getDomLayout() {
    const e = this.gos.get("domLayout") ?? "normal";
    return ["normal", "print", "autoHeight"].indexOf(e) === -1 ? (ie(`${e} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : e;
  }
}, I4 = class extends vt {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`
    ), this.eOverlayWrapper = Fe, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeOverlayWrapperCssClass = null, this.elToFocusAfter = null;
  }
  wireBeans(e) {
    this.overlayService = e.overlayService, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  handleKeyDown(e) {
    if (e.key !== V.TAB || e.defaultPrevented || Mi(e) || this.focusService.findNextFocusableElement(this.eOverlayWrapper, !1, e.shiftKey))
      return;
    let r = !1;
    e.shiftKey ? r = this.focusService.focusGridView(Ye(this.visibleColsService.getAllCols()), !0, !1) : r = this.focusService.focusNextGridCoreContainer(!1), r && e.preventDefault();
  }
  updateLayoutClasses(e, t) {
    const r = this.eOverlayWrapper.classList;
    r.toggle("ag-layout-auto-height", t.autoHeight), r.toggle("ag-layout-normal", t.normal), r.toggle("ag-layout-print", t.print);
  }
  postConstruct() {
    this.createManagedBean(new ty(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.overlayService.setOverlayWrapperComp(this), this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeOverlayWrapperCssClass && t.toggle(this.activeOverlayWrapperCssClass, !1), this.activeOverlayWrapperCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, r, n) {
    if (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.elToFocusAfter = null, this.activePromise = e, !!e) {
      if (this.setDisplayed(!0, { skipAriaHidden: !0 }), r && this.focusService.isGridFocused()) {
        const i = Dt(this.gos);
        i && !pE(this.gos) && (this.elToFocusAfter = i);
      }
      e.then((i) => {
        if (this.activePromise !== e) {
          this.activeOverlay !== i && (this.destroyBean(i), i = null);
          return;
        }
        if (this.activePromise = null, !i)
          return;
        if (this.activeOverlay !== i && (this.eOverlayWrapper.appendChild(i.getGui()), this.activeOverlay = i, n)) {
          const s = i;
          this.updateListenerDestroyFunc = this.addManagedPropertyListener(n, ({ currentValue: a }) => {
            var l;
            (l = s.refresh) == null || l.call(s, this.gos.addGridCommonParams({ ...a ?? {} }));
          });
        }
        const o = this.focusService;
        r && o.isGridFocused() && o.focusInto(this.eOverlayWrapper);
      });
    }
  }
  updateOverlayWrapperPaddingTop(e) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${e}px`);
  }
  destroyActiveOverlay() {
    var n;
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    let t = this.elToFocusAfter;
    this.activeOverlay = null, this.elToFocusAfter = null, t && !this.focusService.isGridFocused() && (t = null);
    const r = this.updateListenerDestroyFunc;
    r && (r(), this.updateListenerDestroyFunc = null), this.destroyBean(e), nn(this.eOverlayWrapper), (n = t == null ? void 0 : t.focus) == null || n.call(t, { preventScroll: !0 });
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  destroy() {
    this.elToFocusAfter = null, this.destroyActiveOverlay(), this.overlayService.setOverlayWrapperComp(void 0), super.destroy();
  }
}, FP = class extends vt {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = Fe, this.eContainer = Fe, this.hideTimeout = null, this.setTemplate(e);
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", _E() || wo());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = NE(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.addOrRemoveCssClass("ag-scrollbar-active", !0), r = () => this.addOrRemoveCssClass("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: r,
      touchend: r
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewportElement();
    qN(
      () => li(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  getViewportElement() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
}, k4 = class extends FP {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
      "horizontal"
    ), this.eLeftSpacer = Fe, this.eRightSpacer = Fe;
  }
  wireBeans(e) {
    super.wireBeans(e), this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new Z0((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar)
      return;
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    let t = this.visibleColsService.getDisplayedColumnsRightWidth();
    const r = !this.enableRtl && e, n = this.scrollVisibleService.getScrollbarWidth();
    r && (t += n), Hn(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= n);
    let i = this.visibleColsService.getColsLeftWidth();
    this.enableRtl && e && (i += n), Hn(this.eLeftSpacer, i), this.eLeftSpacer.classList.toggle("ag-scroller-corner", i <= n);
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isHorizontalScrollShowing(), t = this.invisibleScrollbar, r = this.gos.get("suppressHorizontalScroll"), n = e && this.scrollVisibleService.getScrollbarWidth() || 0, o = r ? 0 : n === 0 && t ? 16 : n;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Vl(this.getGui(), o), Vl(this.eViewport, o), Vl(this.eContainer, o), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  getScrollPosition() {
    return Id(this.getViewportElement(), this.enableRtl);
  }
  setScrollPosition(e) {
    li(this.getViewportElement()) || this.attemptSettingScrollPosition(e), kd(this.getViewportElement(), e, this.enableRtl);
  }
}, MP = class extends J {
  wireBeans(e) {
    this.maxDivHeightScaler = e.rowContainerHeightService;
  }
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({ rowContainerHeightChanged: this.onHeightChanged.bind(this) });
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t);
  }
}, L4 = class extends FP {
  wireBeans(e) {
    super.wireBeans(e), this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  constructor() {
    super(
      /* html */
      `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
      "vertical"
    );
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new MP(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedEventListeners({ rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this) });
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isVerticalScrollShowing(), t = this.invisibleScrollbar, r = e && this.scrollVisibleService.getScrollbarWidth() || 0, n = r === 0 && t ? 16 : r;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Hn(this.getGui(), n), Hn(this.eViewport, n), Hn(this.eContainer, n), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged() {
    const { ctrlsService: e } = this, r = e.getGridBodyCtrl().getBodyViewportElement(), n = this.getScrollPosition(), i = r.scrollTop;
    n != i && this.setScrollPosition(i, !0);
  }
  getScrollPosition() {
    return this.getViewportElement().scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !li(this.getViewportElement()) && this.attemptSettingScrollPosition(e), this.getViewportElement().scrollTop = e;
  }
}, Fm = /* @__PURE__ */ ((e) => (e.FakeHScrollbar = "fakeHScrollComp", e.Header = "centerHeader", e.PinnedTop = "topCenter", e.PinnedBottom = "bottomCenter", e.StickyTop = "stickyTopCenter", e.StickyBottom = "stickyBottomCenter", e))(Fm || {}), _4 = class extends J {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = Ar(
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      500
    ), this.resetLastVScrollDebounced = Ar(() => this.lastScrollSource[
      0
      /* Vertical */
    ] = null, 500);
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.rowModel = e.rowModel, this.heightScaler = e.rowContainerHeightService, this.rowRenderer = e.rowRenderer, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    }), this.ctrlsService.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    this.addHorizontalScrollListeners(), this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.getViewportElement(), {
      scroll: this.onHScroll.bind(
        this,
        "Viewport"
        /* Viewport */
      )
    });
    for (const e of Object.values(Fm)) {
      const t = this.ctrlsService.get(e);
      this.registerScrollPartner(t, this.onHScroll.bind(this, e));
    }
  }
  addVerticalScrollListeners() {
    const e = this.ctrlsService.get("fakeVScrollComp"), t = this.gos.get("debounceVerticalScrollbar"), r = t ? Ar(this.onVScroll.bind(
      this,
      "Viewport"
      /* Viewport */
    ), 100) : this.onVScroll.bind(
      this,
      "Viewport"
      /* Viewport */
    ), n = t ? Ar(this.onVScroll.bind(
      this,
      "fakeVScrollComp"
      /* FakeVScrollbar */
    ), 100) : this.onVScroll.bind(
      this,
      "fakeVScrollComp"
      /* FakeVScrollbar */
    );
    this.addManagedElementListeners(this.eBodyViewport, { scroll: r }), this.registerScrollPartner(e, n);
  }
  registerScrollPartner(e, t) {
    e.onScrollCallback(t);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    this.centerRowsCtrl != null && (e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft()), this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)));
  }
  setScrollLeftForAllContainersExceptCurrent(e) {
    for (const t of [
      ...Object.values(Fm),
      "Viewport"
      /* Viewport */
    ]) {
      if (this.lastScrollSource[
        1
        /* Horizontal */
      ] === t)
        continue;
      const r = this.getViewportForSource(t);
      kd(r, e, this.enableRtl);
    }
  }
  getViewportForSource(e) {
    return e === "Viewport" ? this.centerRowsCtrl.getViewportElement() : this.ctrlsService.get(e).getViewportElement();
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (t === 0 ? this.lastScrollSource[0] = e : this.lastScrollSource[1] = e, !0) : this.lastScrollSource[t] === e;
  }
  onHScroll(e) {
    if (!this.isControllingScroll(
      e,
      1
      /* Horizontal */
    ))
      return;
    const t = this.centerRowsCtrl.getViewportElement(), { scrollLeft: r } = t;
    if (this.shouldBlockScrollUpdate(1, r, !0))
      return;
    const n = Id(this.getViewportForSource(e), this.enableRtl);
    this.doHorizontalScroll(n), this.resetLastHScrollDebounced();
  }
  onVScroll(e) {
    if (!this.isControllingScroll(
      e,
      0
      /* Vertical */
    ))
      return;
    let t;
    e === "Viewport" ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), !this.shouldBlockScrollUpdate(0, t, !0) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === "Viewport" ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      this.eventService.dispatchEvent({
        ...t,
        type: "bodyScrollEnd"
      });
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, r = !1) {
    return r && !wo() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = N0(this.eBodyViewport), { scrollHeight: r } = this.eBodyViewport;
    return e < 0 || e + t > r;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: r } = this.centerRowsCtrl.getViewportElement();
    if (this.enableRtl && Od()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > r;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScroll(
      "Viewport"
      /* Viewport */
    );
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const n = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && Od() ? e = e > 0 ? 0 : n : e = Math.min(Math.max(e, 0), n)), kd(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight, {
      top: this.lastScrollTop,
      bottom: this.lastScrollTop + this.lastOffsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const r = this.rowModel.getRowCount();
    let n = -1;
    for (let i = 0; i < r; i++) {
      const o = this.rowModel.getRow(i);
      if (typeof e == "function") {
        if (o && e(o)) {
          n = i;
          break;
        }
      } else if (e === o || e === o.data) {
        n = i;
        break;
      }
    }
    n >= 0 && this.ensureIndexVisible(n, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (ar(this.gos, "print"))
      return;
    const r = this.rowModel.getRowCount();
    if (typeof e != "number" || e < 0 || e >= r) {
      ie("Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const i = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.getFrameworkOverrides().wrapIncoming(() => {
      var d;
      i || (d = this.paginationService) == null || d.goToPageWithIndex(e);
      const o = this.ctrlsService.getGridBodyCtrl(), s = o.getStickyTopHeight(), a = o.getStickyBottomHeight(), l = this.rowModel.getRow(e);
      let u;
      do {
        const h = l.rowTop, f = l.rowHeight, p = this.pageBoundsService.getPixelOffset(), y = l.rowTop - p, C = y + l.rowHeight, v = this.getVScrollPosition(), w = this.heightScaler.getDivStretchOffset(), R = v.top + w, b = v.bottom + w, P = b - R, S = this.heightScaler.getScrollPositionForPixel(y), E = this.heightScaler.getScrollPositionForPixel(C - P), A = Math.min((S + E) / 2, y), M = R + s > y, I = b - a < C;
        let z = null;
        t === "top" ? z = S : t === "bottom" ? z = E : t === "middle" ? z = A : M ? z = S - s : I && (z = E + a), z !== null && (this.setVerticalScrollPosition(z), this.rowRenderer.redraw({ afterScroll: !0 })), u = h !== l.rowTop || f !== l.rowHeight;
      } while (u);
      this.animationFrameService.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const r = this.columnModel.getCol(e);
    if (!r || r.isPinned() || !this.visibleColsService.isColDisplayed(r))
      return;
    const n = this.getPositionedHorizontalScroll(r, t);
    this.getFrameworkOverrides().wrapIncoming(() => {
      n !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(n), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
    });
  }
  setScrollPosition(e, t) {
    this.getFrameworkOverrides().wrapIncoming(() => {
      this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({ afterScroll: !0 }), this.animationFrameService.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: r, columnAfterEnd: n } = this.isColumnOutsideViewport(e), i = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), o = this.centerRowsCtrl.getCenterWidth(), s = this.enableRtl;
    let a = (s ? r : n) || i, l = s ? n : r;
    t !== "auto" && (a = t === "start", l = t === "end");
    const u = t === "middle";
    if (a || l || u) {
      const { colLeft: d, colMiddle: h, colRight: f } = this.getColumnBounds(e);
      return u ? h - o / 2 : a ? s ? f : d : s ? d - o : f - o;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: r } = this.getViewportBounds(), { colLeft: n, colRight: i } = this.getColumnBounds(e), o = this.enableRtl, s = o ? t > i : r < i, a = o ? r < n : t > n;
    return { columnBeforeStart: s, columnAfterEnd: a };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, r = this.visibleColsService.getBodyContainerWidth(), n = e.getActualWidth(), i = e.getLeft(), o = t ? -1 : 1, s = t ? r - i : i, a = s + n * o, l = s + n / 2 * o;
    return { colLeft: s, colMiddle: l, colRight: a };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), r = t, n = e + t;
    return { start: r, end: n, width: e };
  }
}, z4 = class extends J {
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.ctrlsService = e.ctrlsService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.columnViewportService = e.columnViewportService;
  }
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const e = () => {
      this.animationFrameService.requestAnimationFrame(() => {
        this.onCenterViewportResized();
      });
    };
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.scrollVisibleService.onCentreViewportResized(), this.centerContainerCtrl.isViewportInTheDOMTree()) {
      this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnSizeService.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = jc(e);
    if (t <= 50)
      return;
    let r = this.getPinnedColumnsOverflowingViewport(t - 50);
    const n = this.gos.getCallback("processUnpinnedColumns");
    r.length && (n && (r = n({
      columns: r,
      viewportWidth: t
    })), this.columnModel.setColsPinned(r, null, "viewportSizeFeature"));
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.pinnedWidthService.getPinnedRightWidth(), r = this.pinnedWidthService.getPinnedLeftWidth(), n = t + r;
    if (n < e)
      return [];
    const i = [...this.visibleColsService.getLeftCols()], o = [...this.visibleColsService.getRightCols()];
    let s = 0, a = 0;
    const l = 0, u = [];
    let d = n - l - e;
    for (; (a < i.length || s < o.length) && d > 0; ) {
      if (s < o.length) {
        const h = o[s++];
        d -= h.getActualWidth(), u.push(h);
      }
      if (a < i.length && d > 0) {
        const h = i[a++];
        d -= h.getActualWidth(), u.push(h);
      }
    }
    return u;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = N0(e);
    this.bodyHeight !== t && (this.bodyHeight = t, this.eventService.dispatchEvent({
      type: "bodyHeightChanged"
    }));
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnViewportService.setScrollPosition(e, t);
  }
}, N4 = class extends J {
  wireBeans(e) {
    this.dragService = e.dragService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.rangeService)
      return;
    this.params = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    }, this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
      Ii(this.gos) ? this.enableFeature() : this.disableFeature();
    }), this.addDestroyFunc(() => this.disableFeature()), Ii(this.gos) && this.enableFeature();
  }
  enableFeature() {
    this.dragService.addDragSource(this.params);
  }
  disableFeature() {
    this.dragService.removeDragSource(this.params);
  }
}, B4 = class extends vt {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [V0]
    ), this.eCheckbox = Fe;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), r = k0(e, t), [n, i] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], o = e(n, i);
    this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${o} (${r})`);
  }
  onClicked(e, t, r) {
    return this.rowNode.setSelectedParams({
      newValue: e,
      rangeSelect: r.shiftKey,
      groupSelectsFiltered: t,
      event: r,
      source: "checkboxSelected"
    });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: (n) => ia(n),
      click: (n) => {
        ia(n);
        const i = M0(this.gos) === "filteredDescendants", o = this.eCheckbox.getValue();
        this.shouldHandleIndeterminateState(o, i) ? this.onClicked(!0, i, n || {}) === 0 && this.onClicked(!1, i, n) : o ? this.onClicked(!1, i, n) : this.onClicked(!0, i, n || {});
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), F0(this.gos) || typeof this.getIsVisible() == "function") {
      const n = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: n }), this.addManagedListeners(this.rowNode, {
        dataChanged: n,
        cellChanged: n
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && At(this.gos);
  }
  showOrHideSelect() {
    var i, o, s;
    let e = this.rowNode.selectable;
    const t = this.getIsVisible();
    if (e)
      if (typeof t == "function") {
        const a = (i = this.overrides) == null ? void 0 : i.callbackParams;
        if (!this.column)
          e = t({ ...a, node: this.rowNode, data: this.rowNode.data });
        else {
          const l = this.column.createColumnFunctionCallbackParams(this.rowNode);
          e = t({ ...a, ...l });
        }
      } else
        e = t ?? !1;
    const r = this.gos.get("rowSelection");
    if (r && typeof r != "string" ? !ZN(r) : (o = this.column) == null ? void 0 : o.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!e), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if ((s = this.overrides) != null && s.removeHidden) {
      this.setDisplayed(e);
      return;
    }
    this.setVisible(e);
  }
  getIsVisible() {
    var t, r;
    if (this.overrides)
      return this.overrides.isVisible;
    const e = this.gos.get("rowSelection");
    return e && typeof e != "string" ? na(e) : (r = (t = this.column) == null ? void 0 : t.getColDef()) == null ? void 0 : r.checkboxSelection;
  }
}, G4 = class extends vt {
  constructor(e, t, r) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = r;
  }
  postConstruct() {
    this.getGui().appendChild(tn("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const r = () => {
      try {
        const n = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", n), e.dataTransfer.setData("text/plain", n);
      } catch {
      }
    };
    if (t) {
      const n = this.gos.addGridCommonParams({
        rowNode: this.rowNode,
        dragEvent: e
      });
      t(n);
    } else
      r();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
}, H4 = class extends J {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), { cellClassRules: t } = e, r = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef: e,
      column: this.column,
      rowIndex: this.rowNode.rowIndex
    });
    this.beans.stylingService.processClassRules(
      // if current was previous, skip
      t === this.cellClassRules ? void 0 : this.cellClassRules,
      t,
      r,
      (n) => this.cellComp.addOrRemoveCssClass(n, !0),
      (n) => this.cellComp.addOrRemoveCssClass(n, !1)
    ), this.cellClassRules = t;
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle)
      return;
    let t;
    if (typeof e.cellStyle == "function") {
      const r = this.beans.gos.addGridCommonParams({
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef: e,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      }), n = e.cellStyle;
      t = n(r);
    } else
      t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef: e,
      rowIndex: this.rowNode.rowIndex
    });
    this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !0));
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, W4 = class extends J {
  constructor(e, t, r, n, i) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = n, this.rowCtrl = i;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case V.ENTER:
        this.onEnterKeyDown(e);
        break;
      case V.F2:
        this.onF2KeyDown(e);
        break;
      case V.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case V.TAB:
        this.onTabKeyDown(e);
        break;
      case V.BACKSPACE:
      case V.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case V.DOWN:
      case V.UP:
      case V.RIGHT:
      case V.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService)
      return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    const { cellCtrl: r, beans: n, rowNode: i } = this, { gos: o, rangeService: s, eventService: a } = n;
    if (!r.isEditing()) {
      if (a.dispatchEvent({ type: "keyShortcutChangedCellStart" }), RG(e, o.get("enableCellEditingOnBackspace"))) {
        if (s && Ii(o))
          s.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (r.isCellEditable()) {
          const l = r.getColumn(), u = this.beans.valueService.getDeleteValue(l, i);
          i.setDataValue(l, u, "cellClear");
        }
      } else
        r.startRowOrCellEdit(e, t);
      a.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
      this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
    else if (this.beans.gos.get("enterNavigatesVertically")) {
      const t = e.shiftKey ? V.UP : V.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1);
    } else
      this.cellCtrl.startRowOrCellEdit(V.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(V.F2, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing())
      return;
    const n = e.key;
    n === " " ? this.onSpaceKeyDown(e) : this.cellCtrl.startRowOrCellEdit(n, e) && e.preventDefault();
  }
  onSpaceKeyDown(e) {
    const { gos: t } = this.beans;
    if (!this.cellCtrl.isEditing() && Rd(t)) {
      const r = this.rowNode.isSelected(), n = !r, i = M0(t) === "filteredDescendants", o = this.rowNode.setSelectedParams({
        newValue: n,
        rangeSelect: e.shiftKey,
        groupSelectsFiltered: i,
        event: e,
        source: "spaceKey"
      });
      r === void 0 && o === 0 && this.rowNode.setSelectedParams({
        newValue: !1,
        rangeSelect: e.shiftKey,
        groupSelectsFiltered: i,
        event: e,
        source: "spaceKey"
      });
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, V4 = class extends J {
  constructor(e, t, r) {
    super(), this.cellCtrl = e, this.beans = t, this.column = r;
  }
  onMouseEvent(e, t) {
    if (!Mi(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: r, gos: n } = this.beans, i = e.ctrlKey || e.metaKey;
    r && i && r.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && r.intersectLastRange(!0);
    const o = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(o);
    const s = this.column.getColDef();
    s.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        s.onCellClicked(o);
      });
    }, 0), (n.get("singleClickEdit") || s.singleClickEdit) && !n.get("suppressClickEdit") && !(e.shiftKey && (r == null ? void 0 : r.getCellRanges().length) != 0) && this.cellCtrl.startRowOrCellEdit();
  }
  // returns true if on iPad and this is second 'click' event in 200ms
  isDoubleClickOnIPad() {
    if (!wo() || xE("dblclick"))
      return !1;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: r, cellCtrl: n } = this, { eventService: i, frameworkOverrides: o, gos: s } = r, a = t.getColDef(), l = n.createEvent(e, "cellDoubleClicked");
    i.dispatchEvent(l), typeof a.onCellDoubleClicked == "function" && window.setTimeout(() => {
      o.wrapOutgoing(() => {
        a.onCellDoubleClicked(l);
      });
    }, 0), !s.get("singleClickEdit") && !s.get("suppressClickEdit") && n.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: r, shiftKey: n } = e, i = e.target, { cellCtrl: o, beans: s } = this, { eventService: a, rangeService: l, focusService: u, gos: d } = s;
    if (this.isRightClickInExistingRange(e))
      return;
    const h = l && l.getCellRanges().length != 0;
    if (!n || !h) {
      const p = d.get("enableCellTextSelection") && e.defaultPrevented, y = (ai() || p) && !o.isEditing() && !z0(i);
      o.focusCell(y);
    }
    if (n && h && !u.isCellFocused(o.getCellPosition())) {
      e.preventDefault();
      const f = u.getFocusedCell();
      if (f) {
        const { column: p, rowIndex: y, rowPinned: C } = f, v = s.rowRenderer.getRowByPosition({ rowIndex: y, rowPinned: C }), w = v == null ? void 0 : v.getCellCtrl(p);
        w != null && w.isEditing() && w.stopEditing(), u.setFocusedCell({
          column: p,
          rowIndex: y,
          rowPinned: C,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!this.containsWidget(i)) {
      if (l) {
        const f = this.cellCtrl.getCellPosition();
        if (n)
          l.extendLatestRangeToCell(f);
        else {
          const p = t || r;
          l.setRangeToCell(f, p);
        }
      }
      a.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    if (t) {
      const r = t.isCellInAnyRange(this.cellCtrl.getCellPosition()), n = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (r && n)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Xs(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    this.mouseStayingInsideCell(e) || (this.beans.eventService.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOut")), this.beans.columnHoverService.clearMouseOver());
  }
  onMouseOver(e) {
    this.mouseStayingInsideCell(e) || (this.beans.eventService.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOver")), this.beans.columnHoverService.setMouseOver([this.column]));
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.getGui(), r = t.contains(e.target), n = t.contains(e.relatedTarget);
    return r && n;
  }
  destroy() {
    super.destroy();
  }
}, $4 = class extends J {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    Co(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventService, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1)
      t.push(this.column);
    else {
      let r = this.column;
      const n = this.column.getPinned();
      for (let i = 0; r && i < e && (t.push(r), r = this.beans.visibleColsService.getColAfter(r), !(!r || Ke(r) || n !== r.getPinned())); i++)
        ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = Ye(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left")
      return e;
    const t = this.beans.visibleColsService.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const r = this.beans.visibleColsService.getBodyContainerWidth();
      return t + r + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const r = Zo(this.beans.gos) * this.rowSpan;
    this.eGui.style.height = `${r}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, Sl = "ag-cell-range-selected", j4 = "ag-cell-range-chart", U4 = "ag-cell-range-single-cell", K4 = "ag-cell-range-chart-category", q4 = "ag-cell-range-handle", Y4 = "ag-cell-range-top", J4 = "ag-cell-range-right", X4 = "ag-cell-range-bottom", Q4 = "ag-cell-range-left", Z4 = class {
  constructor(e, t) {
    this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onCellSelectionChanged();
  }
  onCellSelectionChanged() {
    this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(Sl, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${Sl}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${Sl}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${Sl}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${Sl}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(j4, this.hasChartRange), Td(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(U4, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), r = !t && e.top, n = !t && e.right, i = !t && e.bottom, o = !t && e.left;
    this.cellComp.addOrRemoveCssClass(Y4, r), this.cellComp.addOrRemoveCssClass(J4, n), this.cellComp.addOrRemoveCssClass(X4, i), this.cellComp.addOrRemoveCssClass(Q4, o);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((r) => es([
      1,
      0
      /* VALUE */
    ], r.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = !1, r = !1, n = !1, i = !1;
    const o = this.cellCtrl.getCellPosition().column, s = this.beans.visibleColsService;
    let a, l;
    e ? (a = s.getColAfter(o), l = s.getColBefore(o)) : (a = s.getColBefore(o), l = s.getColAfter(o));
    const u = this.rangeService.getCellRanges().filter((d) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), d));
    a || (i = !0), l || (r = !0);
    for (let d = 0; d < u.length && !(t && r && n && i); d++) {
      const h = u[d], f = this.rangeService.getRangeStartRow(h), p = this.rangeService.getRangeEndRow(h);
      !t && this.beans.rowPositionUtils.sameRow(f, this.cellCtrl.getCellPosition()) && (t = !0), !n && this.beans.rowPositionUtils.sameRow(p, this.cellCtrl.getCellPosition()) && (n = !0), !i && a && h.columns.indexOf(a) < 0 && (i = !0), !r && l && h.columns.indexOf(l) < 0 && (r = !0);
    }
    return { top: t, right: r, bottom: n, left: i };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed())
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(q4, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeService.getCellRanges(), r = t.length;
    if (this.rangeCount < 1 || r < 1)
      return !1;
    const n = Ye(t), i = this.cellCtrl.getCellPosition(), o = rS(e) && !this.cellCtrl.isSuppressFillHandle(), s = nB(e);
    let a = r === 1 && !this.cellCtrl.isEditing() && (o || s);
    if (this.hasChartRange) {
      const u = t[0].type === 1 && this.rangeService.isCellInSpecificRange(i, t[0]);
      this.cellComp.addOrRemoveCssClass(K4, u), a = n.type === 0;
    }
    return a && n.endRow != null && this.rangeService.isContiguousRange(n) && this.rangeService.isBottomRightCell(n, i);
  }
  addSelectionHandle() {
    const e = Ye(this.rangeService.getCellRanges()).type, r = rS(this.beans.gos) && Ke(e) ? 0 : 1;
    this.selectionHandle && this.selectionHandle.getType() !== r && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(r)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, e6 = "ag-cell", t6 = "ag-cell-auto-height", r6 = "ag-cell-normal-height", n6 = "ag-cell-focus", i6 = "ag-cell-first-right-pinned", o6 = "ag-cell-last-left-pinned", s6 = "ag-cell-not-inline-editing", a6 = "ag-column-hover", l6 = "ag-cell-wrap-text", c6 = 0, TP = class Mm extends J {
  constructor(t, r, n, i) {
    super(), this.column = t, this.rowNode = r, this.beans = n, this.rowCtrl = i, this.cellRangeFeature = void 0, this.cellPositionFeature = void 0, this.cellCustomStyleFeature = void 0, this.tooltipFeature = void 0, this.cellMouseListenerFeature = void 0, this.cellKeyboardListenerFeature = void 0, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.onCellEditorAttachedFuncs = [], this.instanceId = t.getId() + "-" + c6++, this.colIdSanitised = ni(this.column.getId()), this.createCellPosition(), this.updateAndFormatValue(!1);
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  onFocusOut() {
    this.beans.focusService.clearRestoreFocus();
  }
  addFeatures() {
    this.cellPositionFeature = new $4(this, this.beans), this.cellCustomStyleFeature = new H4(this, this.beans), this.cellMouseListenerFeature = new V4(this, this.beans, this.column), this.cellKeyboardListenerFeature = new W4(
      this,
      this.beans,
      this.column,
      this.rowNode,
      this.rowCtrl
    ), this.column.isTooltipEnabled() && this.enableTooltipFeature(), this.beans.rangeService && Ii(this.beans.gos) && (this.cellRangeFeature = new Z4(this.beans, this));
  }
  removeFeatures() {
    const t = this.beans.context;
    this.cellPositionFeature = t.destroyBean(this.cellPositionFeature), this.cellCustomStyleFeature = t.destroyBean(this.cellCustomStyleFeature), this.cellMouseListenerFeature = t.destroyBean(this.cellMouseListenerFeature), this.cellKeyboardListenerFeature = t.destroyBean(this.cellKeyboardListenerFeature), this.cellRangeFeature = t.destroyBean(this.cellRangeFeature), this.disableTooltipFeature();
  }
  enableTooltipFeature(t, r) {
    const n = () => {
      const s = this.column.getColDef(), a = this.rowNode.data;
      if (s.tooltipField && de(a))
        return Wl(a, s.tooltipField, this.column.isTooltipFieldContainsDots());
      const l = s.tooltipValueGetter;
      return l ? l(
        this.beans.gos.addGridCommonParams({
          location: "cell",
          colDef: this.column.getColDef(),
          column: this.column,
          rowIndex: this.cellPosition.rowIndex,
          node: this.rowNode,
          data: this.rowNode.data,
          value: this.value,
          valueFormatted: this.valueFormatted
        })
      ) : null;
    }, i = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
    !r && i && !this.isCellRenderer() && (r = () => {
      const s = this.getGui(), a = s.children.length === 0 ? s : s.querySelector(".ag-cell-value");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue: t != null ? () => t : n,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => this.valueFormatted,
      shouldDisplayTooltip: r
    };
    this.tooltipFeature = new Ba(o, this.beans);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  setComp(t, r, n, i, o, s) {
    var a, l, u, d;
    this.cellComp = t, this.eGui = r, this.printLayout = i, s ?? (s = this), this.addDomData(s), this.addFeatures(), s.addDestroyFunc(() => this.removeFeatures()), this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(n, s), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (a = this.cellPositionFeature) == null || a.setComp(r), (l = this.cellCustomStyleFeature) == null || l.setComp(t), (u = this.tooltipFeature) == null || u.refreshToolTip(), (d = this.cellKeyboardListenerFeature) == null || d.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), o && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((h) => h()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(t, r) {
    if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !t)
      return;
    const n = t.parentElement, i = ho(this.beans.gos, this.rowNode).height, o = (l) => {
      if (this.editing || !this.isAlive() || !r.isAlive())
        return;
      const { paddingTop: u, paddingBottom: d, borderBottomWidth: h, borderTopWidth: f } = fs(n), p = u + d + h + f, C = t.offsetHeight + p;
      if (l < 5) {
        const w = zt(this.beans.gos), R = !w || !w.contains(t), b = C == 0;
        if (R || b) {
          window.setTimeout(() => o(l + 1), 0);
          return;
        }
      }
      const v = Math.max(C, i);
      this.rowNode.setRowAutoHeight(v, this.column);
    }, s = () => o(0);
    s();
    const a = this.beans.resizeObserverService.observeResize(t, s);
    r.addDestroyFunc(() => {
      a(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const t = this.column.getColDef();
    return t.cellRenderer != null || t.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(t = !1) {
    var f;
    const { beans: r, column: n, rowNode: i, cellRangeFeature: o, cellComp: s } = this, { userComponentFactory: a, animationFrameService: l } = r, u = this.getValueToDisplay();
    let d;
    if (i.stub && ((f = i.groupData) == null ? void 0 : f[this.column.getId()]) == null) {
      const p = this.createCellRendererParams();
      d = a.getLoadingCellRendererDetails(n.getColDef(), p);
    } else if (this.isCellRenderer()) {
      const p = this.createCellRendererParams();
      d = a.getCellRendererDetails(n.getColDef(), p);
    }
    s.setRenderDetails(d, u, t), l.requestAnimationFrame(() => o == null ? void 0 : o.refreshHandle());
  }
  setupControlComps() {
    const t = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(t)), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(t) {
    return this.rowNode.rowPinned != null ? !1 : typeof t == "function" || t === !0;
  }
  isCheckboxSelection(t) {
    const { rowSelection: r } = this.beans.gridOptions;
    return t.checkboxSelection || Kh(this.column) && r && typeof r != "string" && na(r);
  }
  refreshShouldDestroy() {
    const t = this.column.getColDef(), r = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(t)), n = this.includeRowDrag != this.isIncludeControl(t.rowDrag), i = this.includeDndSource != this.isIncludeControl(t.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return r || n || i || o;
  }
  // either called internally if single cell editing, or called by rowRenderer if row editing
  startEditing(t = null, r = !1, n = null) {
    const { editService: i } = this.beans;
    return !this.isCellEditable() || this.editing || !i ? !0 : this.cellComp ? i.startEditing(this, t, r, n) : (this.onCellCompAttachedFuncs.push(() => {
      this.startEditing(t, r, n);
    }), !0);
  }
  setEditing(t, r) {
    this.editCompDetails = r, this.editing !== t && (this.editing = t);
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(t = !1) {
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.stopEditing(t) : this.stopEditing(t);
  }
  onPopupEditorClosed() {
    this.editing && this.stopEditingAndFocus();
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(t = !1) {
    this.onCellEditorAttachedFuncs = [];
    const { editService: r } = this.beans;
    return !this.editing || !r ? !1 : r.stopEditing(this, t);
  }
  createCellRendererParams() {
    return this.beans.gos.addGridCommonParams({
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.beans.valueService.getValueForDisplay(this.column, this.rowNode),
      setValue: (r) => this.beans.valueService.setValue(this.rowNode, this.column, r),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (r, n, i, o) => this.registerRowDragger(r, n, o),
      setTooltip: (r, n) => {
        var i;
        this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(r, n), (i = this.tooltipFeature) == null || i.refreshToolTip();
      }
    });
  }
  setFocusOutOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusOutOnEditor(this));
  }
  setFocusInOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusInOnEditor(this));
  }
  onCellChanged(t) {
    t.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(t) {
    var r;
    this.refreshShouldDestroy() ? (r = this.rowCtrl) == null || r.recreateCell(this) : this.refreshCell(t);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(t) {
    var d, h, f, p, y;
    if (this.suppressRefreshCell || this.editing)
      return;
    const r = this.column.getColDef(), n = t != null && !!t.newData, i = t != null && !!t.suppressFlash || !!r.suppressCellFlash, o = r.field == null && r.valueGetter == null && r.showRowGroup == null, s = t && t.forceRefresh || o || n, a = !!this.cellComp, l = this.updateAndFormatValue(a), u = s || l;
    if (a) {
      if (u) {
        this.showValue(n);
        const C = (d = this.beans.filterManager) == null ? void 0 : d.isSuppressFlashingCellsBecauseFiltering();
        !i && !C && (this.beans.gos.get("enableCellChangeFlash") || r.enableCellChangeFlash) && this.flashCell(), (h = this.cellCustomStyleFeature) == null || h.applyUserStyles(), (f = this.cellCustomStyleFeature) == null || f.applyClassesFromColDef();
      }
      (p = this.tooltipFeature) == null || p.refreshToolTip(), (y = this.cellCustomStyleFeature) == null || y.applyCellClassRules();
    }
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(t = !1, r = !1) {
    var n;
    (n = this.beans.editService) == null || n.stopEditingAndFocus(this, t, r);
  }
  // user can also call this via API
  flashCell(t) {
    const r = (t == null ? void 0 : t.flashDuration) ?? (t == null ? void 0 : t.flashDelay), n = (t == null ? void 0 : t.fadeDuration) ?? (t == null ? void 0 : t.fadeDelay);
    this.animateCell("data-changed", r, n);
  }
  animateCell(t, r, n) {
    if (!this.cellComp)
      return;
    const { gos: i } = this.beans;
    if (r || (r = i.get("cellFlashDuration")), r === 0)
      return;
    de(n) || (n = i.get("cellFadeDuration"));
    const o = `ag-cell-${t}`, s = `ag-cell-${t}-animation`;
    this.cellComp.addOrRemoveCssClass(o, !0), this.cellComp.addOrRemoveCssClass(s, !1), this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(o, !1), this.cellComp.addOrRemoveCssClass(s, !0), this.eGui.style.transition = `background-color ${n}ms`, window.setTimeout(() => {
          this.isAlive() && (this.cellComp.addOrRemoveCssClass(s, !1), this.eGui.style.transition = "");
        }, n));
      }, r);
    });
  }
  onFlashCells(t) {
    if (!this.cellComp)
      return;
    const r = this.beans.cellPositionUtils.createId(this.getCellPosition());
    t.cells[r] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(t) {
    return this.callValueFormatter(t) ?? t;
  }
  callValueFormatter(t) {
    return this.beans.valueService.formatValue(this.column, this.rowNode, t);
  }
  updateAndFormatValue(t) {
    const r = this.value, n = this.valueFormatted;
    return this.value = this.beans.valueService.getValueForDisplay(this.column, this.rowNode), this.valueFormatted = this.callValueFormatter(this.value), t ? !this.valuesAreEqual(r, this.value) || this.valueFormatted != n : !0;
  }
  valuesAreEqual(t, r) {
    const n = this.column.getColDef();
    return n.equals ? n.equals(t, r) : t === r;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  addDomData(t) {
    const r = this.getGui();
    as(this.beans.gos, r, Mm.DOM_DATA_KEY_CELL_CTRL, this), t.addDestroyFunc(() => as(this.beans.gos, r, Mm.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(t, r) {
    return this.beans.gos.addGridCommonParams({
      type: r,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      rowPinned: this.rowNode.rowPinned,
      event: t,
      rowIndex: this.rowNode.rowIndex
    });
  }
  processCharacter(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.processCharacter(t);
  }
  onKeyDown(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.onKeyDown(t);
  }
  onMouseEvent(t, r) {
    var n;
    (n = this.cellMouseListenerFeature) == null || n.onMouseEvent(t, r);
  }
  getGui() {
    return this.eGui;
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var t;
    this.cellComp && ((t = this.cellPositionFeature) == null || t.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { cellComp: t, column: r, beans: n } = this;
    CP(t, r, n.visibleColsService);
  }
  refreshAriaColIndex() {
    const t = this.beans.visibleColsService.getAriaColIndex(this.column);
    kE(this.getGui(), t);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var t;
    return (t = this.cellPositionFeature) == null ? void 0 : t.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(t, r = null) {
    return this.cellComp ? this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(t, this) : this.startEditing(t, !0, r) : (this.onCellCompAttachedFuncs.push(() => {
      this.startRowOrCellEdit(t, r);
    }), !0);
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onCellSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onCellSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(t = !1) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: t
    });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onCellSelectionChanged();
  }
  onSuppressCellFocusChanged(t) {
    this.eGui && xn(this.eGui, "tabindex", t ? void 0 : -1);
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(i6, t);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(o6, t);
  }
  onCellFocused(t) {
    if (this.beans.focusService.isCellFocusSuppressed())
      return;
    const r = this.beans.focusService.isCellFocused(this.cellPosition);
    if (!this.cellComp) {
      r && (t != null && t.forceBrowserFocus) && (this.focusEventToRestore = t);
      return;
    }
    if (this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass(n6, r), r && t && t.forceBrowserFocus) {
      let i = this.cellComp.getFocusableElement();
      if (this.editing) {
        const o = this.beans.focusService.findFocusableElements(i, null, !0);
        o.length && (i = o[0]);
      }
      i.focus({ preventScroll: !!t.preventScrollOnBrowserFocus });
    }
    const n = this.beans.gos.get("editType") === "fullRow";
    !r && !n && this.editing && this.stopRowOrCellEdit(), r && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: Fi(this.rowNode.rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(e6, !0), this.cellComp.addOrRemoveCssClass(s6, !0);
    const t = this.column.isAutoHeight() == !0;
    this.cellComp.addOrRemoveCssClass(t6, t), this.cellComp.addOrRemoveCssClass(r6, !t);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gos.get("columnHoverHighlight"))
      return;
    const t = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(a6, t);
  }
  onColDefChanged() {
    var r;
    if (!this.cellComp)
      return;
    this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (r = this.beans.editService) == null || r.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 });
  }
  setWrapText() {
    const t = this.column.getColDef().wrapText == !0;
    this.cellComp.addOrRemoveCssClass(l6, t);
  }
  dispatchCellContextMenuEvent(t) {
    const r = this.column.getColDef(), n = this.createEvent(t, "cellContextMenu");
    this.beans.eventService.dispatchEvent(n), r.onCellContextMenu && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        r.onCellContextMenu(n);
      });
    }, 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], this.onCellEditorAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const t = new B4();
    return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
  }
  createDndSource() {
    const t = new G4(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(t), t;
  }
  registerRowDragger(t, r, n) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(t, r);
      return;
    }
    const i = this.createRowDragComp(t, r, n);
    i && (this.customRowDragComp = i, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(i), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(t, r, n) {
    const i = this.beans.gos.get("pagination"), o = this.beans.gos.get("rowDragManaged"), s = At(this.beans.gos);
    if (o) {
      if (!s) {
        ie("managed row dragging is only allowed in the Client Side Row Model");
        return;
      }
      if (i) {
        ie("managed row dragging is not possible when doing pagination");
        return;
      }
    }
    const a = new xm(
      () => this.value,
      this.rowNode,
      this.column,
      t,
      r,
      n
    );
    return this.beans.context.createBean(a), a;
  }
  setSuppressRefreshCell(t) {
    this.suppressRefreshCell = t;
  }
  getEditCompDetails() {
    return this.editCompDetails;
  }
  onCellEditorAttached(t) {
    this.onCellEditorAttachedFuncs.push(t);
  }
  cellEditorAttached() {
    this.onCellEditorAttachedFuncs.forEach((t) => t()), this.onCellEditorAttachedFuncs = [];
  }
};
TP.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var ts = TP, u6 = 0, DP = class Tm extends J {
  constructor(t, r, n, i, o) {
    var s;
    super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKeySanitised = null, this.beans = r, this.gos = r.gos, this.rowNode = t, this.paginationPage = ((s = r.paginationService) == null ? void 0 : s.getCurrentPage()) ?? 0, this.useAnimationFrameForCreate = i, this.printLayout = o, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = t.id + "-" + u6++, this.rowId = ni(t.id), this.initRowBusinessKey(), this.rowFocused = r.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = r.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(n), this.rowStyles = this.processStylesFromGridOptions(), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const t = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = ni(t);
  }
  getRowId() {
    return this.rowId;
  }
  getRowStyles() {
    return this.rowStyles;
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  updateGui(t, r) {
    t === "left" ? this.leftGui = r : t === "right" ? this.rightGui = r : t === "fullWidth" ? this.fullWidthGui = r : this.centerGui = r;
  }
  setComp(t, r, n, i) {
    i = Vc(this, this.beans.context, i);
    const o = { rowComp: t, element: r, containerType: n, compBean: i };
    this.allRowGuis.push(o), this.updateGui(n, o), this.initialiseRowComp(o), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(t) {
    this.allRowGuis = this.allRowGuis.filter((r) => r.containerType !== t), this.updateGui(t, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(t) {
    const r = t ? "none" : "";
    this.allRowGuis.forEach((n) => n.element.style.display = r);
  }
  initialiseRowComp(t) {
    const r = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(!1, t), Rd(r) && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const n = t.rowComp;
    this.getInitialRowClasses(t.containerType).forEach((o) => n.addOrRemoveCssClass(o, !0)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && Md(t.element, this.rowNode.expanded == !0), this.setRowCompRowId(n), this.setRowCompRowBusinessKey(n), as(r, t.element, Tm.DOM_DATA_KEY_ROW_CTRL, this), t.compBean.addDestroyFunc(() => as(r, t.element, Tm.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(
      this.addHoverFunctionality.bind(this, t),
      this.rowNode.rowIndex,
      "createTasksP2"
    ) : this.addHoverFunctionality(t), this.isFullWidth() && this.setupFullWidth(t), r.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(t) {
    this.businessKeySanitised != null && t.setRowBusinessKey(this.businessKeySanitised);
  }
  getBusinessKey() {
    return this.businessKeySanitised;
  }
  setRowCompRowId(t) {
    this.rowId = ni(this.rowNode.id), this.rowId != null && t.setRowId(this.rowId);
  }
  executeSlideAndFadeAnimations(t) {
    const { containerType: r } = t;
    this.slideInAnimation[r] && (eS(() => {
      this.onTopChanged();
    }), this.slideInAnimation[r] = !1), this.fadeInAnimation[r] && (eS(() => {
      t.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[r] = !1);
  }
  addRowDraggerToRow(t) {
    if (Ii(this.gos)) {
      ie("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `cellSelection: true`");
      return;
    }
    const r = this.beans.localeService.getLocaleTextFunc(), n = new xm(
      () => `1 ${r("rowDragRow", "row")}`,
      this.rowNode,
      void 0,
      t.element,
      void 0,
      !0
    ), i = this.createBean(n, this.beans.context);
    this.rowDragComps.push(i), t.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((o) => o !== i), this.destroyBean(i, this.beans.context);
    });
  }
  setupFullWidth(t) {
    const r = this.getPinnedForContainer(t.containerType);
    if (this.rowType == "FullWidthDetail" && !this.gos.assertModuleRegistered(
      "@ag-grid-enterprise/master-detail",
      "cell renderer 'agDetailCellRenderer' (for master detail)"
    ))
      return;
    const n = this.createFullWidthCompDetails(t.element, r);
    t.rowComp.showFullWidth(n);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderers() {
    var t, r;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((n) => {
      var i;
      return (i = n == null ? void 0 : n.rowComp) == null ? void 0 : i.getFullWidthCellRenderer();
    }) : [(r = (t = this.fullWidthGui) == null ? void 0 : t.rowComp) == null ? void 0 : r.getFullWidthCellRenderer()];
  }
  // use by autoWidthCalculator, as it clones the elements
  getCellElement(t) {
    const r = this.getCellCtrl(t);
    return r ? r.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    const t = this.gos.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady())
      return;
    const r = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    t(r);
  }
  areAllContainersReady() {
    const t = !!this.leftGui || !this.beans.visibleColsService.isPinningLeft(), r = !!this.centerGui, n = !!this.rightGui || !this.beans.visibleColsService.isPinningRight();
    return t && r && n;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail)
      return !0;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this.rowNode }) : !1;
  }
  setRowType() {
    const t = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents"), r = this.isNodeFullWidthCell(), n = this.gos.get("masterDetail") && this.rowNode.detail, i = this.beans.columnModel.isPivotMode(), s = !!this.rowNode.group && !this.rowNode.footer && A0(this.gos, i);
    t ? this.rowType = "FullWidthLoading" : n ? this.rowType = "FullWidthDetail" : r ? this.rowType = "FullWidth" : s ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(t = !1, r = !1) {
    if (this.isFullWidth())
      return;
    if (t || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(r);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    ), this.updateColumnListsPending = !0);
  }
  createCellCtrls(t, r, n = null) {
    const i = {
      list: [],
      map: {}
    }, o = (a, l, u) => {
      u != null ? i.list.splice(u, 0, l) : i.list.push(l), i.map[a] = l;
    }, s = [];
    for (const a of r) {
      const l = a.getInstanceId();
      let u = t.map[l];
      u || (u = new ts(a, this.rowNode, this.beans, this)), o(l, u);
    }
    for (const a of t.list) {
      const l = a.getColumn().getInstanceId();
      if (i.map[l] != null)
        continue;
      !this.isCellEligibleToBeRemoved(a, n) ? s.push([l, a]) : a.destroy();
    }
    if (s.length)
      for (const [a, l] of s) {
        const u = i.list.findIndex(
          (h) => h.getColumn().getLeft() > l.getColumn().getLeft()
        ), d = u === -1 ? void 0 : Math.max(u - 1, 0);
        o(a, l, d);
      }
    return i;
  }
  updateColumnListsImpl(t) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(t);
  }
  setCellCtrls(t) {
    this.allRowGuis.forEach((r) => {
      const n = this.getCellCtrlsForContainer(r.containerType);
      r.rowComp.setCellCtrls(n, t);
    });
  }
  getCellCtrlsForContainer(t) {
    switch (t) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const t = this.beans.columnViewportService, r = this.beans.visibleColsService;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r.getAllCols()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const n = t.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, n);
      const i = r.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const o = r.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, o, "right");
    }
  }
  isCellEligibleToBeRemoved(t, r) {
    if (t.getColumn().getPinned() != r)
      return !0;
    const s = t.isEditing(), a = this.beans.focusService.isCellFocused(t.getCellPosition());
    if (s || a) {
      const u = t.getColumn();
      return !(this.beans.visibleColsService.getAllCols().indexOf(u) >= 0);
    }
    return !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || ar(this.gos, "print");
  }
  listenOnDomOrder(t) {
    const r = () => {
      t.rowComp.setDomOrder(this.getDomOrder());
    };
    t.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], r);
  }
  setAnimateFlags(t) {
    if (this.isSticky() || !t)
      return;
    const r = de(this.rowNode.oldRowTop), n = this.beans.visibleColsService.isPinningLeft(), i = this.beans.visibleColsService.isPinningRight();
    if (r) {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.slideInAnimation.fullWidth = !0;
        return;
      }
      this.slideInAnimation.center = !0, this.slideInAnimation.left = n, this.slideInAnimation.right = i;
    } else {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.fadeInAnimation.fullWidth = !0;
        return;
      }
      this.fadeInAnimation.center = !0, this.fadeInAnimation.left = n, this.fadeInAnimation.right = i;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const t = (a, l) => a ? a.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(a.element, l).params) : !0, r = t(this.fullWidthGui, null), n = t(this.centerGui, null), i = t(this.leftGui, "left"), o = t(this.rightGui, "right");
    return r && n && i && o;
  }
  addListeners() {
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      expandedChanged: this.updateExpandedCss.bind(this),
      hasChildrenChanged: this.updateExpandedCss.bind(this)
    }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this)
    }), this.addManagedListeners(this.beans.eventService, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context));
    }), this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    ), this.addManagedPropertyListener("rowDragEntireRow", () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((r) => {
          this.addRowDraggerToRow(r);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged());
      },
      cellChanged: (t) => {
        this.getAllCellCtrls().forEach((r) => r.onCellChanged(t));
      }
    });
  }
  onRowNodeDataChanged(t) {
    if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (n) => n.refreshCell({
        suppressFlash: !t.update,
        newData: !t.update
      })
    ), this.allRowGuis.forEach((n) => {
      this.setRowCompRowId(n.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(n.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const t = this.rowNode.highlighted;
    this.allRowGuis.forEach((r) => {
      const n = t === 0, i = t === 1;
      r.rowComp.addOrRemoveCssClass("ag-row-highlight-above", n), r.rowComp.addOrRemoveCssClass("ag-row-highlight-below", i);
    });
  }
  postProcessRowDragging() {
    const t = this.rowNode.dragging;
    this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass("ag-row-dragging", t));
  }
  updateExpandedCss() {
    const t = this.rowNode.isExpandable(), r = this.rowNode.expanded == !0;
    this.allRowGuis.forEach((n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-group", t), n.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && r), n.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !r), Md(n.element, t && r);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: Fi(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  findFullWidthRowGui(t) {
    return this.allRowGuis.find((r) => r.element.contains(t));
  }
  onKeyboardNavigate(t) {
    const r = this.findFullWidthRowGui(t.target);
    if (!((r ? r.element : null) === t.target))
      return;
    const o = this.rowNode, s = this.beans.focusService.getFocusedCell(), a = {
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: (s == null ? void 0 : s.column) ?? this.getColumnForFullWidth(r)
    };
    this.beans.navigationService.navigateToNextCell(t, t.key, a, !0), t.preventDefault();
  }
  onTabKeyDown(t) {
    if (t.defaultPrevented || Mi(t))
      return;
    const r = this.allRowGuis.find(
      (l) => l.element.contains(t.target)
    ), n = r ? r.element : null, i = n === t.target, o = Dt(this.gos);
    let s = !1;
    n && o && (s = n.contains(o) && o.classList.contains("ag-cell"));
    let a = null;
    !i && !s && (a = this.beans.focusService.findNextFocusableElement(
      n,
      !1,
      t.shiftKey
    )), (this.isFullWidth() && i || !a) && this.beans.navigationService.onTabKeyDown(this, t);
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var r;
    const t = (r = this.allRowGuis.find((n) => li(n.element))) == null ? void 0 : r.element;
    return t ? t.getBoundingClientRect().top : 0;
  }
  onSuppressCellFocusChanged(t) {
    const r = this.isFullWidth() && t ? void 0 : -1;
    this.allRowGuis.forEach((n) => {
      xn(n.element, "tabindex", r);
    });
  }
  onFullWidthRowFocused(t) {
    var o;
    const r = this.rowNode, n = t ? this.isFullWidth() && t.rowIndex === r.rowIndex && t.rowPinned == r.rowPinned : !1, i = this.fullWidthGui ? this.fullWidthGui.element : (o = this.centerGui) == null ? void 0 : o.element;
    i && (i.classList.toggle("ag-full-width-focus", n), n && (t != null && t.forceBrowserFocus) && i.focus({ preventScroll: !0 }));
  }
  recreateCell(t) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), t.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(t, r) {
    const n = {
      list: [],
      map: {}
    };
    return t.list.forEach((i) => {
      i !== r && (n.list.push(i), n.map[i.getColumn().getInstanceId()] = i);
    }), n;
  }
  onMouseEvent(t, r) {
    switch (t) {
      case "dblclick":
        this.onRowDblClick(r);
        break;
      case "click":
        this.onRowClick(r);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(r);
        break;
    }
  }
  createRowEvent(t, r) {
    return this.gos.addGridCommonParams({
      type: t,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      event: r
    });
  }
  createRowEventWithSource(t, r) {
    const n = this.createRowEvent(t, r);
    return n.source = this, n;
  }
  onRowDblClick(t) {
    Mi(t) || this.beans.eventService.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", t));
  }
  getColumnForFullWidth(t) {
    const { visibleColsService: r } = this.beans;
    switch (t == null ? void 0 : t.containerType) {
      case "center":
        return r.getCenterCols()[0];
      case "left":
        return r.getLeftCols()[0];
      case "right":
        return r.getRightCols()[0];
      default:
        return r.getAllCols()[0];
    }
  }
  onRowMouseDown(t) {
    if (this.lastMouseDownOnDragger = Xs(t.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const r = this.rowNode;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges();
    const n = this.findFullWidthRowGui(t.target), i = n == null ? void 0 : n.element, o = t.target;
    let s = !0;
    i && i.contains(o) && z0(o) && (s = !1), this.beans.focusService.setFocusedCell({
      rowIndex: r.rowIndex,
      column: this.getColumnForFullWidth(n),
      rowPinned: r.rowPinned,
      forceBrowserFocus: s
    });
  }
  onRowClick(t) {
    if (Mi(t) || this.lastMouseDownOnDragger)
      return;
    const { gos: n } = this;
    this.beans.eventService.dispatchEvent(this.createRowEventWithSource("rowClicked", t));
    const i = t.ctrlKey || t.metaKey, o = t.shiftKey, s = this.rowNode.isSelected(), a = ls(n), l = nS(n), u = iB(n);
    if (
      // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
      // so return if it's a group row
      a && this.rowNode.group || this.isRowSelectionBlocked() || // if selecting and click selection disabled, do nothing
      !u && !s || // if deselecting and click deselection disabled, do nothing
      !l && s
    )
      return;
    const d = oB(n), h = "rowClicked";
    if (s)
      d ? this.rowNode.setSelectedParams({ newValue: !1, event: t, source: h }) : i ? l && this.rowNode.setSelectedParams({ newValue: !1, event: t, source: h }) : u && this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: !o,
        rangeSelect: o,
        event: t,
        source: h
      });
    else {
      const f = d ? !1 : !i;
      this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: f,
        rangeSelect: o,
        event: t,
        source: h
      });
    }
  }
  isRowSelectionBlocked() {
    return !this.rowNode.selectable || !!this.rowNode.rowPinned || !Rd(this.gos);
  }
  setupDetailRowAutoHeight(t) {
    if (this.rowType !== "FullWidthDetail" || !this.gos.get("detailRowAutoHeight"))
      return;
    const r = () => {
      const i = t.clientHeight;
      if (i != null && i > 0) {
        const o = () => {
          this.rowNode.setRowHeight(i), (At(this.gos) || yo(this.gos)) && this.beans.rowModel.onRowHeightChanged();
        };
        window.setTimeout(o, 0);
      }
    }, n = this.beans.resizeObserverService.observeResize(t, r);
    this.addDestroyFunc(n), r();
  }
  createFullWidthCompDetails(t, r) {
    const { gos: n, rowNode: i } = this, o = n.addGridCommonParams({
      fullWidth: !0,
      data: i.data,
      node: i,
      value: i.key,
      valueFormatted: i.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: t,
      eParentOfValue: t,
      pinned: r,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (a, l, u, d) => this.addFullWidthRowDragging(a, l, u, d),
      setTooltip: (a, l) => this.refreshRowTooltip(a, l)
    }), s = this.beans.userComponentFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return s.getFullWidthDetailCellRendererDetails(o);
      case "FullWidthGroup":
        return s.getFullWidthGroupCellRendererDetails(o);
      case "FullWidthLoading":
        return s.getFullWidthLoadingCellRendererDetails(o);
      default:
        return s.getFullWidthCellRendererDetails(o);
    }
  }
  refreshRowTooltip(t, r) {
    if (!this.fullWidthGui)
      return;
    const n = {
      getGui: () => this.fullWidthGui.element,
      getTooltipValue: () => t,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: r
    };
    this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new Ba(n, this.beans));
  }
  addFullWidthRowDragging(t, r, n = "", i) {
    if (!this.isFullWidth())
      return;
    const o = new xm(
      () => n,
      this.rowNode,
      void 0,
      t,
      r,
      i
    );
    this.createBean(o, this.beans.context), this.addDestroyFunc(() => {
      this.destroyBean(o, this.beans.context);
    });
  }
  onUiLevelChanged() {
    const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != t) {
      const r = "ag-row-level-" + t, n = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((i) => {
        i.rowComp.addOrRemoveCssClass(r, !0), i.rowComp.addOrRemoveCssClass(n, !1);
      });
    }
    this.rowLevel = t;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const t = this.isFirstRowOnPage(), r = this.isLastRowOnPage();
    this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-first", t))), this.lastRowOnPage !== r && (this.lastRowOnPage = r, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-last", r)));
  }
  stopEditing(t = !1) {
    var r;
    this.stoppingRowEdit || (r = this.beans.rowEditService) == null || r.stopEditing(this, t);
  }
  setInlineEditingCss() {
    const t = this.editingRow || this.getAllCellCtrls().some((r) => r.isEditing());
    this.allRowGuis.forEach((r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), r.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  setEditingRow(t) {
    this.editingRow = t;
  }
  startRowEditing(t = null, r = null, n = null) {
    var i;
    return this.editingRow ? !0 : ((i = this.beans.rowEditService) == null ? void 0 : i.startEditing(this, t, r, n)) ?? !0;
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !t || !t.length || t.forEach((r) => {
      this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass(r, !0));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !1));
      }
    );
  }
  setStylesFromGridOptions(t, r) {
    t && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(r, (n) => n.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(t) {
    return t === "left" || t === "right" ? t : null;
  }
  getInitialRowClasses(t) {
    const r = this.getPinnedForContainer(t), n = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[t],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned: r
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(n);
  }
  processStylesFromGridOptions() {
    const t = this.gos.get("rowStyle");
    if (t && typeof t == "function") {
      ie("rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const r = this.gos.getCallback("getRowStyle");
    let n;
    if (r) {
      const i = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      n = r(i);
    }
    return n || t ? Object.assign({}, t, n) : this.emptyStyle;
  }
  onRowSelected(t) {
    const r = !!this.rowNode.isSelected();
    this.forEachGui(t, (n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-selected", r), Td(n.element, r), n.element.contains(Dt(this.gos)) && (n === this.centerGui || n === this.fullWidthGui) && this.announceDescription();
    });
  }
  announceDescription() {
    if (this.isRowSelectionBlocked())
      return;
    const t = this.rowNode.isSelected();
    if (t && !nS(this.gos))
      return;
    const n = this.beans.localeService.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row.`
    );
    this.beans.ariaAnnouncementService.announceValue(n, "rowSelection");
  }
  addHoverFunctionality(t) {
    if (!this.active)
      return;
    const { element: r, compBean: n } = t, { rowNode: i, beans: o, gos: s } = this;
    n.addManagedListeners(r, {
      mouseenter: () => i.onMouseEnter(),
      mouseleave: () => i.onMouseLeave()
    }), n.addManagedListeners(i, {
      mouseEnter: () => {
        !o.dragService.isDragging() && !s.get("suppressRowHoverHighlight") && (r.classList.add("ag-row-hover"), i.setHovered(!0));
      },
      mouseLeave: () => {
        r.classList.remove("ag-row-hover"), i.setHovered(!1);
      }
    });
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(t) {
    const r = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(), n = this.applyPaginationOffset(r.top, !0) - 100, i = this.applyPaginationOffset(r.bottom, !0) + 100;
    return Math.min(Math.max(n, t), i);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(t, r) {
    t ? r(t) : this.allRowGuis.forEach(r);
  }
  onRowHeightChanged(t) {
    if (this.rowNode.rowHeight == null)
      return;
    const r = this.rowNode.rowHeight, n = this.beans.environment.getDefaultRowHeight(), o = gE(this.gos) ? ho(this.gos, this.rowNode).height : void 0, s = o ? `${Math.min(n, o) - 2}px` : void 0;
    this.forEachGui(t, (a) => {
      a.element.style.height = `${r}px`, s && a.element.style.setProperty("--ag-line-height", s);
    });
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(t = !1) {
    if (this.active = !1, !t && Js(this.gos) && !this.isSticky())
      if (this.rowNode.rowTop != null) {
        const i = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(i);
      } else
        this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
    this.rowNode.setHovered(!1);
    const r = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(r), this.beans.eventService.dispatchEvent(r), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0, this.stopEditing();
    const t = (r) => (r.list.forEach((n) => n.destroy()), { list: [], map: {} });
    this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
  }
  setFocusedClasses(t) {
    this.forEachGui(t, (r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), r.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
  }
  onPaginationChanged() {
    var r;
    const t = ((r = this.beans.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
    this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(t, r = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return t;
    const n = this.beans.pageBoundsService.getPixelOffset();
    return t + n * (r ? 1 : -1);
  }
  setRowTop(t) {
    if (!this.printLayout && de(t)) {
      const r = this.applyPaginationOffset(t), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(t) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0;
  }
  getInitialTransform(t) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(t)})`;
  }
  getInitialRowTopShared(t) {
    if (this.printLayout)
      return "";
    const r = this.rowNode;
    let n;
    if (this.isSticky())
      n = r.stickyRowTop;
    else {
      const i = this.slideInAnimation[t] ? this.roundRowTopToBounds(r.oldRowTop) : r.rowTop, o = this.applyPaginationOffset(i);
      n = r.isRowPinned() ? o : this.beans.rowContainerHeightService.getRealPixelPosition(o);
    }
    return n + "px";
  }
  setRowTopStyle(t) {
    this.allRowGuis.forEach(
      (r) => this.suppressRowTransform ? r.rowComp.setTop(t) : r.rowComp.setTransform(`translateY(${t})`)
    );
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(t) {
    let r = null;
    return this.getAllCellCtrls().forEach((n) => {
      n.getColumn() == t && (r = n);
    }), r != null || this.getAllCellCtrls().forEach((n) => {
      n.getColSpanningList().indexOf(t) >= 0 && (r = n);
    }), r;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  getRowIndex() {
    return this.rowNode.getRowIndexString();
  }
  updateRowIndexes(t) {
    var s;
    const r = this.rowNode.getRowIndexString();
    if (r === null)
      return;
    const n = this.beans.headerNavigationService.getHeaderRowCount() + (((s = this.beans.filterManager) == null ? void 0 : s.getHeaderRowCount()) ?? 0), i = this.rowNode.rowIndex % 2 === 0, o = n + this.rowNode.rowIndex + 1;
    this.forEachGui(t, (a) => {
      a.rowComp.setRowIndex(r), a.rowComp.addOrRemoveCssClass("ag-row-even", i), a.rowComp.addOrRemoveCssClass("ag-row-odd", !i), KB(a.element, o);
    });
  }
  setStoppingRowEdit(t) {
    this.stoppingRowEdit = t;
  }
};
DP.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var rs = DP, d6 = class extends J {
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.valueService = e.valueService, this.menuService = e.menuService, this.ctrlsService = e.ctrlsService, this.navigationService = e.navigationService, this.focusService = e.focusService, this.undoRedoService = e.undoRedoService, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService, this.clipboardService = e.clipboardService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", xE("touchstart") ? "touchstart" : "mousedown"].forEach((r) => {
      const n = this.processMouseEvent.bind(this, r);
      this.addManagedElementListeners(this.element, { [r]: n });
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || Mi(t))
      return;
    const r = this.getRowForEvent(t), n = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, void 0, r, n) : (n && n.onMouseEvent(e, t), r && r.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!wo())
      return;
    const e = new lo(this.element), t = (r) => {
      const n = this.getRowForEvent(r.touchEvent), i = this.mouseEventService.getRenderedCellForEvent(r.touchEvent);
      this.handleContextMenuMouseEvent(void 0, r.touchEvent, n, i);
    };
    this.addManagedListeners(e, { longTap: t }), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const r = tc(this.gos, t, rs.DOM_DATA_KEY_ROW_CTRL);
      if (r)
        return r;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, r, n) {
    const i = r ? r.getRowNode() : null, o = n ? n.getColumn() : null;
    let s = null;
    if (o) {
      const u = e || t;
      n.dispatchCellContextMenuEvent(u ?? null), s = this.valueService.getValue(o, i);
    }
    const a = this.ctrlsService.getGridBodyCtrl(), l = n ? n.getGui() : a.getGridBodyElement();
    this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: t,
      rowNode: i,
      column: o,
      value: s,
      anchorToElement: l
    });
  }
  getControlsForEventTarget(e) {
    return {
      cellCtrl: pm(this.gos, e, ts.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: pm(this.gos, e, rs.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: r, rowCtrl: n } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (r ? this.processCellKeyboardEvent(r, e, t) : n && n.isFullWidth() && this.processFullWidthRowKeyboardEvent(n, e, t));
  }
  processCellKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = e.getColumn(), o = e.isEditing();
    !Rm(
      this.gos,
      r,
      n,
      i,
      o
    ) && t === "keydown" && (!o && this.navigationService.handlePageScrollingKey(r) || e.onKeyDown(r), this.doGridOperations(r, e.isEditing()), lP(r) && e.processCharacter(r)), t === "keydown" && this.eventService.dispatchEvent(e.createEvent(r, "cellKeyDown"));
  }
  processFullWidthRowKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = this.focusService.getFocusedCell(), o = i && i.column;
    if (!Rm(this.gos, r, n, o, !1)) {
      const a = r.key;
      if (t === "keydown")
        switch (a) {
          case V.PAGE_HOME:
          case V.PAGE_END:
          case V.PAGE_UP:
          case V.PAGE_DOWN:
            this.navigationService.handlePageScrollingKey(r, !0);
            break;
          case V.UP:
          case V.DOWN:
            e.onKeyboardNavigate(r);
            break;
          case V.TAB:
            e.onTabKeyDown(r);
            break;
        }
    }
    t === "keydown" && this.eventService.dispatchEvent(e.createRowEvent("cellKeyDown", r));
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e))
      return;
    const r = xG(e);
    if (r === V.A)
      return this.onCtrlAndA(e);
    if (r === V.C)
      return this.onCtrlAndC(e);
    if (r === V.D)
      return this.onCtrlAndD(e);
    if (r === V.V)
      return this.onCtrlAndV(e);
    if (r === V.X)
      return this.onCtrlAndX(e);
    if (r === V.Y)
      return this.onCtrlAndY();
    if (r === V.Z)
      return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, rowModel: r, rangeService: n } = this;
    if (n && r.isRowsToRender()) {
      const [i, o] = [
        t.isEmpty("top"),
        t.isEmpty("bottom")
      ], s = i ? null : "top";
      let a, l;
      o ? (a = null, l = r.getRowCount() - 1) : (a = "bottom", l = t.getPinnedBottomRowCount() - 1);
      const u = this.visibleColsService.getAllCols();
      if (rn(u))
        return;
      n.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: s,
        rowEndIndex: l,
        rowEndPinned: a,
        columnStart: u[0],
        columnEnd: Ye(u)
      });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    !this.gos.get("undoRedoCellEditing") || !this.undoRedoService || (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    var e;
    (e = this.undoRedoService) == null || e.redo("ui");
  }
}, h6 = class extends J {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({ leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this) });
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    Tt(this.element, t), Hn(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
}, g6 = class extends J {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this)
    });
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    Tt(this.element, t), Hn(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
}, ju = (e) => e.getTopRowCtrls(), Uu = (e) => e.getStickyTopRowCtrls(), Ku = (e) => e.getStickyBottomRowCtrls(), qu = (e) => e.getBottomRowCtrls(), Yu = (e) => e.getCentreRowCtrls(), f6 = {
  center: {
    type: "center",
    container: "ag-center-cols-container",
    viewport: "ag-center-cols-viewport",
    getRowCtrls: Yu
  },
  left: {
    type: "left",
    container: "ag-pinned-left-cols-container",
    pinnedType: "left",
    getRowCtrls: Yu
  },
  right: {
    type: "right",
    container: "ag-pinned-right-cols-container",
    pinnedType: "right",
    getRowCtrls: Yu
  },
  fullWidth: {
    type: "fullWidth",
    container: "ag-full-width-container",
    fullWidth: !0,
    getRowCtrls: Yu
  },
  topCenter: {
    type: "center",
    container: "ag-floating-top-container",
    viewport: "ag-floating-top-viewport",
    getRowCtrls: ju
  },
  topLeft: {
    type: "left",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: ju
  },
  topRight: {
    type: "right",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: ju
  },
  topFullWidth: {
    type: "fullWidth",
    container: "ag-floating-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: ju
  },
  stickyTopCenter: {
    type: "center",
    container: "ag-sticky-top-container",
    viewport: "ag-sticky-top-viewport",
    getRowCtrls: Uu
  },
  stickyTopLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: Uu
  },
  stickyTopRight: {
    type: "right",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: Uu
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Uu
  },
  stickyBottomCenter: {
    type: "center",
    container: "ag-sticky-bottom-container",
    viewport: "ag-sticky-bottom-viewport",
    getRowCtrls: Ku
  },
  stickyBottomLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: Ku
  },
  stickyBottomRight: {
    type: "right",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: Ku
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: Ku
  },
  bottomCenter: {
    type: "center",
    container: "ag-floating-bottom-container",
    viewport: "ag-floating-bottom-viewport",
    getRowCtrls: qu
  },
  bottomLeft: {
    type: "left",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: qu
  },
  bottomRight: {
    type: "right",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: qu
  },
  bottomFullWidth: {
    type: "fullWidth",
    container: "ag-floating-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: qu
  }
};
function Vs(e) {
  return f6[e];
}
var p6 = ["topCenter", "topLeft", "topRight"], m6 = ["bottomCenter", "bottomLeft", "bottomRight"], v6 = ["center", "left", "right"], y6 = ["center", "left", "right", "fullWidth"], C6 = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], w6 = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], b6 = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], OP = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], IP = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], S6 = [
  ...OP,
  "stickyTopFullWidth",
  ...IP,
  "stickyBottomFullWidth"
], x6 = [
  ...p6,
  ...m6,
  ...v6,
  ...OP,
  ...IP
], R6 = class extends J {
  constructor(e) {
    super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = e, this.options = Vs(e);
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService, this.columnViewportService = e.columnViewportService, this.resizeObserverService = e.resizeObserverService, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new z4(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.ctrlsService.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(e, t, r) {
    this.comp = e, this.eContainer = t, this.eViewport = r, this.createManagedBean(new d6(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder();
    const n = () => this.onPinnedWidthChanged();
    this.forContainers(w6, () => {
      this.pinnedWidthFeature = this.createManagedBean(new h6(this.eContainer)), this.addManagedEventListeners({ leftPinnedWidthChanged: n });
    }), this.forContainers(b6, () => {
      this.pinnedWidthFeature = this.createManagedBean(new g6(this.eContainer)), this.addManagedEventListeners({ rightPinnedWidthChanged: n });
    }), this.forContainers(
      y6,
      () => this.createManagedBean(
        new MP(this.eContainer, this.name === "center" ? r : void 0)
      )
    ), this.forContainers(x6, () => this.createManagedBean(new N4(this.eContainer))), this.forContainers(
      C6,
      () => this.createManagedBean(new Z0((i) => this.comp.setContainerWidth(`${i}px`)))
    ), this.visible = this.isContainerVisible(), this.addListeners(), this.registerWithCtrlsService();
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
  addListeners() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll)
    }), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if (S6.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const r = this.gos.get("ensureDomOrder"), n = ar(this.gos, "print");
      this.comp.setDomOrder(r || n);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const e = (t) => {
      this.dragService.isDragging() && t.cancelable && t.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", e, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), r = this.getCenterViewportScrollLeft();
    this.columnViewportService.setScrollPosition(t, r, e);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return jc(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return Id(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = this.resizeObserverService.observeResize(this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return WE(this.eViewport);
  }
  getViewportScrollLeft() {
    return Id(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || o8(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setHorizontalScroll(e) {
    this.comp.setHorizontalScroll(e);
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    kd(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const r = ar(this.gos, "print"), i = this.gos.get("embedFullWidthRows") || r, o = t.filter((s) => {
      const a = s.isFullWidth();
      return this.options.fullWidth ? !i && a : i || !a;
    });
    this.comp.setRowCtrls({ rowCtrls: o, useFlushSync: e });
  }
}, E6 = "ag-force-vertical-scroll", P6 = "ag-selectable", A6 = "ag-column-moving", F6 = class extends J {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.menuService = e.menuService, this.headerNavigationService = e.headerNavigationService, this.dragAndDropService = e.dragAndDropService, this.pinnedRowModel = e.pinnedRowModel, this.rowRenderer = e.rowRenderer, this.popupService = e.popupService, this.mouseEventService = e.mouseEventService, this.rowModel = e.rowModel, this.filterManager = e.filterManager, this.environment = e.environment;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, r, n, i, o, s) {
    var a;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = r, this.eTop = n, this.eBottom = i, this.eStickyTop = o, this.eStickyBottom = s, this.eCenterColsViewport = r.querySelector(
      `.${Vs("center").viewport}`
    ), this.eFullWidthContainer = r.querySelector(
      `.${Vs("fullWidth").container}`
    ), this.eStickyTopFullWidthContainer = o.querySelector(
      `.${Vs("stickyTopFullWidth").container}`
    ), this.eStickyBottomFullWidthContainer = s.querySelector(
      `.${Vs("stickyBottomFullWidth").container}`
    ), this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (l) => this.setCellTextSelection(l.currentValue)
    ), this.createManagedBean(new ty(this.comp)), this.bodyScrollFeature = this.createManagedBean(new _4(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([n, r, i, o, s]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.updateScrollingClasses(), (a = this.filterManager) == null || a.setupAdvancedFilterHeaderComp(n), this.ctrlsService.register("gridBodyCtrl", this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    const e = this.setFloatingHeights.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.onScrollGapChanged.bind(this),
      pinnedRowDataChanged: e,
      pinnedHeightChanged: e,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (r) => {
          const { target: n } = r, i = Xs(n, "ag-root", t);
          t.classList.toggle("ag-has-focus", !i);
        },
        focusout: (r) => {
          const { target: n, relatedTarget: i } = r, o = t.contains(i), s = Xs(
            i,
            "ag-root",
            t
          );
          Xs(n, "ag-root", t) || (!o || s) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(A6, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(P6, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
    const t = e && this.scrollVisibleService.getScrollbarWidth() || 0, r = NE() ? 16 : 0, n = `calc(100% + ${t + r}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(n)), this.updateScrollingClasses();
  }
  onScrollGapChanged() {
    this.updateScrollingClasses();
  }
  updateScrollingClasses() {
    this.eGridBody.classList.toggle(
      "ag-body-vertical-content-no-gap",
      !this.scrollVisibleService.hasVerticalScrollGap()
    ), this.eGridBody.classList.toggle(
      "ag-body-horizontal-content-no-gap",
      !this.scrollVisibleService.hasHorizontalScrollGap()
    );
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus"))
      return;
    const e = (r) => {
      const n = r.relatedTarget;
      if (bm(n) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let i = (
        // see if click came from inside the viewports
        t.some((o) => o.contains(n)) && // and also that it's not from a detail grid
        this.mouseEventService.isElementInThisGrid(n)
      );
      if (!i) {
        const o = this.popupService;
        i = o.getActivePopups().some((s) => s.contains(n)) || o.isElementWithinCustomPopup(n);
      }
      i || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
    t.forEach((r) => this.addManagedElementListeners(r, { focusout: e }));
  }
  updateRowCount() {
    var n;
    const e = this.headerNavigationService.getHeaderRowCount() + (((n = this.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, r = t === -1 ? -1 : e + t;
    this.comp.setRowCount(r);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? E6 : null, r = ar(this.gos, "normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || r && s8(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    let e = this.environment.hasMeasuredSizes();
    const t = () => {
      const r = e && Js(this.gos) && !this.rowContainerHeightService.isStretching(), n = r ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(n, r);
    };
    t(), this.addManagedEventListeners({ heightScaleChanged: t }), this.addManagedPropertyListener("animateRows", t), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !e && this.environment.hasMeasuredSizes() && (e = !0, t());
      }
    });
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: e }), this.mockContextMenuForIPad(e), this.addManagedElementListeners(this.eBodyViewport, { wheel: this.onBodyViewportWheel.bind(this) }), this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) }), this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) }), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX: t, deltaY: r, shiftKey: n } = e;
    (n || Math.abs(t) > Math.abs(r)) && this.mouseEventService.isEventFromThisGrid(e) && this.scrollGridBodyToMatchEvent(e);
  }
  onStickyWheel(e) {
    const { deltaX: t, deltaY: r, shiftKey: n } = e, i = n || Math.abs(t) > Math.abs(r), o = e.target;
    i ? (this.eStickyTopFullWidthContainer.contains(o) || this.eStickyBottomFullWidthContainer.contains(o)) && this.scrollGridBodyToMatchEvent(e) : (e.preventDefault(), this.scrollVertically(r));
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX: t, deltaY: r } = e;
    e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || r });
  }
  onBodyViewportContextMenu(e, t, r) {
    if (!e && !r)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || r).preventDefault();
    const { target: n } = e || t;
    (n === this.eBodyViewport || n === this.ctrlsService.get("center").getViewportElement()) && this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: r,
      value: null,
      anchorToElement: this.eGridBody
    });
  }
  mockContextMenuForIPad(e) {
    if (!wo())
      return;
    const t = new lo(this.eBodyViewport), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  getGui() {
    return this.eGridBody;
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new rG(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(this.rowDragFeature));
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this, t = e.getPinnedTopTotalHeight(), r = e.getPinnedBottomTotalHeight();
    this.comp.setTopHeight(t), this.comp.setBottomHeight(r), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  getStickyBottomHeight() {
    return this.stickyBottomHeight;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.scrollVisibleService.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    var i;
    const t = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + (((i = this.filterManager) == null ? void 0 : i.getHeaderHeight()) ?? 0), r = this.pinnedRowModel.getPinnedTopTotalHeight();
    let n = 0;
    t > 0 && (n += t), r > 0 && (n += r), n > 0 && (n += 1), this.comp.setStickyTopTop(`${n}px`);
  }
  setStickyBottomOffsetBottom() {
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight(), r = this.scrollVisibleService.isHorizontalScrollShowing() && this.scrollVisibleService.getScrollbarWidth() || 0, n = e + r;
    this.comp.setStickyBottomBottom(`${n}px`);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFit(e, t) {
    const n = this.isVerticalScrollShowing() ? this.scrollVisibleService.getScrollbarWidth() : 0, o = jc(this.eGridBody) - n;
    if (o > 0) {
      this.columnSizeService.sizeColumnsToFit(o, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : ie(
      "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?"
    );
  }
  // + rangeService
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: !0 });
  }
  // + focusService
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
};
function xl(e) {
  return e.map((t) => `<ag-row-container name="${t}"></ag-row-container>`).join("");
}
`${xl(["topLeft", "topCenter", "topRight", "topFullWidth"])}${xl(["left", "center", "right", "fullWidth"])}${xl(["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}${xl(["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}${xl(["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}`;
var M6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnAnimationService = e.columnAnimationService;
  }
  postConstruct() {
    this.getScrollbarWidth(), this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    });
  }
  onDisplayedColumnsChanged() {
    this.updateScrollVisible();
  }
  onDisplayedColumnsWidthChanged() {
    this.updateScrollVisible();
  }
  onCentreViewportResized() {
    this.updateScrollGap();
  }
  updateScrollVisible() {
    this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
      this.columnAnimationService.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
    }) : this.updateScrollVisibleImpl();
  }
  updateScrollVisibleImpl() {
    const e = this.ctrlsService.get("center");
    if (!e || this.columnAnimationService.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(t), this.updateScrollGap();
  }
  updateScrollGap() {
    const e = this.ctrlsService.get("center"), t = e.hasHorizontalScrollGap(), r = e.hasVerticalScrollGap();
    (this.horizontalScrollGap !== t || this.verticalScrollGap !== r) && (this.horizontalScrollGap = t, this.verticalScrollGap = r, this.eventService.dispatchEvent({
      type: "scrollGapChanged"
    }));
  }
  setScrollsVisible(e) {
    (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) && (this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing, this.eventService.dispatchEvent({
      type: "scrollVisibilityChanged"
    }));
  }
  // used by pagination service - to know page height
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  // used by header container
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
  hasHorizontalScrollGap() {
    return this.horizontalScrollGap;
  }
  hasVerticalScrollGap() {
    return this.verticalScrollGap;
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const e = this.gos.get("scrollbarWidth"), r = typeof e == "number" && e >= 0 ? e : r8();
      r != null && (this.scrollbarWidth = r, this.eventService.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
}, CS = "__ag_grid_instance", kP = class LP extends J {
  constructor() {
    super(...arguments), this.beanName = "mouseEventService", this.gridInstanceId = LP.gridInstanceSequence.next();
  }
  wireBeans(t) {
    this.ctrlsService = t.ctrlsService;
  }
  // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
  // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
  // for where this is used.
  stampTopLevelGridCompWithGridInstance(t) {
    t[CS] = this.gridInstanceId;
  }
  getRenderedCellForEvent(t) {
    return pm(this.gos, t.target, ts.DOM_DATA_KEY_CELL_CTRL);
  }
  // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
  // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
  // getting executed on many grids at the same time.
  isEventFromThisGrid(t) {
    return this.isElementInThisGrid(t.target);
  }
  isElementInThisGrid(t) {
    let r = t;
    for (; r; ) {
      const n = r[CS];
      if (de(n))
        return n === this.gridInstanceId;
      r = r.parentElement;
    }
    return !1;
  }
  getCellPositionForEvent(t) {
    const r = this.getRenderedCellForEvent(t);
    return r ? r.getCellPosition() : null;
  }
  getNormalisedPosition(t) {
    const r = ar(this.gos, "normal"), n = t;
    let i, o;
    if (n.clientX != null || n.clientY != null ? (i = n.clientX, o = n.clientY) : (i = n.x, o = n.y), r) {
      const s = this.ctrlsService.getGridBodyCtrl(), a = s.getScrollFeature().getVScrollPosition(), l = s.getScrollFeature().getHScrollPosition();
      i += l.left, o += a.top;
    }
    return { x: i, y: o };
  }
};
kP.gridInstanceSequence = new sa();
var T6 = kP, D6 = class extends J {
  constructor() {
    super(), this.beanName = "navigationService", this.onPageDown = tS(this.onPageDown, 100), this.onPageUp = tS(this.onPageUp, 100);
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.ctrlsService = e.ctrlsService, this.rowRenderer = e.rowRenderer, this.headerNavigationService = e.headerNavigationService, this.rowPositionUtils = e.rowPositionUtils, this.cellNavigationService = e.cellNavigationService, this.pinnedRowModel = e.pinnedRowModel, this.scrollVisibleService = e.scrollVisibleService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const r = e.key, n = e.altKey, i = e.ctrlKey || e.metaKey, o = !!this.rangeService && e.shiftKey, s = this.mouseEventService.getCellPositionForEvent(e);
    let a = !1;
    switch (r) {
      case V.PAGE_HOME:
      case V.PAGE_END:
        !i && !n && (this.onHomeOrEndKey(r), a = !0);
        break;
      case V.LEFT:
      case V.RIGHT:
      case V.UP:
      case V.DOWN:
        if (!s)
          return !1;
        i && !n && !o && (this.onCtrlUpDownLeftRight(r, s), a = !0);
        break;
      case V.PAGE_DOWN:
      case V.PAGE_UP:
        !i && !n && (a = this.handlePageUpDown(r, s, t));
        break;
    }
    return a && e.preventDefault(), a;
  }
  handlePageUpDown(e, t, r) {
    return r && (t = this.focusService.getFocusedCell()), t ? (e === V.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    var s;
    const { scrollIndex: t, scrollType: r, scrollColumn: n, focusIndex: i, focusColumn: o } = e;
    de(n) && !n.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(n), de(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, r), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(i), this.focusService.setFocusedCell({
      rowIndex: i,
      column: o,
      rowPinned: null,
      forceBrowserFocus: !0
    }), (s = this.rangeService) == null || s.setRangeToCell({ rowIndex: i, rowPinned: null, column: o });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.getViewportHeight(), i = this.pageBoundsService.getPixelOffset(), o = r.top + n, s = this.rowModel.getRowIndexAtPixel(o + i);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, s) : this.navigateToNextPage(e, s);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.pageBoundsService.getPixelOffset(), i = r.top, o = this.rowModel.getRowIndexAtPixel(i + n);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, o, !0) : this.navigateToNextPage(e, o, !0);
  }
  navigateToNextPage(e, t, r = !1) {
    const n = this.getViewportHeight(), i = this.pageBoundsService.getFirstRow(), o = this.pageBoundsService.getLastRow(), s = this.pageBoundsService.getPixelOffset(), a = this.rowModel.getRow(e.rowIndex), l = r ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (a == null ? void 0 : a.rowHeight) - n - s
    ) : n - s, u = (a == null ? void 0 : a.rowTop) + l;
    let d = this.rowModel.getRowIndexAtPixel(u + s);
    if (d === e.rowIndex) {
      const f = r ? -1 : 1;
      t = d = e.rowIndex + f;
    }
    let h;
    r ? (h = "bottom", d < i && (d = i), t < i && (t = i)) : (h = "top", d > o && (d = o), t > o && (t = o)), this.isRowTallerThanView(d) && (t = d, h = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: h,
      scrollColumn: null,
      focusIndex: d,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, r = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: r ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const n = this.getNextFocusIndexForAutoHeight(e, r);
      this.navigateTo({
        scrollIndex: t,
        scrollType: r ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: n,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const r = t ? -1 : 1, n = this.getViewportHeight(), i = this.pageBoundsService.getLastRow();
    let o = 0, s = e.rowIndex;
    for (; s >= 0 && s <= i; ) {
      const a = this.rowModel.getRow(s);
      if (a) {
        const l = a.rowHeight ?? 0;
        if (o + l > n)
          break;
        o += l;
      }
      s += r;
    }
    return Math.max(0, Math.min(s, i));
  }
  getViewportHeight() {
    const e = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), t = this.scrollVisibleService.getScrollbarWidth();
    let r = e.bottom - e.top;
    return this.ctrlsService.get("center").isHorizontalScrollShowing() && (r -= t), r;
  }
  isRowTallerThanView(e) {
    const t = this.rowModel.getRow(e);
    if (!t)
      return !1;
    const r = t.rowHeight;
    return typeof r != "number" ? !1 : r > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const r = this.cellNavigationService.getNextCellToFocus(e, t, !0), { rowIndex: n } = r, i = r.column;
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: i,
      focusIndex: n,
      focusColumn: i
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === V.PAGE_HOME, r = this.visibleColsService.getAllCols(), n = t ? r[0] : Ye(r), i = t ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: n,
      focusIndex: i,
      focusColumn: n
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const r = t.shiftKey, n = this.tabToNextCellCommon(e, r, t);
    if (n !== !1) {
      n ? t.preventDefault() : n === null && this.focusService.allowFocusForNextGridCoreContainer(r);
      return;
    }
    if (r) {
      const { rowIndex: i, rowPinned: o } = e.getRowPosition();
      (o ? i === 0 : i === this.pageBoundsService.getFirstRow()) && (this.gos.get("headerHeight") === 0 || this.focusService.isHeaderFocusSuppressed() ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)));
    } else
      e instanceof ts && e.focusCell(!0), (!r && this.focusService.focusOverlay(!1) || this.focusService.focusNextGridCoreContainer(r)) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const r = this.focusService.getFocusedCell();
    if (!r)
      return !1;
    let n = this.getCellByPosition(r);
    return !n && (n = this.rowRenderer.getRowByPosition(r), !n || !n.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(n, e, t);
  }
  tabToNextCellCommon(e, t, r) {
    let n = e.isEditing();
    if (!n && e instanceof ts) {
      const s = e.getRowCtrl();
      s && (n = s.isEditing());
    }
    let i;
    return n ? this.gos.get("editType") === "fullRow" ? i = this.moveToNextEditingRow(e, t, r) : i = this.moveToNextEditingCell(e, t, r) : i = this.moveToNextCellNotEditing(e, t), i === null ? i : i || !!this.focusService.getFocusedHeader();
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, r = null) {
    const n = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const i = this.findNextCellToFocusOn(n, t, !0);
    return i === !1 ? null : i == null ? !1 : (i.startEditing(null, !0, r), i.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, r = null) {
    const n = e.getCellPosition(), i = this.findNextCellToFocusOn(n, t, !0);
    if (i === !1)
      return null;
    if (i == null)
      return !1;
    const o = i.getCellPosition(), s = this.isCellEditable(n), a = this.isCellEditable(o), l = o && n.rowIndex === o.rowIndex && n.rowPinned === o.rowPinned;
    return s && e.setFocusOutOnEditor(), l || (e.getRowCtrl().stopEditing(), i.getRowCtrl().startRowEditing(void 0, void 0, r)), a ? (i.setFocusInOnEditor(), i.focusCell()) : i.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t) {
    const r = this.visibleColsService.getAllCols();
    let n;
    e instanceof rs ? n = {
      ...e.getRowPosition(),
      column: t ? r[0] : Ye(r)
    } : n = e.getCellPosition();
    const i = this.findNextCellToFocusOn(n, t, !1);
    if (i === !1)
      return null;
    if (i instanceof ts)
      i.focusCell(!0);
    else if (i)
      return this.tryToFocusFullWidthRow(i.getRowPosition(), t);
    return de(i);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, r) {
    var i;
    let n = e;
    for (; ; ) {
      e !== n && (e = n), t || (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextTabbedCell(n, t);
      const o = this.gos.getCallback("tabToNextCell");
      if (de(o)) {
        const u = o({
          backwards: t,
          editing: r,
          previousCellPosition: e,
          nextCellPosition: n || null
        });
        if (u === !0 || u === null)
          u === null && ie(
            "Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."
          ), n = e;
        else {
          if (u === !1)
            return !1;
          n = {
            rowIndex: u.rowIndex,
            column: u.column,
            rowPinned: u.rowPinned
          };
        }
      }
      if (!n)
        return null;
      if (n.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: l + n.rowIndex,
            column: n.column
          },
          fromCell: !0
        }), null;
      }
      const s = this.gos.get("editType") === "fullRow";
      if (r && !s && !this.isCellEditable(n))
        continue;
      this.ensureCellVisible(n);
      const a = this.getCellByPosition(n);
      if (!a) {
        const l = this.rowRenderer.getRowByPosition(n);
        if (!l || !l.isFullWidth() || r)
          continue;
        return l;
      }
      if (!a.isSuppressNavigable())
        return (i = this.rangeService) == null || i.setRangeToCell(n), a;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.rowModel.getRow(e.rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, r, n) {
    let i = r, o = !1;
    for (; i && (i === r || !this.isValidNavigateCell(i)); )
      this.gos.get("enableRtl") ? t === V.LEFT && (i = this.getLastCellOfColSpan(i)) : t === V.RIGHT && (i = this.getLastCellOfColSpan(i)), i = this.cellNavigationService.getNextCellToFocus(t, i), o = Ke(i);
    if (o && e && e.key === V.UP && (i = {
      rowIndex: -1,
      rowPinned: null,
      column: r.column
    }), n) {
      const a = this.gos.getCallback("navigateToNextCell");
      if (de(a)) {
        const u = a({
          key: t,
          previousCellPosition: r,
          nextCellPosition: i || null,
          event: e
        });
        de(u) ? i = {
          rowPinned: u.rowPinned,
          rowIndex: u.rowIndex,
          column: u.column
        } : i = null;
      }
    }
    if (!i)
      return;
    if (i.rowIndex < 0) {
      const a = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: a + i.rowIndex, column: r.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const s = this.getNormalisedPosition(i);
    s ? this.focusPosition(s) : this.tryToFocusFullWidthRow(i);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t) {
    const r = this.visibleColsService.getAllCols(), n = this.rowRenderer.getRowByPosition(e);
    if (!n || !n.isFullWidth())
      return !1;
    const i = this.focusService.getFocusedCell(), o = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? Ye(r) : r[0])
    };
    this.focusPosition(o);
    const s = t ?? (i != null && this.rowPositionUtils.before(o, i));
    return this.eventService.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: o.column,
      isFullWidthCell: !0,
      fromBelow: s
    }), !0;
  }
  focusPosition(e) {
    var t;
    this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), (t = this.rangeService) == null || t.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t)
      return e;
    const r = t.getColSpanningList();
    return r.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: Ye(r),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = jh(this.gos), r = this.rowModel.getRow(e.rowIndex);
    !(t && (r == null ? void 0 : r.sticky)) && Ke(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
}, O6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeService";
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService;
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      onDragCancel: this.onDragStop.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const r = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(r);
  }
  setResizeIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, I6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.menuService = e.menuService;
  }
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t, r) {
    this.showPopup(
      e,
      (n) => {
        this.popupService.positionPopupUnderMouseEvent({
          column: e,
          type: r,
          mouseEvent: t,
          ePopup: n
        });
      },
      r,
      t.target,
      this.menuService.isLegacyMenuEnabled()
    );
  }
  showMenuAfterButtonClick(e, t, r) {
    let n = -1, i = "left";
    const o = this.menuService.isLegacyMenuEnabled();
    !o && this.gos.get("enableRtl") && (n = 1, i = "right");
    const s = o ? void 0 : 4 * n, a = o ? void 0 : 4;
    this.showPopup(
      e,
      (l) => {
        this.popupService.positionPopupByComponent({
          type: r,
          eventSource: t,
          ePopup: l,
          nudgeX: s,
          nudgeY: a,
          alignSide: i,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      r,
      t,
      o
    );
  }
  showPopup(e, t, r, n, i) {
    const o = e ? this.createBean(new lG(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = o, !(o != null && o.hasFilter()) || !e)
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const s = document.createElement("div");
    Vn(s, "presentation"), s.classList.add("ag-menu"), i || s.classList.add("ag-filter-menu"), [this.tabListener] = this.addManagedElementListeners(s, {
      keydown: (y) => this.trapFocusWithin(y, s)
    }), s.appendChild(o == null ? void 0 : o.getGui());
    let a;
    const l = () => o == null ? void 0 : o.afterGuiDetached(), u = this.menuService.isColumnMenuAnchoringEnabled() ? n ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0, d = (y) => {
      e.setMenuVisible(!1, "contextMenu");
      const C = y instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), C && n && li(n)) {
        const v = this.focusService.findTabbableParent(n);
        v && v.focus();
      }
      l(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, r, e);
    }, h = this.localeService.getLocaleTextFunc(), f = i && r !== "columnFilter" ? h("ariaLabelColumnMenu", "Column Menu") : h("ariaLabelColumnFilter", "Column Filter"), p = this.popupService.addPopup({
      modal: !0,
      eChild: s,
      closeOnEsc: !0,
      closedCallback: d,
      positionCallback: () => t(s),
      anchorToElement: u,
      ariaLabel: f
    });
    p && (this.hidePopup = a = p.hideFunc), o.afterInit().then(() => {
      t(s), o.afterGuiAttached({ container: r, hidePopup: a });
    }), e.setMenuVisible(!0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, r, e);
  }
  trapFocusWithin(e, t) {
    e.key !== V.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, r) {
    this.eventService.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: r ?? null,
      columnGroup: null
    });
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, k6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "resizeObserverService";
  }
  observeResize(e, t) {
    const n = fE(this.gos).ResizeObserver, i = n ? new n(t) : null;
    return i == null || i.observe(e), () => i == null ? void 0 : i.disconnect();
  }
}, L6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "animationFrameService", this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  setScrollTop(e) {
    var r;
    const t = this.gos.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const n = ((r = this.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
      n !== this.lastPage && (this.lastPage = n, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  postConstruct() {
    this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === !1 && ie(`AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, r) {
    this.verifyAnimationFrameOn(r);
    const n = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[r], n), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort(
      (r, n) => r.index !== n.index ? t * (n.index - r.index) : n.createOrder - r.createOrder
    ), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, r = t.list, n = this.createTasksP2, i = n.list, o = this.destroyTasks, s = (/* @__PURE__ */ new Date()).getTime();
    let a = (/* @__PURE__ */ new Date()).getTime() - s;
    const l = e <= 0, u = this.ctrlsService.getGridBodyCtrl();
    for (; l || a < e; ) {
      if (!u.getScrollFeature().scrollGridIfNeeded()) {
        let h;
        if (r.length)
          this.sortTaskList(t), h = r.pop().task;
        else if (i.length)
          this.sortTaskList(n), h = i.pop().task;
        else if (o.length)
          h = o.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(h) || h();
      }
      a = (/* @__PURE__ */ new Date()).getTime() - s;
    }
    r.length || i.length || o.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = !1;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = fE(this.gos);
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  // a debounce utility used for parts of the app involved with rendering.
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    let t = !1;
    return () => {
      if (!this.isOn()) {
        window.setTimeout(e, 0);
        return;
      }
      t || (t = !0, this.addDestroyTask(() => {
        t = !1, e();
      }));
    };
  }
}, $e = /* @__PURE__ */ ((e) => (e.EVERYTHING = "group", e.FILTER = "filter", e.SORT = "sort", e.MAP = "map", e.AGGREGATE = "aggregate", e.FILTER_AGGREGATES = "filter_aggregates", e.PIVOT = "pivot", e.NOTHING = "nothing", e))($e || {}), _6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "expansionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.isClientSideRowModel = At(this.gos);
  }
  expandRows(e) {
    if (!this.isClientSideRowModel)
      return;
    const t = new Set(e);
    this.rowModel.forEachNode((r) => {
      r.id && t.has(r.id) && (r.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  getExpandedRows() {
    const e = [];
    return this.rowModel.forEachNode(({ expanded: t, id: r }) => {
      t && r && e.push(r);
    }), e;
  }
  expandAll(e) {
    this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e);
  }
  setRowNodeExpanded(e, t, r, n) {
    e && (r && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, r, n), e.setExpanded(t, void 0, n));
  }
  onGroupExpandedOrCollapsed() {
    this.isClientSideRowModel && this.rowModel.refreshModel({
      step: "map"
      /* MAP */
    });
  }
}, z6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "menuService";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.filterMenuFactory = e.filterMenuFactory, this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.filterManager = e.filterManager, this.rowRenderer = e.rowRenderer, this.columnChooserFactory = e.columnChooserFactory, this.contextMenuFactory = e.contextMenuFactory, this.enterpriseMenuFactory = e.enterpriseMenuFactory;
  }
  postConstruct() {
    this.activeMenuFactory = this.enterpriseMenuFactory ?? this.filterMenuFactory;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
    this.showColumnMenuCommon(t, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, r) {
    this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, r);
  }
  getContextMenuPosition(e, t) {
    const r = this.getRowCtrl(e), n = this.getCellGui(r, t);
    if (!n)
      return r ? { x: 0, y: r.getRowYPosition() } : { x: 0, y: 0 };
    const i = n.getBoundingClientRect();
    return {
      x: i.x + i.width / 2,
      y: i.y + i.height / 2
    };
  }
  showContextMenu(e) {
    var o;
    const t = e.rowNode, r = e.column;
    let { anchorToElement: n, value: i } = e;
    t && r && i == null && (i = this.valueService.getValueForDisplay(r, t)), n == null && (n = this.getContextMenuAnchorElement(t, r)), (o = this.contextMenuFactory) == null || o.onContextMenu(
      e.mouseEvent ?? null,
      e.touchEvent ?? null,
      t ?? null,
      r ?? null,
      i,
      n
    );
  }
  showColumnChooser(e) {
    var t;
    (t = this.columnChooserFactory) == null || t.showColumnChooser(e);
  }
  hidePopupMenu() {
    var e;
    (e = this.contextMenuFactory) == null || e.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu();
  }
  hideColumnChooser() {
    var e;
    (e = this.columnChooserFactory) == null || e.hideActiveColumnChooser();
  }
  isColumnMenuInHeaderEnabled(e) {
    const { suppressMenu: t, suppressHeaderMenuButton: r } = e.getColDef();
    return !(r ?? t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    const t = e && go(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef();
    return !(t != null && t.suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(wo() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.filterManager) != null && t.isFilterAllowed(e)) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isColumnMenuAnchoringEnabled() {
    return !this.isLegacyMenuEnabled();
  }
  areAdditionalColumnMenuItemsEnabled() {
    return this.getColumnMenuType() === "new";
  }
  isLegacyMenuEnabled() {
    return this.getColumnMenuType() === "legacy";
  }
  isFloatingFilterButtonEnabled(e) {
    var n;
    const t = e.getColDef(), r = (n = t.floatingFilterComponentParams) == null ? void 0 : n.suppressFilterButton;
    return r != null && ie(
      "As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."
    ), t.suppressFloatingFilterButton == null ? !r : !t.suppressFloatingFilterButton;
  }
  getColumnMenuType() {
    return this.gos.get("columnMenu");
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos.get("suppressMenuHide");
    return this.isLegacyMenuEnabled() ? this.gos.exists("suppressMenuHide") ? e : !1 : e;
  }
  showColumnMenuCommon(e, t, r, n) {
    const { positionBy: i } = t, o = t.column;
    if (i === "button") {
      const { buttonElement: s } = t;
      e.showMenuAfterButtonClick(o, s, r, n);
    } else if (i === "mouse") {
      const { mouseEvent: s } = t;
      e.showMenuAfterMouseEvent(o, s, r, n);
    } else o && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(o, "auto"), this.animationFrameService.requestAnimationFrame(() => {
      var a;
      const s = (a = this.ctrlsService.getHeaderRowContainerCtrl(o.getPinned())) == null ? void 0 : a.getHeaderCtrlForColumn(o);
      s && e.showMenuAfterButtonClick(
        o,
        s.getAnchorElementForMenu(n),
        r,
        !0
      );
    }));
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: r } = e || {};
    if (t != null)
      return this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const r = e.getCellCtrl(t);
    return (r == null ? void 0 : r.getGui()) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const r = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(), n = this.getRowCtrl(e);
    if (!n)
      return r;
    const i = this.getCellGui(n, t);
    return i || (n.isFullWidth() ? n.getFullWidthElement() : r);
  }
}, N6 = class extends Uo {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const r = super.setValue(e, t);
    return this.eInput.value = e, r;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, B6 = {
  selector: "AG-INPUT-TEXT-AREA",
  component: N6
}, G6 = class extends Ga {
  constructor() {
    super(
      /* html */
      `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
      [B6]
    ), this.eTextArea = Fe;
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), de(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === V.LEFT || t === V.UP || t === V.RIGHT || t === V.DOWN || e.shiftKey && t === V.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue();
    return !de(e) && !de(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
}, H6 = class extends Ga {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = e;
  }
  postConstruct() {
    as(this.gos, this.getGui(), "popupEditorWrapper", !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, r = (n) => {
      Rm(this.gos, n, t.node, t.column, !0) || t.onKeyDown(n);
    };
    this.addManagedElementListeners(e, { keydown: r });
  }
}, W6 = class extends Ga {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
      [pG]
    ), this.eSelect = Fe, this.startedByEnter = !1;
  }
  wireBeans(e) {
    this.valueService = e.valueService;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueService: r, gos: n } = this, { values: i, value: o, eventKey: s } = e;
    if (Ke(i)) {
      ie("no values found for select cellEditor");
      return;
    }
    this.startedByEnter = s != null ? s === V.ENTER : !1;
    let a = !1;
    i.forEach((h) => {
      const f = { value: h }, p = r.formatValue(e.column, null, h), y = p != null;
      f.text = y ? p : h, t.addOption(f), a = a || o === h;
    }), a ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: u, valueListMaxHeight: d } = e;
    l != null && t.setPickerGap(l), d != null && t.setPickerMaxHeight(d), u != null && t.setPickerMaxWidth(u), n.get("editType") !== "fullRow" && this.addManagedListeners(this.eSelect, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}, Xh = class extends Ga {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`,
      e.getAgComponents()
    ), this.cellEditorInput = e, this.eInput = Fe;
  }
  init(e) {
    this.params = e;
    const { cellStartedEdit: t, eventKey: r, suppressPreventDefault: n } = e, i = this.eInput;
    this.cellEditorInput.init(i, e);
    let o, s = !0;
    t ? (this.focusAfterAttached = !0, r === V.BACKSPACE || r === V.DELETE ? o = "" : r && r.length === 1 ? n ? s = !1 : o = r : (o = this.cellEditorInput.getStartValue(), r !== V.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, o = this.cellEditorInput.getStartValue()), s && o != null && i.setStartValue(o), this.addManagedElementListeners(i.getGui(), {
      keydown: (a) => {
        const { key: l } = a;
        (l === V.PAGE_UP || l === V.PAGE_DOWN) && a.preventDefault();
      }
    });
  }
  afterGuiAttached() {
    var n, i;
    const e = this.localeService.getLocaleTextFunc(), t = this.eInput;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    ai() || t.getFocusableElement().focus();
    const r = t.getInputElement();
    this.highlightAllOnFocus ? r.select() : (i = (n = this.cellEditorInput).setCaret) == null || i.call(n);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), r = e.getInputElement();
    t.focus(), r.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
}, V6 = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>'
    );
  }
  getAgComponents() {
    return [Yh];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !de(e) && !de(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = de(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}, _P = class extends Xh {
  constructor() {
    super(new V6());
  }
}, $6 = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>'
    );
  }
  getAgComponents() {
    return [EG];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step);
    const r = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(r, { keydown: this.preventStepping }) : t.showStepperButtons && r.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === V.UP || e.key === V.DOWN) && e.preventDefault();
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!de(e) && !de(this.params.value))
      return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null)
      return t;
    if (typeof t == "string") {
      if (t === "")
        return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
  setCaret() {
    ai() && this.eInput.getInputElement().focus({ preventScroll: !0 });
  }
}, j6 = class extends Xh {
  constructor() {
    super(new $6());
  }
}, U6 = class extends ms {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = ai();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        this.isDisabled() || e || this.eInput.focus();
      }
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    Dt(this.gos) === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Rn(e ?? null, !1) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, xn(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Rn(e ?? null, !1) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, xn(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, xn(this.eInput, "step", e), this);
  }
  getDate() {
    if (this.eInput.validity.valid)
      return Br(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Rn(e ?? null, !1), t);
  }
}, zP = {
  selector: "AG-INPUT-DATE-FIELD",
  component: U6
}, K6 = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [zP];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !de(e) && !de(this.params.value) ? this.params.value : e ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Rn(e, !1);
  }
}, q6 = class extends Xh {
  constructor() {
    super(new K6());
  }
}, Y6 = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [zP];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !de(e) && !de(this.params.value) ? this.params.value : this.params.parseValue(e ?? "");
  }
  getStartValue() {
    return Rn(this.parseDate(this.params.value ?? void 0) ?? null, !1);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : Br(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Rn(e ?? null, !1) ?? void 0;
  }
}, J6 = class extends Xh {
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  constructor() {
    super(new Y6(() => this.dataTypeService));
  }
}, X6 = class extends Ga {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [V0]
    ), this.eCheckbox = Fe;
  }
  init(e) {
    this.params = e;
    const t = e.value ?? void 0;
    this.eCheckbox.setValue(t), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(this.eCheckbox, {
      fieldValueChanged: (n) => this.setAriaLabel(n.selected)
    });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), r = k0(t, e), n = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${n} (${r})`);
  }
}, Nl = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, Sp = class extends Nl {
  constructor(e, t, r, n) {
    super(e), this.initialRange = t, this.finalRange = r, this.ranges = n;
  }
}, Q6 = 10, wS = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || Q6, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, Z6 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "undoRedoService", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, r = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), n = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(r || n || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: o, rowIndex: s, column: a, oldValue: l, value: u } = e, d = {
        rowPinned: o,
        rowIndex: s,
        columnId: a.getColId(),
        newValue: u,
        oldValue: l
      };
      this.cellValueChanges.push(d);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.cellPositionUtils = e.cellPositionUtils, this.rowPositionUtils = e.rowPositionUtils, this.columnModel = e.columnModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    if (!this.gos.get("undoRedoCellEditing"))
      return;
    const e = this.gos.get("undoRedoCellEditingLimit");
    if (e <= 0)
      return;
    this.undoStack = new wS(e), this.redoStack = new wS(e), this.addListeners();
    const t = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (r) => {
        r.keepUndoRedoStack || this.clearStacks();
      },
      columnPivotModeChanged: t,
      newColumnsLoaded: t,
      columnGroupOpened: t,
      columnRowGroupChanged: t,
      columnMoved: t,
      columnPinned: t,
      columnVisible: t,
      rowDragEnd: t
    }), this.ctrlsService.whenReady(this, (r) => {
      this.gridBodyCtrl = r.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    this.eventService.dispatchEvent({
      type: "undoStarted",
      source: e
    });
    const t = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo");
    this.eventService.dispatchEvent({
      type: "undoEnded",
      source: e,
      operationPerformed: t
    });
  }
  redo(e) {
    this.eventService.dispatchEvent({
      type: "redoStarted",
      source: e
    });
    const t = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo");
    this.eventService.dispatchEvent({
      type: "redoEnded",
      source: e,
      operationPerformed: t
    });
  }
  undoRedo(e, t, r, n, i) {
    if (!e)
      return !1;
    const o = e.pop();
    return !o || !o.cellValueChanges ? !1 : (this.processAction(
      o,
      (s) => s[n],
      i
    ), o instanceof Sp ? this.processRange(this.rangeService, o.ranges || [o[r]]) : this.processCell(o.cellValueChanges), t.push(o), !0);
  }
  processAction(e, t, r) {
    e.cellValueChanges.forEach((n) => {
      const { rowIndex: i, rowPinned: o, columnId: s } = n, a = { rowIndex: i, rowPinned: o }, l = this.rowPositionUtils.getRowNode(a);
      l.displayed && l.setDataValue(s, t(n), r);
    });
  }
  processRange(e, t) {
    let r;
    e.removeAllCellRanges(!0), t.forEach((n, i) => {
      if (!n)
        return;
      const o = n.startRow, s = n.endRow;
      i === t.length - 1 && (r = {
        rowPinned: o.rowPinned,
        rowIndex: o.rowIndex,
        columnId: n.startColumn.getColId()
      }, this.setLastFocusedCell(r));
      const a = {
        rowStartIndex: o.rowIndex,
        rowStartPinned: o.rowPinned,
        rowEndIndex: s.rowIndex,
        rowEndPinned: s.rowPinned,
        columnStart: n.startColumn,
        columns: n.columns
      };
      e.addCellRange(a);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: r, rowPinned: n } = t, i = { rowIndex: r, rowPinned: n }, o = this.rowPositionUtils.getRowNode(i), s = {
      rowPinned: t.rowPinned,
      rowIndex: o.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(s, this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: r, columnId: n, rowPinned: i } = e, o = this.gridBodyCtrl.getScrollFeature(), s = this.columnModel.getCol(n);
    if (!s)
      return;
    o.ensureIndexVisible(r), o.ensureColumnVisible(s);
    const a = { rowIndex: r, column: s, rowPinned: i };
    this.focusService.setFocusedCell({ ...a, forceBrowserFocus: !0 }), t == null || t.setRangeToCell(a);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const e = new Nl(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
          const r = new Nl(this.cellValueChanges);
          this.pushActionsToUndoStack(r);
        }
      },
      pasteStart: () => {
        this.isPasting = !0;
      },
      pasteEnd: () => {
        const e = new Nl(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.isPasting = !1;
      },
      fillStart: () => {
        this.isRangeInAction = !0;
      },
      fillEnd: (e) => {
        const t = new Sp(this.cellValueChanges, e.initialRange, e.finalRange);
        this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = !0;
      },
      keyShortcutChangedCellEnd: () => {
        let e;
        this.rangeService && Ii(this.gos) ? e = new Sp(this.cellValueChanges, void 0, void 0, [
          ...this.rangeService.getCellRanges()
        ]) : e = new Nl(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
      }
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
};
function eH(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
}
function tH(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getHScrollPosition();
}
function NP(e, t, r = "auto") {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(t, r),
    "ensureVisible"
  );
}
function BP(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureIndexVisible(t, r),
    "ensureVisible"
  );
}
function rH(e, t, r = null) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureNodeVisible(t, r),
    "ensureVisible"
  );
}
function nH(e) {
  var t;
  (t = e.undoRedoService) == null || t.undo("api");
}
function iH(e) {
  var t;
  (t = e.undoRedoService) == null || t.redo("api");
}
function oH(e, t = {}) {
  return e.rowRenderer.getCellEditorInstances(t).map($l);
}
function sH(e) {
  return e.rowRenderer.getEditingCells();
}
function aH(e, t = !1) {
  e.rowRenderer.stopEditing(t);
}
function lH(e, t) {
  const r = e.columnModel.getCol(t.colKey);
  if (!r) {
    ie(`no column found for ${t.colKey}`);
    return;
  }
  const n = {
    rowIndex: t.rowIndex,
    rowPinned: t.rowPinned || null,
    column: r
  };
  t.rowPinned == null && BP(e, t.rowIndex), NP(e, t.colKey);
  const o = e.navigationService.getCellByPosition(n);
  if (!o)
    return;
  const { focusService: s, gos: a } = e, l = () => {
    const d = Dt(a), h = o.getGui();
    return d !== h && !!(h != null && h.contains(d));
  }, u = a.get("stopEditingWhenCellsLoseFocus") && l();
  (u || !s.isCellFocused(n)) && s.setFocusedCell({
    ...n,
    forceBrowserFocus: u,
    preventScrollOnBrowserFocus: !0
  }), o.startRowOrCellEdit(t.key);
}
function cH(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentUndoStackSize()) ?? 0;
}
function uH(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentRedoStackSize()) ?? 0;
}
var dH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "editService";
  }
  wireBeans(e) {
    this.navigationService = e.navigationService, this.userComponentFactory = e.userComponentFactory, this.valueService = e.valueService;
  }
  startEditing(e, t = null, r = !1, n = null) {
    var u;
    const i = this.createCellEditorParams(e, t, r), o = e.getColumn().getColDef(), s = this.userComponentFactory.getCellEditorDetails(o, i), a = (s == null ? void 0 : s.popupFromSelector) != null ? s.popupFromSelector : !!o.cellEditorPopup, l = (s == null ? void 0 : s.popupPositionFromSelector) != null ? s.popupPositionFromSelector : o.cellEditorPopupPosition;
    return e.setEditing(!0, s), e.getComp().setEditDetails(s, a, l, this.gos.get("reactiveCustomComponents")), this.eventService.dispatchEvent(e.createEvent(n, "cellEditingStarted")), !((u = s == null ? void 0 : s.params) != null && u.suppressPreventDefault);
  }
  stopEditing(e, t) {
    const r = e.getComp(), { newValue: n, newValueExists: i } = this.takeValueFromCellEditor(t, r), o = e.getRowNode(), s = e.getColumn(), a = this.valueService.getValueForDisplay(s, o);
    let l = !1;
    return i && (l = this.saveNewValue(e, a, n, o, s)), e.setEditing(!1, void 0), r.setEditDetails(), e.updateAndFormatValue(!1), e.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.eventService.dispatchEvent({
      ...e.createEvent(null, "cellEditingStopped"),
      oldValue: a,
      newValue: n,
      valueChanged: l
    }), l;
  }
  handleColDefChanged(e) {
    const t = e.getCellEditor();
    if (t != null && t.refresh) {
      const { eventKey: r, cellStartedEdit: n } = e.getEditCompDetails().params, i = this.createCellEditorParams(e, r, n), o = e.getColumn().getColDef(), s = this.userComponentFactory.getCellEditorDetails(o, i);
      t.refresh(s.params);
    }
  }
  setFocusOutOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor(e) {
    const t = e.getComp(), r = t.getCellEditor();
    r != null && r.focusIn ? r.focusIn() : (e.focusCell(!0), e.onCellEditorAttached(() => {
      var n, i;
      return (i = (n = t.getCellEditor()) == null ? void 0 : n.focusIn) == null ? void 0 : i.call(n);
    }));
  }
  stopEditingAndFocus(e, t = !1, r = !1) {
    e.stopRowOrCellEdit(), e.focusCell(!0), t || this.navigateAfterEdit(r, e.getCellPosition());
  }
  createPopupEditorWrapper(e) {
    return new H6(e);
  }
  takeValueFromCellEditor(e, t) {
    const r = { newValueExists: !1 };
    if (e)
      return r;
    const n = t.getCellEditor();
    return !n || n.isCancelAfterEnd && n.isCancelAfterEnd() ? r : {
      newValue: n.getValue(),
      newValueExists: !0
    };
  }
  /**
   * @returns `True` if the value changes, otherwise `False`.
   */
  saveNewValue(e, t, r, n, i) {
    if (r === t)
      return !1;
    e.setSuppressRefreshCell(!0);
    const o = n.setDataValue(i, r, "edit");
    return e.setSuppressRefreshCell(!1), o;
  }
  createCellEditorParams(e, t, r) {
    const n = e.getColumn(), i = e.getRowNode();
    return this.gos.addGridCommonParams({
      value: this.valueService.getValueForDisplay(n, i),
      eventKey: t,
      column: n,
      colDef: n.getColDef(),
      rowIndex: e.getCellPosition().rowIndex,
      node: i,
      data: i.data,
      cellStartedEdit: r,
      onKeyDown: e.onKeyDown.bind(e),
      stopEditing: e.stopEditingAndFocus.bind(e),
      eGridCell: e.getGui(),
      parseValue: (o) => this.valueService.parseValue(n, i, o, e.getValue()),
      formatValue: e.formatValue.bind(e)
    });
  }
  navigateAfterEdit(e, t) {
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const n = e ? V.UP : V.DOWN;
      this.navigationService.navigateToNextCell(null, n, t, !1);
    }
  }
}, hH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowEditService";
  }
  startEditing(e, t = null, r = null, n = null) {
    let i = !0;
    return e.getAllCellCtrls().reduce((s, a) => {
      const l = a === r;
      return l ? i = a.startEditing(t, l, n) : a.startEditing(null, l, n), s ? !0 : a.isEditing();
    }, !1) && this.setEditing(e, !0), i;
  }
  stopEditing(e, t = !1) {
    const r = e.getAllCellCtrls(), n = e.isEditing();
    e.setStoppingRowEdit(!0);
    let i = !1;
    for (const o of r) {
      const s = o.stopEditing(t);
      n && !t && !i && s && (i = !0);
    }
    i && this.eventService.dispatchEvent(e.createRowEvent("rowValueChanged")), n && this.setEditing(e, !1), e.setStoppingRowEdit(!1);
  }
  setEditing(e, t) {
    e.setEditingRow(t), e.forEachGui(void 0, (n) => n.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const r = t ? e.createRowEvent("rowEditingStarted") : e.createRowEvent("rowEditingStopped");
    this.eventService.dispatchEvent(r);
  }
}, vs = {
  version: Te,
  moduleName: "@ag-grid-community/edit-core",
  beans: [dH]
}, gH = {
  version: Te,
  moduleName: "@ag-grid-community/edit-api",
  apiFunctions: {
    undoCellEditing: nH,
    redoCellEditing: iH,
    getCellEditorInstances: oH,
    getEditingCells: sH,
    stopEditing: aH,
    startEditingCell: lH,
    getCurrentUndoSize: cH,
    getCurrentRedoSize: uH
  },
  dependantModules: [vs]
}, fH = {
  version: Te,
  moduleName: "@ag-grid-community/undo-redo-edit",
  beans: [Z6],
  dependantModules: [vs]
}, pH = {
  version: Te,
  moduleName: "@ag-grid-community/full-row-edit",
  beans: [hH],
  dependantModules: [vs]
}, GP = {
  version: Te,
  moduleName: "@ag-grid-community/default-editor",
  userComponents: [{ name: "agCellEditor", classImp: _P }],
  dependantModules: [vs]
}, mH = {
  version: Te,
  moduleName: "@ag-grid-community/data-type-editors",
  userComponents: [
    { name: "agTextCellEditor", classImp: _P },
    {
      name: "agNumberCellEditor",
      classImp: j6,
      params: {
        suppressPreventDefault: !0
      }
    },
    { name: "agDateCellEditor", classImp: q6 },
    { name: "agDateStringCellEditor", classImp: J6 },
    { name: "agCheckboxCellEditor", classImp: X6 }
  ],
  dependantModules: [GP]
}, vH = {
  version: Te,
  moduleName: "@ag-grid-community/select-editor",
  userComponents: [{ name: "agSelectCellEditor", classImp: W6 }],
  dependantModules: [vs]
}, yH = {
  version: Te,
  moduleName: "@ag-grid-community/large-text-editor",
  userComponents: [{ name: "agLargeTextCellEditor", classImp: G6 }],
  dependantModules: [vs]
}, CH = {
  version: Te,
  moduleName: "@ag-grid-community/all-editors",
  dependantModules: [GP, mH, vH, yH]
}, wH = {
  version: Te,
  moduleName: "@ag-grid-community/editing",
  dependantModules: [vs, fH, pH, CH, gH]
}, bH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalculator";
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const r = this.getHeaderCellForColumn(e);
    if (!r)
      return -1;
    const n = this.rowRenderer.getAllCellsForColumn(e);
    return t || n.push(r), this.addElementsToContainerAndGetWidth(n);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const r = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((o) => this.cloneItemIntoDummy(o, t)), r.appendChild(t);
    const n = t.offsetWidth;
    r.removeChild(t);
    const i = this.getAutoSizePadding();
    return n + i;
  }
  getAutoSizePadding() {
    return this.gos.get("autoSizePadding");
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach((r) => {
      const n = r.getHtmlElementForColumnHeader(e);
      n != null && (t = n);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const r = e.cloneNode(!0);
    r.style.width = "", r.style.position = "static", r.style.left = "";
    const n = document.createElement("div"), i = n.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((a) => r.classList.contains(a)) ? (i.add("ag-header", "ag-header-row"), n.style.position = "static") : i.add("ag-row");
    let s = e.parentElement;
    for (; s; ) {
      if (["ag-header-row", "ag-row"].some((l) => s.classList.contains(l))) {
        for (let l = 0; l < s.classList.length; l++) {
          const u = s.classList[l];
          u != "ag-row-position-absolute" && i.add(u);
        }
        break;
      }
      s = s.parentElement;
    }
    n.appendChild(r), t.appendChild(n);
  }
}, SH = class extends J {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.isClientSide = At(this.gos), this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    }), this.resetStickyContainers();
  }
  getStickyTopRowCtrls() {
    return this.stickyTopRowCtrls;
  }
  getStickyBottomRowCtrls() {
    return this.stickyBottomRowCtrls;
  }
  setOffsetTop(e) {
    this.extraTopHeight !== e && (this.extraTopHeight = e, this.eventService.dispatchEvent({
      type: "stickyTopOffsetChanged",
      offset: e
    }));
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  getExtraTopHeight() {
    return this.extraTopHeight;
  }
  getExtraBottomHeight() {
    return this.extraBottomHeight;
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  getServerSideLastPixelOfGroup(e) {
    var t, r;
    if (this.isClientSide)
      throw new Error("This func should only be called in server side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.master)
        return e.detailNode.rowTop + e.detailNode.rowHeight;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let i = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
        return e.footer && (i = (r = e.sibling.childStore) == null ? void 0 : r.getStoreBounds()), ((i == null ? void 0 : i.heightPx) ?? 0) + ((i == null ? void 0 : i.topPx) ?? 0);
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  getClientSideLastPixelOfGroup(e) {
    if (!this.isClientSide)
      throw new Error("This func should only be called in client side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.footer && e.rowIndex === 0)
        return Number.MAX_SAFE_INTEGER;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let n = e.footer ? e.sibling : e;
        for (; n.isExpandable() && n.expanded; )
          if (n.master)
            n = n.detailNode;
          else if (n.childrenAfterSort) {
            if (n.childrenAfterSort.length === 0)
              break;
            n = Ye(n.childrenAfterSort);
          }
        return n.rowTop + n.rowHeight;
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let r = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), r);
    const n = t ? this.rowRenderer.getFirstVisibleVerticalPixel() - this.extraTopHeight : this.rowRenderer.getLastVisibleVerticalPixel() - this.extraTopHeight, i = /* @__PURE__ */ new Set(), o = (u) => {
      if (i.add(u), t) {
        const d = this.getLastPixelOfGroup(u), h = n + r + u.rowHeight;
        d < h ? u.stickyRowTop = r + (d - h) : u.stickyRowTop = r;
      } else {
        const d = this.getFirstPixelOfGroup(u), h = n - (r + u.rowHeight);
        d > h ? u.stickyRowTop = r - (d - h) : u.stickyRowTop = r;
      }
      r = 0, i.forEach((d) => {
        const h = d.stickyRowTop + d.rowHeight;
        r < h && (r = h);
      });
    }, s = this.areFooterRowsStickySuppressed(), a = this.gos.get("suppressGroupRowsSticky"), l = (u) => {
      if (!u.displayed)
        return !1;
      if (u.footer) {
        if (s === !0 || s === "grand" && u.level === -1 || s === "group" && u.level > -1)
          return !1;
        const d = u.sibling.rowIndex ? u.sibling.rowIndex + 1 === u.rowIndex : !1;
        return e === "bottom" && d ? !1 : !i.has(u);
      }
      return u.isExpandable() ? a === !0 || e === "bottom" ? !1 : !i.has(u) && u.expanded : !1;
    };
    for (let u = 0; u < 100; u++) {
      let d = n + r;
      t || (d = n - r);
      const h = this.rowModel.getRowIndexAtPixel(d), f = this.rowModel.getRow(h);
      if (f == null)
        break;
      const y = this.getStickyAncestors(f).find(
        (v) => (t ? v.rowIndex < h : v.rowIndex > h) && l(v)
      );
      if (y) {
        o(y);
        continue;
      }
      if ((t ? f.rowTop < d : f.rowTop + f.rowHeight > d) && l(f)) {
        o(f);
        continue;
      }
      break;
    }
    return t || i.forEach((u) => {
      u.stickyRowTop = r - (u.stickyRowTop + u.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, i, r);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = !!this.gos.get("groupIncludeFooter") || e === "group", r = !!this.gos.get("groupIncludeTotalFooter") || e === "grand";
    return t && r ? !0 : r ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = jh(this.gos), t = this.areFooterRowsStickySuppressed(), r = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !r);
  }
  getStickyAncestors(e) {
    const t = [];
    let r = e.footer ? e.sibling : e.parent;
    for (; r; )
      r.sibling && t.push(r.sibling), t.push(r), r = r.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.resetStickyContainers();
  }
  resetStickyContainers() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((r) => r.getRowNode() === e)) {
      for (let r = 0; r < this.stickyTopRowCtrls.length; r++) {
        const n = this.stickyTopRowCtrls[r].getRowNode();
        n !== e && t.add(n);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let r = 0; r < this.stickyBottomRowCtrls.length; r++) {
      const n = this.stickyBottomRowCtrls[r].getRowNode();
      n !== e && t.add(n);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, r) {
    const n = e === "top", i = n ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, o = {}, s = [];
    for (let f = 0; f < i.length; f++) {
      const p = i[f].getRowNode();
      if (!t.has(p)) {
        o[p.id] = i[f], p.sticky = !1;
        continue;
      }
      s.push(i[f]);
    }
    const a = /* @__PURE__ */ new Set();
    for (let f = 0; f < s.length; f++)
      a.add(s[f].getRowNode());
    const l = [];
    t.forEach((f) => {
      a.has(f) || (f.sticky = !0, l.push(this.createRowCon(f, !1, !1)));
    });
    let u = !!l.length || s.length !== i.length;
    n ? this.topContainerHeight !== r && (this.topContainerHeight = r, this.gridBodyCtrl.setStickyTopHeight(r), u = !0) : this.bottomContainerHeight !== r && (this.bottomContainerHeight = r, this.gridBodyCtrl.setStickyBottomHeight(r), u = !0), this.destroyRowCtrls(o, !1);
    const d = [...s, ...l];
    d.sort((f, p) => p.getRowNode().rowIndex - f.getRowNode().rowIndex), n || d.reverse(), d.forEach((f) => f.setRowTop(f.getRowNode().stickyRowTop));
    let h = 0;
    return n ? (t.forEach((f) => {
      f.rowIndex < this.pageBoundsService.getFirstRow() && (h += f.rowHeight);
    }), h > this.topContainerHeight && (h = this.topContainerHeight), this.setOffsetTop(h)) : (t.forEach((f) => {
      f.rowIndex > this.pageBoundsService.getLastRow() && (h += f.rowHeight);
    }), h > this.bottomContainerHeight && (h = this.bottomContainerHeight), this.setOffsetBottom(h)), u ? (n ? this.stickyTopRowCtrls = d : this.stickyBottomRowCtrls = d, !0) : !1;
  }
  ensureRowHeightsValid() {
    let e = !1;
    const t = (r) => {
      const n = r.getRowNode();
      if (n.rowHeightEstimated) {
        const i = ho(this.gos, n);
        n.setRowHeight(i.height), e = !0;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
}, xH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((o) => o.onCellSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((o) => o.updateRangeBordersIfRangeCount());
      }, r = () => {
        this.eventService.addEventListener("cellSelectionChanged", e), this.eventService.addEventListener("columnMoved", t), this.eventService.addEventListener("columnPinned", t), this.eventService.addEventListener("columnVisible", t);
      }, n = () => {
        this.eventService.removeEventListener("cellSelectionChanged", e), this.eventService.removeEventListener("columnMoved", t), this.eventService.removeEventListener("columnPinned", t), this.eventService.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => n()), this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        Ii(this.gos) ? r() : n();
      }), Ii(this.gos) && r();
    };
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusService = e.focusService, this.beans = e, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListener("suppressCellFocus", (e) => this.onSuppressCellFocusChanged(e.currentValue)), this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection",
        "rowSelection"
      ],
      () => this.redrawRows()
    ), jh(this.gos) && (At(this.gos) || yo(this.gos)) && (this.stickyRowFeature = this.createManagedBean(
      new SH(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this))
    )), this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = ar(this.gos, "print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new RH(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = vm(this.rowCtrlsByRowIndex), t = vm(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    t.length > 0 || r.length > 0 ? this.allRowCtrls = [...e, ...t, ...r] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  onSuppressCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)), this.getFullWidthRowCtrls().forEach((t) => t.onSuppressCellFocusChanged(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => {
        this.onCellFocusChanged(e);
      },
      cellFocusCleared: () => this.onCellFocusChanged(),
      flashCells: (e) => {
        this.getAllCellCtrls().forEach((t) => t.onFlashCells(e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.columnModel.getCols().forEach((t) => {
      const r = (l) => {
        this.getAllCellCtrls().forEach((u) => {
          u.getColumn() === t && l(u);
        });
      }, n = () => {
        r((l) => l.onLeftChanged());
      }, i = () => {
        r((l) => l.onWidthChanged());
      }, o = () => {
        r((l) => l.onFirstRightPinnedChanged());
      }, s = () => {
        r((l) => l.onLastLeftPinnedChanged());
      }, a = () => {
        r((l) => l.onColDefChanged());
      };
      t.addEventListener("leftChanged", n), t.addEventListener("widthChanged", i), t.addEventListener("firstRightPinnedChanged", o), t.addEventListener("lastLeftPinnedChanged", s), t.addEventListener("colDefChanged", a), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", n), t.removeEventListener("widthChanged", i), t.removeEventListener("firstRightPinnedChanged", o), t.removeEventListener("lastLeftPinnedChanged", s), t.removeEventListener("colDefChanged", a);
      });
    });
  }
  onDomLayoutChanged() {
    const e = ar(this.gos, "print"), t = e || this.gos.get("embedFullWidthRows"), r = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, r && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((r) => {
      const n = r.getCellElement(e);
      n && t.push(n);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, "top"), this.refreshFloatingRows(this.bottomRowCtrls, "bottom");
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getCentreRowCtrls() {
    return this.allRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t) {
    const { pinnedRowModel: r, beans: n, printLayout: i } = this, o = Object.fromEntries(e.map((a) => [a.getRowNode().id, a]));
    r.forEachPinnedRow(t, (a, l) => {
      const u = e[l];
      u && r.getPinnedRowById(u.getRowNode().id, t) === void 0 && (u.destroyFirstPass(), u.destroySecondPass()), a.id in o ? (e[l] = o[a.id], delete o[a.id]) : e[l] = new rs(a, n, !1, !1, i);
    });
    const s = t === "top" ? r.getPinnedTopRowCount() : r.getPinnedBottomRowCount();
    e.length = s;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = !1) {
    var r;
    if (e.sticky)
      this.stickyRowFeature.refreshStickyNode(e);
    else if ((r = this.cachedRowCtrls) != null && r.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const n = (i) => {
        const o = i[e.rowIndex];
        o && o.getRowNode() === e && (o.destroyFirstPass(), o.destroySecondPass(), i[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          n(this.topRowCtrls);
          break;
        case "bottom":
          n(this.bottomRowCtrls);
          break;
        default:
          n(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((r) => this.redrawRow(r, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const r = Dt(this.gos), n = tc(this.gos, r, ts.DOM_DATA_KEY_CELL_CTRL), i = tc(this.gos, r, rs.DOM_DATA_KEY_ROW_CTRL);
    return n || i ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const r = !e.domLayoutChanged && !!e.recycleRows, n = e.animate && Js(this.gos), i = r ? this.getRowsToRecycle() : null;
    if (r || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature) {
      this.stickyRowFeature.checkStickyRows();
      const o = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      o && this.updateContainerHeights(o);
    }
    this.recycleRows(i, n), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var n;
    const t = e.newData || e.newPage, r = this.gos.get("suppressScrollOnNewData");
    t && !r && (this.gridBodyCtrl.getScrollFeature().scrollToTop(), (n = this.stickyRowFeature) == null || n.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let t = this.pageBoundsService.getCurrentPageHeight();
    t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t + e);
  }
  getLockOnRefresh() {
    var e, t;
    if (this.refreshInProgress)
      throw new Error(
        "AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace."
      );
    this.refreshInProgress = !0, (t = (e = this.frameworkOverrides).getLockOnRefresh) == null || t.call(e);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && this.focusService.restoreFocusedCell(e, () => {
      this.onCellFocusChanged(
        this.gos.addGridCommonParams({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          type: "cellFocused"
        })
      );
    });
  }
  stopEditing(e = !1) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), r = t.length;
    for (let n = 0; n < r; n++) {
      const i = t[n].getAllCellCtrls(), o = i.length;
      for (let s = 0; s < o; s++)
        e.push(i[s]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [], t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [], r = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
    for (const n in this.rowCtrlsByRowIndex)
      r.push(this.rowCtrlsByRowIndex[n]);
    return r;
  }
  addRenderedRowListener(e, t, r) {
    const n = this.rowCtrlsByRowIndex[t];
    n && n.addEventListener(e, r);
  }
  flashCells(e = {}) {
    this.getCellCtrls(e.rowNodes, e.columns).forEach(
      (t) => t.flashCell(e)
    );
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    for (const r of this.getCellCtrls(e.rowNodes, e.columns))
      r.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = null;
    this.stickyRowFeature && uS() && (t = this.getCellToRestoreFocusToAfterRefresh() || null);
    for (const r of this.getRowCtrls(e)) {
      if (!r.isFullWidth())
        continue;
      r.refreshFullWidth() || this.redrawRow(r.getRowNode(), !0);
    }
    this.dispatchDisplayedRowsChanged(!1), t && this.restoreFocusedCell(t);
  }
  getCellRendererInstances(e) {
    var i;
    const t = this.getCellCtrls(e.rowNodes, e.columns).map((o) => o.getCellRenderer()).filter((o) => o != null);
    if ((i = e.columns) != null && i.length)
      return t;
    const r = [], n = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((o) => {
      if (n && !this.isRowInMap(o.getRowNode(), n) || !o.isFullWidth())
        return;
      const s = o.getFullWidthCellRenderers();
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        l != null && r.push(l);
      }
    }), [...r, ...t];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => {
      const n = r.getCellEditor();
      n && t.push(n);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const r = t.getCellPosition();
        e.push(r);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e)
      return;
    const t = {
      top: {},
      bottom: {},
      normal: {}
    };
    return e.forEach((r) => {
      const n = r.id;
      switch (r.rowPinned) {
        case "top":
          t.top[n] = r;
          break;
        case "bottom":
          t.bottom[n] = r;
          break;
        default:
          t.normal[n] = r;
          break;
      }
    }), t;
  }
  isRowInMap(e, t) {
    const r = e.id;
    switch (e.rowPinned) {
      case "top":
        return t.top[r] != null;
      case "bottom":
        return t.bottom[r] != null;
      default:
        return t.normal[r] != null;
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = this.mapRowNodes(e), r = this.getAllRowCtrls();
    return !e || !t ? r : r.filter((n) => {
      const i = n.getRowNode();
      return this.isRowInMap(i, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let r;
    de(t) && (r = {}, t.forEach((i) => {
      const o = this.columnModel.getCol(i);
      de(o) && (r[o.getId()] = !0);
    }));
    const n = [];
    return this.getRowCtrls(e).forEach((i) => {
      i.getAllCellCtrls().forEach((o) => {
        const s = o.getColumn().getId();
        r && !r[s] || n.push(o);
      });
    }), n;
  }
  destroy() {
    this.removeAllRowComps(!0), super.destroy();
  }
  removeAllRowComps(e = !1) {
    const t = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(t, e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    zn(this.rowCtrlsByRowIndex, (r, n) => {
      n.getRowNode().id == null && e.push(r);
    }), this.removeRowCtrls(e);
    const t = {};
    return zn(this.rowCtrlsByRowIndex, (r, n) => {
      const i = n.getRowNode();
      t[i.id] = n;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((r) => {
      const n = this.rowCtrlsByRowIndex[r];
      n && (n.destroyFirstPass(t), n.destroySecondPass()), delete this.rowCtrlsByRowIndex[r];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { afterScroll: t } = e;
    let r;
    this.stickyRowFeature && uS() && (r = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const n = this.firstRenderedRow, i = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let o = !1;
    if (this.stickyRowFeature) {
      o = this.stickyRowFeature.checkStickyRows();
      const a = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      a && this.updateContainerHeights(a);
    }
    const s = this.firstRenderedRow !== n || this.lastRenderedRow !== i;
    if (!(t && !o && !s) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !o), r != null)) {
      const a = this.getCellToRestoreFocusToAfterRefresh();
      r != null && a == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(r));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const r = {};
    e.forEach((o) => r[o] = !0);
    const i = Object.keys(this.rowCtrlsByRowIndex).filter((o) => !r[o]);
    this.removeRowCtrls(i, t);
  }
  calculateIndexesToDraw(e) {
    const t = FG(this.firstRenderedRow, this.lastRenderedRow), r = (i, o) => {
      const s = o.getRowNode().rowIndex;
      s != null && (s < this.firstRenderedRow || s > this.lastRenderedRow) && this.doNotUnVirtualiseRow(o) && t.push(s);
    };
    zn(this.rowCtrlsByRowIndex, r), zn(e, r), t.sort((i, o) => i - o);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], s = this.rowModel.getRow(o);
      s && !s.sticky && n.push(o);
    }
    return n;
  }
  recycleRows(e, t = !1, r = !1) {
    const n = this.calculateIndexesToDraw(e);
    (this.printLayout || r) && (t = !1), this.removeRowCompsNotToDraw(n, !t), n.forEach((i) => {
      this.createOrUpdateRowCtrl(i, e, t, r);
    }), e && (r && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    this.eventService.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll: e
    });
  }
  onDisplayedColumnsChanged() {
    const e = this.visibleColsService.isPinningLeft(), t = this.visibleColsService.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const r = t.getRowNode().rowIndex;
      e.push(r.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((r) => {
      if (!r.isFullWidth())
        return !1;
      const n = r.getRowNode();
      return !(t != null && !this.isRowInMap(n, t));
    });
  }
  createOrUpdateRowCtrl(e, t, r, n) {
    let i, o = this.rowCtrlsByRowIndex[e];
    if (o || (i = this.rowModel.getRow(e), de(i) && de(t) && t[i.id] && i.alreadyRendered && (o = t[i.id], t[i.id] = null)), !o)
      if (i || (i = this.rowModel.getRow(e)), de(i))
        o = this.createRowCon(i, r, n);
      else
        return;
    return i && (i.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = o, o;
  }
  destroyRowCtrls(e, t) {
    const r = [];
    zn(e, (n, i) => {
      if (i) {
        if (this.cachedRowCtrls && i.isCacheable()) {
          this.cachedRowCtrls.addRow(i);
          return;
        }
        if (i.destroyFirstPass(!t), t) {
          const o = i.instanceId;
          this.zombieRowCtrls[o] = i, r.push(() => {
            i.destroySecondPass(), delete this.zombieRowCtrls[o];
          });
        } else
          i.destroySecondPass();
      }
    }), t && (r.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), UN(r));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = Zo(this.gos);
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    this.rowContainerHeightService.updateOffset();
    let e, t;
    if (!this.rowModel.isRowsToRender())
      e = 0, t = -1;
    else if (this.printLayout)
      this.environment.refreshRowHeightVariable(), e = this.pageBoundsService.getFirstRow(), t = this.pageBoundsService.getLastRow();
    else {
      const a = this.getRowBufferInPixels(), l = this.ctrlsService.getGridBodyCtrl(), u = this.gos.get("suppressRowVirtualisation");
      let d = !1, h, f;
      do {
        const w = this.pageBoundsService.getPixelOffset(), { pageFirstPixel: R, pageLastPixel: b } = this.pageBoundsService.getCurrentPagePixelRange(), P = this.rowContainerHeightService.getDivStretchOffset(), S = l.getScrollFeature().getVScrollPosition(), E = S.top, A = S.bottom;
        u ? (h = R + P, f = b + P) : (h = Math.max(E + w - a, R) + P, f = Math.min(A + w + a, b) + P), this.firstVisibleVPixel = Math.max(E + w, R) + P, this.lastVisibleVPixel = Math.min(A + w, b) + P, d = this.ensureAllRowsInRangeHaveHeightsCalculated(h, f);
      } while (d);
      let p = this.rowModel.getRowIndexAtPixel(h), y = this.rowModel.getRowIndexAtPixel(f);
      const C = this.pageBoundsService.getFirstRow(), v = this.pageBoundsService.getLastRow();
      p < C && (p = C), y > v && (y = v), e = p, t = y;
    }
    const r = ar(this.gos, "normal"), n = this.gos.get("suppressMaxRenderedRowRestriction"), i = Math.max(this.getRowBuffer(), 500);
    r && !n && t - e > i && (t = e + i);
    const o = e !== this.firstRenderedRow, s = t !== this.lastRenderedRow;
    (o || s) && (this.firstRenderedRow = e, this.lastRenderedRow = t, this.eventService.dispatchEvent({
      type: "viewportChanged",
      firstRow: e,
      lastRow: t
    }));
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    this.dataFirstRenderedFired || (this.dataFirstRenderedFired = !0, window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    }));
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var o, s;
    const r = (o = this.pinnedRowModel) == null ? void 0 : o.ensureRowHeightsValid(), n = (s = this.stickyRowFeature) == null ? void 0 : s.ensureRowHeightsValid(), i = this.rowModel.ensureRowHeightsValid(
      e,
      t,
      this.pageBoundsService.getFirstRow(),
      this.pageBoundsService.getLastRow()
    );
    return (i || n) && this.eventService.dispatchEvent({
      type: "recalculateRowBounds"
    }), n || i || r ? (this.updateContainerHeights(), !0) : !1;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getLastVisibleVerticalPixel() {
    return this.lastVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const n = e.getRowNode(), i = this.focusService.isRowNodeFocused(n), o = e.isEditing(), s = n.detail;
    return i || o || s ? !!this.isRowPresent(n) : !1;
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? this.paginationService ? this.paginationService.isRowPresent(e) : !0 : !1;
  }
  createRowCon(e, t, r) {
    const n = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (n)
      return n;
    const i = this.gos.get("suppressAnimationFrame"), o = r && !i && !this.printLayout;
    return new rs(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: r } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[r];
        break;
      case "bottom":
        t = this.bottomRowCtrls[r];
        break;
      default:
        t = this.rowCtrlsByRowIndex[r], t || (t = this.getStickyTopRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null, t || (t = this.getStickyBottomRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const n = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !n;
  }
}, RH = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.getRowNode() != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, r = this.entriesMap[t];
    delete this.entriesMap[t], Fr(this.entriesList, r);
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], Fr(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}, EH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel", this.nextId = 0, this.pinnedTopRows = new bS(), this.pinnedBottomRows = new bS();
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.setPinnedRowData(this.gos.get("pinnedTopRowData"), "top"), this.setPinnedRowData(this.gos.get("pinnedBottomRowData"), "bottom"), this.addManagedPropertyListener("pinnedTopRowData", (e) => this.setPinnedRowData(e.currentValue, "top")), this.addManagedPropertyListener("pinnedBottomRowData", (e) => this.setPinnedRowData(e.currentValue, "bottom")), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(e) {
    return (e === "top" ? this.pinnedTopRows : this.pinnedBottomRows).isEmpty();
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (r) => {
        r.setRowHeight(r.rowHeight, !0);
      };
      this.pinnedBottomRows.forEach(t), this.pinnedTopRows.forEach(t);
    }
  }
  ensureRowHeightsValid() {
    var n, i;
    let e = !1, t = 0;
    const r = (o) => {
      if (o.rowHeightEstimated) {
        const s = ho(this.gos, o);
        o.setRowTop(t), o.setRowHeight(s.height), t += s.height, e = !0;
      }
    };
    return (n = this.pinnedBottomRows) == null || n.forEach(r), t = 0, (i = this.pinnedTopRows) == null || i.forEach(r), this.eventService.dispatchEvent({
      type: "pinnedHeightChanged"
    }), e;
  }
  setPinnedRowData(e, t) {
    this.updateNodesFromRowData(e, t), this.eventService.dispatchEvent({
      type: "pinnedRowDataChanged"
    });
  }
  /**
   * Updates existing RowNode instances and creates new ones if necessary
   *
   * Setting data as `undefined` will clear row nodes
   */
  updateNodesFromRowData(e, t) {
    const r = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (e === void 0) {
      r.clear();
      return;
    }
    const n = za(this.gos), i = t === "top" ? Ti.ID_PREFIX_TOP_PINNED : Ti.ID_PREFIX_BOTTOM_PINNED, o = r.getIds(), s = [], a = /* @__PURE__ */ new Set();
    let l = 0, u = -1;
    for (const d of e) {
      const h = (n == null ? void 0 : n({ data: d, level: 0, rowPinned: t })) ?? i + this.nextId++;
      if (a.has(h)) {
        ie(
          "Duplicate ID",
          h,
          "found for pinned row with data",
          d,
          "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
        );
        continue;
      }
      u++, a.add(h), s.push(h);
      const f = r.getById(h);
      if (f !== void 0)
        f.data !== d && f.setData(d), l += this.setRowTopAndRowIndex(f, l, u), o.delete(h);
      else {
        const p = new Ti(this.beans);
        p.id = h, p.data = d, p.rowPinned = t, l += this.setRowTopAndRowIndex(p, l, u), r.push(p);
      }
    }
    o.forEach((d) => {
      var h;
      (h = r.getById(d)) == null || h.clearRowTopAndRowIndex();
    }), r.removeAllById(o), r.setOrder(s);
  }
  setRowTopAndRowIndex(e, t, r) {
    return e.setRowTop(t), e.setRowHeight(ho(this.gos, e).height), e.setRowIndex(r), e.rowHeight;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows.getSize();
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows.getSize();
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows.getByIndex(e);
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows.getByIndex(e);
  }
  getPinnedRowById(e, t) {
    return t === "top" ? this.pinnedTopRows.getById(e) : this.pinnedBottomRows.getById(e);
  }
  forEachPinnedRow(e, t) {
    return e === "top" ? this.pinnedTopRows.forEach(t) : this.pinnedBottomRows.forEach(t);
  }
  getTotalHeight(e) {
    const t = e.getSize();
    if (t === 0)
      return 0;
    const r = e.getByIndex(t - 1);
    return r === void 0 ? 0 : r.rowTop + r.rowHeight;
  }
}, bS = class {
  constructor() {
    this.cache = {}, this.ordering = [];
  }
  getById(e) {
    return this.cache[e];
  }
  getByIndex(e) {
    const t = this.ordering[e];
    return this.cache[t];
  }
  push(e) {
    this.cache[e.id] = e, this.ordering.push(e.id);
  }
  removeAllById(e) {
    for (const t of e)
      delete this.cache[t];
    this.ordering = this.ordering.filter((t) => !e.has(t));
  }
  setOrder(e) {
    this.ordering = e;
  }
  forEach(e) {
    this.ordering.forEach((t, r) => {
      const n = this.cache[t];
      n && e(n, r);
    });
  }
  clear() {
    this.ordering.length = 0, this.cache = {};
  }
  isEmpty() {
    return this.ordering.length === 0;
  }
  getSize() {
    return this.ordering.length;
  }
  getIds() {
    return new Set(this.ordering);
  }
}, PH = class extends J {
  constructor(e) {
    super(), this.state = "needsLoading", this.version = 0, this.id = e;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = "loading", this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++, this.state = "needsLoading";
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = "failed", this.processServerFail()), this.dispatchLoadCompleted(!1);
  }
  success(e, t) {
    this.successCommon(e, t);
  }
  pageLoaded(e, t, r) {
    this.successCommon(e, { rowData: t, rowCount: r });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, r = this.isAlive();
    return t && r;
  }
  successCommon(e, t) {
    this.dispatchLoadCompleted(), this.isRequestMostRecentAndLive(e) && (this.state = "loaded", this.processServerResult(t));
  }
  dispatchLoadCompleted(e = !0) {
    const t = {
      type: "loadComplete",
      success: e,
      block: this
    };
    this.dispatchLocalEvent(t);
  }
}, AH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowNodeBlockLoader", this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = Ar(
      this.performCheckBlocksToLoad.bind(this),
      e
    ));
  }
  getMaxConcurrentDatasourceRequests() {
    const e = this.gos.get("maxConcurrentDatasourceRequests");
    if (e == null)
      return 2;
    if (!(e <= 0))
      return e;
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener("loadComplete", this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    Fr(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchLocalEvent({ type: "blockLoaded" }), this.activeBlockLoadsCount == 0 && this.dispatchLocalEvent({ type: "blockLoaderFinished" });
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.gos.get("debug") && Bn("RowNodeBlockLoader - checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.getAvailableLoadingCount(), t = this.blocks.filter((r) => r.getState() === "needsLoading").slice(0, e);
    this.registerLoads(t.length), t.forEach((r) => r.load()), this.printCacheStatus();
  }
  getBlockState() {
    if (yo(this.gos))
      return this.rowModel.getBlockStates();
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: r, state: n } = t.getBlockStateJson();
      e[r] = n;
    }), e;
  }
  printCacheStatus() {
    this.gos.get("debug") && Bn(
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(e) {
    this.activeBlockLoadsCount += e;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
}, FH = {
  version: Te,
  moduleName: "@ag-grid-community/row-node-block",
  beans: [AH]
}, MH = class {
  constructor() {
    this.root = null, this.end = null, this.cachedRange = [];
  }
  init(e) {
    this.rowModel = e;
  }
  reset() {
    this.root = null, this.end = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.root = e, this.end = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.end = e, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t);
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.root === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot() {
    var e;
    return this.root && ((e = this.root) == null ? void 0 : e.key) === null && (this.root = this.rowModel.getRowNode(this.root.id) ?? null), this.root;
  }
  getEnd() {
    var e;
    return this.end && ((e = this.end) == null ? void 0 : e.key) === null && (this.end = this.rowModel.getRowNode(this.end.id) ?? null), this.end;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const r = t[0].id === this.root.id, n = t.findIndex((i) => i.id === e.id);
    if (n > -1) {
      const i = t.slice(0, n), o = t.slice(n + 1);
      return this.setEndRange(e), r ? { keep: i, discard: o } : { keep: o, discard: i };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const r = this.getRoot();
    if (r == null) {
      const i = this.getRange().slice();
      return t && e.depthFirstSearch((o) => !o.group && i.push(o)), i.push(e), this.setRoot(e), { keep: i, discard: [] };
    }
    if (this.rowModel.getNodesInRangeForSelection(r, e).find((i) => {
      var o;
      return i.id === ((o = this.end) == null ? void 0 : o.id);
    }))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const i = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: i };
    }
  }
}, TH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "stylingService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService;
  }
  processAllCellClasses(e, t, r, n) {
    this.processClassRules(void 0, e.cellClassRules, t, r, n), this.processStaticCellClasses(e, t, r);
  }
  processClassRules(e, t, r, n, i) {
    if (t == null && e == null)
      return;
    const o = {}, s = {}, a = (l, u) => {
      l.split(" ").forEach((d) => {
        d.trim() != "" && u(d);
      });
    };
    if (t) {
      const l = Object.keys(t);
      for (let u = 0; u < l.length; u++) {
        const d = l[u], h = t[d];
        let f;
        typeof h == "string" ? f = this.expressionService.evaluate(h, r) : typeof h == "function" && (f = h(r)), a(d, (p) => {
          f ? o[p] = !0 : s[p] = !0;
        });
      }
    }
    e && i && Object.keys(e).forEach(
      (l) => a(l, (u) => {
        o[u] || (s[u] = !0);
      })
    ), i && Object.keys(s).forEach(i), Object.keys(o).forEach(n);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: r } = e;
    if (!r)
      return [];
    let n;
    return typeof r == "function" ? n = r(t) : n = r, typeof n == "string" && (n = [n]), n || [];
  }
  processStaticCellClasses(e, t, r) {
    this.getStaticCellClasses(e, t).forEach((i) => {
      r(i);
    });
  }
}, vd = /* @__PURE__ */ ((e) => (e.TAB_GUARD = "ag-tab-guard", e.TAB_GUARD_TOP = "ag-tab-guard-top", e.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom", e))(vd || {}), HP = class extends J {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: r,
      eBottomGuard: n,
      focusTrapActive: i,
      forceFocusOutWhenTabGuardsAreEmpty: o,
      isFocusableContainer: s,
      focusInnerElement: a,
      onFocusIn: l,
      onFocusOut: u,
      shouldStopEventPropagation: d,
      onTabKeyDown: h,
      handleKeyDown: f,
      eFocusableElement: p
    } = e;
    this.comp = t, this.eTopGuard = r, this.eBottomGuard = n, this.providedFocusInnerElement = a, this.eFocusableElement = p, this.focusTrapActive = !!i, this.forceFocusOutWhenTabGuardsAreEmpty = !!o, this.isFocusableContainer = !!s, this.providedFocusIn = l, this.providedFocusOut = u, this.providedShouldStopEventPropagation = d, this.providedOnTabKeyDown = h, this.providedHandleKeyDown = f;
  }
  wireBeans(e) {
    this.focusService = e.focusService;
  }
  postConstruct() {
    this.createManagedBean(
      new ps(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    var l;
    const t = zt(this.gos), r = this.focusService.findFocusableElements(t.body, null, !0), n = r.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (n === -1)
      return;
    let i, o;
    e ? (i = 0, o = n) : (i = n + 1, o = r.length);
    const s = r.slice(i, o), a = this.gos.get("tabIndex");
    s.sort((u, d) => {
      const h = parseInt(u.getAttribute("tabindex") || "0"), f = parseInt(d.getAttribute("tabindex") || "0");
      return f === a ? 1 : h === a ? -1 : h === 0 ? 1 : f === 0 ? -1 : h - f;
    }), (l = s[e ? s.length - 1 : 0]) == null || l.focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const r = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), r && (r.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, DH = class extends J {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: r, eFocusableElement: n } = this, i = [t, r], o = {
      setTabIndex: (C) => {
        i.forEach(
          (v) => C != null ? v.setAttribute("tabindex", C) : v.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, r);
    const {
      focusTrapActive: s = !1,
      onFocusIn: a,
      onFocusOut: l,
      focusInnerElement: u,
      handleKeyDown: d,
      onTabKeyDown: h,
      shouldStopEventPropagation: f,
      forceFocusOutWhenTabGuardsAreEmpty: p,
      isFocusableContainer: y
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new HP({
        comp: o,
        focusTrapActive: s,
        eTopGuard: t,
        eBottomGuard: r,
        eFocusableElement: n,
        onFocusIn: a,
        onFocusOut: l,
        focusInnerElement: u,
        handleKeyDown: d,
        onTabKeyDown: h,
        shouldStopEventPropagation: f,
        forceFocusOutWhenTabGuardsAreEmpty: p,
        isFocusableContainer: y
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = zt(this.gos).createElement("div"), r = e === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
    return t.classList.add("ag-tab-guard", r), Vn(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    nn(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, r) {
    G0(t) || (t = t.getGui());
    const { eBottomGuard: n } = this;
    n ? n.insertAdjacentElement("beforebegin", t) : e(t, r);
  }
}, OH = class extends vt {
  initialiseTabGuard(t) {
    this.tabGuardFeature = this.createManagedBean(new DH(this)), this.tabGuardFeature.initialiseTabGuard(t);
  }
  forceFocusOutOfContainer(t = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(t);
  }
  appendChild(t, r) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), t, r);
  }
}, IH = 0, kH = 200, LH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "popupService", this.popupList = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.resizeObserverService = e.resizeObserverService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: r } = e, n = this.getPopupIndex(r);
    if (n !== -1) {
      const p = this.popupList[n];
      p.alignedToElement = t;
    }
    const i = t.getBoundingClientRect(), o = this.getParentRect(), s = this.keepXYWithinBounds(
      r,
      i.top - o.top,
      0
      /* vertical */
    ), a = r.clientWidth > 0 ? r.clientWidth : 200;
    r.style.minWidth = `${a}px`;
    const u = o.right - o.left - a;
    let d;
    this.gos.get("enableRtl") ? (d = f(), d < 0 && (d = h(), this.setAlignedStyles(r, "left")), d > u && (d = 0, this.setAlignedStyles(r, "right"))) : (d = h(), d > u && (d = f(), this.setAlignedStyles(r, "right")), d < 0 && (d = 0, this.setAlignedStyles(r, "left"))), r.style.left = `${d}px`, r.style.top = `${s}px`;
    function h() {
      return i.right - o.left - 2;
    }
    function f() {
      return i.left - o.left - a;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: r, nudgeY: n, skipObserver: i } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: !0,
      skipObserver: i,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        e.type,
        e.ePopup,
        null,
        e.mouseEvent,
        e.column,
        e.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      eventSource: o,
      alignSide: s = "left",
      position: a = "over",
      column: l,
      rowNode: u,
      type: d
    } = e, h = o.getBoundingClientRect(), f = this.getParentRect(), p = this.getPopupIndex(t);
    if (p !== -1) {
      const C = this.popupList[p];
      C.alignedToElement = o;
    }
    const y = () => {
      let C = h.left - f.left;
      s === "right" && (C -= t.offsetWidth - h.width);
      let v;
      return a === "over" ? (v = h.top - f.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, h, f, e.nudgeY || 0) === "under" ? v = h.top - f.top + h.height : v = h.top - t.offsetHeight - (n || 0) * 2 - f.top), { x: C, y: v };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      updatePosition: y,
      postProcessCallback: () => this.callPostProcessPopup(d, t, o, null, l, u)
    });
  }
  shouldRenderUnderOrAbove(e, t, r, n) {
    const i = r.bottom - t.bottom, o = t.top - r.top, s = e.offsetHeight + n;
    return i > s ? "under" : o > s || o > i ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r], { alignedToElement: i } = n;
    !i || (["right", "left", "over", "above", "under"].forEach((s) => {
      i.classList.remove(`ag-has-popup-positioned-${s}`), e.classList.remove(`ag-popup-positioned-${s}`);
    }), !t) || (i.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, r, n, i, o) {
    const s = this.gos.getCallback("postProcessPopup");
    s && s({
      column: i,
      rowNode: o,
      ePopup: t,
      type: e,
      eventSource: r,
      mouseEvent: n
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: r, nudgeX: n, nudgeY: i, skipObserver: o, updatePosition: s } = e, a = { width: 0, height: 0 }, l = (u = !1) => {
      let { x: d, y: h } = s();
      u && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, n && (d += n), i && (h += i), r && (d = this.keepXYWithinBounds(
        t,
        d,
        1
        /* horizontal */
      ), h = this.keepXYWithinBounds(
        t,
        h,
        0
        /* vertical */
      )), t.style.left = `${d}px`, t.style.top = `${h}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !o) {
      const u = this.resizeObserverService.observeResize(
        t,
        () => l(!0)
      );
      setTimeout(() => u(), kH);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = zt(this.gos);
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), HE(t);
  }
  keepXYWithinBounds(e, t, r) {
    const n = r === 0, i = n ? "clientHeight" : "clientWidth", o = n ? "top" : "left", s = n ? "height" : "width", a = n ? "scrollTop" : "scrollLeft", l = zt(this.gos), u = l.documentElement, d = this.getPopupParent(), h = e.getBoundingClientRect(), f = d.getBoundingClientRect(), p = l.documentElement.getBoundingClientRect(), y = d === l.body, C = Math.ceil(h[s]);
    let w = y ? (n ? GE : Dd)(u) + u[a] : d[i];
    y && (w -= Math.abs(p[o] - f[o]));
    const R = w - C;
    return Math.min(Math.max(t, 0), Math.abs(R));
  }
  addPopup(e) {
    const t = zt(this.gos), { eChild: r, ariaLabel: n, alwaysOnTop: i, positionCallback: o, anchorToElement: s } = e;
    if (!t)
      return ie("could not find the document, document is empty"), { hideFunc: () => {
      } };
    const a = this.getPopupIndex(r);
    if (a !== -1)
      return { hideFunc: this.popupList[a].hideFunc };
    this.initialisePopupPosition(r);
    const l = this.createPopupWrapper(r, n, !!i), u = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return o && o(), this.addPopupToPopupList(r, l, u, s), {
      hideFunc: u
    };
  }
  initialisePopupPosition(e) {
    const r = this.getPopupParent().getBoundingClientRect();
    de(e.style.top) || (e.style.top = `${r.top * -1}px`), de(e.style.left) || (e.style.left = `${r.left * -1}px`);
  }
  createPopupWrapper(e, t, r) {
    const n = this.getPopupParent(), i = document.createElement("div");
    return this.environment.applyThemeClasses(i), i.classList.add("ag-popup"), e.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Vn(e, "dialog"), oa(e, t), i.appendChild(e), n.appendChild(i), r ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), i;
  }
  handleThemeChange(e) {
    if (e.themeChanged)
      for (const t of this.popupList)
        this.environment.applyThemeClasses(t.wrapper);
  }
  addEventListenersToPopup(e) {
    const t = zt(this.gos), r = this.getPopupParent(), { wrapperEl: n, eChild: i, closedCallback: o, afterGuiAttached: s, closeOnEsc: a, modal: l } = e;
    let u = !1;
    const d = (y) => {
      if (!n.contains(Dt(this.gos)))
        return;
      y.key === V.ESCAPE && !Mi(y) && p({ keyboardEvent: y });
    }, h = (y) => p({ mouseEvent: y }), f = (y) => p({ touchEvent: y }), p = (y = {}) => {
      const { mouseEvent: C, touchEvent: v, keyboardEvent: w, forceHide: R } = y;
      !R && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: C, touchEvent: v }, i) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u) || (u = !0, r.removeChild(n), t.removeEventListener("keydown", d), t.removeEventListener("mousedown", h), t.removeEventListener("touchstart", f), t.removeEventListener("contextmenu", h), this.eventService.removeEventListener("dragStarted", h), o && o(C || v || w), this.removePopupFromPopupList(i));
    };
    return s && s({ hidePopup: p }), window.setTimeout(() => {
      a && t.addEventListener("keydown", d), l && (t.addEventListener("mousedown", h), this.eventService.addEventListener("dragStarted", h), t.addEventListener("touchstart", f), t.addEventListener("contextmenu", h));
    }, 0), p;
  }
  addPopupToPopupList(e, t, r, n) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: r,
      instanceId: IH++,
      isAnchored: !!n
    }), n && this.setPopupPositionRelatedToElement(e, n);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r];
    if (n.stopAnchoringPromise && n.stopAnchoringPromise.then((o) => o && o()), n.stopAnchoringPromise = void 0, n.isAnchored = !1, !t)
      return;
    const i = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: n.hideFunc
    });
    return n.stopAnchoringPromise = i, n.isAnchored = !0, i;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), r = t.getBoundingClientRect(), { element: n, ePopup: i } = e, o = n.getBoundingClientRect(), s = (h) => parseInt(h.substring(0, h.length - 1), 10), a = (h, f) => {
      const p = r[h] - o[h], y = s(i.style[h]);
      return {
        initialDiff: p,
        lastDiff: p,
        initial: y,
        last: y,
        direction: f
      };
    }, l = a(
      "top",
      0
      /* vertical */
    ), u = a(
      "left",
      1
      /* horizontal */
    ), d = this.getFrameworkOverrides();
    return new _t((h) => {
      d.wrapIncoming(() => {
        d.setInterval(() => {
          const f = t.getBoundingClientRect(), p = n.getBoundingClientRect();
          if (p.top == 0 && p.left == 0 && p.height == 0 && p.width == 0) {
            e.hidePopup();
            return;
          }
          const C = (v, w) => {
            const R = s(i.style[w]);
            v.last !== R && (v.initial = R, v.last = R);
            const b = f[w] - p[w];
            if (b != v.lastDiff) {
              const P = this.keepXYWithinBounds(
                i,
                v.initial + v.initialDiff - b,
                v.direction
              );
              i.style[w] = `${P}px`, v.last = P;
            }
            v.lastDiff = b;
          };
          C(l, "top"), C(u, "left");
        }, 200).then((f) => {
          h(() => {
            f != null && window.clearInterval(f);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: r, touchEvent: n } = e, i = r || n;
    if (!i)
      return !1;
    const o = this.getPopupIndex(t);
    if (o === -1)
      return !1;
    for (let s = o; s < this.popupList.length; s++) {
      const a = this.popupList[s];
      if (dB(a.element, i))
        return !0;
    }
    return this.isElementWithinCustomPopup(i.target);
  }
  isElementWithinCustomPopup(e) {
    const t = zt(this.gos);
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const r = this.getWrapper(e);
    r && (r.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(r));
  }
  /** @return true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), r = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), n = r.length, i = this.getWrapper(e);
    if (!i || n <= 1 || !t.contains(e))
      return;
    const o = [], s = [];
    for (const f of r)
      f !== i && (f.classList.contains("ag-always-on-top") ? s.push(f) : o.push(f));
    const a = [], l = s.length, h = i.classList.contains("ag-always-on-top") || !l ? [...o, ...s, i] : [...o, i, ...s];
    for (let f = 0; f <= n; f++) {
      const p = h[f];
      if (r[f] === h[f] || p === i)
        continue;
      p.querySelectorAll("div").forEach((C) => {
        C.scrollTop !== 0 && a.push([C, C.scrollTop]);
      }), f === 0 ? t.insertAdjacentElement("afterbegin", p) : h[f - 1].insertAdjacentElement("afterend", p);
    }
    for (; a.length; ) {
      const f = a.pop();
      f[0].scrollTop = f[1];
    }
  }
}, _H = ["touchstart", "touchend", "touchmove", "touchcancel"], WP = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t();
  }
  setInterval(e, t) {
    return new _t((r) => {
      r(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, r, n) {
    const i = es(_H, t);
    e.addEventListener(t, r, { capture: !!n, passive: i });
  }
  get shouldWrapOutgoing() {
    return !1;
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `https://www.ag-grid.com/${this.frameworkName === "solid" ? "react" : this.frameworkName}-data-grid${e ? `/${e}` : ""}`;
  }
}, zH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "cellNavigationService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.pinnedRowModel = e.pinnedRowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, r = !1) {
    return r ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const r = e === V.UP, n = e === V.DOWN, i = e === V.LEFT;
    let o, s;
    if (r || n)
      s = r ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow(), o = t.column;
    else {
      const a = this.visibleColsService.getAllCols(), l = this.gos.get("enableRtl");
      s = t.rowIndex, o = i !== l ? a[0] : Ye(a);
    }
    return {
      rowIndex: s,
      rowPinned: null,
      column: o
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let r = t, n = !1;
    for (; !n; ) {
      switch (e) {
        case V.UP:
          r = this.getCellAbove(r);
          break;
        case V.DOWN:
          r = this.getCellBelow(r);
          break;
        case V.RIGHT:
          this.gos.get("enableRtl") ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
          break;
        case V.LEFT:
          this.gos.get("enableRtl") ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
          break;
        default:
          r = null, ie("unknown key for navigation ", e);
          break;
      }
      r ? n = this.isCellGoodToFocusOn(r) : n = !0;
    }
    return r;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let r;
    switch (e.rowPinned) {
      case "top":
        r = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        r = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        r = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return r ? !t.isSuppressNavigable(r) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, r = e.rowPinned;
    let n = !1;
    if (this.isLastRowInContainer(e))
      switch (r) {
        case "bottom":
          return null;
        case "top":
          return this.rowModel.isRowsToRender() ? { rowIndex: this.pageBoundsService.getFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    else r && (n = !0);
    const i = this.rowModel.getRow(e.rowIndex), o = n ? void 0 : this.getNextStickyPosition(i);
    return o || { rowIndex: t + 1, rowPinned: r };
  }
  getNextStickyPosition(e, t) {
    if (!jh(this.gos) || !e || !e.sticky)
      return;
    const r = this.rowRenderer.getStickyTopRowCtrls().some((a) => a.getRowNode().rowIndex === e.rowIndex);
    let n = [];
    r ? n = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
      (a, l) => a.getRowNode().rowIndex - l.getRowNode().rowIndex
    ) : n = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
      (a, l) => l.getRowNode().rowIndex - a.getRowNode().rowIndex
    );
    const i = t ? -1 : 1, o = n.findIndex((a) => a.getRowNode().rowIndex === e.rowIndex), s = n[o + i];
    if (s)
      return { rowIndex: s.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, r = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowCount() - 1 <= r : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowCount() - 1 <= r : this.pageBoundsService.getLastRow() <= r;
  }
  getRowAbove(e) {
    const t = e.rowIndex, r = e.rowPinned, n = r ? t === 0 : t === this.pageBoundsService.getFirstRow();
    let i = !1;
    if (n)
      return r === "top" ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    r && (i = !0);
    const o = this.rowModel.getRow(e.rowIndex), s = i ? void 0 : this.getNextStickyPosition(o, !0);
    return s || { rowIndex: t - 1, rowPinned: r };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.pageBoundsService.getLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowCount() - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColAfter(e.column);
    if (!i) {
      i = t[0];
      const s = this.getRowBelow(e);
      if (Ke(s) || !s.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(s)) ?? !0))
        return null;
      r = s ? s.rowIndex : null, n = s ? s.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
  getNextTabbedCellBackwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColBefore(e.column);
    if (!i) {
      i = Ye(t);
      const s = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (Ke(s) || !s.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(s)) ?? !0))
        return null;
      r = s ? s.rowIndex : null, n = s ? s.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
}, br = (e, t) => {
  for (const r in t)
    t[r] = e;
  return t;
}, SS = {
  ...br("@ag-grid-community/core", {
    dispatchEvent: 0,
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0,
    getState: 0,
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0,
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRow: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRow: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0,
    getModel: 0,
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0,
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0,
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0,
    expireValueCache: 0,
    getValue: 0,
    getCellValue: 0,
    showColumnMenuAfterButtonClick: 0,
    showColumnMenuAfterMouseClick: 0,
    showColumnMenu: 0,
    hidePopupMenu: 0,
    onSortChanged: 0,
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0,
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0,
    setGridAriaProperty: 0,
    refreshCells: 0,
    flashCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0,
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0,
    getColumnDef: 0,
    getColumnDefs: 0,
    sizeColumnsToFit: 0,
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumn: 0,
    getDisplayNameForColumnGroup: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnVisible: 0,
    setColumnsVisible: 0,
    setColumnPinned: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0,
    moveColumn: 0,
    moveColumnByIndex: 0,
    moveColumns: 0,
    setColumnWidth: 0,
    setColumnWidths: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0,
    autoSizeColumn: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0,
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCellEditorInstances: 0,
    getEditingCells: 0,
    stopEditing: 0,
    startEditingCell: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0,
    isAnyFilterPresent: 0,
    onFilterChanged: 0,
    isColumnFilterPresent: 0,
    getFilterInstance: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0,
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0,
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0,
    // These may need updating to say which of multiple possible modules they could be missing from.
    expandAll: 0,
    collapseAll: 0,
    onRowHeightChanged: 0,
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...br("@ag-grid-community/client-side-row-model", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    resetRowHeights: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0
  }),
  ...br("@ag-grid-community/csv-export", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...br("@ag-grid-community/infinite-row-model", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...br("@ag-grid-enterprise/advanced-filter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...br("@ag-grid-enterprise/charts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...br("@ag-grid-enterprise/clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...br("@ag-grid-enterprise/excel-export", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...br("@ag-grid-enterprise/master-detail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...br("@ag-grid-enterprise/menu", {
    showContextMenu: 0,
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...br("@ag-grid-enterprise/range-selection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...br("@ag-grid-enterprise/row-grouping", {
    addAggFunc: 0,
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0,
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumn: 0,
    removeValueColumns: 0,
    addValueColumn: 0,
    addValueColumns: 0,
    setRowGroupColumns: 0,
    removeRowGroupColumn: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumn: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0,
    setPivotColumns: 0,
    removePivotColumn: 0,
    removePivotColumns: 0,
    addPivotColumn: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...br("@ag-grid-enterprise/server-side-row-model", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0
  }),
  ...br("@ag-grid-enterprise/side-bar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...br("@ag-grid-enterprise/status-bar", {
    getStatusPanel: 0
  })
}, xp = {
  isDestroyed: () => !0,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
}, NH = (e, t) => e.eventService.dispatchEvent(t), VP = class {
};
Reflect.defineProperty(VP, "name", { value: "GridApi" });
var BH = class extends J {
  constructor() {
    super(), this.beanName = "apiFunctionService", this.api = new VP(), this.fns = {
      ...xp,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent: NH
    }, this.beans = null, this.preDestroyLink = "";
    const { api: e } = this;
    for (const t in SS)
      e[t] = this.makeApi(t)[t];
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.preDestroyLink = this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(e, t) {
    var i;
    const { fns: r, beans: n } = this;
    r !== xp && (r[e] = ((i = n == null ? void 0 : n.validationService) == null ? void 0 : i.validateApiFunction(e, t)) ?? t);
  }
  makeApi(e) {
    return {
      [e]: (...t) => {
        const {
          beans: r,
          fns: { [e]: n }
        } = this;
        return n ? n(r, ...t) : this.apiNotFound(e);
      }
    };
  }
  apiNotFound(e) {
    const { beans: t, gos: r, preDestroyLink: n } = this;
    if (!t)
      ie(
        `Grid API function ${e}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${n}`
      );
    else {
      const i = SS[e];
      r.assertModuleRegistered(i, `api.${e}`) && ie(`API function '${e}' not registered to module '${i}'`);
    }
  }
  destroy() {
    super.destroy(), this.fns = xp, this.beans = null;
  }
};
function GH(e) {
  return {
    beanName: "gridApi",
    bean: e.getBean("apiFunctionService").api
  };
}
var HH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnDefFactory";
  }
  buildColumnDefs(e, t, r) {
    const n = [], i = {};
    return e.forEach((o) => {
      const s = this.createDefFromColumn(o, t, r);
      let a = !0, l = s, u = o.getOriginalParent(), d = null;
      for (; u; ) {
        let h = null;
        if (u.isPadding()) {
          u = u.getOriginalParent();
          continue;
        }
        const f = i[u.getGroupId()];
        if (f) {
          f.children.push(l), a = !1;
          break;
        }
        if (h = this.createDefFromGroup(u), h && (h.children = [l], i[h.groupId] = h, l = h, u = u.getOriginalParent()), u != null && d === u) {
          a = !1;
          break;
        }
        d = u;
      }
      a && n.push(l);
    }), n;
  }
  createDefFromGroup(e) {
    const t = mm(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, r) {
    const n = mm(e.getColDef());
    return n.colId = e.getColId(), n.width = e.getActualWidth(), n.rowGroup = e.isRowGroupActive(), n.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, n.pivot = e.isPivotActive(), n.pivotIndex = e.isPivotActive() ? r.indexOf(e) : null, n.aggFunc = e.isValueActive() ? e.getAggFunc() : null, n.hide = e.isVisible() ? void 0 : !0, n.pinned = e.isPinned() ? e.getPinned() : null, n.sort = e.getSort() ? e.getSort() : null, n.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, n;
  }
}, WH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnEventDispatcher";
  }
  visibleCols(e) {
    this.eventService.dispatchEvent({
      type: "displayedColumnsChanged",
      source: e
    });
  }
  gridColumns() {
    this.eventService.dispatchEvent({
      type: "gridColumnsChanged"
    });
  }
  headerHeight(e) {
    this.eventService.dispatchEvent({
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    });
  }
  groupHeaderHeight(e) {
    this.eventService.dispatchEvent({
      type: "columnGroupHeaderHeightChanged",
      columnGroup: e,
      source: "autosizeColumnGroupHeaderHeight"
    });
  }
  groupOpened(e) {
    this.eventService.dispatchEvent({
      type: "columnGroupOpened",
      columnGroup: e.length === 1 ? e[0] : void 0,
      columnGroups: e
    });
  }
  rowGroupChanged(e, t) {
    this.eventService.dispatchEvent({
      type: "columnRowGroupChanged",
      columns: e,
      column: e.length === 1 ? e[0] : null,
      source: t
    });
  }
  genericColumnEvent(e, t, r) {
    this.eventService.dispatchEvent({
      type: e,
      columns: t,
      column: t.length === 1 ? t[0] : null,
      source: r
    });
  }
  pivotModeChanged() {
    this.eventService.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  virtualColumnsChanged(e) {
    this.eventService.dispatchEvent({
      type: "virtualColumnsChanged",
      afterScroll: e
    });
  }
  newColumnsLoaded(e) {
    this.eventService.dispatchEvent({
      type: "newColumnsLoaded",
      source: e
    });
  }
  /** @deprecated v32.2 */
  everythingChanged(e) {
    this.eventService.dispatchEvent({
      type: "columnEverythingChanged",
      source: e
    });
  }
  columnMoved(e) {
    const { movedColumns: t, source: r, toIndex: n, finished: i } = e;
    this.eventService.dispatchEvent({
      type: "columnMoved",
      columns: t,
      column: t && t.length === 1 ? t[0] : null,
      toIndex: n,
      finished: i,
      source: r
    });
  }
  columnPinned(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, n = this.getCommonValue(e, (i) => i.getPinned());
    this.eventService.dispatchEvent({
      type: "columnPinned",
      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
      pinned: n ?? null,
      columns: e,
      column: r,
      source: t
    });
  }
  columnVisible(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, n = this.getCommonValue(e, (i) => i.isVisible());
    this.eventService.dispatchEvent({
      type: "columnVisible",
      visible: n,
      columns: e,
      column: r,
      source: t
    });
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0)
      return;
    const r = t(e[0]);
    for (let n = 1; n < e.length; n++)
      if (r !== t(e[n]))
        return;
    return r;
  }
  columnChanged(e, t, r) {
    this.eventService.dispatchEvent({
      type: e,
      columns: t,
      column: t && t.length == 1 ? t[0] : null,
      source: r
    });
  }
  columnResized(e, t, r, n = null) {
    e && e.length && this.eventService.dispatchEvent({
      type: "columnResized",
      columns: e,
      column: e.length === 1 ? e[0] : null,
      flexColumns: n,
      finished: t,
      source: r
    });
  }
}, VH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnGetStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService;
  }
  getColumnState() {
    const e = this.columnModel.getColDefCols();
    if (Ke(e) || !this.columnModel.isAlive())
      return [];
    const r = this.columnModel.getAllCols().map((n) => this.createStateItemFromColumn(n));
    return this.orderColumnStateList(r), r;
  }
  createStateItemFromColumn(e) {
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns(), n = e.isRowGroupActive() ? t.indexOf(e) : null, i = e.isPivotActive() ? r.indexOf(e) : null, o = e.isValueActive() ? e.getAggFunc() : null, s = e.getSort() != null ? e.getSort() : null, a = e.getSortIndex() != null ? e.getSortIndex() : null, l = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return {
      colId: e.getColId(),
      width: e.getActualWidth(),
      hide: !e.isVisible(),
      pinned: e.getPinned(),
      sort: s,
      sortIndex: a,
      aggFunc: o,
      rowGroup: e.isRowGroupActive(),
      rowGroupIndex: n,
      pivot: e.isPivotActive(),
      pivotIndex: i,
      flex: l
    };
  }
  orderColumnStateList(e) {
    const t = this.columnModel.getCols(), r = new Map(t.map((n, i) => [n.getColId(), i]));
    e.sort((n, i) => {
      const o = r.has(n.colId) ? r.get(n.colId) : -1, s = r.has(i.colId) ? r.get(i.colId) : -1;
      return o - s;
    });
  }
}, $H = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnGroupStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService;
  }
  getColumnGroupState() {
    const e = [], t = this.columnModel.getColTree();
    return ki(null, t, (r) => {
      Er(r) && e.push({
        groupId: r.getGroupId(),
        open: r.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.columnModel.getColDefColTree();
    if (!t)
      return;
    const r = [];
    ki(null, t, (n) => {
      if (Er(n)) {
        const i = n.getColGroupDef(), o = {
          groupId: n.getGroupId(),
          open: i ? i.openByDefault : void 0
        };
        r.push(o);
      }
    }), this.setColumnGroupState(r, e);
  }
  setColumnGroupState(e, t) {
    if (!this.columnModel.getColTree())
      return;
    this.columnAnimationService.start();
    const n = [];
    e.forEach((i) => {
      const o = i.groupId, s = i.open, a = this.columnModel.getProvidedColGroup(o);
      a && a.isExpanded() !== s && (a.setExpanded(s), n.push(a));
    }), this.visibleColsService.refresh(t, !0), n.length && this.eventDispatcher.groupOpened(n), this.columnAnimationService.finish();
  }
}, jH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnViewportService", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, r = !1) {
    const n = this.visibleColsService.isBodyWidthDirty();
    if (!(e === this.scrollWidth && t === this.scrollPosition && !n)) {
      if (this.scrollWidth = e, this.scrollPosition = t, this.visibleColsService.setBodyWidthDirty(), this.gos.get("enableRtl")) {
        const o = this.visibleColsService.getBodyContainerWidth();
        this.viewportLeft = o - this.scrollPosition - this.scrollWidth, this.viewportRight = o - this.scrollPosition;
      } else
        this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition;
      this.columnModel.isReady() && this.checkViewportColumns(r);
    }
  }
  getHeadersToRender(e, t) {
    let r;
    switch (e) {
      case "left":
        r = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        r = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        r = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return r || [];
  }
  extractViewportColumns() {
    const e = this.visibleColsService.getCenterCols();
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() || this.isAnyParentAutoHeaderHeight(e) ? !0 : this.isColumnInRowViewport(e);
  }
  isAnyParentAutoHeaderHeight(e) {
    for (; e; ) {
      if (e.isAutoHeaderHeight())
        return !0;
      e = e.getParent();
    }
    return !1;
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, r = t + e.getActualWidth(), n = this.viewportLeft - 200, i = this.viewportRight + 200, o = t < n && r < n, s = t > i && r > i;
    return !o && !s;
  }
  // used by Grid API only
  getViewportColumns() {
    const e = this.visibleColsService.getLeftCols(), t = this.visibleColsService.getRightCols();
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.columnModel.isColSpanActive())
      return this.colsWithinViewport;
    const t = (i) => {
      const o = i.getLeft();
      return de(o) && o > this.viewportLeft;
    }, r = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this), n = this.visibleColsService.getColsCenter();
    return this.visibleColsService.getColsForRow(
      e,
      n,
      r,
      t
    );
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventDispatcher.virtualColumnsChanged(e);
  }
  calculateHeaderRows() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
    const e = {}, t = this.visibleColsService.getLeftCols(), r = this.visibleColsService.getRightCols();
    this.headerColsWithinViewport.concat(t).concat(r).forEach((o) => e[o.getId()] = !0);
    const i = (o, s, a) => {
      let l = !1;
      for (let u = 0; u < o.length; u++) {
        const d = o[u];
        let h = !1;
        if (go(d))
          h = e[d.getId()] === !0;
        else {
          const p = d.getDisplayedChildren();
          p && (h = i(p, s, a + 1));
        }
        h && (l = !0, s[a] || (s[a] = []), s[a].push(d));
      }
      return l;
    };
    i(this.visibleColsService.getTreeLeft(), this.rowsOfHeadersToRenderLeft, 0), i(this.visibleColsService.getTreeRight(), this.rowsOfHeadersToRenderRight, 0), i(this.visibleColsService.getTreeCenter(), this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (n) => `${n.getId()}-${n.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), r = this.colsWithinViewportHash !== t;
    return r && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), r;
  }
}, UH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "agComponentUtils";
  }
  wireBeans(e) {
    this.componentMetadataProvider = e.componentMetadataProvider;
  }
  adaptFunction(e, t) {
    const r = this.componentMetadataProvider.retrieve(e);
    return r && r.functionAdapter ? r.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(n) {
        const i = e(n), o = typeof i;
        if (o === "string" || o === "number" || o === "boolean") {
          this.eGui = ac("<span>" + i + "</span>");
          return;
        }
        if (i == null) {
          this.eGui = ac("<span></span>");
          return;
        }
        this.eGui = i;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : !1;
  }
}, KH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "componentMetadataProvider";
  }
  wireBeans(e) {
    this.agComponentUtils = e.agComponentUtils;
  }
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: [
          "afterGuiAttached",
          "setInputPlaceholder",
          "setInputAriaLabel",
          "setDisabled",
          "onParamsUpdated",
          "refresh"
        ]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      dragAndDropImageComponent: {
        mandatoryMethodList: ["setIcon", "setLabel"],
        optionalMethodList: []
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: [],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: [
          "isPopup",
          "isCancelBeforeStart",
          "isCancelAfterEnd",
          "getPopupPosition",
          "focusIn",
          "focusOut",
          "afterGuiAttached",
          "refresh"
        ]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: [
          "afterGuiAttached",
          "afterGuiDetached",
          "onNewRowsLoaded",
          "getModelAsString",
          "onFloatingFilterChanged",
          "onAnyFilterChanged",
          "refresh"
        ]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "getState"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      menuItem: {
        mandatoryMethodList: [],
        optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
      }
    };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
}, qH = [
  // core beans only
  "rowPositionUtils",
  "cellPositionUtils",
  "headerPositionUtils",
  "paginationAutoPageSizeService",
  "apiFunctionService",
  "gridApi",
  "userComponentRegistry",
  "agComponentUtils",
  "componentMetadataProvider",
  "resizeObserverService",
  "userComponentFactory",
  "rowContainerHeightService",
  "horizontalResizeService",
  "localeService",
  "validationService",
  "pinnedRowModel",
  "dragService",
  "visibleColsService",
  "eventService",
  "gos",
  "popupService",
  "selectionService",
  "columnFilterService",
  "quickFilterService",
  "filterManager",
  "columnModel",
  "headerNavigationService",
  "pageBoundsService",
  "paginationService",
  "pageBoundsListener",
  "rowRenderer",
  "expressionService",
  "columnFactory",
  "alignedGridsService",
  "navigationService",
  "valueCache",
  "valueService",
  "loggerFactory",
  "autoWidthCalculator",
  "filterMenuFactory",
  "dragAndDropService",
  "focusService",
  "mouseEventService",
  "environment",
  "cellNavigationService",
  "stylingService",
  "scrollVisibleService",
  "sortController",
  "columnHoverService",
  "columnAnimationService",
  "selectableService",
  "autoColService",
  "controlsColService",
  "changeDetectionService",
  "animationFrameService",
  "undoRedoService",
  "columnDefFactory",
  "rowCssClassCalculator",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsService",
  "pinnedWidthService",
  "rowNodeEventThrottle",
  "ctrlsFactory",
  "dataTypeService",
  "syncService",
  "overlayService",
  "stateService",
  "expansionService",
  "apiEventService",
  "ariaAnnouncementService",
  "menuService",
  "columnApplyStateService",
  "columnEventDispatcher",
  "columnMoveService",
  "columnAutosizeService",
  "columnGetStateService",
  "columnGroupStateService",
  "columnSizeService",
  "funcColsService",
  "columnNameService",
  "columnViewportService",
  "pivotResultColsService",
  "showRowGroupColsService"
], xS = Object.fromEntries(
  qH.map((e, t) => [e, t])
);
function YH(e, t) {
  const r = (e.beanName ? xS[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, n = (t.beanName ? xS[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return r - n;
}
function JH(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroyService" ? -1 : 0;
}
var XH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "ctrlsFactory", this.registry = {};
  }
  register(e) {
    this.registry[e.name] = e.classImp;
  }
  getInstance(e, ...t) {
    const r = this.registry[e];
    if (r != null)
      return new r(...t);
  }
}, QH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "ctrlsService", this.params = {
      gridCtrl: void 0,
      gridBodyCtrl: void 0,
      center: void 0,
      left: void 0,
      right: void 0,
      bottomCenter: void 0,
      bottomLeft: void 0,
      bottomRight: void 0,
      topCenter: void 0,
      topLeft: void 0,
      topRight: void 0,
      stickyTopCenter: void 0,
      stickyTopLeft: void 0,
      stickyTopRight: void 0,
      stickyBottomCenter: void 0,
      stickyBottomLeft: void 0,
      stickyBottomRight: void 0,
      fakeHScrollComp: void 0,
      fakeVScrollComp: void 0,
      gridHeaderCtrl: void 0,
      centerHeader: void 0,
      leftHeader: void 0,
      rightHeader: void 0
    }, this.ready = !1, this.readyCallbacks = [], this.runReadyCallbacksAsync = !1;
  }
  wireBeans(e) {
    var t, r;
    this.runReadyCallbacksAsync = ((r = (t = e.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : r.call(t)) ?? !1;
  }
  postConstruct() {
    this.addEventListener(
      "ready",
      () => {
        this.updateReady(), this.ready && (this.readyCallbacks.forEach((e) => e(this.params)), this.readyCallbacks.length = 0);
      },
      this.runReadyCallbacksAsync
    );
  }
  updateReady() {
    this.ready = Object.values(this.params).every((e) => (e == null ? void 0 : e.isAlive()) ?? !1);
  }
  whenReady(e, t) {
    this.ready ? t(this.params) : this.readyCallbacks.push(t), e.addDestroyFunc(() => {
      const r = this.readyCallbacks.indexOf(t);
      r >= 0 && this.readyCallbacks.splice(r, 1);
    });
  }
  register(e, t) {
    this.params[e] = t, this.updateReady(), this.ready && this.dispatchLocalEvent({ type: "ready" }), t.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(e) {
    return this.params[e];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: r } = this.params;
    return [e, r, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
}, ZH = class extends J {
  constructor() {
    super(...arguments), this.beanName = "cellPositionUtils";
  }
  createId(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return this.createIdFromValues({ rowIndex: t, column: n, rowPinned: r });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return `${t}.${r ?? "null"}.${n.getId()}`;
  }
  equals(e, t) {
    const r = e.column === t.column, n = e.rowPinned === t.rowPinned, i = e.rowIndex === t.rowIndex;
    return r && n && i;
  }
}, eW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowNodeEventThrottle", this.events = [];
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowModel = e.rowModel;
  }
  postConstruct() {
    At(this.gos) && (this.clientSideRowModel = this.rowModel);
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpanded(e, t) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const r = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((n) => this.eventService.dispatchEvent(n)), this.events = [];
    };
    t ? r() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced());
  }
}, tW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowPositionUtils";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.pageBoundsService = e.pageBoundsService;
  }
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const r = this.pinnedRowModel.getPinnedBottomRowCount(), n = this.pinnedRowModel.getPinnedTopRowCount();
    return r ? (t = "bottom", e = r - 1) : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getLastRow()) : n && (t = "top", e = n - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  // tests if this row selection is before the other row selection
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top")
          return !0;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom")
          return !1;
        break;
      default:
        if (de(t.rowPinned))
          return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
}, RS = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, ES = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, PS = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, rW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.ancestorThemeClasses = [], this.sizesMeasured = !1, this.gridTheme = null;
  }
  wireBeans(e) {
    this.resizeObserverService = e.resizeObserverService, this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange()), this.handleThemeGridOptionChange(), this.addDestroyFunc(() => this.stopUsingTheme()), this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.ancestorThemeClasses = this.readAncestorThemeClasses(), this.setUpThemeClassObservers(), this.getSizeEl(RS), this.getSizeEl(ES), this.getSizeEl(PS);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(RS);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(ES);
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(PS);
  }
  hasMeasuredSizes() {
    return this.sizesMeasured;
  }
  getGridThemeClass() {
    var e;
    return ((e = this.gridTheme) == null ? void 0 : e.getCssClass()) || null;
  }
  getThemeClasses() {
    return this.gridTheme ? [this.gridTheme.getCssClass()] : this.ancestorThemeClasses;
  }
  applyThemeClasses(e) {
    const t = this.getThemeClasses();
    for (const r of Array.from(e.classList))
      r.startsWith("ag-theme-") && !t.includes(r) && e.classList.remove(r);
    e.classList.add(...t);
  }
  refreshRowHeightVariable() {
    const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), t = this.gos.get("rowHeight");
    if (t == null || isNaN(t) || !isFinite(t))
      return e !== null && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
    const r = `${t}px`;
    return e != r ? (this.eGridDiv.style.setProperty("--ag-line-height", r), t) : e != "" ? parseFloat(e) : -1;
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const r = this.measureSizeEl(e);
    return r === "detached" || r === "no-styles" ? e.defaultValue : (this.lastKnownValues.set(e, r), r);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const r = t.offsetWidth;
    return r === AS ? "no-styles" : (this.sizesMeasured = !0, r);
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    let r = this.eMeasurementContainer;
    r || (r = this.eMeasurementContainer = document.createElement("div"), r.className = "ag-measurement-container", this.gos.get("theme") && this.applyThemeClasses(r), this.eGridDiv.appendChild(r)), t = document.createElement("div"), t.style.width = `var(${e.cssName}, ${AS}px)`, r.appendChild(t), this.sizeEls.set(e, t);
    let n = this.measureSizeEl(e);
    n === "no-styles" && ie(
      `no value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`
    );
    const i = this.resizeObserverService.observeResize(t, () => {
      const o = this.measureSizeEl(e);
      o === "detached" || o === "no-styles" || (this.lastKnownValues.set(e, o), o !== n && (n = o, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => i()), t;
  }
  fireGridStylesChangedEvent(e) {
    this.eventService.dispatchEvent({
      type: "gridStylesChanged",
      [e]: !0
    });
  }
  setUpThemeClassObservers() {
    const e = new MutationObserver(() => {
      const r = this.readAncestorThemeClasses();
      nW(r, this.ancestorThemeClasses) || (this.ancestorThemeClasses = r, this.fireGridStylesChangedEvent("themeChanged"));
    });
    let t = this.eGridDiv;
    for (; t; )
      e.observe(t || this.eGridDiv, {
        attributes: !0,
        attributeFilter: ["class"]
      }), t = t.parentElement;
    this.addDestroyFunc(() => e.disconnect());
  }
  readAncestorThemeClasses() {
    let e = this.eGridDiv;
    const t = [];
    for (; e; ) {
      const r = Array.from(e.classList).filter((n) => n.startsWith("ag-theme-"));
      for (const n of r)
        t.includes(n) || t.unshift(n);
      e = e.parentElement;
    }
    return Object.freeze(t);
  }
  handleThemeGridOptionChange() {
    const { gos: e, eMeasurementContainer: t, gridTheme: r } = this, n = e.get("theme") || null;
    n !== r && (r == null || r.stopUse(), this.gridTheme = n, n == null || n.startUse({
      loadThemeGoogleFonts: e.get("loadThemeGoogleFonts"),
      container: this.eGridDiv
    }), t && this.applyThemeClasses(t), this.fireGridStylesChangedEvent("themeChanged"));
  }
  stopUsingTheme() {
    var e;
    (e = this.gridTheme) == null || e.stopUse(), this.gridTheme = null;
  }
}, nW = (e, t) => e.length === t.length && e.findIndex((r, n) => e[n] !== t[n]) === -1, AS = 15538, iW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "eventService", this.globalEventService = new _a();
  }
  wireBeans(e) {
    this.globalEventListener = e.globalEventListener, this.globalSyncEventListener = e.globalSyncEventListener;
  }
  postConstruct() {
    if (this.globalEventListener) {
      const e = Ed(this.gos);
      this.addGlobalListener(this.globalEventListener, e);
    }
    this.globalSyncEventListener && this.addGlobalListener(this.globalSyncEventListener, !1);
  }
  addEventListener(e, t, r) {
    this.globalEventService.addEventListener(e, t, r);
  }
  removeEventListener(e, t, r) {
    this.globalEventService.removeEventListener(e, t, r);
  }
  addGlobalListener(e, t = !1) {
    this.globalEventService.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalEventService.removeGlobalListener(e, t);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e));
  }
  dispatchEventOnce(e) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e));
  }
}, ry = class vn extends J {
  constructor() {
    super(...arguments), this.beanName = "focusService";
  }
  wireBeans(t) {
    this.eGridDiv = t.eGridDiv, this.columnModel = t.columnModel, this.visibleColsService = t.visibleColsService, this.headerNavigationService = t.headerNavigationService, this.headerPositionUtils = t.headerPositionUtils, this.rowRenderer = t.rowRenderer, this.rowPositionUtils = t.rowPositionUtils, this.cellPositionUtils = t.cellPositionUtils, this.navigationService = t.navigationService, this.ctrlsService = t.ctrlsService, this.filterManager = t.filterManager, this.rangeService = t.rangeService, this.advancedFilterService = t.advancedFilterService, this.overlayService = t.overlayService;
  }
  static addKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", vn.toggleKeyboardMode), t.addEventListener("mousedown", vn.toggleKeyboardMode));
  }
  static removeKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.removeEventListener("keydown", vn.toggleKeyboardMode), t.removeEventListener("mousedown", vn.toggleKeyboardMode));
  }
  static toggleKeyboardMode(t) {
    const r = vn.keyboardModeActive, n = t.type === "keydown";
    n && (t.ctrlKey || t.metaKey || t.altKey) || r !== n && (vn.keyboardModeActive = n);
  }
  postConstruct() {
    const t = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: t,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: t,
      columnRowGroupChanged: t
    }), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady(this, (r) => {
      this.gridCtrl = r.gridCtrl;
    });
  }
  registerKeyboardFocusEvents() {
    const t = zt(this.gos);
    vn.addKeyboardModeEvents(t), vn.instanceCount++, this.addDestroyFunc(() => {
      vn.instanceCount--, vn.removeKeyboardModeEvents(t);
    });
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition)
      return;
    const t = this.focusedCellPosition.column, r = this.columnModel.getCol(t.getId());
    t !== r && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return vn.keyboardModeActive;
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(Dt(this.gos), rs.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(
      Dt(this.gos),
      Jh.DOM_DATA_KEY_HEADER_CTRL
    ) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(t, r) {
    let n = t;
    for (; n; ) {
      if (tc(this.gos, n, r))
        return !1;
      n = n.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(t) {
    return this.isCellRestoreFocused(t) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), !0) : !1;
  }
  clearRestoreFocus() {
    this.restoredFocusedCellPosition = null, this.awaitRestoreFocusedCell = !1;
  }
  restoreFocusedCell(t, r) {
    this.awaitRestoreFocusedCell = !0, setTimeout(() => {
      this.awaitRestoreFocusedCell && (this.setRestoreFocusedCell(t), r());
    });
  }
  isCellRestoreFocused(t) {
    return this.restoredFocusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(t) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = t);
  }
  getFocusEventParams(t) {
    const { rowIndex: r, rowPinned: n, column: i } = t, o = {
      rowIndex: r,
      rowPinned: n,
      column: i,
      isFullWidthCell: !1
    }, s = this.rowRenderer.getRowByPosition({ rowIndex: r, rowPinned: n });
    return s && (o.isFullWidthCell = s.isFullWidth()), o;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null)
      return;
    const t = this.getFocusEventParams(this.focusedCellPosition);
    this.focusedCellPosition = null, this.eventService.dispatchEvent({
      type: "cellFocusCleared",
      ...t
    });
  }
  setFocusedCell(t) {
    const { column: r, rowIndex: n, rowPinned: i, forceBrowserFocus: o = !1, preventScrollOnBrowserFocus: s = !1 } = t, a = this.columnModel.getCol(r);
    if (!a) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = {
      rowIndex: n,
      rowPinned: Fi(i),
      column: a
    }, this.eventService.dispatchEvent({
      type: "cellFocused",
      ...this.getFocusEventParams(this.focusedCellPosition),
      forceBrowserFocus: o,
      preventScrollOnBrowserFocus: s
    });
  }
  isCellFocused(t) {
    return this.focusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.focusedCellPosition);
  }
  isRowNodeFocused(t) {
    return this.isRowFocused(t.rowIndex, t.rowPinned);
  }
  isHeaderWrapperFocused(t) {
    if (this.focusedHeaderPosition == null)
      return !1;
    const r = t.getColumnGroupChild(), n = t.getRowIndex(), i = t.getPinned(), { column: o, headerRowIndex: s } = this.focusedHeaderPosition;
    return r === o && n === s && i == o.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(t, r) {
    this.focusedHeaderPosition = { headerRowIndex: t, column: r };
  }
  isHeaderFocusSuppressed() {
    return this.gos.get("suppressHeaderFocus") || this.overlayService.isExclusive();
  }
  isCellFocusSuppressed() {
    return this.gos.get("suppressCellFocus") || this.overlayService.isExclusive();
  }
  focusHeaderPosition(t) {
    var u;
    if (this.isHeaderFocusSuppressed())
      return !1;
    const { direction: r, fromTab: n, allowUserOverride: i, event: o, fromCell: s, rowWithoutSpanValue: a } = t;
    let { headerPosition: l } = t;
    if (s && ((u = this.filterManager) != null && u.isAdvancedFilterHeaderActive()))
      return this.focusAdvancedFilter(l);
    if (i) {
      const d = this.getFocusedHeader(), h = this.headerNavigationService.getHeaderRowCount();
      if (n) {
        const f = this.gos.getCallback("tabToNextHeader");
        f && (l = this.getHeaderPositionFromUserFunc({
          userFunc: f,
          direction: r,
          currentPosition: d,
          headerPosition: l,
          headerRowCount: h
        }));
      } else {
        const f = this.gos.getCallback("navigateToNextHeader");
        if (f && o) {
          const p = {
            key: o.key,
            previousHeaderPosition: d,
            nextHeaderPosition: l,
            headerRowCount: h,
            event: o
          };
          l = f(p);
        }
      }
    }
    return l ? this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: r,
      event: o,
      fromCell: s,
      rowWithoutSpanValue: a
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(t) {
    if (this.isHeaderFocusSuppressed())
      return !1;
    const { userFunc: r, headerPosition: n, direction: i, event: o } = t, s = this.getFocusedHeader(), a = this.headerNavigationService.getHeaderRowCount(), l = this.getHeaderPositionFromUserFunc({
      userFunc: r,
      direction: i,
      currentPosition: s,
      headerPosition: n,
      headerRowCount: a
    });
    return !!l && this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: i,
      event: o
    });
  }
  getHeaderPositionFromUserFunc(t) {
    const { userFunc: r, direction: n, currentPosition: i, headerPosition: o, headerRowCount: s } = t, l = r({
      backwards: n === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: o,
      headerRowCount: s
    });
    return l === !0 || l === null ? (l === null && ie(
      "Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."
    ), i) : l === !1 ? null : l;
  }
  focusProvidedHeaderPosition(t) {
    var h;
    const { headerPosition: r, direction: n, fromCell: i, rowWithoutSpanValue: o, event: s } = t, { column: a, headerRowIndex: l } = r;
    if (l === -1)
      return (h = this.filterManager) != null && h.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(r) : this.focusGridView(a);
    this.headerNavigationService.scrollToColumn(a, n);
    const u = this.ctrlsService.getHeaderRowContainerCtrl(a.getPinned()), d = (u == null ? void 0 : u.focusHeader(r.headerRowIndex, a, s)) || !1;
    return d && (o != null || i) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(o ?? -1), d;
  }
  focusFirstHeader() {
    if (this.overlayService.isExclusive() && this.focusOverlay())
      return !0;
    let t = this.visibleColsService.getAllCols()[0];
    if (!t)
      return !1;
    t.getParent() && (t = this.visibleColsService.getColGroupAtLevel(t, 0));
    const r = this.headerPositionUtils.getHeaderIndexToFocus(t, 0);
    return this.focusHeaderPosition({
      headerPosition: r,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(t) {
    if (this.overlayService.isExclusive() && this.focusOverlay(!0))
      return !0;
    const r = this.headerNavigationService.getHeaderRowCount() - 1, n = Ye(this.visibleColsService.getAllCols());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: r, column: n },
      rowWithoutSpanValue: -1,
      event: t
    });
  }
  focusPreviousFromFirstCell(t) {
    var r;
    return (r = this.filterManager) != null && r.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(t);
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(t, r) {
    return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === t && this.focusedCellPosition.rowPinned === Fi(r);
  }
  findFocusableElements(t, r, n = !1) {
    const i = n8;
    let o = BE;
    r && (o += ", " + r), n && (o += ', [tabindex="-1"]');
    const s = Array.prototype.slice.apply(t.querySelectorAll(i)).filter((u) => li(u)), a = Array.prototype.slice.apply(t.querySelectorAll(o));
    return a.length ? ((u, d) => u.filter((h) => d.indexOf(h) === -1))(s, a) : s;
  }
  focusInto(t, r = !1, n = !1) {
    const i = this.findFocusableElements(t, null, n), o = r ? Ye(i) : i[0];
    return o ? (o.focus({ preventScroll: !0 }), !0) : !1;
  }
  findFocusableElementBeforeTabGuard(t, r) {
    if (!r)
      return null;
    const n = this.findFocusableElements(t), i = n.indexOf(r);
    if (i === -1)
      return null;
    let o = -1;
    for (let s = i - 1; s >= 0; s--)
      if (n[s].classList.contains(
        "ag-tab-guard-top"
        /* TAB_GUARD_TOP */
      )) {
        o = s;
        break;
      }
    return o <= 0 ? null : n[o - 1];
  }
  findNextFocusableElement(t = this.eGridDiv, r, n) {
    const i = this.findFocusableElements(t, r ? ':not([tabindex="-1"])' : null), o = Dt(this.gos);
    let s;
    r ? s = i.findIndex((l) => l.contains(o)) : s = i.indexOf(o);
    const a = s + (n ? -1 : 1);
    return a < 0 || a >= i.length ? null : i[a];
  }
  isTargetUnderManagedComponent(t, r) {
    if (!r)
      return !1;
    const n = t.querySelectorAll(`.${ps.FOCUS_MANAGED_CLASS}`);
    if (!n.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (n[i].contains(r))
        return !0;
    return !1;
  }
  findTabbableParent(t, r = 5) {
    let n = 0;
    for (; t && bm(t) === null && ++n <= r; )
      t = t.parentElement;
    return bm(t) === null ? null : t;
  }
  focusOverlay(t) {
    var n;
    const r = this.overlayService.isVisible() && ((n = this.overlayService.getOverlayWrapper()) == null ? void 0 : n.getGui());
    return !!r && this.focusInto(r, t);
  }
  focusGridViewFailed(t, r) {
    return r && this.focusOverlay(t) || t && this.focusLastHeader();
  }
  focusGridView(t, r = !1, n = !0) {
    var o, s;
    if (this.overlayService.isExclusive())
      return n && this.focusOverlay(r);
    if (this.isCellFocusSuppressed())
      return r && !this.isHeaderFocusSuppressed() ? this.focusLastHeader() : n && this.focusOverlay(r) ? !0 : this.focusNextGridCoreContainer(!1);
    const i = r ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (i) {
      const { rowIndex: a, rowPinned: l } = i;
      if (t ?? (t = (o = this.getFocusedHeader()) == null ? void 0 : o.column), t && a !== void 0 && a !== null) {
        if (this.navigationService.ensureCellVisible({ rowIndex: a, column: t, rowPinned: l }), r) {
          const u = this.rowRenderer.getRowByPosition(i);
          if (u != null && u.isFullWidth() && this.navigationService.tryToFocusFullWidthRow(i, r))
            return !0;
        }
        return this.setFocusedCell({
          rowIndex: a,
          column: t,
          rowPinned: Fi(l),
          forceBrowserFocus: !0
        }), (s = this.rangeService) == null || s.setRangeToCell({ rowIndex: a, rowPinned: l, column: t }), !0;
      }
    }
    return !!(n && this.focusOverlay(r) || r && this.focusLastHeader());
  }
  /** Returns true if an element inside the grid has focus */
  isGridFocused() {
    const t = Dt(this.gos);
    return !!t && this.eGridDiv.contains(t);
  }
  focusNextGridCoreContainer(t, r = !1) {
    return !r && this.gridCtrl.focusNextInnerContainer(t) ? !0 : ((r || !t && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(t), !1);
  }
  focusAdvancedFilter(t) {
    var r;
    return this.advancedFilterFocusColumn = t == null ? void 0 : t.column, ((r = this.advancedFilterService) == null ? void 0 : r.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(t, r) {
    var i;
    const n = (r ? void 0 : this.advancedFilterFocusColumn) ?? ((i = this.visibleColsService.getAllCols()) == null ? void 0 : i[0]);
    return t ? this.focusHeaderPosition({
      headerPosition: {
        column: n,
        headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
      }
    }) : this.focusGridView(n);
  }
  clearAdvancedFilterColumn() {
    this.advancedFilterFocusColumn = void 0;
  }
  addFocusableContainer(t) {
    this.gridCtrl.addFocusableContainer(t);
  }
  removeFocusableContainer(t) {
    this.gridCtrl.removeFocusableContainer(t);
  }
  focusGridInnerElement(t) {
    return this.gridCtrl.focusInnerElement(t);
  }
  allowFocusForNextGridCoreContainer(t) {
    this.gridCtrl.allowFocusForNextCoreContainer(t);
  }
};
ry.keyboardModeActive = !1;
ry.instanceCount = 0;
var oW = ry, sW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "pinnedWidthService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = ar(this.gos, "print"), t = e ? 0 : this.visibleColsService.getColsLeftWidth(), r = e ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: "leftPinnedWidthChanged" })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
}, aW = class extends J {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.beans = e, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  setComp(e, t, r) {
    this.view = e, this.eGridHostDiv = t, this.eGui = r, this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
    const { dragAndDropService: n, mouseEventService: i, ctrlsService: o, resizeObserverService: s } = this.beans, a = {
      getContainer: () => this.eGui,
      isInterestedIn: (u) => u === 1 || u === 0,
      getIconName: () => "notAllowed"
    };
    n.addDropTarget(a), this.addDestroyFunc(() => n.removeDropTarget(a)), i.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new ty(this.view)), this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr"), this.updateGridThemeClass(), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
    const l = s.observeResize(
      this.eGridHostDiv,
      this.onGridSizeChanged.bind(this)
    );
    this.addDestroyFunc(() => l()), o.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = this.focusService.findTabbableParent(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, r, n, i, o;
    const e = this.beans;
    return {
      paginationSelector: (t = e.paginationService) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: (r = e.columnDropZonesService) == null ? void 0 : r.getDropZoneSelector(),
      sideBarSelector: (n = e.sideBarService) == null ? void 0 : n.getSideBarSelector(),
      statusBarSelector: (i = e.statusBarService) == null ? void 0 : i.getStatusPanelSelector(),
      watermarkSelector: (o = e.licenseManager) == null ? void 0 : o.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventService.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), { indexWithFocus: r, nextIndex: n } = this.getNextFocusableIndex(t, e);
    if (n < 0 || n >= t.length)
      return !1;
    if (n === 0) {
      if (r > 0) {
        const i = this.visibleColsService.getAllCols(), o = Ye(i);
        if (this.focusService.focusGridView(o, !0))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[n], e);
  }
  focusInnerElement(e) {
    const t = this.gos.getCallback("focusGridInnerElement");
    if (t && t({ fromBottom: !!e }))
      return !0;
    const r = this.getFocusableContainers(), n = this.visibleColsService.getAllCols();
    if (e) {
      if (r.length > 1)
        return this.focusContainer(Ye(r), !0);
      const i = Ye(n);
      if (this.focusService.focusGridView(i, !0))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || this.focusService.isHeaderFocusSuppressed()) {
      if (this.focusService.focusGridView(n[0]))
        return !0;
      for (let i = 1; i < r.length; i++)
        if (this.focusService.focusInto(r[i].getGui()))
          return !0;
      return !1;
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  allowFocusForNextCoreContainer(e) {
    var o;
    const t = this.view.getFocusableContainers(), { nextIndex: r, indexWithFocus: n } = this.getNextFocusableIndex(t, e);
    if (n === -1 || r < 0 || r >= t.length)
      return;
    const i = t[r];
    (o = i.setAllowFocus) == null || o.call(i, !0), setTimeout(() => {
      var s;
      (s = i.setAllowFocus) == null || s.call(i, !1);
    });
  }
  getNextFocusableIndex(e, t) {
    const r = Dt(this.gos), n = e.findIndex((o) => o.getGui().contains(r)), i = n + (t ? -1 : 1);
    return {
      indexWithFocus: n,
      nextIndex: i
    };
  }
  focusContainer(e, t) {
    var n, i;
    (n = e.setAllowFocus) == null || n.call(e, !0);
    const r = this.focusService.focusInto(e.getGui(), t);
    return (i = e.setAllowFocus) == null || i.call(e, !1), r;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  updateGridThemeClass() {
    const e = this.beans.environment.getGridThemeClass();
    e && this.view.setGridThemeClass(e);
  }
  handleThemeChange(e) {
    e.themeChanged && this.updateGridThemeClass();
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, lW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsService", this.consuming = !1;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.ctrlsService = e.ctrlsService, this.columnApplyStateService = e.columnApplyStateService;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    typeof e == "function" && (e = e());
    const r = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
    return e.map((i) => {
      var s;
      if (!i) {
        tt("alignedGrids contains an undefined option."), t || tt(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`), tt(r());
        return;
      }
      if (this.isGridApi(i))
        return i;
      const o = i;
      return "current" in o ? (s = o.current) == null ? void 0 : s.api : (o.api || tt(
        `alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${r()}`
      ), o.api);
    }).filter((i) => !!i && !i.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: e,
      columnVisible: e,
      columnPinned: e,
      columnGroupOpened: e,
      columnResized: e,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
      alignedGridScroll: ({ event: t }) => this.onScrollEvent(t)
    });
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    this.fireEvent({
      type: "alignedGridColumn",
      event: e
    });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent({
      type: "alignedGridScroll",
      event: e
    });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  extractDataFromEvent(e, t) {
    const r = [];
    return e.columns ? e.columns.forEach((n) => {
      r.push(t(n));
    }) : e.column && r.push(t(e.column)), r;
  }
  getMasterColumns(e) {
    return this.extractDataFromEvent(e, (t) => t);
  }
  getColumnIds(e) {
    return this.extractDataFromEvent(e, (t) => t.getColId());
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          this.processColumnEvent(e);
          break;
        }
        case "columnGroupOpened": {
          this.processGroupOpenedEvent(e);
          break;
        }
        case "columnPivotChanged":
          ie(
            "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid."
          );
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    const { columnModel: t } = this;
    e.columnGroups.forEach((r) => {
      let n = null;
      r && (n = t.getProvidedColGroup(r.getGroupId())), !(r && !n) && t.setColumnGroupOpened(n, r.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var u;
    const t = e.column;
    let r = null;
    if (t && (r = this.columnModel.getColDefCol(t.getColId())), t && !r)
      return;
    const n = this.getMasterColumns(e), { columnApplyStateService: i, columnSizeService: o, ctrlsService: s } = this;
    switch (e.type) {
      case "columnMoved":
        {
          const h = e.api.getColumnState().map((f) => ({ colId: f.colId }));
          i.applyColumnState(
            { state: h, applyOrder: !0 },
            "alignedGridChanged"
          );
        }
        break;
      case "columnVisible":
        {
          const h = e.api.getColumnState().map((f) => ({ colId: f.colId, hide: f.hide }));
          i.applyColumnState({ state: h }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const h = e.api.getColumnState().map((f) => ({ colId: f.colId, pinned: f.pinned }));
          i.applyColumnState({ state: h }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const d = e, h = {};
        n.forEach((f) => {
          h[f.getId()] = { key: f.getColId(), newWidth: f.getActualWidth() };
        }), (u = d.flexColumns) == null || u.forEach((f) => {
          h[f.getId()] && delete h[f.getId()];
        }), o.setColumnWidths(
          Object.values(h),
          !1,
          d.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const l = s.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((d) => {
      d.setGridOption("alwaysShowVerticalScroll", l);
    });
  }
}, cW = {
  version: Te,
  moduleName: "@ag-grid-community/aligned-grid",
  beans: [lW]
};
function uW(e, t) {
  const r = e.columnModel.getColDefCol(t);
  return r ? r.getColDef() : null;
}
function dW(e) {
  return e.columnModel.getColumnDefs();
}
function hW(e, t) {
  typeof t == "number" ? e.columnSizeService.sizeColumnsToFit(t, "api") : e.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(t);
}
function gW(e, t, r) {
  e.columnModel.setColumnGroupOpened(t, r, "api");
}
function fW(e, t, r) {
  return e.visibleColsService.getColumnGroup(t, r);
}
function pW(e, t) {
  return e.columnModel.getProvidedColGroup(t);
}
function mW(e, t, r) {
  return e.columnNameService.getDisplayNameForColumn(t, r) || "";
}
function vW(e, t, r) {
  return e.columnNameService.getDisplayNameForColumnGroup(t, r) || "";
}
function yW(e, t) {
  return e.columnModel.getColDefCol(t);
}
function CW(e) {
  return e.columnModel.getColDefCols();
}
function wW(e, t) {
  return e.columnApplyStateService.applyColumnState(t, "api");
}
function bW(e) {
  return e.columnGetStateService.getColumnState();
}
function SW(e) {
  e.columnApplyStateService.resetColumnState("api");
}
function xW(e) {
  return e.columnGroupStateService.getColumnGroupState();
}
function RW(e, t) {
  e.columnGroupStateService.setColumnGroupState(t, "api");
}
function EW(e) {
  e.columnGroupStateService.resetColumnGroupState("api");
}
function PW(e) {
  return e.visibleColsService.isPinningLeft() || e.visibleColsService.isPinningRight();
}
function AW(e) {
  return e.visibleColsService.isPinningLeft();
}
function FW(e) {
  return e.visibleColsService.isPinningRight();
}
function MW(e, t) {
  return e.visibleColsService.getColAfter(t);
}
function TW(e, t) {
  return e.visibleColsService.getColBefore(t);
}
function DW(e, t, r) {
  e.columnModel.setColsVisible([t], r, "api");
}
function OW(e, t, r) {
  e.columnModel.setColsVisible(t, r, "api");
}
function IW(e, t, r) {
  e.columnModel.setColsPinned([t], r, "api");
}
function kW(e, t, r) {
  e.columnModel.setColsPinned(t, r, "api");
}
function LW(e) {
  return e.columnModel.getCols();
}
function _W(e) {
  return e.visibleColsService.getLeftCols();
}
function zW(e) {
  return e.visibleColsService.getCenterCols();
}
function NW(e) {
  return e.visibleColsService.getRightCols();
}
function BW(e) {
  return e.visibleColsService.getAllCols();
}
function GW(e) {
  return e.columnViewportService.getViewportColumns();
}
function HW(e, t, r) {
  e.columnMoveService.moveColumns([t], r, "api");
}
function WW(e, t, r) {
  e.columnMoveService.moveColumnByIndex(t, r, "api");
}
function VW(e, t, r) {
  e.columnMoveService.moveColumns(t, r, "api");
}
function $W(e, t, r, n = !0, i = "api") {
  e.columnSizeService.setColumnWidths([{ key: t, newWidth: r }], !1, n, i);
}
function jW(e, t, r = !0, n = "api") {
  e.columnSizeService.setColumnWidths(t, !1, r, n);
}
function UW(e) {
  return e.visibleColsService.getTreeLeft();
}
function KW(e) {
  return e.visibleColsService.getTreeCenter();
}
function qW(e) {
  return e.visibleColsService.getTreeRight();
}
function YW(e) {
  return e.visibleColsService.getAllTrees();
}
function JW(e, t, r) {
  return e.columnAutosizeService.autoSizeCols({ colKeys: [t], skipHeader: r, source: "api" });
}
function XW(e, t, r) {
  e.columnAutosizeService.autoSizeCols({ colKeys: t, skipHeader: r, source: "api" });
}
function QW(e, t) {
  e.columnAutosizeService.autoSizeAllColumns("api", t);
}
var ZW = class extends J {
  constructor() {
    super(...arguments), this.beanName = "dataTypeService", this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.columnApplyStateService = e.columnApplyStateService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(Wo(e.source));
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, this.formatValueFuncs = {};
    const t = (n) => (i) => {
      const { column: o, node: s, value: a } = i;
      let l = o.getColDef().valueFormatter;
      return l === n.groupSafeValueFormatter && (l = n.valueFormatter), this.valueService.formatValue(o, s, a, l);
    };
    Object.entries(e).forEach(([n, i]) => {
      const o = {
        ...i,
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
      };
      this.dataTypeDefinitions[n] = o, this.formatValueFuncs[n] = t(o);
    });
    const r = this.gos.get("dataTypeDefinitions") ?? {};
    this.dataTypeMatchers = {}, Object.entries(r).forEach(([n, i]) => {
      const o = this.processDataTypeDefinition(
        i,
        r,
        [n],
        e
      );
      o && (this.dataTypeDefinitions[n] = o, i.dataTypeMatcher && (this.dataTypeMatchers[n] = i.dataTypeMatcher), this.formatValueFuncs[n] = t(o));
    }), this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((n) => {
      const i = this.dataTypeMatchers[n];
      i && delete this.dataTypeMatchers[n], this.dataTypeMatchers[n] = i ?? e[n].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const r = {
      ...e,
      ...t
    };
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (r.columnTypes = [
      ...md(e.columnTypes),
      ...md(t.columnTypes)
    ]), r;
  }
  processDataTypeDefinition(e, t, r, n) {
    let i;
    const o = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let s = n[o];
      const a = t[o];
      if (s && a && (s = a), !this.validateDataTypeDefinition(e, s, o))
        return;
      i = this.mergeDataTypeDefinitions(s, e);
    } else {
      if (r.includes(o)) {
        ie(
          'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.'
        );
        return;
      }
      const s = t[o];
      if (!this.validateDataTypeDefinition(e, s, o))
        return;
      const a = this.processDataTypeDefinition(
        s,
        t,
        [...r, o],
        n
      );
      if (!a)
        return;
      i = this.mergeDataTypeDefinitions(
        a,
        e
      );
    }
    return {
      ...i,
      groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
    };
  }
  validateDataTypeDefinition(e, t, r) {
    return t ? t.baseDataType !== e.baseDataType ? (ie('The "baseDataType" property of a data type definition must match that of its parent.'), !1) : !0 : (ie(`The data type definition ${r} does not exist.`), !1);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter)
      return (t) => {
        var r, n;
        if ((r = t.node) != null && r.group) {
          const i = (t.colDef.pivotValueColumn ?? t.column).getAggFunc();
          if (i) {
            if (i === "first" || i === "last")
              return e.valueFormatter(t);
            if (e.baseDataType === "number" && i !== "count") {
              if (typeof t.value == "number")
                return e.valueFormatter(t);
              if (typeof t.value == "object") {
                if (!t.value)
                  return;
                if ("toNumber" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.toNumber()
                  });
                if ("value" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.value
                  });
              }
            }
            return;
          }
          if ((this.gos.get("suppressGroupMaintainValueType") || this.gos.get("groupDisplayType") === "groupRows") && !this.gos.get("treeData"))
            return;
        } else if (this.groupHideOpenParents && t.column.isRowGroupActive() && typeof t.value == "string" && !((n = e.dataTypeMatcher) != null && n.call(e, t.value)))
          return;
        return e.valueFormatter(t);
      };
  }
  updateColDefAndGetColumnType(e, t, r) {
    let { cellDataType: n } = t;
    const { field: i } = t;
    if (n === void 0 && (n = e.cellDataType), (n == null || n === !0) && (n = this.canInferCellDataType(e, t) ? this.inferCellDataType(i, r) : !1), !n) {
      e.cellDataType = !1;
      return;
    }
    const o = this.dataTypeDefinitions[n];
    if (!o) {
      ie(`Missing data type definition - "${n}"`);
      return;
    }
    return e.cellDataType = n, o.groupSafeValueFormatter && (e.valueFormatter = o.groupSafeValueFormatter), o.valueParser && (e.valueParser = o.valueParser), o.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, n, o, r), o.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const r = (n) => {
      t.add(n.key);
    };
    e.addEventListener("columnStateUpdated", r), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.removeEventListener("columnStateUpdated", r)
    );
  }
  canInferCellDataType(e, t) {
    if (!At(this.gos))
      return !1;
    const r = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (this.doColDefPropsPreventInference(t, r))
      return !1;
    const n = t.type === null ? e.type : t.type;
    if (n) {
      const i = this.gos.get("columnTypes") ?? {};
      if (md(n).some((s) => {
        const a = i[s.trim()];
        return a && this.doColDefPropsPreventInference(a, r);
      }))
        return !1;
    }
    return !this.doColDefPropsPreventInference(e, r);
  }
  doColDefPropsPreventInference(e, t) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(
      ([r, n]) => this.doesColDefPropPreventInference(e, t, r, n)
    );
  }
  doesColDefPropPreventInference(e, t, r, n) {
    if (!t[r])
      return !1;
    const i = e[r];
    return i === null ? (t[r] = !1, !1) : n === void 0 ? !!i : i === n;
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let r;
    const n = this.getInitialData();
    if (n) {
      const o = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      r = Wl(n, e, o);
    } else
      this.initWaitForRowData(t);
    if (r == null)
      return;
    const [i] = Object.entries(this.dataTypeMatchers).find(
      ([o, s]) => s(r)
    ) ?? ["object"];
    return i;
  }
  getInitialData() {
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t != null && t.length)
        return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData)
      return;
    this.isWaitingForRowData = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const [r] = this.addManagedEventListeners({
      rowDataUpdateStarted: (n) => {
        const { firstRowData: i } = n;
        i && (r == null || r(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(i, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations(), this.eventService.dispatchEvent({
          type: "dataTypesInferred"
        }));
      }
    });
  }
  isPendingInference() {
    return this.isWaitingForRowData;
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const r = [];
    this.destroyColumnStateUpdateListeners();
    const n = {}, i = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([o, s]) => {
      const a = this.columnModel.getCol(o);
      if (!a)
        return;
      const l = a.getColDef();
      if (!this.columnModel.resetColDefIntoCol(a, "cellDataTypeInferred"))
        return;
      const u = a.getColDef();
      if (t && u.type && u.type !== l.type) {
        const d = this.getUpdatedColumnState(a, s);
        d.rowGroup && d.rowGroupIndex == null && (n[o] = d), d.pivot && d.pivotIndex == null && (i[o] = d), r.push(d);
      }
    }), t && r.push(
      ...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(
        n,
        i
      )
    ), r.length && this.columnApplyStateService.applyColumnState({ state: r }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const r = this.columnApplyStateService.getColumnStateFromColDef(e);
    return t.forEach((n) => {
      delete r[n], n === "rowGroup" ? delete r.rowGroupIndex : n === "pivot" && delete r.pivotIndex;
    }), r;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, r = e.object;
    this.hasObjectValueParser = t.valueParser !== r.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== r.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    return e ? this.getDataTypeDefinition(e) ?? this.dataTypeDefinitions.dateString : this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var n;
    if (t == null)
      return !0;
    const r = (n = this.getDataTypeDefinition(e)) == null ? void 0 : n.dataTypeMatcher;
    return r ? r(t) : !0;
  }
  validateColDef(e) {
    const t = (r) => ie(
      `Cell data type is "object" but no Value ${r} has been provided. Please either provide an object data type definition with a Value ${r}, or set "colDef.value${r}"`
    );
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && t("Formatter"), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && t("Parser"));
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  setColDefPropertiesForBaseDataType(e, t, r, n) {
    var o;
    const i = this.formatValueFuncs[t];
    switch (r.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor";
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (s) => !!s.colDef.editable && s.event.key === V.SPACE;
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = i;
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = i;
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (s, a) => {
          const l = this.columnModel.getColDefCol(n), u = l == null ? void 0 : l.getColDef();
          if (!l || !u)
            return 0;
          const d = s == null ? "" : i({ column: l, node: null, value: s }), h = a == null ? "" : i({ column: l, node: null, value: a });
          return d === h ? 0 : d > h ? 1 : -1;
        }, e.keyCreator = i;
        break;
      }
    }
    (o = this.filterManager) == null || o.setColDefPropertiesForDataType(e, r, i);
  }
  getDefaultDataTypes() {
    const e = (r) => !!r.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (r) => {
          var n, i;
          return ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : Number(r.newValue);
        },
        valueFormatter: (r) => r.value == null ? "" : typeof r.value != "number" || isNaN(r.value) ? t("invalidNumber", "Invalid Number") : String(r.value),
        dataTypeMatcher: (r) => typeof r == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (r) => r.newValue === "" ? null : um(r.newValue),
        dataTypeMatcher: (r) => typeof r == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (r) => {
          var n, i;
          return r.newValue == null ? r.newValue : ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : String(r.newValue).toLowerCase() === "true";
        },
        valueFormatter: (r) => r.value == null ? "" : String(r.value),
        dataTypeMatcher: (r) => typeof r == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (r) => Br(r.newValue == null ? null : String(r.newValue)),
        valueFormatter: (r) => r.value == null ? "" : !(r.value instanceof Date) || isNaN(r.value.getTime()) ? t("invalidDate", "Invalid Date") : Rn(r.value, !1) ?? "",
        dataTypeMatcher: (r) => r instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (r) => Br(r) ?? void 0,
        dateFormatter: (r) => Rn(r ?? null, !1) ?? void 0,
        valueParser: (r) => e(String(r.newValue)) ? r.newValue : null,
        valueFormatter: (r) => e(String(r.value)) ? r.value : "",
        dataTypeMatcher: (r) => typeof r == "string" && e(r)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (r) => um(r.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
}, eV = {
  version: Te,
  moduleName: "@ag-grid-community/data-type",
  beans: [ZW]
}, tV = {
  version: Te,
  moduleName: "@ag-grid-community/column-api",
  apiFunctions: {
    getColumnDef: uW,
    getColumnDefs: dW,
    sizeColumnsToFit: hW,
    setColumnGroupOpened: gW,
    getColumnGroup: fW,
    getProvidedColumnGroup: pW,
    getDisplayNameForColumn: mW,
    getDisplayNameForColumnGroup: vW,
    getColumn: yW,
    getColumns: CW,
    applyColumnState: wW,
    getColumnState: bW,
    resetColumnState: SW,
    getColumnGroupState: xW,
    setColumnGroupState: RW,
    resetColumnGroupState: EW,
    isPinning: PW,
    isPinningLeft: AW,
    isPinningRight: FW,
    getDisplayedColAfter: MW,
    getDisplayedColBefore: TW,
    setColumnVisible: DW,
    setColumnsVisible: OW,
    setColumnPinned: IW,
    setColumnsPinned: kW,
    getAllGridColumns: LW,
    getDisplayedLeftColumns: _W,
    getDisplayedCenterColumns: zW,
    getDisplayedRightColumns: NW,
    getAllDisplayedColumns: BW,
    getAllDisplayedVirtualColumns: GW,
    moveColumn: HW,
    moveColumnByIndex: WW,
    moveColumns: VW,
    setColumnWidth: $W,
    setColumnWidths: jW,
    getLeftDisplayedColumnGroups: UW,
    getCenterDisplayedColumnGroups: KW,
    getRightDisplayedColumnGroups: qW,
    getAllDisplayedColumnGroups: YW,
    autoSizeColumn: JW,
    autoSizeColumns: XW,
    autoSizeAllColumns: QW
  }
};
function rV(e, t) {
  e.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(t);
}
function nV(e, t) {
  const r = e.dragAndDropService.findExternalZone(t);
  r && e.dragAndDropService.removeDropTarget(r);
}
function iV(e, t) {
  return e.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(t);
}
var oV = {
  version: Te,
  moduleName: "@ag-grid-community/drag-api",
  apiFunctions: {
    addRowDropZone: rV,
    removeRowDropZone: nV,
    getRowDropZoneParams: iV
  }
};
function sV(e) {
  return e.pinnedRowModel.getPinnedTopRowCount();
}
function aV(e) {
  return e.pinnedRowModel.getPinnedBottomRowCount();
}
function lV(e, t) {
  return e.pinnedRowModel.getPinnedTopRow(t);
}
function cV(e, t) {
  return e.pinnedRowModel.getPinnedBottomRow(t);
}
var uV = {
  version: Te,
  moduleName: "@ag-grid-community/pinned-row-api",
  apiFunctions: {
    getPinnedTopRowCount: sV,
    getPinnedBottomRowCount: aV,
    getPinnedTopRow: lV,
    getPinnedBottomRow: cV
  }
};
function dV(e) {
  e.overlayService.showLoadingOverlay();
}
function hV(e) {
  e.overlayService.showNoRowsOverlay();
}
function gV(e) {
  e.overlayService.hideOverlay();
}
var fV = {
  version: Te,
  moduleName: "@ag-grid-community/overlay-api",
  apiFunctions: {
    showLoadingOverlay: dV,
    showNoRowsOverlay: hV,
    hideOverlay: gV
  }
};
function pV(e, t, r) {
  if (!t)
    return;
  const n = e.ctrlsService.getGridBodyCtrl().getGui(), i = `aria-${t}`;
  r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
}
function mV(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function vV(e, t = {}) {
  const r = (n) => ie(
    `Since v31.1 api.flashCells parameter '${n}Delay' is deprecated. Please use '${n}Duration' instead.`
  );
  de(t.fadeDelay) && r("fade"), de(t.flashDelay) && r("flash"), e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.flashCells(t));
}
function yV(e) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getHeaderRowContainerCtrls().forEach((t) => t.refresh())
  );
}
function CV(e) {
  return e.animationFrameService.isQueueEmpty();
}
function wV(e) {
  e.animationFrameService.flushAllFrames();
}
function bV(e) {
  return {
    rowHeight: Zo(e.gos),
    headerHeight: e.columnModel.getHeaderHeight()
  };
}
function SV(e, t = {}) {
  return e.rowRenderer.getCellRendererInstances(t).map($l);
}
var xV = {
  version: Te,
  moduleName: "@ag-grid-community/render-api",
  apiFunctions: {
    setGridAriaProperty: pV,
    refreshCells: mV,
    flashCells: vV,
    refreshHeader: yV,
    isAnimationFrameQueueEmpty: CV,
    flushAllAnimationFrames: wV,
    getSizesForCurrentTheme: bV,
    getCellRendererInstances: SV
  }
};
function RV(e) {
  e.valueCache.expire();
}
function EV(e, t, r) {
  return $P(e, { colKey: t, rowNode: r });
}
function $P(e, t) {
  const { colKey: r, rowNode: n, useFormatter: i } = t, o = e.columnModel.getColDefCol(r) ?? e.columnModel.getCol(r);
  if (Ke(o))
    return null;
  const s = e.valueService.getValueForDisplay(o, n);
  return i ? e.valueService.formatValue(o, n, s) ?? ni(s, !0) : s;
}
function PV(e) {
  return e.context.getGridId();
}
function AV(e) {
  e.gridDestroyService.destroy();
}
function FV(e) {
  return e.gridDestroyService.isDestroyCalled();
}
function MV(e, t) {
  return e.gos.get(t);
}
function TV(e, t, r) {
  jP(e, { [t]: r });
}
function jP(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function DV(e, t, r) {
  e.apiEventService.addEventListener(t, r);
}
function OV(e, t, r) {
  e.apiEventService.removeEventListener(t, r);
}
function IV(e, t) {
  e.apiEventService.addGlobalListener(t);
}
function kV(e, t) {
  e.apiEventService.removeGlobalListener(t);
}
function LV(e) {
  return e.focusService.getFocusedCell();
}
function _V(e) {
  return e.focusService.clearFocusedCell();
}
function zV(e, t, r, n) {
  e.focusService.setFocusedCell({ rowIndex: t, column: r, rowPinned: n, forceBrowserFocus: !0 });
}
function NV(e, t) {
  return e.navigationService.tabToNextCell(!1, t);
}
function BV(e, t) {
  return e.navigationService.tabToNextCell(!0, t);
}
function GV(e, t, r = !1) {
  const n = e.headerNavigationService.getHeaderPositionForColumn(t, r);
  n && e.focusService.focusHeaderPosition({ headerPosition: n });
}
function HV(e, t, r) {
  const n = e.columnModel.getCol(t);
  e.menuService.showColumnMenu({
    column: n,
    buttonElement: r,
    positionBy: "button"
  });
}
function WV(e, t, r) {
  let n = e.columnModel.getCol(t);
  if (n || (n = e.columnModel.getColDefCol(t)), !n) {
    tt(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: n,
    mouseEvent: r,
    positionBy: "mouse"
  });
}
function VV(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    tt(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: r,
    positionBy: "auto"
  });
}
function $V(e) {
  e.menuService.hidePopupMenu();
}
function jV(e, t = {}) {
  const r = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(r));
}
function UV(e, t, r, n, i) {
  e.expansionService.setRowNodeExpanded(t, r, n, i);
}
function KV(e, t) {
  return e.rowModel.getRowNode(t);
}
function qV(e, t, r, n) {
  e.rowRenderer.addRenderedRowListener(t, r, n);
}
function YV(e) {
  return e.rowRenderer.getRenderedNodes();
}
function JV(e, t, r) {
  e.rowModel.forEachNode(t, r);
}
function XV(e) {
  return UP(e);
}
function UP(e) {
  return e.rowRenderer.getFirstVirtualRenderedRow();
}
function QV(e) {
  return KP(e);
}
function KP(e) {
  return e.rowRenderer.getLastVirtualRenderedRow();
}
function ZV(e, t) {
  return e.rowModel.getRow(t);
}
function e$(e) {
  return e.rowModel.getRowCount();
}
function t$(e) {
  return e.rowModel;
}
function r$(e, t) {
  if (!t.nodes.every((a) => a.rowPinned ? (ie("cannot select pinned rows"), !1) : a.id === void 0 ? (ie("cannot select node until id for node is known"), !1) : !0))
    return;
  const { nodes: n, source: i, newValue: o } = t, s = n;
  e.selectionService.setNodesSelected({ nodes: s, source: i ?? "api", newValue: o });
}
function n$(e, t = "apiSelectAll") {
  e.selectionService.selectAllRowNodes({ source: t });
}
function i$(e, t = "apiSelectAll") {
  e.selectionService.deselectAllRowNodes({ source: t });
}
function o$(e, t = "apiSelectAllFiltered") {
  e.selectionService.selectAllRowNodes({ source: t, justFiltered: !0 });
}
function s$(e, t = "apiSelectAllFiltered") {
  e.selectionService.deselectAllRowNodes({ source: t, justFiltered: !0 });
}
function a$(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.selectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function l$(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.deselectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function c$(e) {
  return e.selectionService.getSelectedNodes();
}
function u$(e) {
  return e.selectionService.getSelectedRows();
}
function d$(e) {
  e.sortController.onSortChanged("api");
}
var h$ = {
  version: Te,
  moduleName: "@ag-grid-community/core-api",
  apiFunctions: {
    getGridId: PV,
    destroy: AV,
    isDestroyed: FV,
    getGridOption: MV,
    setGridOption: TV,
    updateGridOptions: jP
  }
}, g$ = {
  version: Te,
  moduleName: "@ag-grid-community/row-selection-api",
  apiFunctions: {
    setNodesSelected: r$,
    selectAll: n$,
    deselectAll: i$,
    selectAllFiltered: o$,
    deselectAllFiltered: s$,
    selectAllOnCurrentPage: a$,
    deselectAllOnCurrentPage: l$,
    getSelectedNodes: c$,
    getSelectedRows: u$
  }
}, f$ = {
  version: Te,
  moduleName: "@ag-grid-community/row-api",
  apiFunctions: {
    redrawRows: jV,
    setRowNodeExpanded: UV,
    getRowNode: KV,
    addRenderedRowListener: qV,
    getRenderedNodes: YV,
    forEachNode: JV,
    getFirstDisplayedRow: XV,
    getFirstDisplayedRowIndex: UP,
    getLastDisplayedRow: QV,
    getLastDisplayedRowIndex: KP,
    getDisplayedRowAtIndex: ZV,
    getDisplayedRowCount: e$,
    getModel: t$
  }
}, p$ = {
  version: Te,
  moduleName: "@ag-grid-community/scroll-api",
  apiFunctions: {
    getVerticalPixelRange: eH,
    getHorizontalPixelRange: tH,
    ensureColumnVisible: NP,
    ensureIndexVisible: BP,
    ensureNodeVisible: rH
  }
}, m$ = {
  version: Te,
  moduleName: "@ag-grid-community/keyboard-navigation-api",
  apiFunctions: {
    getFocusedCell: LV,
    clearFocusedCell: _V,
    setFocusedCell: zV,
    setFocusedHeader: GV,
    tabToNextCell: NV,
    tabToPreviousCell: BV
  }
}, v$ = {
  version: Te,
  moduleName: "@ag-grid-community/event-api",
  apiFunctions: {
    addEventListener: DV,
    addGlobalListener: IV,
    removeEventListener: OV,
    removeGlobalListener: kV
  }
}, y$ = {
  version: Te,
  moduleName: "@ag-grid-community/cell-api",
  apiFunctions: {
    expireValueCache: RV,
    getValue: EV,
    getCellValue: $P
  }
}, C$ = {
  version: Te,
  moduleName: "@ag-grid-community/menu-api",
  apiFunctions: {
    showColumnMenuAfterButtonClick: HV,
    showColumnMenuAfterMouseClick: WV,
    showColumnMenu: VV,
    hidePopupMenu: $V
  }
}, w$ = {
  version: Te,
  moduleName: "@ag-grid-community/sort-api",
  apiFunctions: {
    onSortChanged: d$
  }
}, b$ = {
  version: Te,
  moduleName: "@ag-grid-community/api",
  dependantModules: [
    h$,
    uV,
    g$,
    tV,
    f$,
    oV,
    p$,
    fV,
    m$,
    v$,
    xV,
    y$,
    C$,
    w$
  ]
};
function S$(e) {
  var t;
  return ((t = e.stateService) == null ? void 0 : t.getState()) ?? {};
}
function x$(e) {
  switch (e = { ...e }, e.version || (e.version = "32.1.0"), e.version) {
    case "32.1.0":
      e = R$(e);
  }
  return e;
}
function R$(e) {
  return e.cellSelection = E$(e, "rangeSelection"), e;
}
function E$(e, t) {
  if (e && typeof e == "object")
    return e[t];
}
var P$ = class extends J {
  constructor() {
    super(...arguments), this.beanName = "stateService", this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = Ar(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = Ar(
      () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
      0
    ), this.onRowSelectedDebounced = Ar(() => {
      this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
    }, 0), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.ctrlsService = e.ctrlsService, this.pivotResultColsService = e.pivotResultColsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnGroupStateService = e.columnGroupStateService, this.columnGetStateService = e.columnGetStateService, this.paginationService = e.paginationService, this.selectionService = e.selectionService, this.expansionService = e.expansionService, this.columnAnimationService = e.columnAnimationService, this.columnApplyStateService = e.columnApplyStateService, this.sideBarService = e.sideBarService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.isClientSideRowModel = At(this.gos), this.cachedState = this.getInitialState(), this.setCachedStateValue("version", Te), this.ctrlsService.whenReady(
      this,
      () => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady())
    );
    const [e, t, r] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source: n }) => {
        n === "gridInitializing" && (e(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()));
      },
      rowCountReady: () => {
        t == null || t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
      },
      firstDataRendered: () => {
        r == null || r(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
      }
    });
  }
  getInitialState() {
    return x$(this.gos.get("initialState") ?? {});
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    this.updateCachedState("sideBar", this.getSideBarState());
    const e = () => this.updateCachedState("sideBar", this.getSideBarState());
    this.addManagedEventListeners({
      toolPanelVisibleChanged: e,
      sideBarUpdated: e
    });
  }
  setupStateOnColumnsInitialised() {
    const e = this.getInitialState();
    this.setColumnState(e), this.setColumnGroupState(e), this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState());
    const t = (r) => () => this.updateColumnState([r]);
    this.addManagedEventListeners({
      columnValueChanged: t("aggregation"),
      columnMoved: t("columnOrder"),
      columnPinned: t("columnPinning"),
      columnResized: t("columnSizing"),
      columnVisible: t("columnVisibility"),
      columnPivotChanged: t("pivot"),
      columnPivotModeChanged: t("pivot"),
      columnRowGroupChanged: t("rowGroup"),
      sortChanged: t("sort"),
      newColumnsLoaded: () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "rowGroup",
        "sort"
      ]),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setupStateOnRowCountReady() {
    const {
      filter: e,
      rowGroupExpansion: t,
      rowSelection: r,
      pagination: n
    } = this.getInitialState(), i = this.gos.get("advancedFilterModel");
    (e || i) && this.setFilterState(e, i), t && this.setRowGroupExpansionState(t), r && this.setRowSelectionState(r), n && this.setPaginationState(n), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState());
    const o = () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
    this.addManagedEventListeners({
      filterChanged: () => this.updateCachedState("filter", this.getFilterState()),
      rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
      expandOrCollapseAll: o,
      // `groupDefaultExpanded` updates expansion state without an expansion event
      columnRowGroupChanged: o,
      rowDataUpdated: () => {
        this.gos.get("groupDefaultExpanded") !== 0 && setTimeout(() => {
          o();
        });
      },
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
      },
      paginationChanged: (s) => {
        (s.newPage || s.newPageSize) && this.updateCachedState("pagination", this.getPaginationState());
      }
    });
  }
  setupStateOnFirstDataRendered() {
    const {
      scroll: e,
      cellSelection: t,
      focusedCell: r,
      columnOrder: n
    } = this.getInitialState();
    r && this.setFocusedCellState(r), t && this.setCellSelectionState(t), e && this.setScrollState(e), this.setColumnPivotState(!!(n != null && n.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState());
    const i = this.getRangeSelectionState();
    this.updateCachedState("rangeSelection", i), this.updateCachedState("cellSelection", i), this.updateCachedState("scroll", this.getScrollState()), this.addManagedEventListeners({
      cellFocused: () => this.updateCachedState("focusedCell", this.getFocusedCellState()),
      cellSelectionChanged: (o) => {
        if (o.finished) {
          const s = this.getRangeSelectionState();
          this.updateCachedState("rangeSelection", s), this.updateCachedState("cellSelection", s);
        }
      },
      bodyScrollEnd: () => this.updateCachedState("scroll", this.getScrollState())
    });
  }
  getColumnState() {
    const e = this.columnModel.isPivotMode(), t = [], r = [], n = [], i = [], o = [], s = [], a = [], l = [], u = [];
    let d = 0;
    const h = this.columnGetStateService.getColumnState();
    for (let f = 0; f < h.length; f++) {
      const {
        colId: p,
        sort: y,
        sortIndex: C,
        rowGroup: v,
        rowGroupIndex: w,
        aggFunc: R,
        pivot: b,
        pivotIndex: P,
        pinned: S,
        hide: E,
        width: A,
        flex: M
      } = h[f];
      u.push(p), y && (t[C ?? d++] = { colId: p, sort: y }), v && (r[w ?? 0] = p), typeof R == "string" && n.push({ colId: p, aggFunc: R }), b && (i[P ?? 0] = p), S && (S === "right" ? s : o).push(p), E && a.push(p), (M || A) && l.push({ colId: p, flex: M ?? void 0, width: A });
    }
    return {
      sort: t.length ? { sortModel: t } : void 0,
      rowGroup: r.length ? { groupColIds: r } : void 0,
      aggregation: n.length ? { aggregationModel: n } : void 0,
      pivot: i.length || e ? { pivotMode: e, pivotColIds: i } : void 0,
      columnPinning: o.length || s.length ? { leftColIds: o, rightColIds: s } : void 0,
      columnVisibility: a.length ? { hiddenColIds: a } : void 0,
      columnSizing: l.length ? { columnSizingModel: l } : void 0,
      columnOrder: u.length ? { orderedColIds: u } : void 0
    };
  }
  setColumnState(e) {
    const {
      sort: t,
      rowGroup: r,
      aggregation: n,
      pivot: i,
      columnPinning: o,
      columnVisibility: s,
      columnSizing: a,
      columnOrder: l,
      partialColumnState: u
    } = e, d = {}, h = (v) => {
      let w = d[v];
      return w || (w = { colId: v }, d[v] = w, w);
    }, f = u ? {} : {
      sort: null,
      sortIndex: null,
      rowGroup: null,
      rowGroupIndex: null,
      aggFunc: null,
      pivot: null,
      pivotIndex: null,
      pinned: null,
      hide: null,
      flex: null
    };
    t && (t.sortModel.forEach(({ colId: v, sort: w }, R) => {
      const b = h(v);
      b.sort = w, b.sortIndex = R;
    }), f.sort = null, f.sortIndex = null), r && (r.groupColIds.forEach((v, w) => {
      const R = h(v);
      R.rowGroup = !0, R.rowGroupIndex = w;
    }), f.rowGroup = null, f.rowGroupIndex = null), n && (n.aggregationModel.forEach(({ colId: v, aggFunc: w }) => {
      h(v).aggFunc = w;
    }), f.aggFunc = null), i && (i.pivotColIds.forEach((v, w) => {
      const R = h(v);
      R.pivot = !0, R.pivotIndex = w;
    }), this.gos.updateGridOptions({
      options: { pivotMode: i.pivotMode },
      source: "gridInitializing"
    }), f.pivot = null, f.pivotIndex = null), o && (o.leftColIds.forEach((v) => {
      h(v).pinned = "left";
    }), o.rightColIds.forEach((v) => {
      h(v).pinned = "right";
    }), f.pinned = null), s && (s.hiddenColIds.forEach((v) => {
      h(v).hide = !0;
    }), f.hide = null), a && (a.columnSizingModel.forEach(({ colId: v, flex: w, width: R }) => {
      const b = h(v);
      b.flex = w ?? null, b.width = R;
    }), f.flex = null);
    const p = l == null ? void 0 : l.orderedColIds, y = !!(p != null && p.length), C = y ? p.map((v) => h(v)) : Object.values(d);
    C.length && (this.columnStates = C, this.columnApplyStateService.applyColumnState(
      {
        state: C,
        applyOrder: y,
        defaultState: f
      },
      "gridInitializing"
    ));
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const r = this.columnGroupStates;
    if (this.columnGroupStates = void 0, !!this.pivotResultColsService.isPivotResultColsPresent()) {
      if (t) {
        const n = [];
        for (const i of t)
          this.pivotResultColsService.getPivotResultCol(i.colId) && n.push(i);
        this.columnApplyStateService.applyColumnState(
          {
            state: n,
            applyOrder: e
          },
          "gridInitializing"
        );
      }
      r && this.columnGroupStateService.setColumnGroupState(r, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const e = this.columnGroupStateService.getColumnGroupState(), t = [];
    return e.forEach(({ groupId: r, open: n }) => {
      n && t.push(r);
    }), t.length ? { openColumnGroupIds: t } : void 0;
  }
  setColumnGroupState(e) {
    var i;
    if (!Object.prototype.hasOwnProperty.call(e, "columnGroup"))
      return;
    const t = new Set((i = e.columnGroup) == null ? void 0 : i.openColumnGroupIds), n = this.columnGroupStateService.getColumnGroupState().map(({ groupId: o }) => {
      const s = t.has(o);
      return s && t.delete(o), {
        groupId: o,
        open: s
      };
    });
    t.forEach((o) => {
      n.push({
        groupId: o,
        open: !0
      });
    }), n.length && (this.columnGroupStates = n), this.columnGroupStateService.setColumnGroupState(n, "gridInitializing");
  }
  getFilterState() {
    var r, n;
    let e = (r = this.filterManager) == null ? void 0 : r.getFilterModel();
    e && Object.keys(e).length === 0 && (e = void 0);
    const t = ((n = this.filterManager) == null ? void 0 : n.getAdvancedFilterModel()) ?? void 0;
    return e || t ? { filterModel: e, advancedFilterModel: t } : void 0;
  }
  setFilterState(e, t) {
    var i, o;
    const { filterModel: r, advancedFilterModel: n } = e ?? {
      advancedFilterModel: t
    };
    r && ((i = this.filterManager) == null || i.setFilterModel(r, "columnFilter")), n && ((o = this.filterManager) == null || o.setAdvancedFilterModel(n));
  }
  getRangeSelectionState() {
    var t;
    const e = (t = this.rangeService) == null ? void 0 : t.getCellRanges().map((r) => {
      const { id: n, type: i, startRow: o, endRow: s, columns: a, startColumn: l } = r;
      return {
        id: n,
        type: i,
        startRow: o,
        endRow: s,
        colIds: a.map((u) => u.getColId()),
        startColId: l.getColId()
      };
    });
    return e != null && e.length ? { cellRanges: e } : void 0;
  }
  setCellSelectionState(e) {
    const { gos: t, rangeService: r, columnModel: n, visibleColsService: i } = this;
    if (!Ii(t) || !r)
      return;
    const o = [];
    if (e.cellRanges.forEach((s) => {
      const a = [];
      if (s.colIds.forEach((u) => {
        const d = n.getCol(u);
        d && a.push(d);
      }), !a.length)
        return;
      let l = n.getCol(s.startColId);
      if (!l) {
        const u = i.getAllCols(), d = new Set(a);
        l = u.find((h) => d.has(h));
      }
      o.push({
        ...s,
        columns: a,
        startColumn: l
      });
    }), tB(t) && rB(t) && o.length > 1)
      return ie("cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`");
    r.setCellRanges(o);
  }
  getScrollState() {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const e = (n = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : n.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: r } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return r || t ? {
      top: r,
      left: t
    } : void 0;
  }
  setScrollState(e) {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const { top: t, left: r } = e;
    (n = this.ctrlsService.getGridBodyCtrl()) == null || n.getScrollFeature().setScrollPosition(t, r);
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.sideBarService) == null ? void 0 : e.getSideBarComp()) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.focusService.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: r, rowPinned: n } = e;
      return {
        colId: t.getColId(),
        rowIndex: r,
        rowPinned: n
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { colId: t, rowIndex: r, rowPinned: n } = e;
    this.focusService.setFocusedCell({
      column: this.columnModel.getCol(t),
      rowIndex: r,
      rowPinned: n,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    if (!this.paginationService)
      return;
    const e = this.paginationService.getCurrentPage(), t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationService.getPageSize();
    if (!(!e && !t))
      return { page: e, pageSize: t };
  }
  setPaginationState(e) {
    this.paginationService && (e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationService.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && this.paginationService.setPage(e.page));
  }
  getRowSelectionState() {
    var r;
    const e = this.selectionService.getSelectionState();
    return !e || !Array.isArray(e) && (e.selectAll === !1 || e.selectAllChildren === !1) && !((r = e == null ? void 0 : e.toggledNodes) != null && r.length) ? void 0 : e;
  }
  setRowSelectionState(e) {
    this.selectionService.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const e = this.expansionService.getExpandedRows();
    return e.length ? {
      expandedRowGroupIds: e
    } : void 0;
  }
  setRowGroupExpansionState(e) {
    this.expansionService.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let r = !1;
    Object.entries(t).forEach(([n, i]) => {
      ec(i, this.cachedState[n]) || (r = !0);
    }), this.cachedState = {
      ...this.cachedState,
      ...t
    }, r && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const r = this.cachedState[e];
    this.setCachedStateValue(e, t), ec(t, r) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = {
      ...this.cachedState,
      [e]: t
    };
  }
  refreshStaleState() {
    this.staleStateKeys.forEach((e) => {
      switch (e) {
        case "rowSelection":
          this.setCachedStateValue(e, this.getRowSelectionState());
          break;
      }
    }), this.staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = Array.from(this.queuedUpdateSources);
    this.queuedUpdateSources.clear(), this.eventService.dispatchEvent({
      type: "stateUpdated",
      sources: e,
      state: this.cachedState
    });
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = !0, this.columnAnimationService.setSuppressAnimation(!0), e(), setTimeout(() => {
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
}, qP = {
  version: Te,
  moduleName: "@ag-grid-community/state-core",
  beans: [P$]
}, A$ = {
  version: Te,
  moduleName: "@ag-grid-community/state-api",
  apiFunctions: {
    getState: S$
  },
  dependantModules: [qP]
}, F$ = {
  version: Te,
  moduleName: "@ag-grid-community/state",
  dependantModules: [qP, A$]
};
function M$(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function T$(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getPageSize()) ?? 100;
}
function D$(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getCurrentPage()) ?? 0;
}
function O$(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getTotalPages()) ?? 1;
}
function I$(e) {
  return e.paginationService ? e.paginationService.getMasterRowCount() : e.rowModel.getRowCount();
}
function k$(e) {
  var t;
  (t = e.paginationService) == null || t.goToNextPage();
}
function L$(e) {
  var t;
  (t = e.paginationService) == null || t.goToPreviousPage();
}
function _$(e) {
  var t;
  (t = e.paginationService) == null || t.goToFirstPage();
}
function z$(e) {
  var t;
  (t = e.paginationService) == null || t.goToLastPage();
}
function N$(e, t) {
  var r;
  (r = e.paginationService) == null || r.goToPage(t);
}
var B$ = class extends J {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t
      }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.paginationService.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const r = Math.max(Zo(this.gos), 1), n = Math.floor(e / r);
        this.paginationService.setPageSize(n, "autoCalculated");
      };
      this.isBodyRendered ? Ar(() => t(), 50)() : (t(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
};
function G$(e, t, r) {
  e.addManagedElementListeners(t, {
    keydown: (n) => {
      if (!n.defaultPrevented && n.key === V.TAB) {
        const i = n.shiftKey;
        r.findNextFocusableElement(t, !1, i) || r.focusNextGridCoreContainer(i) && n.preventDefault();
      }
    }
  });
}
var Rl = "paginationPageSizeSelector", H$ = class extends vt {
  constructor() {
    super(
      /* html */
      '<span class="ag-paging-page-size"></span>'
    ), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.paginationService.getPageSize() || (this.paginationService.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.addManagedPropertyListener(Rl, () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.paginationService.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && !e && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp);
  }
  reset() {
    nn(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get(Rl) !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.paginationService.getPageSize(), r = !t || !e.includes(t);
    if (r) {
      const i = this.gos.exists("paginationPageSize"), o = this.gos.get(Rl) !== !0;
      ie(
        `'paginationPageSize=${t}'${i ? "" : " (default value)"}, but ${t} is not included in${o ? "" : " the default"} paginationPageSizeSelector=[${e.join(", ")}].`
      ), o || ie(
        `Either set '${Rl}' to an array that includes ${t} or to 'false' to disable the page size selector.`
      ), e.unshift("");
    }
    const n = String(r ? "" : t);
    this.selectPageSizeComp ? (Co(this.pageSizeOptions, e) || (this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(e)), this.pageSizeOptions = e), this.selectPageSizeComp.setValue(n, !0)) : this.createPageSizeSelectorComp(e, n), this.hasEmptyOption = r;
  }
  createPageSizeSelectOptions(e) {
    return e.map((t) => ({
      value: String(t)
    }));
  }
  createPageSizeSelectorComp(e, t) {
    const r = this.localeService.getLocaleTextFunc(), n = r("pageSizeSelectorLabel", "Page Size:"), i = r("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new U0()).addOptions(this.createPageSizeSelectOptions(e)).setValue(t).setAriaLabel(i).setLabel(n).onValueChange(() => this.handlePageSizeItemSelected()), this.appendChild(this.selectPageSizeComp);
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get(Rl);
    return !Array.isArray(t) || rn(t) ? e : [...t].sort((r, n) => r - n);
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
}, W$ = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: H$
}, V$ = class extends OH {
  constructor() {
    super(), this.btFirst = Fe, this.btPrevious = Fe, this.btNext = Fe, this.btLast = Fe, this.lbRecordCount = Fe, this.lbFirstRowOnPage = Fe, this.lbLastRowOnPage = Fe, this.lbCurrent = Fe, this.lbTotal = Fe, this.pageSizeComp = Fe, this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1, this.allowFocusInnerElement = !1;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.focusService = e.focusService, this.ariaAnnouncementService = e.ariaAnnouncementService;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [W$]);
    const { btFirst: t, btPrevious: r, btNext: n, btLast: i } = this;
    this.activateTabIndex([t, r, n, i]), t.insertAdjacentElement("afterbegin", tn(e ? "last" : "first", this.gos)), r.insertAdjacentElement("afterbegin", tn(e ? "next" : "previous", this.gos)), n.insertAdjacentElement("afterbegin", tn(e ? "previous" : "next", this.gos)), i.insertAdjacentElement("afterbegin", tn(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (o) => {
        this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(o) : this.focusService.focusGridInnerElement(o);
      },
      forceFocusOutWhenTabGuardsAreEmpty: !0
    }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: r } = e;
      this.addManagedListeners(t, {
        click: r,
        keydown: (n) => {
          (n.key === V.ENTER || n.key === V.SPACE) && (n.preventDefault(), r());
        }
      });
    }), G$(this, this.getGui(), this.focusService), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToFirstPage();
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    if (t)
      return t({ value: e });
    const r = this.localeService.getLocaleTextFunc(), n = r("thousandSeparator", ","), i = r("decimalSeparator", ".");
    return MG(e, n, i);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), r = e("to", "to"), n = e("of", "of"), i = e("firstPage", "First Page"), o = e("previousPage", "Previous Page"), s = e("nextPage", "Next Page"), a = e("lastPage", "Last Page"), l = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel">
                    <span id="ag-${l}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${r}</span>
                    <span id="ag-${l}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${n}</span>
                    <span id="ag-${l}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${i}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <span class="ag-paging-description">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${n}</span>
                        <span id="ag-${l}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationService.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationService.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationService.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), r = this.paginationService.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const n = this.isZeroPagesToDisplay(), i = e === r - 1;
    this.nextButtonDisabled = i || n, this.lastButtonDisabled = !t || n || e === r - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    VB(e, t), e.classList.toggle("ag-disabled", t);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages();
    return e && t === 0;
  }
  updateLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages(), r = this.paginationService.getMasterRowCount(), n = e ? r : null;
    if (n === 1) {
      const R = this.rowModel.getRow(0);
      if (R && R.group && !(R.groupData || R.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    const i = this.paginationService.getCurrentPage(), o = this.paginationService.getPageSize();
    let s, a;
    this.isZeroPagesToDisplay() ? s = a = 0 : (s = o * i + 1, a = s + o - 1, e && a > n && (a = n));
    const l = s + o - 1, u = !e && r < l, d = this.formatNumber(s);
    this.lbFirstRowOnPage.textContent = d;
    let h;
    const f = this.localeService.getLocaleTextFunc();
    u ? h = f("pageLastRowUnknown", "?") : h = this.formatNumber(a), this.lbLastRowOnPage.textContent = h;
    const y = t > 0 ? i + 1 : 0, C = this.formatNumber(y);
    this.lbCurrent.textContent = C;
    let v, w;
    if (e)
      v = this.formatNumber(t), w = this.formatNumber(n);
    else {
      const R = f("more", "more");
      v = R, w = R;
    }
    this.lbTotal.textContent = v, this.lbRecordCount.textContent = w, this.announceAriaStatus(d, h, w, C, v);
  }
  announceAriaStatus(e, t, r, n, i) {
    const o = this.localeService.getLocaleTextFunc(), s = o("page", "Page"), a = o("to", "to"), l = o("of", "of"), u = `${e} ${a} ${t} ${l} ${r}`, d = `${s} ${n} ${l} ${i}`;
    u !== this.ariaRowStatus && (this.ariaRowStatus = u, this.ariaAnnouncementService.announceValue(u, "paginationRow")), d !== this.ariaPageStatus && (this.ariaPageStatus = d, this.ariaAnnouncementService.announceValue(d, "paginationPage"));
  }
  setTotalLabelsToZero() {
    const e = this.formatNumber(0);
    this.lbFirstRowOnPage.textContent = e, this.lbCurrent.textContent = e, this.lbLastRowOnPage.textContent = e, this.lbTotal.textContent = e, this.lbRecordCount.textContent = e, this.announceAriaStatus(e, e, e, e, e);
  }
}, $$ = {
  selector: "AG-PAGINATION",
  component: V$
}, j$ = class extends J {
  constructor() {
    super(...arguments), this.beanName = "paginationService", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return $$;
  }
  isPaginateChildRows() {
    return this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren") ? !0 : this.gos.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    !this.active || this.currentPage === e || typeof this.currentPage != "number" || (this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: !0 }));
  }
  isRowPresent(e) {
    return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex;
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return de(this.pageSizeAutoCalculated) && this.gos.get("paginationAutoPageSize") ? this.pageSizeAutoCalculated : de(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : de(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : de(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.pageBoundsService.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0 }));
  }
  setPageSize(e, t) {
    const r = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    r !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0, keepRenderedRows: !0 }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let r = this.pageSize * (this.currentPage + 1) - 1;
    if (r > e && (r = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), r === e)
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const n = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
      this.bottomDisplayedRowIndex = n - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = !1, newPage: r = !1, newPageSize: n = !1 } = e;
    this.eventService.dispatchEvent({
      type: "paginationChanged",
      animate: !1,
      newData: !1,
      newPage: r,
      newPageSize: n,
      keepRenderedRows: t
    });
  }
}, YP = {
  version: Te,
  moduleName: "@ag-grid-community/pagination-core",
  beans: [j$, B$]
}, U$ = {
  version: Te,
  moduleName: "@ag-grid-community/pagination-api",
  dependantModules: [YP],
  apiFunctions: {
    paginationIsLastPageFound: M$,
    paginationGetPageSize: T$,
    paginationGetCurrentPage: D$,
    paginationGetTotalPages: O$,
    paginationGetRowCount: I$,
    paginationGoToNextPage: k$,
    paginationGoToPreviousPage: L$,
    paginationGoToFirstPage: _$,
    paginationGoToLastPage: z$,
    paginationGoToPage: N$
  }
}, K$ = {
  version: Te,
  moduleName: "@ag-grid-community/pagination",
  dependantModules: [YP, U$]
}, zr = "clientSide", Sr = "serverSide", zs = "infinite", q$ = {
  onGroupExpandedOrCollapsed: [zr],
  refreshClientSideRowModel: [zr],
  isRowDataEmpty: [zr],
  forEachLeafNode: [zr],
  forEachNodeAfterFilter: [zr],
  forEachNodeAfterFilterAndSort: [zr],
  resetRowHeights: [zr],
  applyTransaction: [zr],
  applyTransactionAsync: [zr],
  flushAsyncTransactions: [zr],
  getBestCostNodeSelection: [zr],
  getServerSideSelectionState: [Sr],
  setServerSideSelectionState: [Sr],
  applyServerSideTransaction: [Sr],
  applyServerSideTransactionAsync: [Sr],
  applyServerSideRowData: [Sr],
  retryServerSideLoads: [Sr],
  flushServerSideAsyncTransactions: [Sr],
  refreshServerSide: [Sr],
  getServerSideGroupLevelState: [Sr],
  refreshInfiniteCache: [zs],
  purgeInfiniteCache: [zs],
  getInfiniteRowCount: [zs],
  isLastRowIndexKnown: [zs, Sr],
  expandAll: [zr, Sr],
  collapseAll: [zr, Sr],
  onRowHeightChanged: [zr, Sr],
  setRowCount: [zs, Sr],
  getCacheBlockState: [zs, Sr]
}, Y$ = {
  getValue: {
    version: "v31.3",
    new: "getCellValue"
  },
  getFirstDisplayedRow: {
    version: "v31.1",
    new: "getFirstDisplayedRowIndex"
  },
  getLastDisplayedRow: {
    version: "v31.1",
    new: "getLastDisplayedRowIndex"
  },
  getModel: {
    version: "v31.1",
    message: "Please use the appropriate grid API methods instead."
  },
  setColumnVisible: {
    version: "v31.1",
    old: "setColumnVisible(key,visible)",
    new: "setColumnsVisible([key],visible)"
  },
  setColumnPinned: {
    version: "v31.1",
    old: "setColumnPinned(key,pinned)",
    new: "setColumnsPinned([key],pinned)"
  },
  moveColumn: {
    version: "v31.1",
    old: "moveColumn(key, toIndex)",
    new: "moveColumns([key], toIndex)"
  },
  setColumnWidth: {
    version: "v31.1",
    old: "setColumnWidth(col, width)",
    new: "setColumnWidths([{key: col, newWidth: width}])"
  },
  autoSizeColumn: {
    version: "v31.1",
    old: "autoSizeColumn(key, skipHeader)",
    new: "autoSizeColumns([key], skipHeader)"
  },
  addAggFunc: {
    version: "v31.1",
    old: "addAggFunc(key, func)",
    new: "addAggFuncs({ key: func })"
  },
  removeValueColumn: {
    version: "v31.1",
    old: "removeValueColumn(colKey)",
    new: "removeValueColumns([colKey])"
  },
  addValueColumn: {
    version: "v31.1",
    old: "addValueColumn(colKey)",
    new: "addValueColumns([colKey])"
  },
  removeRowGroupColumn: {
    version: "v31.1",
    old: "removeRowGroupColumn(colKey)",
    new: "removeRowGroupColumns([colKey])"
  },
  addRowGroupColumn: {
    version: "v31.1",
    old: "addRowGroupColumn(colKey)",
    new: "addRowGroupColumns([colKey])"
  },
  removePivotColumn: {
    version: "v31.1",
    old: "removePivotColumn(colKey)",
    new: "removePivotColumns([colKey])"
  },
  addPivotColumn: {
    version: "v31.1",
    old: "addPivotColumn(colKey)",
    new: "addPivotColumns([colKey])"
  },
  showColumnMenuAfterButtonClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  showColumnMenuAfterMouseClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  getFilterInstance: {
    version: "v31.1",
    message: "'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously."
  },
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  },
  clearRangeSelection: {
    version: "v32.2",
    message: "Use `clearCellSelection` instead."
  },
  getInfiniteRowCount: {
    version: "v32.2",
    old: "getInfiniteRowCount()",
    new: "getDisplayedRowCount()"
  }
};
function J$(e, t, r) {
  const n = Y$[e];
  if (n) {
    const { version: o, new: s, old: a, message: l } = n, u = a ?? e;
    return (...d) => {
      const h = s ? `Please use ${s} instead. ` : "";
      return ie(`Since ${o} api.${u} is deprecated. ${h}${l ?? ""}`), t.apply(t, d);
    };
  }
  const i = q$[e];
  return i ? (...o) => {
    const s = r.rowModel.getType();
    if (!i.includes(s)) {
      tt(
        `api.${e} can only be called when gridOptions.rowModelType is ${i.join(" or ")}`
      );
      return;
    }
    return t.apply(t, o);
  } : t;
}
var X$ = {
  columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." },
  suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." },
  suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" },
  checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." },
  headerCheckboxSelection: {
    version: "32.2",
    message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
  },
  headerCheckboxSelectionFilteredOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.'
  },
  headerCheckboxSelectionCurrentPageOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.'
  },
  showDisabledCheckboxes: {
    version: "32.2",
    message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
  }
}, Zi = (e, t) => {
  const r = t.rowModelType ?? "clientSide";
  return r === "clientSide" || r === "serverSide" ? {
    module: "@ag-grid-enterprise/row-grouping"
    /* RowGroupingModule */
  } : null;
}, Q$ = {
  // supported on all row models, but need module for client side.
  enableRowGroup: Zi,
  rowGroup: Zi,
  rowGroupIndex: Zi,
  enablePivot: Zi,
  enableValue: Zi,
  pivot: Zi,
  pivotIndex: Zi,
  aggFunc: Zi,
  cellEditor: (e) => e.cellEditor === "agRichSelect" || e.cellEditor === "agRichSelectCellEditor" ? {
    module: "@ag-grid-enterprise/rich-select"
    /* RichSelectModule */
  } : null,
  menuTabs: (e) => {
    var r;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (r = e.menuTabs) != null && r.some((n) => t.includes(n)) ? {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    } : null;
  },
  columnsMenuParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  columnChooserParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  children: () => Hs
}, Z$ = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0
}, e5 = Object.keys(Z$), Hs = {
  objectName: "colDef",
  allProperties: e5,
  docsUrl: "column-properties/",
  deprecations: X$,
  validations: Q$
}, t5 = () => ({
  advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." },
  suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." },
  cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" },
  cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" },
  suppressServerSideInfiniteScroll: { version: "31.1" },
  serverSideSortOnServer: { version: "31.1" },
  serverSideFilterOnServer: { version: "31.1" },
  enableCellChangeFlash: {
    version: "31.2",
    message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns."
  },
  groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." },
  groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." },
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." },
  enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." },
  suppressMultiRangeSelection: {
    version: "32.2",
    message: "Use `cellSelection.suppressMultiRanges` instead."
  },
  suppressClearOnFillReduction: {
    version: "32.2",
    message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
  },
  fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." },
  fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." },
  suppressRowClickSelection: {
    version: "32.2",
    message: "Use `rowSelection.enableClickSelection` instead."
  },
  suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." },
  rowMultiSelectWithClick: {
    version: "32.2",
    message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
  },
  groupSelectsChildren: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "descendants"` instead.'
  },
  groupSelectsFiltered: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.'
  },
  isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." },
  suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." },
  onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." },
  onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." },
  suppressBrowserResizeObserver: {
    version: "32.2",
    message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
  },
  onColumnEverythingChanged: {
    version: "32.2",
    message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
  }
}), r5 = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  enableStrictPivotColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressMoveWhenColumnDragging: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressAsyncEvents: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  enableCellChangeFlash: !1,
  cellFlashDelay: 500,
  cellFlashDuration: 500,
  cellFadeDelay: 1e3,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupIncludeTotalFooter: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  suppressServerSideInfiniteScroll: !1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSideSortOnServer: !1,
  serverSideFilterOnServer: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  suppressGroupMaintainValueType: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0,
  suppressSetFilterByDefault: !1
}, n5 = () => ({
  sideBar: {
    module: "@ag-grid-enterprise/side-bar"
    /* SideBarModule */
  },
  statusBar: {
    module: "@ag-grid-enterprise/status-bar"
    /* StatusBarModule */
  },
  enableCharts: {
    module: "@ag-grid-enterprise/charts"
    /* GridChartsModule */
  },
  getMainMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  getContextMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  allowContextMenuWithControlKey: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  enableAdvancedFilter: {
    module: "@ag-grid-enterprise/advanced-filter"
    /* AdvancedFilterModule */
  },
  treeData: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "@ag-grid-enterprise/row-grouping",
    validate: (e) => {
      const t = e.rowModelType ?? "clientSide";
      switch (t) {
        case "clientSide": {
          const r = `treeData requires 'getDataPath' in the ${t} row model.`;
          return e.getDataPath ? null : r;
        }
        case "serverSide": {
          const r = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${t} row model.`;
          return e.isServerSideGroup && e.getServerSideGroupKey ? null : r;
        }
      }
      return null;
    }
  },
  masterDetail: {
    module: "@ag-grid-enterprise/master-detail"
    /* MasterDetailModule */
  },
  enableRangeSelection: {
    module: "@ag-grid-enterprise/range-selection"
    /* RangeSelectionModule */
  },
  enableRangeHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  enableFillHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  groupDefaultExpanded: {
    supportedRowModels: ["clientSide"]
  },
  groupIncludeFooter: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (e) => {
      switch (e.rowModelType ?? "clientSide") {
        case "clientSide":
          return null;
        case "serverSide":
          return e.suppressServerSideInfiniteScroll ? "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll" : null;
      }
      return null;
    }
  },
  groupHideOpenParents: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: {
      groupTotalRow: [void 0, "bottom"]
    }
  },
  groupIncludeTotalFooter: {
    supportedRowModels: ["clientSide"]
  },
  groupRemoveSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveLowestSingleChildren: [void 0, !1]
    }
  },
  groupRemoveLowestSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveSingleChildren: [void 0, !1]
    }
  },
  groupSelectsChildren: {
    dependencies: {
      rowSelection: ["multiple"]
    }
  },
  viewportDatasource: {
    supportedRowModels: ["viewport"],
    module: "@ag-grid-enterprise/viewport-row-model"
    /* ViewportRowModelModule */
  },
  serverSideDatasource: {
    supportedRowModels: ["serverSide"],
    module: "@ag-grid-enterprise/server-side-row-model"
    /* ServerSideRowModelModule */
  },
  cacheBlockSize: {
    supportedRowModels: ["serverSide", "infinite"]
  },
  datasource: {
    supportedRowModels: ["infinite"],
    module: "@ag-grid-community/infinite-row-model"
    /* InfiniteRowModelModule */
  },
  rowData: {
    supportedRowModels: ["clientSide"],
    module: "@ag-grid-community/client-side-row-model"
    /* ClientSideRowModelModule */
  },
  paginationPageSizeSelector: {
    validate: (e) => {
      const t = e.paginationPageSizeSelector;
      return typeof t == "boolean" || t == null || t.length ? null : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
    }
  },
  rowSelection: {
    validate({ rowSelection: e }) {
      return e && typeof e == "string" ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.' : e && typeof e != "object" ? "Expected `RowSelectionOptions` object for the `rowSelection` property." : null;
    }
  },
  cellSelection: {
    module: "@ag-grid-enterprise/range-selection"
    /* RangeSelectionModule */
  },
  columnDefs: () => Hs,
  defaultColDef: () => Hs,
  defaultColGroupDef: () => Hs,
  autoGroupColumnDef: () => Hs,
  selectionColumnDef: () => Hs
}), i5 = () => ({
  objectName: "gridOptions",
  allProperties: [...nc.ALL_PROPERTIES, ...ic.EVENT_CALLBACKS],
  propertyExceptions: ["api"],
  docsUrl: "grid-options/",
  deprecations: t5(),
  validations: n5()
}), o5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "validationService";
  }
  wireBeans(e) {
    this.beans = e, this.gridOptions = e.gridOptions;
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  processGridOptions(e) {
    this.processOptions(e, i5());
  }
  validateApiFunction(e, t) {
    return J$(e, t, this.beans);
  }
  processOptions(e, t) {
    const { validations: r, deprecations: n, allProperties: i, propertyExceptions: o, objectName: s, docsUrl: a } = t;
    i && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...o ?? [], ...Object.keys(n)],
      i,
      s,
      a
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((d) => {
      const h = n[d];
      if (h)
        if ("renamed" in h) {
          const { renamed: b, version: P } = h;
          l.add(
            `As of v${P}, ${String(d)} is deprecated. Please use ${String(b)} instead.`
          ), e[b] = e[d];
        } else {
          const { message: b, version: P } = h;
          l.add(`As of v${P}, ${String(d)} is deprecated. ${b ?? ""}`);
        }
      const f = e[d];
      if (f == null || f === !1)
        return;
      const p = r[d];
      let y;
      if (p)
        if (typeof p == "function") {
          const b = p(e, this.gridOptions);
          if (!b)
            return;
          if ("objectName" in b) {
            const P = e[d];
            if (Array.isArray(P)) {
              P.forEach((S) => {
                this.processOptions(S, b);
              });
              return;
            }
            this.processOptions(e[d], b);
            return;
          }
          y = b;
        } else
          y = p;
      else return;
      const { module: C, dependencies: v, validate: w, supportedRowModels: R } = y;
      if (R) {
        const b = this.gridOptions.rowModelType ?? "clientSide";
        if (!R.includes(b)) {
          l.add(`${String(d)} is not supported with the '${b}' row model.`);
          return;
        }
      }
      if (C) {
        const b = Array.isArray(C) ? C : [C];
        let P = !0;
        if (b.forEach((S) => {
          this.gos.assertModuleRegistered(S, String(d)) || (P = !1, l.add(`${String(d)} is only available when ${S} is loaded.`));
        }), !P)
          return;
      }
      if (v) {
        const b = this.checkForRequiredDependencies(d, v, e);
        if (b) {
          l.add(b);
          return;
        }
      }
      if (w) {
        const b = w(e, this.gridOptions);
        if (b) {
          l.add(b);
          return;
        }
      }
    }), l.size > 0 && l.forEach((d) => {
      ie(d);
    });
  }
  checkForRequiredDependencies(e, t, r) {
    const i = Object.entries(t).find(([a, l]) => {
      const u = r[a];
      return !l.includes(u);
    });
    if (!i)
      return null;
    const [o, s] = i;
    return s.length > 1 ? `'${String(e)}' requires '${o}' to be one of [${s.join(", ")}].` : `'${String(e)}' requires '${o}' to be ${s[0]}.`;
  }
  checkProperties(e, t, r, n, i) {
    const o = ["__ob__", "__v_skip", "__metadata__"], s = s5(
      Object.getOwnPropertyNames(e),
      [...o, ...t, ...r],
      r
    );
    if (zn(s, (a, l) => {
      let u = `invalid ${n} property '${a}' did you mean any of these: ${l.slice(0, 8).join(", ")}.`;
      r.includes("context") && (u += `
If you are trying to annotate ${n} with application data, use the '${n}.context' property instead.`), ie(u);
    }), Object.keys(s).length > 0 && i) {
      const a = this.getFrameworkOverrides().getDocLink(i);
      ie(`to see all the valid ${n} properties please check: ${a}`);
    }
  }
};
function s5(e, t, r) {
  const n = {}, i = e.filter(
    (o) => !t.some((s) => s === o)
  );
  return i.length > 0 && i.forEach(
    (o) => n[o] = JE({ inputValue: o, allSuggestions: r }).values
  ), n;
}
var a5 = {
  version: Te,
  moduleName: "@ag-grid-community/core"
  /* CommunityCoreModule */
}, l5 = {
  version: Te,
  moduleName: "@ag-grid-community/core-validations",
  beans: [o5]
}, c5 = {
  version: Te,
  moduleName: "@ag-grid-community/core-community-features",
  dependantModules: [
    a5,
    l5,
    wH,
    g4,
    F$,
    eV,
    cW,
    K$,
    b$
  ]
}, u5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "gridDestroyService", this.destroyCalled = !1;
  }
  wireBeans(e) {
    this.beans = e;
  }
  destroy() {
    var e, t;
    this.destroyCalled || (this.eventService.dispatchEvent({
      type: "gridPreDestroyed",
      state: ((e = this.beans.stateService) == null ? void 0 : e.getState()) ?? {}
    }), this.destroyCalled = !0, (t = this.beans.ctrlsService.get("gridCtrl")) == null || t.destroyGridUi(), this.beans.context.destroy(), super.destroy());
  }
  isDestroyCalled() {
    return this.destroyCalled;
  }
}, yd = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), d5 = (e) => e === "checkboxSelected" || e === "rowClicked" || e === "spaceKey" || e === "uiSelectAll" || e === "uiSelectAllCurrentPage" || e === "uiSelectAllFiltered", h5 = new Map([
  ...nc.BOOLEAN_PROPERTIES.map((e) => [e, hm]),
  ...nc.NUMBER_PROPERTIES.map((e) => [e, fP]),
  ["groupAggFiltering", (e) => typeof e == "function" ? e : hm(e)],
  ["pageSize", Yn(1)],
  ["autoSizePadding", Yn(0)],
  ["keepDetailRowsCount", Yn(1)],
  ["rowBuffer", Yn(0)],
  ["infiniteInitialRowCount", Yn(1)],
  ["cacheOverflowSize", Yn(1)],
  ["cacheBlockSize", Yn(1)],
  ["serverSideInitialRowCount", Yn(1)],
  ["viewportRowModelPageSize", Yn(1)],
  ["viewportRowModelBufferSize", Yn(0)]
]);
function JP(e, t) {
  const r = h5.get(e);
  return r ? r(t) : t;
}
function g5(e) {
  const t = {};
  return Object.entries(e).forEach(([r, n]) => {
    const i = JP(r, n);
    t[r] = i;
  }), t;
}
var XP = class QP extends J {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new _a(), this.globalEventHandlerFactory = (t) => (r, n) => {
      if (!this.isAlive())
        return;
      const i = yd.has(r);
      if (i && !t || !i && t)
        return;
      const o = ic.getCallbackForEvent(r), s = this.gridOptions[o];
      typeof s == "function" && this.frameworkOverrides.wrapOutgoing(() => {
        s(n);
      });
    };
  }
  wireBeans(t) {
    this.gridOptions = t.gridOptions, this.eGridDiv = t.eGridDiv, this.validationService = t.validationService, this.environment = t.environment, this.api = t.gridApi, this.gridId = t.context.getGridId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    const t = !this.get("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), t), this.eventService.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: r }) => {
        this.updateGridOptions({ options: r, force: !0, source: "gridOptionsUpdated" });
      }
    });
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(t) {
    return this.gridOptions[t] ?? r5[t];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(t) {
    return this.mergeGridCommonParams(this.gridOptions[t]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(t) {
    return de(this.gridOptions[t]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(t) {
    return t && ((n) => {
      const i = n;
      return i.api = this.api, i.context = this.gridOptionsContext, t(i);
    });
  }
  updateGridOptions({
    options: t,
    force: r,
    source: n = "api"
  }) {
    var s;
    const i = { id: QP.changeSetId++, properties: [] }, o = [];
    Object.entries(t).forEach(([a, l]) => {
      n === "api" && _B[a] && ie(`${a} is an initial property and cannot be updated.`);
      const u = JP(a, l), d = r || typeof u == "object" && n === "api", h = this.gridOptions[a];
      if (d || h !== u) {
        this.gridOptions[a] = u;
        const f = {
          type: a,
          currentValue: u,
          previousValue: h,
          changeSet: i,
          source: n
        };
        o.push(f);
      }
    }), (s = this.validationService) == null || s.processGridOptions(this.gridOptions), i.properties = o.map((a) => a.type), o.forEach((a) => {
      this.gridOptions.debug && Bn(`Updated property ${a.type} from`, a.previousValue, " to ", a.currentValue), this.propertyEventService.dispatchEvent(a);
    });
  }
  addPropertyEventListener(t, r) {
    this.propertyEventService.addEventListener(t, r);
  }
  removePropertyEventListener(t, r) {
    this.propertyEventService.removeEventListener(t, r);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  getGridCommonParams() {
    return {
      api: this.api,
      context: this.gridOptionsContext
    };
  }
  addGridCommonParams(t) {
    const r = t;
    return r.api = this.api, r.context = this.gridOptionsContext, r;
  }
  assertModuleRegistered(t, r) {
    return Cn.__assertRegistered(t, r, this.gridId);
  }
  isModuleRegistered(t) {
    return Cn.__isRegistered(t, this.gridId);
  }
};
XP.changeSetId = 0;
var f5 = XP, p5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "headerPositionUtils";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  findHeader(e, t) {
    let r, n;
    if ($t(e.column) ? r = this.visibleColsService.getGroupAtDirection(e.column, t) : (n = `getCol${t}`, r = this.visibleColsService[n](e.column)), !r)
      return;
    const { headerRowIndex: i } = e;
    if (this.getHeaderRowType(i) !== "filter") {
      const a = [r];
      for (; r.getParent(); )
        r = r.getParent(), a.push(r);
      r = a[a.length - 1 - i];
    }
    const { column: o, headerRowIndex: s } = this.getHeaderIndexToFocus(r, i);
    return {
      column: o,
      headerRowIndex: s
    };
  }
  getHeaderIndexToFocus(e, t) {
    let r;
    if ($t(e) && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
      const n = e;
      r = n.getLeafColumns()[0];
      let i = r;
      for (; i !== n; )
        t++, i = i.getParent();
    }
    return {
      column: r || e,
      headerRowIndex: t
    };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
  }
  getColumnVisibleParent(e, t) {
    const r = this.getHeaderRowType(t), n = r === "filter", i = r === "column";
    let o = n ? e : e.getParent(), s = t - 1, a = s;
    if (i && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; o && o.isPadding(); )
        o = o.getParent(), s--;
      a = s, s < 0 && (o = e, s = t, a = void 0);
    }
    return { column: o, headerRowIndex: s, headerRowIndexWithoutSpan: a };
  }
  getColumnVisibleChild(e, t, r = "After") {
    const n = this.getHeaderRowType(t);
    let i = e, o = t + 1;
    const s = o;
    if (n === "group") {
      const a = e.getDisplayedLeafColumns(), l = r === "After" ? a[0] : Ye(a), u = [];
      let d = l;
      for (; d.getParent() !== e; )
        d = d.getParent(), u.push(d);
      if (i = l, l.isSpanHeaderHeight())
        for (let h = u.length - 1; h >= 0; h--) {
          const f = u[h];
          if (!f.isPadding()) {
            i = f;
            break;
          }
          o++;
        }
      else
        i = Ye(u), i || (i = l);
    }
    return { column: i, headerRowIndex: o, headerRowIndexWithoutSpan: s };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const r = this.visibleColsService.getAllCols(), n = r[t === "start" ? 0 : r.length - 1];
    if (!n)
      return;
    const i = this.ctrlsService.getHeaderRowContainerCtrl(n.getPinned()), o = i == null ? void 0 : i.getRowType(e);
    if (o == "group") {
      const s = this.visibleColsService.getColGroupAtLevel(n, e);
      return {
        headerRowIndex: e,
        column: s
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: o == null ? -1 : e,
      column: n
    };
  }
}, m5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "localeService";
  }
  getLocaleTextFunc() {
    const e = this.gos.getCallback("getLocaleText");
    if (e)
      return (r, n, i) => e({
        key: r,
        defaultValue: n,
        variableValues: i
      });
    const t = this.gos.get("localeText");
    return (r, n, i) => {
      let o = t && t[r];
      if (o && i && i.length) {
        let s = 0;
        for (; !(s >= i.length || o.indexOf("${variable}") === -1); )
          o = o.replace("${variable}", i[s++]);
      }
      return o ?? n;
    };
  }
}, v5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "apiEventService", this.syncEventListeners = /* @__PURE__ */ new Map(), this.asyncEventListeners = /* @__PURE__ */ new Map(), this.syncGlobalEventListeners = /* @__PURE__ */ new Set(), this.globalEventListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.frameworkEventWrappingService = new D0(this.getFrameworkOverrides());
  }
  addEventListener(e, t) {
    const r = this.frameworkEventWrappingService.wrap(t), n = Ed(this.gos) && !yd.has(e), i = n ? this.asyncEventListeners : this.syncEventListeners;
    i.has(e) || i.set(e, /* @__PURE__ */ new Set()), i.get(e).add(r), this.eventService.addEventListener(e, r, n);
  }
  removeEventListener(e, t) {
    var o;
    const r = this.frameworkEventWrappingService.unwrap(t), n = this.asyncEventListeners.get(e), i = !!(n != null && n.delete(r));
    i || (o = this.syncEventListeners.get(e)) == null || o.delete(r), this.eventService.removeEventListener(e, r, i);
  }
  addGlobalListener(e) {
    const t = this.frameworkEventWrappingService.wrapGlobal(e);
    if (Ed(this.gos)) {
      const n = (o, s) => {
        yd.has(o) && t(o, s);
      }, i = (o, s) => {
        yd.has(o) || t(o, s);
      };
      this.globalEventListenerPairs.set(e, { syncListener: n, asyncListener: i }), this.eventService.addGlobalListener(n, !1), this.eventService.addGlobalListener(i, !0);
    } else
      this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, !1);
  }
  removeGlobalListener(e) {
    const t = this.frameworkEventWrappingService.unwrapGlobal(e);
    if (this.globalEventListenerPairs.has(t)) {
      const { syncListener: n, asyncListener: i } = this.globalEventListenerPairs.get(t);
      this.eventService.removeGlobalListener(n, !1), this.eventService.removeGlobalListener(i, !0), this.globalEventListenerPairs.delete(e);
    } else
      this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((r, n) => {
      r.forEach((i) => this.eventService.removeEventListener(n, i, t)), r.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((r) => this.eventService.removeGlobalListener(r, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncEventListeners, !1), this.destroyEventListeners(this.asyncEventListeners, !0), this.destroyGlobalListeners(this.syncGlobalEventListeners, !1), this.globalEventListenerPairs.forEach(({ syncListener: e, asyncListener: t }) => {
      this.eventService.removeGlobalListener(e, !1), this.eventService.removeGlobalListener(t, !0);
    }), this.globalEventListenerPairs.clear();
  }
}, y5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages(), this.eventService.dispatchEvent({
      type: "paginationChanged",
      animate: (e == null ? void 0 : e.animate) ?? !1,
      newData: (e == null ? void 0 : e.newData) ?? !1,
      newPage: (e == null ? void 0 : e.newPage) ?? !1,
      newPageSize: (e == null ? void 0 : e.newPageSize) ?? !1,
      keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? !1
    });
  }
  calculatePages() {
    this.paginationService ? this.paginationService.calculatePages() : this.pageBoundsService.calculateBounds(0, this.rowModel.getRowCount() - 1);
  }
}, C5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsService", this.pixelOffset = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  getFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getCurrentPageHeight() {
    return Ke(this.topRowBounds) || Ke(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  calculateBounds(e, t) {
    this.topRowBounds = this.rowModel.getRowBounds(e), this.topRowBounds && (this.topRowBounds.rowIndex = e), this.bottomRowBounds = this.rowModel.getRowBounds(t), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = t), this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    const e = de(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, w5 = class extends J {
  constructor() {
    super(), this.beanName = "ariaAnnouncementService", this.descriptionContainer = null, this.pendingAnnouncements = /* @__PURE__ */ new Map(), this.updateAnnouncement = Ar(this.updateAnnouncement.bind(this), 200);
  }
  wireBeans(e) {
    this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    const e = zt(this.gos), t = this.descriptionContainer = e.createElement("div");
    t.classList.add("ag-aria-description-container"), OE(t, "polite"), WB(t, "additions text"), HB(t, !0), this.eGridDiv.appendChild(t);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(e, t) {
    this.pendingAnnouncements.set(t, e), this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer)
      return;
    const e = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear(), this.descriptionContainer.textContent = "", setTimeout(() => {
      this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e);
    }, 50);
  }
  destroy() {
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (nn(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null, this.pendingAnnouncements.clear();
  }
}, b5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnAnimationService", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.activeNext = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0, this.activeNext = !0);
  }
  finish() {
    this.active && this.flush(
      () => this.activeNext = !1,
      () => this.active = !1
    );
  }
  executeNextVMTurn(e) {
    this.activeNext ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1);
    });
  }
  flush(e, t) {
    if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
      e(), t();
      return;
    }
    const r = (n) => {
      for (; n.length; ) {
        const i = n.pop();
        i && i();
      }
    };
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e(), r(this.executeNextFuncs);
      }, 0), window.setTimeout(() => {
        t(), r(this.executeLaterFuncs);
      }, 200);
    });
  }
}, S5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "columnHoverService";
  }
  setMouseOver(e) {
    this.updateState(e);
  }
  clearMouseOver() {
    this.updateState(null);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
  updateState(e) {
    this.selectedColumns = e, this.eventService.dispatchEvent({
      type: "columnHoverChanged"
    });
  }
}, x5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "overlayService", this.state = 0, this.showInitialOverlay = !0, this.wrapperPadding = 0;
  }
  wireBeans(e) {
    this.userComponentFactory = e.userComponentFactory, this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.isClientSide = At(this.gos);
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e,
      gridSizeChanged: this.onGridSizeChanged.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = !1, this.updateOverlayVisibility();
      }
    }), this.addManagedPropertyListener("loading", e);
  }
  setOverlayWrapperComp(e) {
    this.overlayWrapperComp = e, this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 && !!this.overlayWrapperComp;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 && !!this.overlayWrapperComp;
  }
  /** Gets the overlay wrapper component */
  getOverlayWrapper() {
    return this.overlayWrapperComp;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos.get("loading");
    !e && (e !== void 0 || this.gos.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1, !(this.gos.get("loading") || this.gos.get("suppressNoRowsOverlay")) && this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    if (this.showInitialOverlay = !1, this.gos.get("loading")) {
      ie(
        "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead."
      );
      return;
    }
    this.doHideOverlay();
  }
  updateOverlayVisibility() {
    if (!this.overlayWrapperComp) {
      this.state = 0;
      return;
    }
    let e = this.gos.get("loading");
    this.showInitialOverlay && e === void 0 && !this.gos.get("suppressLoadingOverlay") && (e = !this.gos.get("columnDefs") || !this.columnModel.isReady() || !this.gos.get("rowData") && this.isClientSide), e ? this.state !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, this.rowModel.isEmpty() && !this.gos.get("suppressNoRowsOverlay") && this.isClientSide ? this.state !== 2 && this.doShowNoRowsOverlay() : this.state !== 0 && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.overlayWrapperComp && (this.state = 1, this.showOverlay(
      this.userComponentFactory.getLoadingOverlayCompDetails({}),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    ), this.updateExclusive());
  }
  doShowNoRowsOverlay() {
    this.overlayWrapperComp && (this.state = 2, this.showOverlay(
      this.userComponentFactory.getNoRowsOverlayCompDetails({}),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    ), this.updateExclusive());
  }
  doHideOverlay() {
    this.overlayWrapperComp && (this.state = 0, this.overlayWrapperComp.hideOverlay(), this.updateExclusive());
  }
  showOverlay(e, t, r) {
    var i;
    const n = e.newAgStackInstance();
    (i = this.overlayWrapperComp) == null || i.showOverlay(n, t, this.isExclusive(), r), this.refreshWrapperPadding();
  }
  updateExclusive() {
    const e = this.exclusive;
    this.exclusive = this.isExclusive(), this.exclusive !== e && this.eventService.dispatchEvent({
      type: "overlayExclusiveChanged"
    });
  }
  onGridSizeChanged() {
    this.refreshWrapperPadding();
  }
  refreshWrapperPadding() {
    if (!this.overlayWrapperComp)
      return;
    let e = 0;
    if (this.state === 2) {
      const t = this.ctrlsService.get("gridHeaderCtrl");
      e = (t == null ? void 0 : t.getHeaderHeight()) || 0;
    } else this.wrapperPadding !== 0 && (e = 0);
    this.wrapperPadding !== e && (this.wrapperPadding = e, this.overlayWrapperComp.updateOverlayWrapperPaddingTop(e));
  }
}, R5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowCssClassCalculator";
  }
  wireBeans(e) {
    this.stylingService = e.stylingService;
  }
  getInitialRowClasses(e) {
    const t = [];
    return de(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), iS(t, this.processClassesFromGridOptions(e.rowNode)), iS(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], r = (o) => {
      typeof o == "string" ? t.push(o) : Array.isArray(o) && o.forEach((s) => t.push(s));
    }, n = this.gos.get("rowClass");
    if (n) {
      if (typeof n == "function")
        return ie("rowClass should not be a function, please use getRowClass instead"), [];
      r(n);
    }
    const i = this.gos.getCallback("getRowClass");
    if (i) {
      const o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      }, s = i(o);
      r(s);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(
      e,
      (r) => {
        t.push(r);
      },
      () => {
      }
    ), t;
  }
  processRowClassRules(e, t, r) {
    const n = this.gos.addGridCommonParams({
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    this.stylingService.processClassRules(
      void 0,
      this.gos.get("rowClassRules"),
      n,
      t,
      r
    );
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
}, E5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeightService", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = ZB(), this.gos.get("debug") && Bn("RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight();
    (t !== this.scrollY || r !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = r, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.gos.get("debug") && Bn(
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), r = e / t;
    return this.maxScrollY * r;
  }
}, P5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  postConstruct() {
    this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = Zn(this.gos), this.addManagedPropertyListener(
      "accentedSort",
      (e) => this.isAccentedSort = e.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = Zn(this.gos)
    );
  }
  doFullSort(e, t) {
    const r = (i, o) => ({ currentPos: o, rowNode: i }), n = e.map(r);
    return n.sort(this.compareRowNodes.bind(this, t)), n.map((i) => i.rowNode);
  }
  compareRowNodes(e, t, r) {
    const n = t.rowNode, i = r.rowNode;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o], l = a.sort === "desc", u = this.getValue(n, a.column), d = this.getValue(i, a.column);
      let h;
      const f = this.getComparator(a, n);
      if (f ? h = f(u, d, n, i, l) : h = YN(u, d, this.isAccentedSort), !isNaN(h) && h !== 0)
        return a.sort === "asc" ? h : h * -1;
    }
    return t.currentPos - r.currentPos;
  }
  getComparator(e, t) {
    const r = e.column, n = r.getColDef().comparator;
    if (n != null)
      return n;
    if (!r.getColDef().showRowGroup)
      return;
    const i = !t.group && r.getColDef().field;
    if (!i)
      return;
    const o = this.columnModel.getColDefCol(i);
    if (o)
      return o.getColDef().comparator;
  }
  getValue(e, t) {
    var n, i, o;
    if (!this.primaryColumnsSortGroups)
      return this.valueService.getValue(t, e, !1, !1);
    if (e.rowGroupColumn === t) {
      if (A0(this.gos, this.columnModel.isPivotActive())) {
        const l = (n = e.allLeafChildren) == null ? void 0 : n[0];
        return l ? this.valueService.getValue(t, l, !1, !1) : void 0;
      }
      const a = (i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCol(t.getId());
      return a ? (o = e.groupData) == null ? void 0 : o[a.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return this.valueService.getValue(t, e, !1, !1);
  }
}, Qh = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  // can be set inactive by:
  // a) ClientSideRowModel, if no transactions or
  // b) PivotService, if secondary columns changed
  setInactive() {
    this.active = !1;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children)
      for (let r = 0; r < e.children.length; r++)
        this.depthFirstSearchChangedPath(e.children[r], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, r) {
    if (e.childrenAfterGroup)
      for (let n = 0; n < e.childrenAfterGroup.length; n++) {
        const i = e.childrenAfterGroup[n];
        i.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[n], t, r) : r && t(i);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, r = !1) {
    this.active && !r ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, r = 0;
    for (; !this.mapToItems[t.id]; ) {
      const n = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = n, r++, t = t.parent;
    }
    return r;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let r = e;
    for (; r; )
      this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach((n) => this.nodeIdsToColumns[r.id][n.getId()] = !0), r = r.parent;
  }
  linkPathItems(e, t) {
    let r = e;
    for (let n = 0; n < t; n++) {
      const i = this.mapToItems[r.id], o = this.mapToItems[r.parent.id];
      o.children || (o.children = []), o.children.push(i), r = r.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const r = this.createPathItems(e);
    this.linkPathItems(e, r), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => r[i.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => !r[i.getId()]);
  }
}, ZP = class extends J {
  constructor() {
    super(...arguments), this.beanName = "selectionService", this.selectedNodes = /* @__PURE__ */ new Map(), this.selectionCtx = new MH(), this.rowSelectionMode = void 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    const { gos: e, rowModel: t, onRowSelected: r } = this;
    this.selectionCtx.init(t), this.rowSelectionMode = Ad(e), this.groupSelectsChildren = ls(e), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      const n = ls(e), i = Ad(e);
      (n !== this.groupSelectsChildren || i !== this.rowSelectionMode) && (this.groupSelectsChildren = n, this.rowSelectionMode = i, this.deselectAllRowNodes({ source: "api" }));
    }), this.addManagedEventListeners({ rowSelected: r.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes(), this.selectionCtx.reset();
  }
  isMultiSelect() {
    return this.rowSelectionMode === "multiRow";
  }
  /**
   * We override the selection value for UI-triggered events because it's the
   * current selection state that should determine the next selection state. This
   * is a stepping stone towards removing selection logic from event listeners and
   * other code external to the selection service(s).
   */
  overrideSelectionValue(e, t) {
    if (!d5(t))
      return e;
    const r = this.selectionCtx.getRoot();
    return r ? r.isSelected() ?? !1 : !0;
  }
  setNodesSelected(e) {
    var h;
    const { newValue: t, clearSelection: r, suppressFinishActions: n, rangeSelect: i, nodes: o, event: s, source: a } = e;
    if (o.length === 0)
      return 0;
    if (o.length > 1 && !this.isMultiSelect())
      return ie("cannot multi select unless selection mode is 'multiRow'"), 0;
    const l = this.groupSelectsChildren && e.groupSelectsFiltered === !0, u = o.map((f) => f.footer ? f.sibling : f);
    if (i) {
      if (u.length > 1)
        return ie("cannot range select while selecting multiple rows"), 0;
      const f = u[0], p = this.overrideSelectionValue(t, a);
      if (this.isMultiSelect()) {
        if (this.selectionCtx.isInRange(f)) {
          const y = this.selectionCtx.truncate(f);
          return p && this.selectRange(y.discard, !1, a), this.selectRange(y.keep, p, a);
        } else if (this.selectionCtx.getRoot() !== f) {
          const v = this.selectionCtx.extend(f, this.groupSelectsChildren);
          return p && this.selectRange(v.discard, !1, a), this.selectRange(v.keep, p, a);
        }
      }
    }
    n || this.selectionCtx.setRoot(u[0]);
    let d = 0;
    for (let f = 0; f < u.length; f++) {
      const p = u[f];
      l && p.group || p.selectThisNode(t, s, a) && d++, this.groupSelectsChildren && ((h = p.childrenAfterGroup) != null && h.length) && (d += this.selectChildren(p, t, l, a));
    }
    return n || (t && (r || !this.isMultiSelect()) && (d += this.clearOtherNodes(u[0], a)), d > 0 && (this.updateGroupsFromChildrenSelections(a), this.dispatchSelectionChanged(a))), d;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, r) {
    let n = 0;
    return e.forEach((i) => {
      if (i.group && this.groupSelectsChildren)
        return;
      i.selectThisNode(t, void 0, r) && n++;
    }), n > 0 && (this.updateGroupsFromChildrenSelections(r), this.dispatchSelectionChanged(r)), n;
  }
  selectChildren(e, t, r, n) {
    const i = r ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return Ke(i) ? 0 : this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      groupSelectsFiltered: r,
      source: n,
      nodes: i
    });
  }
  getSelectedNodes() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && e.push(t);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && t.data && e.push(t.data);
    }), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((r, n) => {
      r && e(r) && t.set(n, r);
    }), this.selectedNodes = t;
  }
  // should only be called if groupSelectsChildren=true
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || !At(this.gos))
      return !1;
    const n = this.rowModel.getRootNode();
    t || (t = new Qh(!0, n), t.setInactive());
    let i = !1;
    return t.forEachChangedNodeDepthFirst((o) => {
      if (o !== n) {
        const s = o.calculateSelectedFromChildren();
        i = o.selectThisNode(s === null ? !1 : s, void 0, e) || i;
      }
    }), i;
  }
  clearOtherNodes(e, t) {
    const r = /* @__PURE__ */ new Map();
    let n = 0;
    return this.selectedNodes.forEach((i) => {
      if (i && i.id !== e.id) {
        const o = this.selectedNodes.get(i.id);
        n += o.setSelectedParams({
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsChildren && i.parent && r.set(i.parent.id, i.parent);
      }
    }), r.forEach((i) => {
      const o = i.calculateSelectedFromChildren();
      i.selectThisNode(o === null ? !1 : o, void 0, t);
    }), n;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    if (de(t) && e.id !== t.id && t) {
      const n = t.id;
      this.selectedNodes.get(n) == e && this.selectedNodes.set(t.id, t);
    }
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(!1);
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    var e;
    (e = this.selectedNodes) == null || e.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    if (!At(this.gos))
      return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null)
      return;
    const r = [];
    function n(i) {
      for (let o = 0, s = i.length; o < s; o++) {
        const a = i[o];
        if (a.isSelected())
          r.push(a);
        else {
          const l = a;
          l.group && l.children && n(l.children);
        }
      }
    }
    return n(t), r;
  }
  isEmpty() {
    let e = 0;
    return this.selectedNodes.forEach((t) => {
      t && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (s) => s.selectThisNode(!1, void 0, n), r = At(this.gos), { source: n, justFiltered: i, justCurrentPage: o } = e;
    if (o || i) {
      if (!r) {
        tt("selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(i, o).forEach(t);
    } else
      this.selectedNodes.forEach((s) => {
        s && t(s);
      }), this.reset(n);
    this.selectionCtx.reset(), r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(n), this.dispatchSelectionChanged(n);
  }
  getSelectedCounts(e, t) {
    let r = 0, n = 0;
    const i = (o) => {
      this.groupSelectsChildren && o.group || (o.isSelected() ? r++ : o.selectable && n++);
    };
    return this.getNodesToSelect(e, t).forEach(i), { selectedCount: r, notSelectedCount: n };
  }
  getSelectAllState(e, t) {
    const { selectedCount: r, notSelectedCount: n } = this.getSelectedCounts(e, t);
    return r === 0 && n === 0 ? !1 : r > 0 && n > 0 ? null : r > 0;
  }
  hasNodesToSelect(e = !1, t = !1) {
    return this.getNodesToSelect(e, t).filter((r) => r.selectable).length > 0;
  }
  /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e = !1, t = !1) {
    this.validateSelectAllType();
    const r = [];
    if (t)
      return this.forEachNodeOnPage((i) => {
        if (!i.group) {
          r.push(i);
          return;
        }
        if (!i.expanded) {
          const o = (s) => {
            var a;
            r.push(s), (a = s.childrenAfterFilter) != null && a.length && s.childrenAfterFilter.forEach(o);
          };
          o(i);
          return;
        }
        this.groupSelectsChildren || r.push(i);
      }), r;
    const n = this.rowModel;
    return e ? (n.forEachNodeAfterFilter((i) => {
      r.push(i);
    }), r) : (n.forEachNode((i) => {
      r.push(i);
    }), r);
  }
  forEachNodeOnPage(e) {
    const t = this.pageBoundsService.getFirstRow(), r = this.pageBoundsService.getLastRow();
    for (let n = t; n <= r; n++) {
      const i = this.rowModel.getRow(n);
      i && e(i);
    }
  }
  selectAllRowNodes(e) {
    if (eB(this.gos) && !CE(this.gos))
      return ie("cannot multi select unless selection mode is 'multiRow'");
    this.validateSelectAllType();
    const { source: t, justFiltered: r, justCurrentPage: n } = e, i = this.getNodesToSelect(r, n);
    i.forEach((o) => o.selectThisNode(!0, void 0, t)), this.selectionCtx.setRoot(i[0] ?? null), this.selectionCtx.setEndRange(Ye(i) ?? null), At(this.gos) && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t), this.dispatchSelectionChanged(t);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t != null && t.id && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e))
      return tt(
        "Invalid selection state. When using client-side row model, the state must conform to `string[]`."
      );
    const r = new Set(e), n = [];
    this.rowModel.forEachNode((i) => {
      r.has(i.id) && n.push(i);
    }), this.setNodesSelected({
      newValue: !0,
      nodes: n,
      source: t
    });
  }
  dispatchSelectionChanged(e) {
    this.eventService.dispatchEvent({
      type: "selectionChanged",
      source: e
    });
  }
  validateSelectAllType() {
    if (!At(this.gos))
      throw new Error(
        `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`
      );
  }
}, A5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "selectableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => this.updateSelectable());
  }
  /**
   * Used by CSRM only, to update selectable state after group state changes.
   */
  updateSelectableAfterGrouping() {
    this.updateSelectable(!0);
  }
  updateSelectable(e = !1) {
    const { gos: t } = this, r = Rd(t), n = F0(t);
    if (!r || !n)
      return;
    const i = ls(t), o = At(t) && i, s = [], a = (l) => {
      if (e && !l.group)
        return;
      if (o && l.group) {
        const d = l.childrenAfterGroup.some((h) => h.selectable === !0);
        l.setRowSelectable(d, !0);
        return;
      }
      const u = (n == null ? void 0 : n(l)) ?? !0;
      l.setRowSelectable(u, !0), !u && l.isSelected() && s.push(l);
    };
    if (o) {
      const l = this.rowModel;
      new Qh(!1, l.getRootNode()).forEachChangedNodeDepthFirst(a, !0, !0);
    } else
      this.rowModel.forEachNode(a);
    s.length && this.selectionService.setNodesSelected({
      nodes: s,
      newValue: !1,
      source: "selectableChanged"
    }), o && this.selectionService instanceof ZP && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
  }
}, FS = ["asc", "desc", null], F5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "sortController";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  progressSort(e, t, r) {
    const n = this.getNextSortDirection(e);
    this.setSortForColumn(e, n, t, r);
  }
  setSortForColumn(e, t, r, n) {
    t !== "asc" && t !== "desc" && (t = null);
    const i = Zn(this.gos);
    let o = [e];
    if (i && e.getColDef().showRowGroup) {
      const l = this.funcColsService.getSourceColumnsForGroupColumn(e), u = l == null ? void 0 : l.filter((d) => d.isSortable());
      u && (o = [e, ...u]);
    }
    o.forEach((l) => l.setSort(t, n));
    const s = (r || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"), a = [];
    if (!s) {
      const l = this.clearSortBarTheseColumns(o, n);
      a.push(...l);
    }
    this.updateSortIndex(e), a.push(...o), this.dispatchSortChangedEvents(n, a);
  }
  updateSortIndex(e) {
    var a;
    const t = Zn(this.gos), r = (a = this.showRowGroupColsService) == null ? void 0 : a.getShowRowGroupCol(e.getId()), n = t && r || e, i = this.getColumnsWithSortingOrdered();
    this.columnModel.getAllCols().forEach((l) => l.setSortIndex(null));
    const o = i.filter((l) => t && l.getColDef().showRowGroup ? !1 : l !== n);
    (n.getSort() ? [...o, n] : o).forEach((l, u) => {
      l.setSortIndex(u);
    });
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.columnModel.getAllCols().filter((r) => !!r.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const r = {
      type: "sortChanged",
      source: e
    };
    t && (r.columns = t), this.eventService.dispatchEvent(r);
  }
  clearSortBarTheseColumns(e, t) {
    const r = [];
    return this.columnModel.getAllCols().forEach((n) => {
      e.includes(n) || (n.getSort() && r.push(n), n.setSort(void 0, t));
    }), r;
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? t = this.gos.get("sortingOrder") : t = FS, !Array.isArray(t) || t.length <= 0)
      return ie(`sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const r = t.indexOf(e.getSort()), n = r < 0, i = r == t.length - 1;
    let o;
    return n || i ? o = t[0] : o = t[r + 1], FS.indexOf(o) < 0 ? (ie("invalid sort type ", o), null) : o;
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    let e = this.columnModel.getAllCols().filter((o) => !!o.getSort());
    if (this.columnModel.isPivotMode()) {
      const o = Zn(this.gos);
      e = e.filter((s) => {
        var d;
        const a = !!s.getAggFunc(), l = !s.isPrimary(), u = o ? (d = this.showRowGroupColsService) == null ? void 0 : d.getShowRowGroupCol(s.getId()) : s.getColDef().showRowGroup;
        return a || l || u;
      });
    }
    const t = this.funcColsService.getRowGroupColumns().filter((o) => !!o.getSort()), r = {};
    e.forEach((o, s) => r[o.getId()] = s), e.sort((o, s) => {
      const a = o.getSortIndex(), l = s.getSortIndex();
      if (a != null && l != null)
        return a - l;
      if (a == null && l == null) {
        const u = r[o.getId()], d = r[s.getId()];
        return u > d ? 1 : -1;
      } else return l == null ? -1 : 1;
    });
    const n = Zn(this.gos) && !!t.length;
    n && (e = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        e.map((o) => {
          var s;
          return ((s = this.showRowGroupColsService) == null ? void 0 : s.getShowRowGroupCol(o.getId())) ?? o;
        })
      )
    ]);
    const i = /* @__PURE__ */ new Map();
    return e.forEach((o, s) => i.set(o, s)), n && t.forEach((o) => {
      const s = this.showRowGroupColsService.getShowRowGroupCol(o.getId());
      i.set(o, i.get(s));
    }), i;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [r, n]) => t - n).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = Zn(this.gos), r = !!e.getColDef().showRowGroup;
    return t && r;
  }
  getDisplaySortForColumn(e) {
    const t = this.funcColsService.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const n = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, i = n[0].getSort();
    return n.every((s) => s.getSort() == i) ? i : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
}, M5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "syncService", this.waitingForColumns = !1;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.ctrlsService.whenReady(this, () => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    this.columnModel.setColumnDefs(e ?? [], "gridInitializing"), this.rowModel.start();
  }
  gridReady() {
    this.eventService.dispatchEvent({
      type: "gridReady"
    });
    const e = this.gos.isModuleRegistered(
      "@ag-grid-enterprise/core"
      /* EnterpriseCoreModule */
    );
    this.gos.get("debug") && Bn(`initialised successfully, enterprise = ${e}`);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.columnModel.setColumnDefs(t, Wo(e.source));
    }
  }
}, T5 = "paste", D5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    At(this.gos) && (this.clientSideRowModel = this.rowModel), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    e.source !== T5 && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gos.get("suppressChangeDetection"))
      return;
    const r = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const n = this.gos.get("aggregateOnlyChangedColumns"), i = new Qh(n, this.clientSideRowModel.getRootNode());
      i.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(i), i.forEachChangedNodeDepthFirst((o) => {
        r.push(o);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: r });
  }
}, O5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "expressionService", this.expressionToFunctionCache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    tt("value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (r) {
      return Bn("Processing of the expression failed"), Bn("Expression = ", e), Bn("Params = ", t), Bn("Exception = ", r), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e])
      return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), r = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      t
    );
    return this.expressionToFunctionCache[e] = r, r;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, I5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, r) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = r);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
}, k5 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "valueService", this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.columnModel = e.columnModel, this.valueCache = e.valueCache, this.dataTypeService = e.dataTypeService;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.isSsrm = yo(this.gos), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (r) => this.callColumnCellValueChangedHandler(r), t = Ed(this.gos);
    this.eventService.addEventListener("cellValueChanged", e, t), this.addDestroyFunc(() => this.eventService.removeEventListener("cellValueChanged", e, t)), this.addManagedPropertyListener("treeData", (r) => this.isTreeData = r.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * This hides values in expanded group rows which are instead displayed by the footer row.
   */
  getValueForDisplay(e, t) {
    const r = t.leafGroup && this.columnModel.isPivotMode(), n = t.group && t.expanded && !t.footer && !r, i = this.gos.get("groupSuppressBlankHeader");
    if (!n || i)
      return this.getValue(e, t);
    let o = !1;
    const s = this.gos.get("groupTotalRow") ?? this.gos.get("groupIncludeFooter");
    typeof s != "function" ? o = !!s : o = !!(this.gos.getCallback("groupTotalRow") ?? this.gos.getCallback("groupIncludeFooter"))({ node: this });
    const a = n && o;
    return this.getValue(e, t, !1, a);
  }
  getValue(e, t, r = !1, n = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const i = e.getColDef(), o = i.field, s = e.getColId(), a = t.data;
    let l;
    const u = t.groupData && t.groupData[s] !== void 0, d = !n && t.aggData && t.aggData[s] !== void 0, h = this.isSsrm && n && !!e.getColDef().aggFunc, f = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (r && i.filterValueGetter ? l = this.executeFilterValueGetter(i.filterValueGetter, a, e, t) : this.isTreeData && d ? l = t.aggData[s] : this.isTreeData && i.valueGetter ? l = this.executeValueGetter(i.valueGetter, a, e, t) : this.isTreeData && o && a ? l = Wl(a, o, e.isFieldContainsDots()) : u ? l = t.groupData[s] : d ? l = t.aggData[s] : i.valueGetter ? l = this.executeValueGetter(i.valueGetter, a, e, t) : f ? l = Wl(a, t.field, e.isFieldContainsDots()) : o && a && !h && (l = Wl(a, o, e.isFieldContainsDots())), this.cellExpressions && typeof l == "string" && l.indexOf("=") === 0) {
      const p = l.substring(1);
      l = this.executeValueGetter(p, a, e, t);
    }
    if (l == null) {
      const p = this.getOpenedGroup(t, e);
      if (p != null)
        return p;
    }
    return l;
  }
  parseValue(e, t, r, n) {
    const i = e.getColDef(), o = i.valueParser;
    if (de(o)) {
      const s = this.gos.addGridCommonParams({
        node: t,
        data: t == null ? void 0 : t.data,
        oldValue: n,
        newValue: r,
        colDef: i,
        column: e
      });
      return typeof o == "function" ? o(s) : this.expressionService.evaluate(o, s);
    }
    return r;
  }
  getDeleteValue(e, t) {
    return de(e.getColDef().valueParser) ? this.parseValue(e, t, "", this.getValueForDisplay(e, t)) ?? null : null;
  }
  formatValue(e, t, r, n, i = !0) {
    let o = null, s;
    const a = e.getColDef();
    if (n ? s = n : i && (s = a.valueFormatter), s) {
      const l = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t ? t.data : null,
        colDef: a,
        column: e
      });
      typeof s == "function" ? o = s(l) : o = this.expressionService.evaluate(s, l);
    } else if (a.refData)
      return a.refData[r] || "";
    return o == null && Array.isArray(r) && (o = r.join(", ")), o;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const n = t.getColDef().showRowGroup;
    let i = e.parent;
    for (; i != null; ) {
      if (i.rowGroupColumn && (n === !0 || n === i.rowGroupColumn.getColId()))
        return i.key;
      i = i.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, r, n) {
    const i = this.columnModel.getColDefCol(t);
    if (!e || !i)
      return !1;
    Ke(e.data) && (e.data = {});
    const { field: o, valueSetter: s } = i.getColDef();
    if (Ke(o) && Ke(s))
      return ie("you need either field or valueSetter set on colDef for editing to work"), !1;
    if (this.dataTypeService && !this.dataTypeService.checkType(i, r))
      return ie("Data type of the new value does not match the cell data type of the column"), !1;
    const a = this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      oldValue: this.getValue(i, e),
      newValue: r,
      colDef: i.getColDef(),
      column: i
    });
    a.newValue = r;
    let l;
    if (de(s) ? typeof s == "function" ? l = s(a) : l = this.expressionService.evaluate(s, a) : l = this.setValueUsingField(e.data, o, r, i.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged();
    const u = this.getValue(i, e);
    return this.eventService.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: a.column,
      colDef: a.colDef,
      data: e.data,
      node: e,
      oldValue: a.oldValue,
      newValue: u,
      value: u,
      source: n
    }), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.getFrameworkOverrides().wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, r, n) {
    if (!t)
      return !1;
    let i = !1;
    if (!n)
      i = e[t] === r, i || (e[t] = r);
    else {
      const o = t.split(".");
      let s = e;
      for (; o.length > 0 && s; ) {
        const a = o.shift();
        o.length === 0 ? (i = s[a] === r, i || (s[a] = r)) : s = s[a];
      }
    }
    return !i;
  }
  executeFilterValueGetter(e, t, r, n) {
    const i = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    return typeof e == "function" ? e(i) : this.expressionService.evaluate(e, i);
  }
  executeValueGetter(e, t, r, n) {
    const i = r.getColId(), o = this.valueCache.getValue(n, i);
    if (o !== void 0)
      return o;
    const s = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    let a;
    return typeof e == "function" ? a = e(s) : a = this.expressionService.evaluate(e, s), this.valueCache.setValue(n, i, a), a;
  }
  getValueCallback(e, t) {
    const r = this.columnModel.getColDefCol(t);
    return r ? this.getValue(r, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const r = this.getValue(e, t), n = e.getColDef().keyCreator;
    let i = r;
    if (n) {
      const o = this.gos.addGridCommonParams({
        value: r,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      i = n(o);
    }
    return typeof i == "string" || i == null || (i = String(i), i === "[object Object]" && ie(
      "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key"
    )), i;
  }
}, ny = class No {
  static applyGlobalGridOptions(t) {
    if (!No.gridOptions)
      return t;
    let r = {};
    return Pr(r, No.gridOptions, !0, !0), No.mergeStrategy === "deep" ? Pr(r, t, !0, !0) : r = { ...r, ...t }, No.gridOptions.context && (r.context = No.gridOptions.context), t.context && (No.mergeStrategy === "deep" && r.context && Pr(t.context, r.context, !0, !0), r.context = t.context), r;
  }
};
ny.gridOptions = void 0;
ny.mergeStrategy = "shallow";
var eA = ny;
function L5(e) {
  var t;
  return (t = eA.gridOptions) == null ? void 0 : t[e];
}
var _5 = 1, z5 = class {
  create(e, t, r, n, i) {
    const o = eA.applyGlobalGridOptions(t), s = g5(o), a = s.gridId ?? String(_5++), l = this.getRegisteredModules(i, a), u = this.createBeansList(s.rowModelType, l, a), d = this.createProvidedBeans(e, s, i);
    if (!u) {
      tt("Failed to create grid.");
      return;
    }
    const h = {
      providedBeanInstances: d,
      beanClasses: u,
      gridId: a,
      beanInitComparator: YH,
      beanDestroyComparator: JH,
      derivedBeans: [GH]
    }, f = new Z8(h);
    return this.registerModuleUserComponents(f, l), this.registerControllers(f, l), this.registerModuleApiFunctions(f, l), r(f), f.getBean("syncService").start(), n && n(f), f.getBean("gridApi");
  }
  registerControllers(e, t) {
    const r = e.getBean("ctrlsFactory");
    t.forEach((n) => {
      n.controllers && n.controllers.forEach((i) => r.register(i));
    });
  }
  getRegisteredModules(e, t) {
    const r = e ? e.modules : null, n = Cn.__getRegisteredModules(t), i = [], o = {}, s = (a, l, u) => {
      ((h) => {
        o[h.moduleName] || (o[h.moduleName] = !0, i.push(h), Cn.__register(h, a, u));
      })(l), l.dependantModules && l.dependantModules.forEach((h) => s(a, h, u));
    };
    return s(
      !!(r != null && r.length) || !Cn.__isPackageBased(),
      c5,
      void 0
    ), r && r.forEach((a) => s(!0, a, t)), n && n.forEach((a) => s(!Cn.__isPackageBased(), a, void 0)), i;
  }
  registerModuleUserComponents(e, t) {
    const r = this.extractModuleEntity(
      t,
      (i) => i.userComponents ? i.userComponents : []
    ), n = e.getBean("userComponentRegistry");
    r.forEach(({ name: i, classImp: o, params: s }) => {
      n.registerDefaultComponent(i, o, s);
    });
  }
  registerModuleApiFunctions(e, t) {
    const r = e.getBean("apiFunctionService");
    t.forEach((n) => {
      const i = n.apiFunctions;
      i && Object.keys(i).forEach((s) => {
        r == null || r.addFunction(s, i[s]);
      });
    });
  }
  createProvidedBeans(e, t, r) {
    let n = r ? r.frameworkOverrides : null;
    Ke(n) && (n = new WP());
    const i = {
      gridOptions: t,
      eGridDiv: e,
      globalEventListener: r ? r.globalEventListener : null,
      globalSyncEventListener: r ? r.globalSyncEventListener : null,
      frameworkOverrides: n
    };
    return r && r.providedBeanInstances && Object.assign(i, r.providedBeanInstances), i;
  }
  createBeansList(e = "clientSide", t, r) {
    const n = t.filter(
      (l) => !l.rowModel || l.rowModel === e
    ), i = {
      clientSide: "@ag-grid-community/client-side-row-model",
      infinite: "@ag-grid-community/infinite-row-model",
      serverSide: "@ag-grid-enterprise/server-side-row-model",
      viewport: "@ag-grid-enterprise/viewport-row-model"
      /* ViewportRowModelModule */
    };
    if (!i[e]) {
      tt("Could not find row model for rowModelType = ", e);
      return;
    }
    if (!Cn.__assertRegistered(
      i[e],
      `rowModelType = '${e}'`,
      r
    ))
      return;
    const o = [
      tW,
      ZH,
      p5,
      u5,
      BH,
      I8,
      UH,
      KH,
      k6,
      XE,
      E5,
      O6,
      m5,
      EH,
      nG,
      IB,
      iW,
      f5,
      LH,
      ZP,
      bB,
      f4,
      C5,
      y5,
      xH,
      O5,
      wB,
      D6,
      I5,
      k5,
      bH,
      I6,
      eG,
      oW,
      T6,
      rW,
      zH,
      TH,
      M6,
      F5,
      S5,
      b5,
      A5,
      D5,
      L6,
      HH,
      R5,
      P5,
      QH,
      sW,
      eW,
      XH,
      M5,
      x5,
      _6,
      v5,
      w5,
      z6,
      RB,
      WH,
      EB,
      SB,
      VH,
      $H,
      DB,
      xB,
      MB,
      jH,
      TB,
      pB
    ], s = this.extractModuleEntity(n, (l) => l.beans ? l.beans : []);
    o.push(...s);
    const a = [];
    return o.forEach((l) => {
      a.indexOf(l) < 0 && a.push(l);
    }), a;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
}, tA = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowModelHelperService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    const e = this.rowModel;
    switch (e.getType()) {
      case "clientSide":
        this.clientSideRowModel = e;
        break;
      case "infinite":
        this.infiniteRowModel = e;
        break;
      case "serverSide":
        this.serverSideRowModel = e;
        break;
    }
  }
  getClientSideRowModel() {
    return this.clientSideRowModel;
  }
  getInfiniteRowModel() {
    return this.infiniteRowModel;
  }
  getServerSideRowModel() {
    return this.serverSideRowModel;
  }
};
function N5(e) {
  e.expansionService.expandAll(!0);
}
function B5(e) {
  e.expansionService.expandAll(!1);
}
function G5(e) {
  var n, i;
  const t = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel(), r = (i = e.rowModelHelperService) == null ? void 0 : i.getServerSideRowModel();
  t ? t.onRowHeightChanged() : r && r.onRowHeightChanged();
}
function H5(e, t, r) {
  var o, s;
  const n = (o = e.rowModelHelperService) == null ? void 0 : o.getServerSideRowModel();
  if (n) {
    if (e.funcColsService.isRowGroupEmpty()) {
      n.setRowCount(t, r);
      return;
    }
    tt("setRowCount cannot be used while using row grouping.");
    return;
  }
  const i = (s = e.rowModelHelperService) == null ? void 0 : s.getInfiniteRowModel();
  if (i) {
    i.setRowCount(t, r);
    return;
  }
}
function W5(e) {
  var t;
  return ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {};
}
function V5(e) {
  return e.rowModel.isLastRowIndexKnown();
}
var $5 = {
  version: Te,
  moduleName: "@ag-grid-community/csrm-ssrm-shared-api",
  apiFunctions: {
    expandAll: N5,
    collapseAll: B5,
    onRowHeightChanged: G5
  }
}, j5 = {
  version: Te,
  moduleName: "@ag-grid-community/ssrm-infinite-shared-api",
  apiFunctions: {
    setRowCount: H5,
    getCacheBlockState: W5,
    isLastRowIndexKnown: V5
  }
}, U5 = class {
  wrap(e, t, r = [], n) {
    const i = this.createWrapper(e, n);
    return t.forEach((o) => {
      this.createMethod(i, o, !0);
    }), r.forEach((o) => {
      this.createMethod(i, o, !1);
    }), i;
  }
  createMethod(e, t, r) {
    e.addMethod(t, this.createMethodProxy(e, t, r));
  }
  createMethodProxy(e, t, r) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (r && ie("Framework component is missing the method " + t + "()"), null);
    };
  }
}, Ha = typeof global > "u" ? {} : global;
Ha.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Ha.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Ha.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Ha.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Ha.Node = typeof Node > "u" ? {} : Node;
Ha.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var mr = O.createContext({}), Kc = (e, t, r, n) => {
  if (!e || e.componentFromFramework || t.isDestroyed())
    return;
  const o = e.newAgStackInstance();
  if (o == null)
    return;
  let s, a, l = !1;
  return o.then((u) => {
    if (l) {
      t.destroyBean(u);
      return;
    }
    s = u, a = s.getGui(), r.appendChild(a), MS(n, s);
  }), () => {
    var u;
    l = !0, s && ((u = a == null ? void 0 : a.parentElement) == null || u.removeChild(a), t.destroyBean(s), n && MS(n, void 0));
  };
}, MS = (e, t) => {
  if (e)
    if (e instanceof Function)
      e(t);
    else {
      const r = e;
      r.current = t;
    }
}, In = (...e) => e.filter((r) => r != null && r !== "").join(" "), wn = class rA {
  constructor(...t) {
    this.classesMap = {}, t.forEach((r) => {
      this.classesMap[r] = !0;
    });
  }
  setClass(t, r) {
    if (!!this.classesMap[t] == r)
      return this;
    const i = new rA();
    return i.classesMap = { ...this.classesMap }, i.classesMap[t] = r, i;
  }
  toString() {
    return Object.keys(this.classesMap).filter((r) => this.classesMap[r]).join(" ");
  }
}, Wa = (e) => {
  const t = () => typeof Symbol == "function" && Symbol.for, r = () => t() ? Symbol.for("react.memo") : 60115;
  return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === r();
}, nE, Dm = (nE = O.version) == null ? void 0 : nE.split(".")[0], K5 = Dm === "16" || Dm === "17";
function q5() {
  return Dm === "19";
}
var Cd = !1;
function Y5(e) {
  return Cd || setTimeout(() => Cd = !1, 0), Cd = !0, e();
}
var iy = (e, t) => {
  !K5 && e && !Cd ? CN.flushSync(t) : t();
};
function oy(e, t, r) {
  if (t == null || e == null)
    return t;
  if (e === t || t.length === 0 && e.length === 0)
    return e;
  if (r || e.length === 0 && t.length > 0 || e.length > 0 && t.length === 0)
    return t;
  const n = [], i = [], o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  for (let a = 0; a < t.length; a++) {
    const l = t[a];
    s.set(l.instanceId, l);
  }
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    o.set(l.instanceId, l), s.has(l.instanceId) && n.push(l);
  }
  for (let a = 0; a < t.length; a++) {
    const l = t[a], u = l.instanceId;
    o.has(u) || i.push(l);
  }
  return n.length === e.length && i.length === 0 ? e : n.length === 0 && i.length === t.length ? t : n.length === 0 ? i : i.length === 0 ? n : [...n, ...i];
}
var nA = Vh((e, t) => {
  var Z;
  const { ctrlsFactory: r, context: n } = Wt(mr), i = ge(null), o = ge(null), s = ge(null), a = ge(null), l = ge(null), u = ge(), [d, h] = pe(), [f, p] = pe(), [y, C] = pe(), [v, w] = pe(() => new wn()), [R, b] = pe(() => new wn("ag-hidden")), [P, S] = pe(() => new wn("ag-hidden")), [E, A] = pe(() => new wn("ag-invisible"));
  S0(t, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), ao(() => Kc(d, n, o.current), [d]);
  const M = Qe((te) => {
    if (i.current = te, !te) {
      u.current = n.destroyBean(u.current);
      return;
    }
    const se = {
      setInnerRenderer: (U, X) => {
        h(U), C(X);
      },
      setChildCount: (U) => p(U),
      addOrRemoveCssClass: (U, X) => w((he) => he.setClass(U, X)),
      setContractedDisplayed: (U) => S((X) => X.setClass("ag-hidden", !U)),
      setExpandedDisplayed: (U) => b((X) => X.setClass("ag-hidden", !U)),
      setCheckboxVisible: (U) => A((X) => X.setClass("ag-invisible", !U))
    }, W = r.getInstance("groupCellRendererCtrl");
    W && (u.current = n.createBean(W), u.current.init(
      se,
      te,
      s.current,
      a.current,
      l.current,
      nA,
      e
    ));
  }, []), I = Se(() => `ag-cell-wrapper ${v.toString()}`, [v]), z = Se(() => `ag-group-expanded ${R.toString()}`, [R]), k = Se(
    () => `ag-group-contracted ${P.toString()}`,
    [P]
  ), _ = Se(() => `ag-group-checkbox ${E.toString()}`, [E]), q = d && d.componentFromFramework, j = q ? d.componentClass : void 0, Q = d == null && y != null, K = ni(y, !0);
  return /* @__PURE__ */ O.createElement(
    "span",
    {
      className: I,
      ref: M,
      ...e.colDef ? {} : { role: (Z = u.current) == null ? void 0 : Z.getCellAriaRole() }
    },
    /* @__PURE__ */ O.createElement("span", { className: z, ref: a }),
    /* @__PURE__ */ O.createElement("span", { className: k, ref: l }),
    /* @__PURE__ */ O.createElement("span", { className: _, ref: s }),
    /* @__PURE__ */ O.createElement("span", { className: "ag-group-value", ref: o }, Q && /* @__PURE__ */ O.createElement(O.Fragment, null, K), q && /* @__PURE__ */ O.createElement(j, { ...d.params })),
    /* @__PURE__ */ O.createElement("span", { className: "ag-group-child-count" }, f)
  );
}), TS = nA, sy = mo({
  setMethods: () => {
  }
}), J5 = (e) => {
  const { initialProps: t, addUpdateCallback: r, CustomComponentClass: n, setMethods: i } = e, [{ key: o, ...s }, a] = pe(t);
  return pr(() => {
    r((l) => a(l));
  }, []), /* @__PURE__ */ O.createElement(sy.Provider, { value: { setMethods: i } }, /* @__PURE__ */ O.createElement(n, { key: o, ...s }));
}, X5 = Tr(J5), Q5 = 0;
function DS() {
  return `agPortalKey_${++Q5}`;
}
var iA = class {
  constructor(e, t, r, n) {
    this.portal = null, this.oldPortal = null, this.reactComponent = e, this.portalManager = t, this.componentType = r, this.suppressFallbackMethods = !!n, this.statelessComponent = this.isStateless(this.reactComponent), this.key = DS(), this.portalKey = DS(), this.instanceCreated = this.isStatelessComponent() ? _t.resolve(!1) : new _t((i) => {
      this.resolveInstanceCreated = i;
    });
  }
  getGui() {
    return this.eParentElement;
  }
  /** `getGui()` returns the parent element. This returns the actual root element. */
  getRootElement() {
    return this.eParentElement.firstChild;
  }
  destroy() {
    this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy();
    const e = this.portal;
    e && this.portalManager.destroyPortal(e);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), r = document.createElement(t || "div");
    return r.classList.add("ag-react-container"), e.reactContainer = r, r;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && (ie(
      'Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle())), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && (ie(
      'Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t))));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] != null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const r = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!r) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const n = r[e];
    if (n)
      return n.apply(r, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.createOrUpdatePortal(e), new _t((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (this.ref = (t) => {
      var r;
      this.componentInstance = t, this.addParentContainerStyleAndClasses(), (r = this.resolveInstanceCreated) == null || r.call(this, !0), this.resolveInstanceCreated = void 0;
    }, e.ref = this.ref), this.reactElement = this.createElement(this.reactComponent, { ...e, key: this.key }), this.portal = $h(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createElement(e, t) {
    return x0(e, t);
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, e);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  /*
   * fallback methods - these will be invoked if a corresponding instance method is not present
   * for example if refresh is called and is not available on the component instance, then refreshComponent on this
   * class will be invoked instead
   *
   * Currently only refresh is supported
   */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const r = this[`${e}Component`];
    if (!this.suppressFallbackMethods && r)
      return r.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? !1 : !!this[`${e}Component`];
  }
};
function ay(e, t, r) {
  e.forEach((n) => {
    const i = t[n];
    i && (r[n] = i);
  });
}
var hi = class extends iA {
  constructor() {
    super(...arguments), this.awaitUpdateCallback = new _t((e) => {
      this.resolveUpdateCallback = e;
    }), this.wrapperComponent = X5;
  }
  init(e) {
    return this.sourceParams = e, super.init(this.getProps());
  }
  addMethod() {
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  getFrameworkComponentInstance() {
    return this;
  }
  createElement(e, t) {
    return super.createElement(this.wrapperComponent, {
      initialProps: t,
      CustomComponentClass: e,
      setMethods: (r) => this.setMethods(r),
      addUpdateCallback: (r) => {
        this.updateCallback = () => (r(this.getProps()), new _t((n) => {
          setTimeout(() => {
            n();
          });
        })), this.resolveUpdateCallback();
      }
    });
  }
  setMethods(e) {
    this.providedMethods = e, ay(this.getOptionalMethods(), this.providedMethods, this);
  }
  getOptionalMethods() {
    return [];
  }
  getProps() {
    return {
      ...this.sourceParams,
      key: this.key,
      ref: this.ref
    };
  }
  refreshProps() {
    return this.updateCallback ? this.updateCallback() : new _t(
      (e) => this.awaitUpdateCallback.then(() => {
        this.updateCallback().then(() => e());
      })
    );
  }
}, Z5 = class extends hi {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, ej = class extends hi {
  constructor() {
    super(...arguments), this.date = null, this.onDateChange = (e) => this.updateDate(e);
  }
  getDate() {
    return this.date;
  }
  setDate(e) {
    this.date = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled"];
  }
  updateDate(e) {
    this.setDate(e), this.sourceParams.onDateChanged();
  }
  getProps() {
    const e = super.getProps();
    return e.date = this.date, e.onDateChange = this.onDateChange, delete e.onDateChanged, e;
  }
}, tj = class extends hi {
  constructor() {
    super(...arguments), this.label = "", this.icon = null, this.shake = !1;
  }
  setIcon(e, t) {
    this.icon = e, this.shake = t, this.refreshProps();
  }
  setLabel(e) {
    this.label = e, this.refreshProps();
  }
  getProps() {
    const e = super.getProps(), { label: t, icon: r, shake: n } = this;
    return e.label = t, e.icon = r, e.shake = n, e;
  }
}, rj = class extends hi {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e), this.onUiChange = () => this.sourceParams.filterChangedCallback(), this.expectingNewMethods = !0, this.hasBeenActive = !1;
  }
  isFilterActive() {
    return this.model != null;
  }
  doesFilterPass(e) {
    return this.providedMethods.doesFilterPass(e);
  }
  getModel() {
    return this.model;
  }
  setModel(e) {
    return this.expectingNewMethods = !0, this.model = e, this.hasBeenActive || (this.hasBeenActive = this.isFilterActive()), this.refreshProps();
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onAnyFilterChanged"];
  }
  setMethods(e) {
    var t;
    this.expectingNewMethods === !1 && this.hasBeenActive && ((t = this.providedMethods) == null ? void 0 : t.doesFilterPass) !== (e == null ? void 0 : e.doesFilterPass) && setTimeout(() => {
      this.sourceParams.filterChangedCallback();
    }), this.expectingNewMethods = !1, super.setMethods(e);
  }
  updateModel(e) {
    this.setModel(e).then(() => this.sourceParams.filterChangedCallback());
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e.onUiChange = this.onUiChange, delete e.filterChangedCallback, delete e.filterModifiedCallback, delete e.valueGetter, e;
  }
};
function oA(e, t) {
  e.parentFilterInstance((r) => {
    (r.setModel(t) || _t.resolve()).then(() => {
      e.filterParams.filterChangedCallback();
    });
  });
}
var nj = class {
  constructor(e, t) {
    this.floatingFilterParams = e, this.refreshProps = t, this.model = null, this.onModelChange = (r) => this.updateModel(r);
  }
  getProps() {
    return {
      ...this.floatingFilterParams,
      model: this.model,
      onModelChange: this.onModelChange
    };
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.floatingFilterParams = e, this.refreshProps();
  }
  setMethods(e) {
    ay(this.getOptionalMethods(), e, this);
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), oA(this.floatingFilterParams, e);
  }
}, ij = class extends hi {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e);
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), oA(this.sourceParams, e);
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e;
  }
}, oj = class extends hi {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, sj = class extends hi {
  constructor() {
    super(...arguments), this.active = !1, this.expanded = !1, this.onActiveChange = (e) => this.updateActive(e);
  }
  setActive(e) {
    this.awaitSetActive(e);
  }
  setExpanded(e) {
    this.expanded = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["select", "configureDefaults"];
  }
  awaitSetActive(e) {
    return this.active = e, this.refreshProps();
  }
  updateActive(e) {
    const t = this.awaitSetActive(e);
    e && t.then(() => this.sourceParams.onItemActivated());
  }
  getProps() {
    const e = super.getProps();
    return e.active = this.active, e.expanded = this.expanded, e.onActiveChange = this.onActiveChange, delete e.onItemActivated, e;
  }
}, aj = class extends hi {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, lj = class extends hi {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, cj = class extends hi {
  constructor() {
    super(...arguments), this.onStateChange = (e) => this.updateState(e);
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getState() {
    return this.state;
  }
  updateState(e) {
    this.state = e, this.refreshProps(), this.sourceParams.onStateUpdated();
  }
  getProps() {
    const e = super.getProps();
    return e.state = this.state, e.onStateChange = this.onStateChange, e;
  }
};
function ly() {
  ie("As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.");
}
var uj = 1e3, dj = class {
  constructor(e, t, r) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = t || "div", this.refresher = e, this.maxComponentCreationTimeMs = r || uj;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, r) {
    this.portals = [...this.portals, e], this.waitForInstance(t, r), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || (this.refresher(), this.hasPendingPortalUpdate = !1);
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(e, t, r = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered())
      t(e);
    else {
      if (Date.now() - r >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate)
        return;
      window.setTimeout(() => {
        this.waitForInstance(e, t, r);
      });
    }
  }
}, hj = ({ ctrl: e }) => {
  const t = e.isAlive(), { context: r } = Wt(mr), n = t ? e.getColId() : void 0, [i, o] = pe(), s = ge(), a = ge(null), l = ge(null), u = ge(null), d = ge(), h = ge();
  t && !h.current && (h.current = new $c(() => a.current));
  const f = Qe((v) => {
    var b;
    if (a.current = v, s.current = v ? r.createBean(new Na()) : r.destroyBean(s.current), !v || !t)
      return;
    const w = {
      setWidth: (P) => {
        a.current && (a.current.style.width = P);
      },
      addOrRemoveCssClass: (P, S) => h.current.addOrRemoveCssClass(P, S),
      setAriaSort: (P) => {
        a.current && (P ? JB(a.current, P) : XB(a.current));
      },
      setUserCompDetails: (P) => o(P),
      getUserCompInstance: () => d.current || void 0
    };
    e.setComp(w, v, l.current, u.current, s.current);
    const R = e.getSelectAllGui();
    (b = l.current) == null || b.insertAdjacentElement("afterend", R), s.current.addDestroyFunc(() => R.remove());
  }, []);
  ao(
    () => Kc(i, r, u.current, d),
    [i]
  ), pr(() => {
    e.setDragSource(a.current);
  }, [i]);
  const p = Se(() => !!((i == null ? void 0 : i.componentFromFramework) && Wa(i.componentClass)), [i]), y = i && i.componentFromFramework, C = i && i.componentClass;
  return /* @__PURE__ */ O.createElement("div", { ref: f, className: "ag-header-cell", "col-id": n, role: "columnheader" }, /* @__PURE__ */ O.createElement("div", { ref: l, className: "ag-header-cell-resize", role: "presentation" }), /* @__PURE__ */ O.createElement("div", { ref: u, className: "ag-header-cell-comp-wrapper", role: "presentation" }, y && p && /* @__PURE__ */ O.createElement(C, { ...i.params }), y && !p && /* @__PURE__ */ O.createElement(C, { ...i.params, ref: d })));
}, gj = Tr(hj), fj = ({ ctrl: e }) => {
  const { context: t, gos: r } = Wt(mr), [n, i] = pe(
    () => new wn("ag-header-cell", "ag-floating-filter")
  ), [o, s] = pe(() => new wn()), [a, l] = pe(
    () => new wn("ag-floating-filter-button", "ag-hidden")
  ), [u, d] = pe("false"), [h, f] = pe(), [, p] = pe(1), y = ge(), C = ge(null), v = ge(null), w = ge(null), R = ge(null), b = ge(), P = ge(), S = (K) => {
    K != null && b.current && b.current(K);
  }, E = Qe((K) => {
    if (C.current = K, y.current = K ? t.createBean(new Na()) : t.destroyBean(y.current), !K)
      return;
    P.current = new _t((te) => {
      b.current = te;
    });
    const Z = {
      addOrRemoveCssClass: (te, se) => i((W) => W.setClass(te, se)),
      addOrRemoveBodyCssClass: (te, se) => s((W) => W.setClass(te, se)),
      setButtonWrapperDisplayed: (te) => {
        l((se) => se.setClass("ag-hidden", !te)), d(te ? "false" : "true");
      },
      setWidth: (te) => {
        C.current && (C.current.style.width = te);
      },
      setCompDetails: (te) => f(te),
      getFloatingFilterComp: () => P.current ? P.current : null,
      setMenuIcon: (te) => {
        var se;
        return (se = R.current) == null ? void 0 : se.appendChild(te);
      }
    };
    e.setComp(Z, K, R.current, v.current, y.current);
  }, []);
  ao(
    () => Kc(h, t, v.current, S),
    [h]
  );
  const A = Se(() => n.toString(), [n]), M = Se(() => o.toString(), [o]), I = Se(() => a.toString(), [a]), z = Se(() => !!(h && h.componentFromFramework && Wa(h.componentClass)), [h]), k = Se(() => r.get("reactiveCustomComponents"), []), _ = Se(() => {
    if (h)
      if (k) {
        const K = new nj(
          h.params,
          () => p((Z) => Z + 1)
        );
        return S(K), K;
      } else h.componentFromFramework && ly();
  }, [h]), q = _ == null ? void 0 : _.getProps(), j = h && h.componentFromFramework, Q = h && h.componentClass;
  return /* @__PURE__ */ O.createElement("div", { ref: E, className: A, role: "gridcell" }, /* @__PURE__ */ O.createElement("div", { ref: v, className: M, role: "presentation" }, j && !k && /* @__PURE__ */ O.createElement(Q, { ...h.params, ref: z ? () => {
  } : S }), j && k && /* @__PURE__ */ O.createElement(
    sy.Provider,
    {
      value: {
        setMethods: (K) => _.setMethods(K)
      }
    },
    /* @__PURE__ */ O.createElement(Q, { ...q })
  )), /* @__PURE__ */ O.createElement(
    "div",
    {
      ref: w,
      "aria-hidden": u,
      className: I,
      role: "presentation"
    },
    /* @__PURE__ */ O.createElement(
      "button",
      {
        ref: R,
        type: "button",
        className: "ag-button ag-floating-filter-button-button",
        tabIndex: -1
      }
    )
  ));
}, pj = Tr(fj), mj = ({ ctrl: e }) => {
  const { context: t } = Wt(mr), [r, n] = pe(() => new wn()), [i, o] = pe(() => new wn()), [s, a] = pe("false"), [l, u] = pe(), [d, h] = pe(), f = Se(() => e.getColId(), []), p = ge(), y = ge(null), C = ge(null), v = ge(null), w = ge(), R = Qe((M) => {
    if (y.current = M, p.current = M ? t.createBean(new Na()) : t.destroyBean(p.current), !M)
      return;
    const I = {
      setWidth: (z) => {
        y.current && (y.current.style.width = z);
      },
      addOrRemoveCssClass: (z, k) => n((_) => _.setClass(z, k)),
      setHeaderWrapperHidden: (z) => {
        const k = v.current;
        k && (z ? k.style.setProperty("display", "none") : k.style.removeProperty("display"));
      },
      setHeaderWrapperMaxHeight: (z) => {
        const k = v.current;
        k && (z != null ? k.style.setProperty("max-height", `${z}px`) : k.style.removeProperty("max-height"), k.classList.toggle("ag-header-cell-comp-wrapper-limited-height", z != null));
      },
      setUserCompDetails: (z) => h(z),
      setResizableDisplayed: (z) => {
        o((k) => k.setClass("ag-hidden", !z)), a(z ? "false" : "true");
      },
      setAriaExpanded: (z) => u(z),
      getUserCompInstance: () => w.current || void 0
    };
    e.setComp(I, M, C.current, v.current, p.current);
  }, []);
  ao(() => Kc(d, t, v.current), [d]), pr(() => {
    y.current && e.setDragSource(y.current);
  }, [d]);
  const b = Se(() => !!((d == null ? void 0 : d.componentFromFramework) && Wa(d.componentClass)), [d]), P = Se(() => "ag-header-group-cell " + r.toString(), [r]), S = Se(
    () => "ag-header-cell-resize " + i.toString(),
    [i]
  ), E = d && d.componentFromFramework, A = d && d.componentClass;
  return /* @__PURE__ */ O.createElement("div", { ref: R, className: P, "col-id": f, role: "columnheader", "aria-expanded": l }, /* @__PURE__ */ O.createElement("div", { ref: v, className: "ag-header-cell-comp-wrapper", role: "presentation" }, E && b && /* @__PURE__ */ O.createElement(A, { ...d.params }), E && !b && /* @__PURE__ */ O.createElement(A, { ...d.params, ref: w })), /* @__PURE__ */ O.createElement("div", { ref: C, "aria-hidden": s, className: S }));
}, vj = Tr(mj), yj = ({ ctrl: e }) => {
  const { context: t } = Wt(mr), { topOffset: r, rowHeight: n } = Se(() => e.getTopAndHeight(), []), i = e.getAriaRowIndex(), o = e.getHeaderRowClass(), [s, a] = pe(() => n + "px"), [l, u] = pe(() => r + "px"), d = ge(null), h = ge(null), [f, p] = pe(() => e.getHeaderCtrls()), y = ge(), C = ge(null), v = Qe((b) => {
    if (C.current = b, y.current = b ? t.createBean(new Na()) : t.destroyBean(y.current), !b)
      return;
    const P = {
      setHeight: (S) => a(S),
      setTop: (S) => u(S),
      setHeaderCtrls: (S, E, A) => {
        h.current = d.current, d.current = S;
        const M = oy(h.current, S, E);
        M !== h.current && iy(A, () => p(M));
      },
      setWidth: (S) => {
        C.current && (C.current.style.width = S);
      }
    };
    e.setComp(P, y.current, !1);
  }, []), w = Se(
    () => ({
      height: s,
      top: l
    }),
    [s, l]
  ), R = Qe((b) => {
    switch (e.getType()) {
      case Pm.COLUMN_GROUP:
        return /* @__PURE__ */ O.createElement(vj, { ctrl: b, key: b.instanceId });
      case Pm.FLOATING_FILTER:
        return /* @__PURE__ */ O.createElement(pj, { ctrl: b, key: b.instanceId });
      default:
        return /* @__PURE__ */ O.createElement(gj, { ctrl: b, key: b.instanceId });
    }
  }, []);
  return /* @__PURE__ */ O.createElement("div", { ref: v, className: o, role: "row", style: w, "aria-rowindex": i }, f.map(R));
}, Cj = Tr(yj), wj = ({ pinned: e }) => {
  const [t, r] = pe(!0), [n, i] = pe([]), { context: o } = Wt(mr), s = ge(null), a = ge(null), l = ge(), u = e === "left", d = e === "right", h = !u && !d, f = Qe((C) => {
    if (s.current = C, l.current = C ? o.createBean(new O4(e)) : o.destroyBean(l.current), !C)
      return;
    const v = {
      setDisplayed: r,
      setCtrls: (w) => i(w),
      // centre only
      setCenterWidth: (w) => {
        a.current && (a.current.style.width = w);
      },
      setViewportScrollLeft: (w) => {
        s.current && (s.current.scrollLeft = w);
      },
      // pinned only
      setPinnedContainerWidth: (w) => {
        s.current && (s.current.style.width = w, s.current.style.minWidth = w, s.current.style.maxWidth = w);
      }
    };
    l.current.setComp(v, s.current);
  }, []), p = t ? "" : "ag-hidden", y = () => n.map((C) => /* @__PURE__ */ O.createElement(Cj, { ctrl: C, key: C.instanceId }));
  return /* @__PURE__ */ O.createElement(O.Fragment, null, u && /* @__PURE__ */ O.createElement(
    "div",
    {
      ref: f,
      className: "ag-pinned-left-header " + p,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    y()
  ), d && /* @__PURE__ */ O.createElement(
    "div",
    {
      ref: f,
      className: "ag-pinned-right-header " + p,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    y()
  ), h && /* @__PURE__ */ O.createElement("div", { ref: f, className: "ag-header-viewport " + p, role: "presentation" }, /* @__PURE__ */ O.createElement("div", { ref: a, className: "ag-header-container", role: "rowgroup" }, y())));
}, Rp = Tr(wj), bj = () => {
  const [e, t] = pe(() => new wn()), [r, n] = pe(), { context: i } = Wt(mr), o = ge(null), s = ge(), a = Qe((d) => {
    if (o.current = d, s.current = d ? i.createBean(new p4()) : i.destroyBean(s.current), !d)
      return;
    const h = {
      addOrRemoveCssClass: (f, p) => t((y) => y.setClass(f, p)),
      setHeightAndMinHeight: (f) => n(f)
    };
    s.current.setComp(h, d, d);
  }, []), l = Se(() => "ag-header " + e.toString(), [e]), u = Se(
    () => ({
      height: r,
      minHeight: r
    }),
    [r]
  );
  return /* @__PURE__ */ O.createElement("div", { ref: a, className: l, style: u, role: "presentation" }, /* @__PURE__ */ O.createElement(Rp, { pinned: "left" }), /* @__PURE__ */ O.createElement(Rp, { pinned: null }), /* @__PURE__ */ O.createElement(Rp, { pinned: "right" }));
}, Sj = Tr(bj), xj = (e, t) => {
  pr(() => {
    const r = t.current;
    if (r) {
      const n = r.parentElement;
      if (n) {
        const i = document.createComment(e);
        return n.insertBefore(i, r), () => {
          n.removeChild(i);
        };
      }
    }
  }, [e]);
}, $o = xj, Rj = class {
  constructor(e, t) {
    this.cellEditorParams = e, this.refreshProps = t, this.instanceCreated = new _t((r) => {
      this.resolveInstanceCreated = r;
    }), this.onValueChange = (r) => this.updateValue(r), this.value = e.value;
  }
  getProps() {
    return {
      ...this.cellEditorParams,
      initialValue: this.cellEditorParams.value,
      value: this.value,
      onValueChange: this.onValueChange
    };
  }
  getValue() {
    return this.value;
  }
  refresh(e) {
    this.cellEditorParams = e, this.refreshProps();
  }
  setMethods(e) {
    ay(this.getOptionalMethods(), e, this);
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  setRef(e) {
    var t;
    this.componentInstance = e, (t = this.resolveInstanceCreated) == null || t.call(this), this.resolveInstanceCreated = void 0;
  }
  getOptionalMethods() {
    return ["isCancelBeforeStart", "isCancelAfterEnd", "focusIn", "focusOut", "afterGuiAttached"];
  }
  updateValue(e) {
    this.value = e, this.refreshProps();
  }
}, Ej = (e) => {
  const t = ge(e), r = ge(), n = ge(!1), i = ge(!1), [, o] = pe(0);
  n.current && (i.current = !0), pr(() => (n.current || (r.current = t.current(), n.current = !0), o((s) => s + 1), () => {
    var s;
    i.current && ((s = r.current) == null || s.call(r));
  }), []);
}, Pj = (e) => {
  const [t, r] = pe(), { context: n, popupService: i, localeService: o, gos: s, editService: a } = Wt(mr);
  return Ej(() => {
    var P, S;
    const { editDetails: l, cellCtrl: u, eParentCell: d } = e, { compDetails: h } = l, f = s.get("stopEditingWhenCellsLoseFocus"), p = n.createBean(a.createPopupEditorWrapper(h.params)), y = p.getGui();
    if (e.jsChildComp) {
      const E = e.jsChildComp.getGui();
      E && y.appendChild(E);
    }
    const C = {
      column: u.getColumn(),
      rowNode: u.getRowNode(),
      type: "popupCellEditor",
      eventSource: d,
      ePopup: y,
      position: l.popupPosition,
      keepWithinBounds: !0
    }, v = i.positionPopupByComponent.bind(i, C), w = o.getLocaleTextFunc(), R = i.addPopup({
      modal: f,
      eChild: y,
      closeOnEsc: !0,
      closedCallback: () => {
        u.onPopupEditorClosed();
      },
      anchorToElement: d,
      positionCallback: v,
      ariaLabel: w("ariaLabelCellEditor", "Cell Editor")
    }), b = R ? R.hideFunc : void 0;
    return r(p), (S = (P = e.jsChildComp) == null ? void 0 : P.afterGuiAttached) == null || S.call(P), () => {
      b == null || b(), n.destroyBean(p);
    };
  }), /* @__PURE__ */ O.createElement(O.Fragment, null, t && e.wrappedContent && $h(e.wrappedContent, t.getGui()));
}, OS = Tr(Pj), Aj = (e, t, r, n, i, o) => {
  const { context: s } = Wt(mr), a = Qe(() => {
    const l = i.current;
    if (!l)
      return;
    const u = l.getGui();
    u && u.parentElement && u.parentElement.removeChild(u), s.destroyBean(l), i.current = void 0;
  }, []);
  pr(() => {
    const l = e != null, u = (e == null ? void 0 : e.compDetails) && !e.compDetails.componentFromFramework, d = t && r == null;
    if (!(l && u && !d)) {
      a();
      return;
    }
    const f = e.compDetails;
    if (i.current) {
      const y = i.current, v = y.refresh != null && e.force == !1 ? y.refresh(f.params) : !1;
      if (v === !0 || v === void 0)
        return;
      a();
    }
    const p = f.newAgStackInstance();
    p != null && p.then((y) => {
      if (!y)
        return;
      const C = y.getGui();
      if (!C)
        return;
      (t ? r : o.current).appendChild(C), i.current = y;
    });
  }, [e, t, n]), pr(() => a, []);
}, Fj = Aj, Mj = (e, t, r) => {
  const { compProxy: n } = e;
  r(n);
  const i = n.getProps(), o = Wa(t);
  return /* @__PURE__ */ O.createElement(
    sy.Provider,
    {
      value: {
        setMethods: (s) => n.setMethods(s)
      }
    },
    o ? /* @__PURE__ */ O.createElement(t, { ...i }) : /* @__PURE__ */ O.createElement(t, { ...i, ref: (s) => n.setRef(s) })
  );
}, IS = (e, t, r) => {
  const n = e.compProxy;
  return /* @__PURE__ */ O.createElement(O.Fragment, null, n ? Mj(e, t, r) : /* @__PURE__ */ O.createElement(t, { ...e.compDetails.params, ref: r }));
}, Tj = (e, t, r, n, i) => {
  const o = e.compDetails, s = o.componentClass, a = o.componentFromFramework && !e.popup, l = o.componentFromFramework && e.popup, u = !o.componentFromFramework && e.popup;
  return /* @__PURE__ */ O.createElement(O.Fragment, null, a && IS(e, s, t), l && /* @__PURE__ */ O.createElement(
    OS,
    {
      editDetails: e,
      cellCtrl: n,
      eParentCell: r,
      wrappedContent: IS(e, s, t)
    }
  ), u && i && /* @__PURE__ */ O.createElement(
    OS,
    {
      editDetails: e,
      cellCtrl: n,
      eParentCell: r,
      jsChildComp: i
    }
  ));
}, Dj = (e, t, r, n, i, o, s) => {
  const { compDetails: a, value: l } = e, u = !a, d = a && a.componentFromFramework, h = a && a.componentClass, f = l != null && l.toString ? l.toString() : l, p = () => /* @__PURE__ */ O.createElement(O.Fragment, null, u && /* @__PURE__ */ O.createElement(O.Fragment, null, f), d && !o && /* @__PURE__ */ O.createElement(h, { ...a.params, key: t, ref: n }), d && o && /* @__PURE__ */ O.createElement(h, { ...a.params, key: t }));
  return /* @__PURE__ */ O.createElement(O.Fragment, null, i ? /* @__PURE__ */ O.createElement("span", { role: "presentation", id: `cell-${r}`, className: "ag-cell-value", ref: s }, p()) : p());
}, Oj = ({
  cellCtrl: e,
  printLayout: t,
  editingRow: r
}) => {
  const { context: n } = Wt(mr), { colIdSanitised: i, instanceId: o } = e, s = ge(), [a, l] = pe(
    () => e.isCellRenderer() ? void 0 : { compDetails: void 0, value: e.getValueToDisplay(), force: !1 }
  ), [u, d] = pe(), [h, f] = pe(1), [p, y] = pe(), [C, v] = pe(!1), [w, R] = pe(!1), [b, P] = pe(!1), [S, E] = pe(), A = Se(() => e.isForceWrapper(), [e]), M = Se(() => e.getCellAriaRole(), [e]), I = ge(null), z = ge(null), k = ge(), _ = ge(), q = ge(), j = ge([]), Q = ge(), [K, Z] = pe(0), te = Qe((ee) => {
    Q.current = ee, Z((fe) => fe + 1);
  }, []), se = a != null && (C || b || w), W = A || se, U = Qe(
    (ee) => {
      if (_.current = ee, ee) {
        const fe = ee.isCancelBeforeStart && ee.isCancelBeforeStart();
        setTimeout(() => {
          fe ? (e.stopEditing(!0), e.focusCell(!0)) : e.cellEditorAttached();
        });
      }
    },
    [e]
  ), X = ge();
  X.current || (X.current = new $c(() => I.current)), Fj(a, W, Q.current, K, k, I);
  const he = ge();
  ao(() => {
    var oe;
    const ee = he.current, fe = a;
    if (he.current = a, ee == null || ee.compDetails == null || fe == null || fe.compDetails == null)
      return;
    const ye = ee.compDetails, B = fe.compDetails;
    if (ye.componentClass != B.componentClass || ((oe = z.current) == null ? void 0 : oe.refresh) == null)
      return;
    z.current.refresh(B.params) != !0 && f((Me) => Me + 1);
  }, [a]), ao(() => {
    if (!(u && !u.compDetails.componentFromFramework))
      return;
    const fe = u.compDetails, ye = u.popup === !0, B = fe.newAgStackInstance();
    return B.then((Ae) => {
      if (!Ae)
        return;
      const oe = Ae.getGui();
      if (U(Ae), !ye) {
        const Me = (A ? q : I).current;
        Me == null || Me.appendChild(oe), Ae.afterGuiAttached && Ae.afterGuiAttached();
      }
      E(Ae);
    }), () => {
      B.then((Ae) => {
        var Me;
        const oe = Ae.getGui();
        n.destroyBean(Ae), U(void 0), E(void 0), (Me = oe == null ? void 0 : oe.parentElement) == null || Me.removeChild(oe);
      });
    };
  }, [u]);
  const ce = Qe(
    (ee) => {
      if (q.current = ee, !ee) {
        j.current.forEach((ye) => ye()), j.current = [];
        return;
      }
      const fe = (ye) => {
        if (ye) {
          const B = ye.getGui();
          ee.insertAdjacentElement("afterbegin", B), j.current.push(() => {
            n.destroyBean(ye), cs(B);
          });
        }
        return ye;
      };
      if (C) {
        const ye = e.createSelectionCheckbox();
        fe(ye);
      }
      b && fe(e.createDndSource()), w && fe(e.createRowDragComp());
    },
    [e, n, b, w, C]
  ), me = Qe((ee) => {
    if (I.current = ee, s.current = ee ? n.createBean(new Na()) : n.destroyBean(s.current), !ee || !e)
      return;
    const fe = {
      addOrRemoveCssClass: (B, Ae) => X.current.addOrRemoveCssClass(B, Ae),
      setUserStyles: (B) => y(B),
      getFocusableElement: () => I.current,
      setIncludeSelection: (B) => v(B),
      setIncludeRowDrag: (B) => R(B),
      setIncludeDndSource: (B) => P(B),
      getCellEditor: () => _.current || null,
      getCellRenderer: () => z.current ?? k.current,
      getParentOfValue: () => Q.current ?? q.current ?? I.current,
      setRenderDetails: (B, Ae, oe) => {
        l((Me) => (Me == null ? void 0 : Me.compDetails) !== B || (Me == null ? void 0 : Me.value) !== Ae || (Me == null ? void 0 : Me.force) !== oe ? {
          value: Ae,
          compDetails: B,
          force: oe
        } : Me);
      },
      setEditDetails: (B, Ae, oe, Me) => {
        if (B) {
          let Je;
          Me ? Je = new Rj(
            B.params,
            () => f((nt) => nt + 1)
          ) : B.componentFromFramework && ly(), d({
            compDetails: B,
            popup: Ae,
            popupPosition: oe,
            compProxy: Je
          }), Ae || l(void 0);
        } else
          d((Je) => {
            Je != null && Je.compProxy && (_.current = void 0);
          });
      }
    }, ye = q.current || void 0;
    e.setComp(fe, ee, ye, t, r, s.current);
  }, []), ve = Se(() => {
    var fe;
    return !!(((fe = a == null ? void 0 : a.compDetails) == null ? void 0 : fe.componentFromFramework) && Wa(a.compDetails.componentClass));
  }, [a]);
  ao(() => {
    var ee;
    I.current && (X.current.addOrRemoveCssClass("ag-cell-value", !W), X.current.addOrRemoveCssClass("ag-cell-inline-editing", !!u && !u.popup), X.current.addOrRemoveCssClass("ag-cell-popup-editing", !!u && !!u.popup), X.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !u || !!u.popup), (ee = e.getRowCtrl()) == null || ee.setInlineEditingCss(), e.shouldRestoreFocus() && !e.isEditing() && I.current.focus({ preventScroll: !0 }));
  });
  const Pe = () => /* @__PURE__ */ O.createElement(O.Fragment, null, a != null && Dj(
    a,
    h,
    o,
    z,
    W,
    ve,
    te
  ), u != null && Tj(u, U, I.current, e, S)), Re = Qe(() => e.onFocusOut(), []);
  return /* @__PURE__ */ O.createElement("div", { ref: me, style: p, role: M, "col-id": i, onBlur: Re }, W ? /* @__PURE__ */ O.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: ce }, Pe()) : Pe());
}, Ij = Tr(Oj), kj = ({ rowCtrl: e, containerType: t }) => {
  const { context: r, gos: n } = Wt(mr), i = ge(), o = ge(e.getDomOrder()), s = e.isFullWidth(), a = e.getRowNode().displayed, [l, u] = pe(() => a ? e.getRowIndex() : null), [d, h] = pe(() => e.getRowId()), [f, p] = pe(() => e.getBusinessKey()), [y, C] = pe(() => e.getRowStyles()), v = ge(null), w = ge(null), [R, b] = pe(() => null), [P, S] = pe(), [E, A] = pe(
    () => a ? e.getInitialRowTop(t) : void 0
  ), [M, I] = pe(
    () => a ? e.getInitialTransform(t) : void 0
  ), z = ge(null), k = ge(), _ = ge(!1), [q, j] = pe(0);
  pr(() => {
    var me;
    if (_.current || !P || q > 10)
      return;
    const ce = (me = z.current) == null ? void 0 : me.firstChild;
    ce ? (e.setupDetailRowAutoHeight(ce), _.current = !0) : j((ve) => ve + 1);
  }, [P, q]);
  const Q = ge();
  Q.current || (Q.current = new $c(() => z.current));
  const K = Qe((ce) => {
    if (z.current = ce, i.current = ce ? r.createBean(new Na()) : r.destroyBean(i.current), !ce) {
      e.unsetComp(t);
      return;
    }
    if (!e.isAlive())
      return;
    const me = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: A,
      setTransform: I,
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (ve, Pe) => Q.current.addOrRemoveCssClass(ve, Pe),
      setDomOrder: (ve) => o.current = ve,
      setRowIndex: u,
      setRowId: h,
      setRowBusinessKey: p,
      setUserStyles: C,
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (ve, Pe) => {
        w.current = v.current, v.current = ve;
        const Re = oy(w.current, ve, o.current);
        Re !== w.current && iy(Pe, () => b(Re));
      },
      showFullWidth: (ve) => S(ve),
      getFullWidthCellRenderer: () => k.current,
      refreshFullWidth: (ve) => U.current ? (S((Pe) => ({
        ...Pe,
        params: ve()
      })), !0) : !k.current || !k.current.refresh ? !1 : k.current.refresh(ve())
    };
    e.setComp(me, ce, t, i.current);
  }, []);
  ao(
    () => Kc(P, r, z.current, k),
    [P]
  );
  const Z = Se(() => {
    const ce = { top: E, transform: M };
    return Object.assign(ce, y), ce;
  }, [E, M, y]), te = s && (P == null ? void 0 : P.componentFromFramework), se = !s && R != null, W = Se(() => !!((P == null ? void 0 : P.componentFromFramework) && Wa(P.componentClass)), [P]), U = ge(!1);
  pr(() => {
    U.current = W && !!P && !!n.get("reactiveCustomComponents");
  }, [W, P]);
  const X = () => R == null ? void 0 : R.map((ce) => /* @__PURE__ */ O.createElement(
    Ij,
    {
      cellCtrl: ce,
      editingRow: e.isEditing(),
      printLayout: e.isPrintLayout(),
      key: ce.instanceId
    }
  )), he = () => {
    const ce = P.componentClass;
    return /* @__PURE__ */ O.createElement(O.Fragment, null, W ? /* @__PURE__ */ O.createElement(ce, { ...P.params }) : /* @__PURE__ */ O.createElement(ce, { ...P.params, ref: k }));
  };
  return /* @__PURE__ */ O.createElement(
    "div",
    {
      ref: K,
      role: "row",
      style: Z,
      "row-index": l,
      "row-id": d,
      "row-business-key": f
    },
    se && X(),
    te && he()
  );
}, Lj = Tr(kj), _j = ({ name: e }) => {
  const { context: t } = Wt(mr), r = Se(() => Vs(e), [e]), n = ge(null), i = ge(null), o = ge([]), s = ge([]), [a, l] = pe(() => []), u = ge(!1), d = ge(), h = Se(() => In(r.viewport), [r]), f = Se(() => In(r.container), [r]), p = r.type === "center", y = p ? n : i;
  $o(" AG Row Container " + e + " ", y);
  const C = Qe(() => p ? n.current != null && i.current != null : i.current != null, []), v = Qe(() => p ? n.current == null && i.current == null : i.current == null, []), w = Qe(() => {
    if (v() && (d.current = t.destroyBean(d.current)), C()) {
      const S = (A) => {
        const M = oy(
          s.current,
          o.current,
          u.current
        );
        M !== s.current && (s.current = M, iy(A, () => l(M)));
      }, E = {
        setHorizontalScroll: (A) => {
          n.current && (n.current.scrollLeft = A);
        },
        setViewportHeight: (A) => {
          n.current && (n.current.style.height = A);
        },
        setRowCtrls: ({ rowCtrls: A, useFlushSync: M }) => {
          const I = !!M && o.current.length > 0 && A.length > 0;
          o.current = A, S(I);
        },
        setDomOrder: (A) => {
          u.current != A && (u.current = A, S(!1));
        },
        setContainerWidth: (A) => {
          i.current && (i.current.style.width = A);
        },
        setOffsetTop: (A) => {
          i.current && (i.current.style.transform = `translateY(${A})`);
        }
      };
      d.current = t.createBean(new R6(e)), d.current.setComp(E, i.current, n.current);
    }
  }, [C, v]), R = Qe(
    (S) => {
      i.current = S, w();
    },
    [w]
  ), b = Qe(
    (S) => {
      n.current = S, w();
    },
    [w]
  ), P = () => /* @__PURE__ */ O.createElement("div", { className: f, ref: R, role: "rowgroup" }, a.map((S) => /* @__PURE__ */ O.createElement(Lj, { rowCtrl: S, containerType: r.type, key: S.instanceId })));
  return /* @__PURE__ */ O.createElement(O.Fragment, null, p ? /* @__PURE__ */ O.createElement("div", { className: h, ref: b, role: "presentation" }, P()) : P());
}, zj = Tr(_j), Nj = () => {
  const { context: e, resizeObserverService: t } = Wt(mr), [r, n] = pe(""), [i, o] = pe(0), [s, a] = pe(0), [l, u] = pe("0px"), [d, h] = pe("0px"), [f, p] = pe("100%"), [y, C] = pe("0px"), [v, w] = pe("0px"), [R, b] = pe("100%"), [P, S] = pe(""), [E, A] = pe(""), [M, I] = pe(null), [z, k] = pe(""), [_, q] = pe(null), [j, Q] = pe("ag-layout-normal"), K = ge();
  K.current || (K.current = new $c(() => Z.current));
  const Z = ge(null), te = ge(null), se = ge(null), W = ge(null), U = ge(null), X = ge(null), he = ge(null), ce = ge([]), me = ge([]);
  $o(" AG Grid Body ", Z), $o(" AG Pinned Top ", te), $o(" AG Sticky Top ", se), $o(" AG Middle ", X), $o(" AG Pinned Bottom ", he);
  const ve = Qe((Nt) => {
    if (Z.current = Nt, !Nt) {
      ce.current = e.destroyBeans(ce.current), me.current.forEach((yt) => yt()), me.current = [];
      return;
    }
    if (!e)
      return;
    const Et = (yt, Ot) => {
      yt.appendChild(Ot), me.current.push(() => yt.removeChild(Ot));
    }, Ut = (yt) => {
      const Ot = e.createBean(new yt());
      return ce.current.push(Ot), Ot;
    }, Or = (yt, Ot, Wi) => {
      Et(yt, document.createComment(Wi)), Et(yt, Ut(Ot).getGui());
    };
    Or(Nt, k4, " AG Fake Horizontal Scroll "), Or(Nt, I4, " AG Overlay Wrapper "), U.current && Or(U.current, L4, " AG Fake Vertical Scroll ");
    const Po = {
      setRowAnimationCssOnBodyViewport: n,
      setColumnCount: (yt) => {
        Z.current && qB(Z.current, yt);
      },
      setRowCount: (yt) => {
        Z.current && UB(Z.current, yt);
      },
      setTopHeight: o,
      setBottomHeight: a,
      setStickyTopHeight: u,
      setStickyTopTop: h,
      setStickyTopWidth: p,
      setTopDisplay: S,
      setBottomDisplay: A,
      setColumnMovingCss: (yt, Ot) => K.current.addOrRemoveCssClass(yt, Ot),
      updateLayoutClasses: Q,
      setAlwaysVerticalScrollClass: I,
      setPinnedTopBottomOverflowY: k,
      setCellSelectableCss: (yt, Ot) => q(Ot ? yt : null),
      setBodyViewportWidth: (yt) => {
        X.current && (X.current.style.width = yt);
      },
      registerBodyViewportResizeListener: (yt) => {
        if (X.current) {
          const Ot = t.observeResize(X.current, yt);
          me.current.push(() => Ot());
        }
      },
      setStickyBottomHeight: C,
      setStickyBottomBottom: w,
      setStickyBottomWidth: b
    }, on = e.createBean(new F6());
    ce.current.push(on), on.setComp(
      Po,
      Nt,
      X.current,
      te.current,
      he.current,
      se.current,
      W.current
    );
  }, []), Pe = Se(() => In("ag-root", "ag-unselectable", j), [j]), Re = Se(
    () => In(
      "ag-body-viewport",
      r,
      j,
      M,
      _
    ),
    [r, j, M, _]
  ), ee = Se(() => In("ag-body", j), [j]), fe = Se(() => In("ag-floating-top", _), [_]), ye = Se(() => In("ag-sticky-top", _), [_]), B = Se(
    () => In("ag-sticky-bottom", y === "0px" ? "ag-hidden" : null, _),
    [_, y]
  ), Ae = Se(() => In("ag-floating-bottom", _), [_]), oe = Se(
    () => ({
      height: i,
      minHeight: i,
      display: P,
      overflowY: z
    }),
    [i, P, z]
  ), Me = Se(
    () => ({
      height: l,
      top: d,
      width: f
    }),
    [l, d, f]
  ), Je = Se(
    () => ({
      height: y,
      bottom: v,
      width: R
    }),
    [y, v, R]
  ), nt = Se(
    () => ({
      height: s,
      minHeight: s,
      display: E,
      overflowY: z
    }),
    [s, E, z]
  ), $r = (Nt) => /* @__PURE__ */ O.createElement(zj, { name: Nt, key: `${Nt}-container` }), Dr = ({
    section: Nt,
    children: Et,
    className: Ut,
    style: Or
  }) => /* @__PURE__ */ O.createElement("div", { ref: Nt, className: Ut, role: "presentation", style: Or }, Et.map($r));
  return /* @__PURE__ */ O.createElement("div", { ref: ve, className: Pe, role: "treegrid" }, /* @__PURE__ */ O.createElement(Sj, null), Dr({
    section: te,
    className: fe,
    style: oe,
    children: ["topLeft", "topCenter", "topRight", "topFullWidth"]
  }), /* @__PURE__ */ O.createElement("div", { className: ee, ref: U, role: "presentation" }, Dr({
    section: X,
    className: Re,
    children: ["left", "center", "right", "fullWidth"]
  })), Dr({
    section: se,
    className: ye,
    style: Me,
    children: ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"]
  }), Dr({
    section: W,
    className: B,
    style: Je,
    children: ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"]
  }), Dr({
    section: he,
    className: Ae,
    style: nt,
    children: ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"]
  }));
}, Bj = Tr(Nj), Gj = (e, t) => {
  const { children: r, eFocusableElement: n, onTabKeyDown: i, gridCtrl: o, forceFocusOutWhenTabGuardsAreEmpty: s } = e, { context: a } = Wt(mr), l = ge(null), u = ge(null), d = ge(), h = (v) => {
    const w = v == null ? void 0 : parseInt(v, 10).toString();
    [l, u].forEach((R) => {
      var b, P;
      w === void 0 ? (b = R.current) == null || b.removeAttribute("tabindex") : (P = R.current) == null || P.setAttribute("tabindex", w);
    });
  };
  S0(t, () => ({
    forceFocusOutOfContainer(v) {
      var w;
      (w = d.current) == null || w.forceFocusOutOfContainer(v);
    }
  }));
  const f = Qe(() => {
    const v = l.current, w = u.current;
    if (!v && !w) {
      d.current = a.destroyBean(d.current);
      return;
    }
    if (v && w) {
      const R = {
        setTabIndex: h
      };
      d.current = a.createBean(
        new HP({
          comp: R,
          eTopGuard: v,
          eBottomGuard: w,
          eFocusableElement: n,
          onTabKeyDown: i,
          forceFocusOutWhenTabGuardsAreEmpty: s,
          focusInnerElement: (b) => o.focusInnerElement(b)
        })
      );
    }
  }, []), p = Qe(
    (v) => {
      l.current = v, f();
    },
    [f]
  ), y = Qe(
    (v) => {
      u.current = v, f();
    },
    [f]
  ), C = (v) => {
    const w = v === "top" ? vd.TAB_GUARD_TOP : vd.TAB_GUARD_BOTTOM;
    return /* @__PURE__ */ O.createElement(
      "div",
      {
        className: `${vd.TAB_GUARD} ${w}`,
        role: "presentation",
        ref: v === "top" ? p : y
      }
    );
  };
  return /* @__PURE__ */ O.createElement(O.Fragment, null, C("top"), r, C("bottom"));
}, Hj = Vh(Gj), Wj = Tr(Hj), Vj = ({ context: e }) => {
  const [t, r] = pe(""), [n, i] = pe(""), [o, s] = pe(""), [a, l] = pe(null), [u, d] = pe(null), [h, f] = pe(!1), [p, y] = pe(), C = ge(), v = ge(null), w = ge(), [R, b] = pe(null), P = ge(() => {
  }), S = ge(), E = ge([]), A = Qe(() => {
  }, []), M = Se(() => e.isDestroyed() ? null : e.getBeans(), [e]);
  $o(" AG Grid ", v);
  const I = Qe((j) => {
    if (v.current = j, C.current = j ? e.createBean(new aW()) : e.destroyBean(C.current), !j || e.isDestroyed())
      return;
    const Q = C.current;
    P.current = Q.focusInnerElement.bind(Q);
    const K = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass: r,
      setGridThemeClass: i,
      forceFocusOutOfContainer: (Z) => {
        var te, se;
        if (!Z && ((te = S.current) != null && te.isDisplayed())) {
          S.current.forceFocusOutOfContainer(Z);
          return;
        }
        (se = w.current) == null || se.forceFocusOutOfContainer(Z);
      },
      updateLayoutClasses: s,
      getFocusableContainers: () => {
        var se;
        const Z = [], te = (se = v.current) == null ? void 0 : se.querySelector(".ag-root");
        return te && Z.push({ getGui: () => te }), E.current.forEach((W) => {
          W.isDisplayed() && Z.push(W);
        }), Z;
      },
      setCursor: l,
      setUserSelect: d
    };
    Q.setComp(K, j, j), f(!0);
  }, []);
  pr(() => {
    const j = C.current, Q = v.current;
    if (!p || !M || !j || !R || !Q)
      return;
    const K = [], {
      watermarkSelector: Z,
      paginationSelector: te,
      sideBarSelector: se,
      statusBarSelector: W,
      gridHeaderDropZonesSelector: U
    } = j.getOptionalSelectors(), X = [];
    if (U) {
      const ce = e.createBean(new U.component()), me = ce.getGui();
      Q.insertAdjacentElement("afterbegin", me), X.push(me), K.push(ce);
    }
    if (se) {
      const ce = e.createBean(new se.component()), me = ce.getGui(), ve = R.querySelector(".ag-tab-guard-bottom");
      ve && (ve.insertAdjacentElement("beforebegin", me), X.push(me)), K.push(ce), E.current.push(ce);
    }
    const he = (ce) => {
      const me = e.createBean(new ce()), ve = me.getGui();
      return Q.insertAdjacentElement("beforeend", ve), X.push(ve), K.push(me), me;
    };
    if (W && he(W.component), te) {
      const ce = he(te.component);
      S.current = ce, E.current.push(ce);
    }
    return Z && he(Z.component), () => {
      e.destroyBeans(K), X.forEach((ce) => {
        var me;
        (me = ce.parentElement) == null || me.removeChild(ce);
      });
    };
  }, [p, R, M]);
  const z = Se(
    () => In("ag-root-wrapper", t, n, o),
    [t, n, o]
  ), k = Se(
    () => In("ag-root-wrapper-body", "ag-focus-managed", o),
    [o]
  ), _ = Se(
    () => ({
      userSelect: u ?? "",
      WebkitUserSelect: u ?? "",
      cursor: a ?? ""
    }),
    [u, a]
  ), q = Qe((j) => {
    w.current = j, y(j !== null);
  }, []);
  return /* @__PURE__ */ O.createElement("div", { ref: I, className: z, style: _, role: "presentation" }, /* @__PURE__ */ O.createElement("div", { className: k, ref: b, role: "presentation" }, h && R && M && /* @__PURE__ */ O.createElement(mr.Provider, { value: M }, /* @__PURE__ */ O.createElement(
    Wj,
    {
      ref: q,
      eFocusableElement: R,
      onTabKeyDown: A,
      gridCtrl: C.current,
      forceFocusOutWhenTabGuardsAreEmpty: !0
    },
    // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    /* @__PURE__ */ O.createElement(Bj, null)
  ))));
}, $j = Tr(Vj), jj = class extends J {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  areHeaderCellsRendered() {
    return this.ctrlsService.getHeaderRowContainerCtrls().every((e) => e.getAllCtrls().every((t) => t.areCellsRendered()));
  }
}, sA = (e) => {
  var v;
  const t = ge(), r = ge(null), n = ge(null), i = ge([]), o = ge([]), s = ge(e), a = ge(), l = ge(), u = ge(!1), [d, h] = pe(void 0), [, f] = pe(0), p = Qe((w) => {
    if (r.current = w, !w) {
      i.current.forEach((k) => k()), i.current.length = 0;
      return;
    }
    const R = e.modules || [];
    n.current || (n.current = new dj(
      () => f((k) => k + 1),
      e.componentWrappingElement,
      e.maxComponentCreationTimeMs
    ), i.current.push(() => {
      var k;
      (k = n.current) == null || k.destroy(), n.current = null;
    }));
    const b = zB(e.gridOptions, e), P = () => {
      if (u.current) {
        const k = () => {
          var q;
          return (q = a.current) != null && q.shouldQueueUpdates() ? void 0 : o.current.shift();
        };
        let _ = k();
        for (; _; )
          _(), _ = k();
      }
    }, S = new Yj(P);
    a.current = S;
    const E = new jj(), A = {
      providedBeanInstances: {
        frameworkComponentWrapper: new Kj(
          n.current,
          b.reactiveCustomComponents ?? L5("reactiveCustomComponents") ?? !0
        ),
        renderStatusService: E
      },
      modules: R,
      frameworkOverrides: S
    }, M = (k) => {
      h(k), k.createBean(E), i.current.push(() => {
        k.destroy();
      }), k.getBean("ctrlsService").whenReady(
        {
          addDestroyFunc: (_) => {
            i.current.push(_);
          }
        },
        () => {
          var q;
          if (k.isDestroyed())
            return;
          const _ = t.current;
          _ && ((q = e.setGridApi) == null || q.call(e, _));
        }
      );
    }, I = (k) => {
      k.getBean("ctrlsService").whenReady(
        {
          addDestroyFunc: (_) => {
            i.current.push(_);
          }
        },
        () => {
          o.current.forEach((_) => _()), o.current.length = 0, u.current = !0;
        }
      );
    }, z = new z5();
    b.gridId ?? (b.gridId = l.current), t.current = z.create(
      w,
      b,
      M,
      I,
      A
    ), i.current.push(() => {
      t.current = void 0;
    }), t.current && (l.current = t.current.getGridId());
  }, []), y = Se(() => ({
    height: "100%",
    ...e.containerStyle || {}
  }), [e.containerStyle]), C = Qe((w) => {
    var R;
    u.current && !((R = a.current) != null && R.shouldQueueUpdates()) ? w() : o.current.push(w);
  }, []);
  return pr(() => {
    const w = Uj(s.current, e);
    s.current = e, C(() => {
      t.current && NB(w, t.current);
    });
  }, [e]), /* @__PURE__ */ O.createElement("div", { style: y, className: e.className, ref: p }, d && !d.isDestroyed() ? /* @__PURE__ */ O.createElement($j, { context: d }) : null, ((v = n.current) == null ? void 0 : v.getPortals()) ?? null);
};
function Uj(e, t) {
  const r = {};
  return Object.keys(t).forEach((n) => {
    const i = t[n];
    e[n] !== i && (r[n] = i);
  }), r;
}
var Kj = class extends U5 {
  constructor(e, t) {
    super(), this.parent = e, this.reactiveCustomComponents = t;
  }
  createWrapper(e, t) {
    if (this.reactiveCustomComponents) {
      const i = ((o) => {
        switch (o) {
          case "filter":
            return rj;
          case "floatingFilterComponent":
            return ij;
          case "dateComponent":
            return ej;
          case "dragAndDropImageComponent":
            return tj;
          case "loadingOverlayComponent":
            return oj;
          case "noRowsOverlayComponent":
            return aj;
          case "statusPanel":
            return lj;
          case "toolPanel":
            return cj;
          case "menuItem":
            return sj;
          case "cellRenderer":
            return Z5;
        }
      })(t.propertyName);
      if (i)
        return new i(e, this.parent, t);
    } else
      switch (t.propertyName) {
        case "filter":
        case "floatingFilterComponent":
        case "dateComponent":
        case "dragAndDropImageComponent":
        case "loadingOverlayComponent":
        case "noRowsOverlayComponent":
        case "statusPanel":
        case "toolPanel":
        case "menuItem":
        case "cellRenderer":
          ly();
          break;
      }
    const r = !t.cellRenderer && t.propertyName !== "toolPanel";
    return new iA(e, this.parent, t, r);
  }
}, qj = Vh((e, t) => {
  const { ctrlsFactory: r, context: n, gos: i, resizeObserverService: o, rowModel: s } = Wt(mr), [a, l] = pe(() => new wn()), [u, d] = pe(() => new wn()), [h, f] = pe(), [p, y] = pe(), C = ge(), v = ge(null), w = ge(), R = Se(() => Cn.__getGridRegisteredModules(e.api.getGridId()), [e]), b = Se(() => a.toString() + " ag-details-row", [a]), P = Se(() => u.toString() + " ag-details-grid", [u]);
  t && S0(t, () => ({
    refresh() {
      var A;
      return ((A = C.current) == null ? void 0 : A.refresh()) ?? !1;
    }
  })), e.template && ie(
    "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/"
  );
  const S = Qe((A) => {
    var z;
    if (v.current = A, !A) {
      C.current = n.destroyBean(C.current), (z = w.current) == null || z.call(w);
      return;
    }
    const M = {
      addOrRemoveCssClass: (k, _) => l((q) => q.setClass(k, _)),
      addOrRemoveDetailGridCssClass: (k, _) => d((q) => q.setClass(k, _)),
      setDetailGrid: (k) => f(k),
      setRowData: (k) => y(k),
      getGui: () => v.current
    }, I = r.getInstance("detailCellRenderer");
    if (I && (n.createBean(I), I.init(M, e), C.current = I, i.get("detailRowAutoHeight"))) {
      const k = () => {
        if (v.current == null)
          return;
        const _ = v.current.clientHeight;
        _ != null && _ > 0 && setTimeout(() => {
          e.node.setRowHeight(_), (At(i) || yo(i)) && s.onRowHeightChanged();
        }, 0);
      };
      w.current = o.observeResize(A, k), k();
    }
  }, []), E = Qe((A) => {
    var M;
    (M = C.current) == null || M.registerDetailWithMaster(A);
  }, []);
  return /* @__PURE__ */ O.createElement("div", { className: b, ref: S }, h && /* @__PURE__ */ O.createElement(
    sA,
    {
      className: P,
      ...h,
      modules: R,
      rowData: p,
      setGridApi: E
    }
  ));
}), Yj = class extends WP {
  constructor(e) {
    super("react"), this.processQueuedUpdates = e, this.queueUpdates = !1, this.frameworkComponents = {
      agGroupCellRenderer: TS,
      agGroupRowRenderer: TS,
      agDetailCellRenderer: qj
    }, this.wrapIncoming = (t, r) => r === "ensureVisible" ? Y5(t) : t(), this.renderingEngine = "react";
  }
  frameworkComponent(e) {
    return this.frameworkComponents[e];
  }
  isFrameworkComponent(e) {
    if (!e)
      return !1;
    const t = e.prototype;
    return !(t && "getGui" in t);
  }
  getLockOnRefresh() {
    this.queueUpdates = !0;
  }
  releaseLockOnRefresh() {
    this.queueUpdates = !1, this.processQueuedUpdates();
  }
  shouldQueueUpdates() {
    return this.queueUpdates;
  }
  runWhenReadyAsync() {
    return q5();
  }
}, aA = class extends R0 {
  constructor() {
    super(...arguments), this.apiListeners = [], this.setGridApi = (e) => {
      this.api = e, this.apiListeners.forEach((t) => t(e));
    };
  }
  registerApiListener(e) {
    this.apiListeners.push(e);
  }
  componentWillUnmount() {
    this.apiListeners.length = 0;
  }
  render() {
    return /* @__PURE__ */ O.createElement(sA, { ...this.props, setGridApi: this.setGridApi });
  }
}, Jj = "ROOT_NODE_ID", Ep = 0, Xj = class {
  constructor(e, t, r, n, i, o) {
    this.nextId = 0, this.rowCountReady = !1, this.allNodesMap = {}, this.rootNode = e, this.gos = t, this.eventService = r, this.funcColsService = n, this.beans = o, this.selectionService = i, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = Jj, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [];
  }
  getCopyOfNodesMap() {
    return EE(this.allNodesMap);
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  setRowData(e) {
    if (typeof e == "string") {
      ie("rowData must be an array.");
      return;
    }
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e);
    const t = this.rootNode, r = this.rootNode.sibling;
    t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, e ? t.allLeafChildren = e.map(
      (n, i) => this.createNode(n, this.rootNode, Ep, i)
    ) : (t.allLeafChildren = [], t.childrenAfterGroup = []), r && (r.childrenAfterFilter = t.childrenAfterFilter, r.childrenAfterGroup = t.childrenAfterGroup, r.childrenAfterAggFilter = t.childrenAfterAggFilter, r.childrenAfterSort = t.childrenAfterSort, r.childrenMapped = t.childrenMapped, r.allLeafChildren = t.allLeafChildren);
  }
  updateRowData(e) {
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e.add);
    const t = {
      rowNodeTransaction: { remove: [], update: [], add: [] },
      rowsInserted: !1
    }, r = [];
    return this.executeRemove(e, t, r), this.executeUpdate(e, t, r), this.executeAdd(e, t), this.updateSelection(r, "rowDataChanged"), t;
  }
  /**
   * Used by the immutable service, after updateRowData, after updating with a generated transaction to
   * apply the order as specified by the the new data. We use sourceRowIndex to determine the order of the rows.
   * Time complexity is O(n) where n is the number of rows/rowData
   * @returns true if the order changed, otherwise false
   */
  updateRowOrderFromRowData(e) {
    const t = this.rootNode.allLeafChildren, r = (t == null ? void 0 : t.length) ?? 0, n = /* @__PURE__ */ new Map();
    let i = -1, o = -1;
    for (let s = 0; s < r; ++s) {
      const a = t[s], l = a.data;
      l !== e[s] && (o < 0 && (i = s), o = s, n.set(l, a));
    }
    if (i < 0)
      return !1;
    for (let s = i; s <= o; ++s) {
      const a = n.get(e[s]);
      a !== void 0 && (t[s] = a, a.sourceRowIndex = s);
    }
    return !0;
  }
  isRowCountReady() {
    return this.rowCountReady;
  }
  dispatchRowDataUpdateStartedEvent(e) {
    this.eventService.dispatchEvent({
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    });
  }
  updateSelection(e, t) {
    const r = e.length > 0;
    r && this.selectionService.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    }), this.selectionService.updateGroupsFromChildrenSelections(t), r && this.eventService.dispatchEvent({
      type: "selectionChanged",
      source: t
    });
  }
  executeAdd(e, t) {
    const r = e.add;
    if (rn(r))
      return;
    const n = this.rootNode.allLeafChildren;
    let i = n.length;
    if (typeof e.addIndex == "number" && (i = this.sanitizeAddIndex(e.addIndex), i > 0 && this.gos.get("treeData")))
      for (let l = 0; l < n.length; l++) {
        const u = n[l];
        if ((u == null ? void 0 : u.rowIndex) == i - 1) {
          i = l + 1;
          break;
        }
      }
    const o = r.map(
      (a, l) => this.createNode(a, this.rootNode, Ep, i + l)
    );
    if (i < n.length) {
      const a = n.slice(0, i), l = n.slice(i, n.length), u = a.length + o.length;
      for (let d = 0, h = l.length; d < h; ++d)
        l[d].sourceRowIndex = u + d;
      this.rootNode.allLeafChildren = [...a, ...o, ...l], t.rowsInserted = !0;
    } else
      this.rootNode.allLeafChildren = n.concat(o);
    const s = this.rootNode.sibling;
    s && (s.allLeafChildren = n), t.rowNodeTransaction.add = o;
  }
  sanitizeAddIndex(e) {
    var r;
    const t = ((r = this.rootNode.allLeafChildren) == null ? void 0 : r.length) ?? 0;
    return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e);
  }
  executeRemove(e, { rowNodeTransaction: t }, r) {
    var s, a;
    const { remove: n } = e;
    if (rn(n))
      return;
    const i = {};
    n.forEach((l) => {
      const u = this.lookupRowNode(l);
      u && (u.isSelected() && r.push(u), u.clearRowTopAndRowIndex(), i[u.id] = !0, delete this.allNodesMap[u.id], t.remove.push(u));
    }), this.rootNode.allLeafChildren = ((s = this.rootNode.allLeafChildren) == null ? void 0 : s.filter((l) => !i[l.id])) ?? null, (a = this.rootNode.allLeafChildren) == null || a.forEach((l, u) => {
      l.sourceRowIndex = u;
    });
    const o = this.rootNode.sibling;
    o && (o.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(e, { rowNodeTransaction: t }, r) {
    const { update: n } = e;
    rn(n) || n.forEach((i) => {
      const o = this.lookupRowNode(i);
      o && (o.updateData(i), !o.selectable && o.isSelected() && r.push(o), this.setMasterForRow(o, i, Ep, !1), t.update.push(o));
    });
  }
  lookupRowNode(e) {
    var n;
    const t = za(this.gos);
    let r;
    if (t) {
      const i = t({ data: e, level: 0 });
      if (r = this.allNodesMap[i], !r)
        return tt(`could not find row id=${i}, data item was not found for this id`), null;
    } else if (r = (n = this.rootNode.allLeafChildren) == null ? void 0 : n.find((i) => i.data === e), !r)
      return tt("could not find data item as object was not found", e), tt("Consider using getRowId to help the Grid find matching row data"), null;
    return r || null;
  }
  createNode(e, t, r, n) {
    const i = new Ti(this.beans);
    return i.sourceRowIndex = n, i.group = !1, this.setMasterForRow(i, e, r, !0), t && (i.parent = t), i.level = r, i.setDataAndId(e, this.nextId.toString()), this.allNodesMap[i.id] && ie(
      `duplicate node id '${i.id}' detected from getRowId callback, this could cause issues in your grid.`
    ), this.allNodesMap[i.id] = i, this.nextId++, i;
  }
  setMasterForRow(e, t, r, n) {
    if (this.gos.get("treeData"))
      e.setMaster(!1), n && (e.expanded = !1);
    else {
      if (this.gos.get("masterDetail")) {
        const s = this.gos.get("isRowMaster");
        s ? e.setMaster(s(t)) : e.setMaster(!0);
      } else
        e.setMaster(!1);
      if (n) {
        const s = this.funcColsService.getRowGroupColumns(), a = s ? s.length : 0, l = r + a;
        e.expanded = e.master ? this.isExpanded(l) : !1;
      }
    }
  }
  isExpanded(e) {
    const t = this.gos.get("groupDefaultExpanded");
    return t === -1 ? !0 : e < t;
  }
}, Qj = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = Ar(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowCountReady = !1;
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.selectionService = e.selectionService, this.valueCache = e.valueCache, this.environment = e.environment, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggregationStage = e.aggregationStage, this.pivotStage = e.pivotStage, this.filterAggregatesStage = e.filterAggregatesStage;
  }
  postConstruct() {
    const e = this.refreshModel.bind(this, { step: $e.EVERYTHING }), t = !this.gos.get("suppressAnimationFrame"), r = this.refreshModel.bind(this, {
      step: $e.EVERYTHING,
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: t
    });
    this.addManagedEventListeners({
      newColumnsLoaded: r,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, { step: $e.PIVOT }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Ti(this.beans), this.nodeManager = new Xj(
      this.rootNode,
      this.gos,
      this.eventService,
      this.funcColsService,
      this.selectionService,
      this.beans
    );
  }
  addPropertyListeners() {
    const e = /* @__PURE__ */ new Set(["treeData", "masterDetail"]), t = /* @__PURE__ */ new Set([
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType"
    ]), r = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), n = /* @__PURE__ */ new Set([
      "removePivotHeaderRowWhenSingleValueColumn",
      "pivotRowTotals",
      "pivotColumnGroupTotals",
      "suppressExpandablePivotGroups"
    ]), i = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "groupIncludeTotalFooter",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), o = /* @__PURE__ */ new Set([
      "postSortRows",
      "groupDisplayType",
      "accentedSort"
    ]), s = /* @__PURE__ */ new Set([]), a = /* @__PURE__ */ new Set([
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupIncludeFooter",
      "groupTotalRow"
    ]), l = [
      ...e,
      ...t,
      ...r,
      ...n,
      ...n,
      ...i,
      ...o,
      ...s,
      ...a
    ];
    this.addManagedPropertyListeners(l, (u) => {
      var f;
      const d = (f = u.changeSet) == null ? void 0 : f.properties;
      if (!d)
        return;
      const h = (p) => d.some((y) => p.has(y));
      if (h(e)) {
        this.setRowData(this.rootNode.allLeafChildren.map((p) => p.data));
        return;
      }
      if (h(t)) {
        this.refreshModel({ step: $e.EVERYTHING });
        return;
      }
      if (h(r)) {
        this.refreshModel({ step: $e.FILTER });
        return;
      }
      if (h(n)) {
        this.refreshModel({ step: $e.PIVOT });
        return;
      }
      if (h(i)) {
        this.refreshModel({ step: $e.AGGREGATE });
        return;
      }
      if (h(o)) {
        this.refreshModel({ step: $e.SORT });
        return;
      }
      if (h(s)) {
        this.refreshModel({ step: $e.FILTER_AGGREGATES });
        return;
      }
      h(a) && this.refreshModel({ step: $e.MAP });
    }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.hasStarted = !0, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData();
  }
  setInitialData() {
    const e = this.gos.get("rowData");
    e && (this.shouldSkipSettingDataOnStart = !0, this.setRowData(e));
  }
  ensureRowHeightsValid(e, t, r, n) {
    let i, o = !1;
    do {
      i = !1;
      const s = this.getRowIndexAtPixel(e), a = this.getRowIndexAtPixel(t), l = Math.max(s, r), u = Math.min(a, n);
      for (let d = l; d <= u; d++) {
        const h = this.getRow(d);
        if (h.rowHeightEstimated) {
          const f = ho(this.gos, h);
          h.setRowHeight(f.height), i = !0, o = !0;
        }
      }
      i && this.setRowTopAndRowIndex();
    } while (i);
    return o;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const r = /* @__PURE__ */ new Set(), n = ar(this.gos, "normal");
    for (let i = 0; i < this.rowsToDisplay.length; i++) {
      const o = this.rowsToDisplay[i];
      if (o.id != null && r.add(o.id), o.rowHeight == null) {
        const s = ho(this.gos, o, n, e);
        o.setRowHeight(s.height, s.estimated);
      }
      o.setRowTop(t), o.setRowIndex(i), t += o.rowHeight;
    }
    return r;
  }
  clearRowTopAndRowIndex(e, t) {
    const r = e.isActive(), n = (o) => {
      o && o.id != null && !t.has(o.id) && o.clearRowTopAndRowIndex();
    }, i = (o) => {
      if (n(o), n(o.detailNode), n(o.sibling), o.hasChildren() && o.childrenAfterGroup) {
        const s = o.level == -1;
        r && !s && !o.expanded || o.childrenAfterGroup.forEach(i);
      }
    };
    i(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, r = 0) {
    const n = this.getRowIndexAtPixel(t), i = this.getRow(n), o = !this.gos.get("suppressAnimationFrame");
    if (i === e[0])
      return !1;
    const s = this.rootNode.allLeafChildren;
    return e.forEach((a) => {
      Fr(s, a);
    }), e.forEach((a, l) => {
      Fd(s, a, Math.max(n + r, 0) + l);
    }), e.forEach((a, l) => {
      a.sourceRowIndex = l;
    }), this.refreshModel({
      step: $e.EVERYTHING,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: o,
      rowNodesOrderChanged: !0
      // We assume the order changed and we don't need to check if it really did
    }), !0;
  }
  highlightRowAtPixel(e, t) {
    const r = t != null ? this.getRowIndexAtPixel(t) : null, n = r != null ? this.getRow(r) : null;
    if (!n || !e || t == null) {
      this.clearHighlightedRow();
      return;
    }
    const i = this.getHighlightPosition(t, n), o = this.isHighlightingCurrentPosition(e, n, i), s = this.lastHighlightedRow != null && this.lastHighlightedRow !== n;
    (o || s) && (this.clearHighlightedRow(), o) || (n.setHighlighted(i), this.lastHighlightedRow = n);
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const i = this.getRowIndexAtPixel(e);
      if (t = this.getRow(i || 0), !t)
        return zl.Below;
    }
    const { rowTop: r, rowHeight: n } = t;
    return e - r < n / 2 ? zl.Above : zl.Below;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isHighlightingCurrentPosition(e, t, r) {
    if (e === t)
      return !0;
    const n = r === zl.Above ? -1 : 1;
    return this.getRow(t.rowIndex + n) === e;
  }
  clearHighlightedRow() {
    this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  /**
   * Returns the number of rows with level === 1
   */
  getTopLevelRowCount() {
    if (this.rowsToDisplay.length === 0)
      return 0;
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return 1;
    const t = this.rootNode.childrenAfterAggFilter, r = this.rootNode.sibling ? 1 : 0;
    return (t ? t.length : 0) + r;
  }
  /**
   * Get the row display index by the top level index
   * top level index is the index of rows with level === 1
   */
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return e;
    let r = e;
    if (this.rowsToDisplay[0].footer) {
      if (e === 0)
        return 0;
      r -= 1;
    }
    const n = this.rowsToDisplay[this.rowsToDisplay.length - 1], i = r >= this.rootNode.childrenAfterSort.length;
    if (n.footer && i)
      return n.rowIndex;
    let o = this.rootNode.childrenAfterSort[r];
    if (this.gos.get("groupHideOpenParents"))
      for (; o.expanded && o.childrenAfterSort && o.childrenAfterSort.length > 0; )
        o = o.childrenAfterSort[0];
    return o.rowIndex;
  }
  getRowBounds(e) {
    if (Ke(this.rowsToDisplay))
      return null;
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = Js(this.gos);
    this.refreshModel({ step: $e.MAP, keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = Js(this.gos), n = e.columns.length === 0 || e.columns.some((i) => i.isPrimary()) ? $e.FILTER : $e.FILTER_AGGREGATES;
    this.refreshModel({ step: n, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = Js(this.gos);
    this.refreshModel({
      step: $e.SORT,
      keepRenderedRows: !0,
      animate: e,
      keepEditingRows: !0
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({ step: $e.PIVOT }) : this.refreshModel({ step: $e.AGGREGATE });
  }
  createChangePath(e) {
    const t = rn(e), r = new Qh(!1, this.rootNode);
    return t && r.setInactive(), r;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null)
      return !1;
    const t = e.rowNodeTransactions.filter(
      (n) => n.add != null && n.add.length > 0 || n.remove != null && n.remove.length > 0
    );
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = $e.EVERYTHING;
    const r = {
      everything: $e.EVERYTHING,
      group: $e.EVERYTHING,
      filter: $e.FILTER,
      map: $e.MAP,
      aggregate: $e.AGGREGATE,
      filter_aggregates: $e.FILTER_AGGREGATES,
      sort: $e.SORT,
      pivot: $e.PIVOT,
      nothing: $e.NOTHING
    };
    if (de(e) && (t = r[e]), Ke(t)) {
      tt(`invalid step ${e}, available steps are ${Object.keys(r).join(", ")}`);
      return;
    }
    const n = !this.gos.get("suppressAnimationFrame");
    return {
      step: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: n
    };
  }
  refreshModel(e) {
    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching())
      return;
    const t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t))
      return;
    const r = this.createChangePath(t.rowNodeTransactions);
    switch (this.isRefreshingModel = !0, t.step) {
      case $e.EVERYTHING:
        this.doRowGrouping(
          t.rowNodeTransactions,
          r,
          !!t.rowNodesOrderChanged,
          !!t.afterColumnsChanged
        );
      case $e.FILTER:
        this.doFilter(r);
      case $e.PIVOT:
        this.doPivot(r);
      case $e.AGGREGATE:
        this.doAggregate(r);
      case $e.FILTER_AGGREGATES:
        this.doFilterAggregates(r);
      case $e.SORT:
        this.doSort(t.rowNodeTransactions, r);
      case $e.MAP:
        this.doRowsToDisplay();
    }
    const n = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(r, n), this.isRefreshingModel = !1, this.eventService.dispatchEvent({
      type: "modelUpdated",
      animate: t.animate,
      keepRenderedRows: t.keepRenderedRows,
      newData: t.newData,
      newPage: !1,
      keepUndoRedoStack: t.keepUndoRedoStack
    });
  }
  isEmpty() {
    const e = Ke(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return Ke(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return de(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let r = !1, n = !1;
    const i = [], o = ls(this.gos);
    return this.forEachNodeAfterFilterAndSort((s) => {
      if (n)
        return;
      if (r && (s === t || s === e) && (n = !0, s.group && o)) {
        i.push(...s.allLeafChildren);
        return;
      }
      if (!r) {
        if (s !== t && s !== e)
          return;
        r = !0;
      }
      if (!s.group || !o) {
        i.push(s);
        return;
      }
    }), i;
  }
  // eslint-disable-next-line
  setDatasource(e) {
    tt("should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0)
      return -1;
    let t = 0, r = this.rowsToDisplay.length - 1;
    if (e <= 0)
      return 0;
    if (Ye(this.rowsToDisplay).rowTop <= e)
      return this.rowsToDisplay.length - 1;
    let i = -1, o = -1;
    for (; ; ) {
      const s = Math.floor((t + r) / 2), a = this.rowsToDisplay[s];
      if (this.isRowInPixel(a, e) || (a.rowTop < e ? t = s + 1 : a.rowTop > e && (r = s - 1), i === t && o === r))
        return s;
      i = t, o = r;
    }
  }
  isRowInPixel(e, t) {
    const r = e.rowTop, n = e.rowTop + e.rowHeight;
    return r <= t && n > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, r) => e(t, r));
  }
  forEachNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback: e,
      recursionType: 0,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback: e,
      recursionType: 1,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback: e,
      recursionType: 2,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback: e,
      recursionType: 3,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: r, recursionType: n, includeFooterNodes: i } = e;
    let { index: o } = e;
    const s = (a) => {
      var p;
      const l = (p = t[0]) == null ? void 0 : p.parent;
      if (!l)
        return;
      const u = i && mE(this.gos), d = vE(this.gos), h = i && d({ node: l });
      if (l === this.rootNode) {
        u === a && (l.createFooter(), r(l.sibling, o++));
        return;
      }
      h === a && (l.createFooter(), r(l.sibling, o++));
    };
    s("top");
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (r(l, o++), l.hasChildren() && !l.footer) {
        let u = null;
        switch (n) {
          case 0:
            u = l.childrenAfterGroup;
            break;
          case 1:
            u = l.childrenAfterAggFilter;
            break;
          case 2:
            u = l.childrenAfterSort;
            break;
          case 3:
            u = l.leafGroup ? null : l.childrenAfterSort;
            break;
        }
        u && (o = this.recursivelyWalkNodesAndCallback({
          nodes: [...u],
          callback: r,
          recursionType: n,
          index: o,
          includeFooterNodes: i
        }));
      }
    }
    return s("bottom"), o;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var t;
    (t = this.aggregationStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  // + gridApi.expandAll()
  // + gridApi.collapseAll()
  expandOrCollapseAll(e) {
    const t = this.gos.get("treeData"), r = this.columnModel.isPivotActive(), n = (i) => {
      i && i.forEach((o) => {
        const s = () => {
          o.expanded = e, n(o.childrenAfterGroup);
        };
        if (t) {
          de(o.childrenAfterGroup) && s();
          return;
        }
        if (r) {
          !o.leafGroup && s();
          return;
        }
        o.group && s();
      });
    };
    this.rootNode && n(this.rootNode.childrenAfterGroup), this.refreshModel({ step: $e.MAP }), this.eventService.dispatchEvent({
      type: "expandOrCollapseAll",
      source: e ? "expandAll" : "collapseAll"
    });
  }
  doSort(e, t) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions: e,
      changedPath: t
    });
  }
  doRowGrouping(e, t, r, n) {
    if (this.groupStage)
      e ? this.groupStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: e,
        rowNodesOrderChanged: r,
        changedPath: t
      }) : this.groupStage.execute({
        rowNode: this.rootNode,
        changedPath: t,
        afterColumnsChanged: n
      }), ls(this.gos) && this.selectionService.updateGroupsFromChildrenSelections(
        "rowGroupChanged",
        t
      ) && this.eventService.dispatchEvent({
        type: "selectionChanged",
        source: "rowGroupChanged"
      });
    else {
      const i = this.rootNode, o = i.sibling;
      i.childrenAfterGroup = i.allLeafChildren, o && (o.childrenAfterGroup = i.childrenAfterGroup), this.rootNode.updateHasChildren();
    }
    this.nodeManager.isRowCountReady() && (this.rowCountReady = !0, this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    }));
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getNodeManager() {
    return this.nodeManager;
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Ti.ID_PREFIX_ROW_GROUP) == 0) {
      let r;
      return this.forEachNode((n) => {
        n.id === e && (r = n);
      }), r;
    }
    return this.nodeManager.getRowNode(e);
  }
  // rows: the rows to put into the model
  setRowData(e) {
    this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh();
  }
  dispatchUpdateEventsAndRefresh() {
    this.eventService.dispatchEvent({
      type: "rowDataUpdated"
    }), this.refreshModel({
      step: $e.EVERYTHING,
      newData: !0
    });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const r = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.isAlive() && this.executeBatchUpdateRowData();
      }, r);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    var n;
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let r = !1;
    (n = this.rowDataTransactionBatch) == null || n.forEach((i) => {
      const { rowNodeTransaction: o, rowsInserted: s } = this.nodeManager.updateRowData(i.rowDataTransaction);
      s && (r = !0), t.push(o), i.callback && e.push(i.callback.bind(null, o));
    }), this.commonUpdateRowData(t, r), e.length > 0 && window.setTimeout(() => {
      e.forEach((i) => i());
    }, 0), t.length > 0 && this.eventService.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    }), this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  /**
   * Used to apply transaction changes.
   * Called by gridApi & rowDragFeature
   */
  updateRowData(e) {
    this.valueCache.onDataChanged();
    const { rowNodeTransaction: t, rowsInserted: r } = this.nodeManager.updateRowData(e);
    return this.commonUpdateRowData([t], r), t;
  }
  /**
   * Used to apply generated transaction
   */
  afterImmutableDataChange(e, t) {
    this.commonUpdateRowData([e], t);
  }
  /**
   * Common to:
   * - executeBatchUpdateRowData (batch transactions)
   * - updateRowData (single transaction)
   * - afterImmutableDataChange (generated transaction)
   *
   * @param rowNodeTrans - the transactions to apply
   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
   */
  commonUpdateRowData(e, t) {
    if (!this.hasStarted)
      return;
    const r = !this.gos.get("suppressAnimationFrame");
    this.eventService.dispatchEvent({
      type: "rowDataUpdated"
    }), this.refreshModel({
      step: $e.EVERYTHING,
      rowNodeTransactions: e,
      rowNodesOrderChanged: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: r
    });
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: $e.MAP,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      keepUndoRedoStack: !0
    });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, !0), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const r = t.detailNode;
      r && r.setRowHeight(r.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      if (this.columnModel.isAutoRowHeightActive())
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.hasStarted || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy(), this.clearHighlightedRow();
  }
};
function Zj(e) {
  e.expansionService.onGroupExpandedOrCollapsed();
}
function e7(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.refreshModel(t);
}
function t7(e) {
  var t, r;
  return ((r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null ? void 0 : r.isEmpty()) ?? !0;
}
function r7(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachLeafNode(t);
}
function n7(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilter(t);
}
function i7(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilterAndSort(t);
}
function o7(e) {
  var t, r;
  if (e.columnModel.isAutoRowHeightActive()) {
    ie("calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
    return;
  }
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null || r.resetRowHeights();
}
function s7(e, t) {
  return e.frameworkOverrides.wrapIncoming(
    () => {
      var r, n;
      return (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null ? void 0 : n.updateRowData(t);
    }
  );
}
function a7(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var n, i;
      return (i = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel()) == null ? void 0 : i.batchUpdateRowData(t, r);
    }
  );
}
function l7(e) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var t, r;
      return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null ? void 0 : r.flushAsyncTransactions();
    }
  );
}
function c7(e) {
  return e.selectionService.getBestCostNodeSelection();
}
var u7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "filterStage";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var r;
    const t = !!((r = this.filterManager) != null && r.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const r = (n, i) => {
      n.hasChildren() && e && !i ? n.childrenAfterFilter = n.childrenAfterGroup.filter((o) => {
        const s = o.childrenAfterFilter && o.childrenAfterFilter.length > 0, a = o.data && this.filterManager.doesRowPassFilter({ rowNode: o });
        return s || a;
      }) : n.childrenAfterFilter = n.childrenAfterGroup, n.sibling && (n.sibling.childrenAfterFilter = n.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const n = (o, s) => {
        if (o.childrenAfterGroup)
          for (let a = 0; a < o.childrenAfterGroup.length; a++) {
            const l = o.childrenAfterGroup[a], u = s || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? n(o.childrenAfterGroup[a], u) : r(l, u);
          }
        r(o, s);
      }, i = (o) => n(o, !1);
      t.executeFromRootNode(i);
    } else {
      const n = (i) => r(i, !1);
      t.forEachChangedNodeDepthFirst(n, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, d7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "flattenStage";
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel;
  }
  execute(e) {
    const t = e.rowNode, r = [], n = this.columnModel.isPivotMode(), i = n && t.leafGroup, o = i ? [t] : t.childrenAfterSort, s = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(s, o, r, n, 0);
    const a = r.length > 0;
    if (!i && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
    a && s.grandTotalRow) {
      t.createFooter();
      const u = s.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(s, t.sibling, r, 0, u);
    }
    return r;
  }
  getFlattenDetails() {
    const e = this.gos.get("groupRemoveSingleChildren");
    return {
      groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"),
      groupRemoveSingleChildren: e,
      isGroupMultiAutoColumn: QN(this.gos),
      hideOpenParents: this.gos.get("groupHideOpenParents"),
      grandTotalRow: mE(this.gos),
      groupTotalRow: vE(this.gos)
    };
  }
  recursivelyAddToRowsToDisplay(e, t, r, n, i) {
    if (!rn(t))
      for (let o = 0; o < t.length; o++) {
        const s = t[o], a = s.hasChildren(), l = n && !a, u = e.groupRemoveSingleChildren && a && s.childrenAfterGroup.length === 1, d = e.groupRemoveLowestSingleChildren && a && s.leafGroup && s.childrenAfterGroup.length === 1, h = n && s.leafGroup, f = e.hideOpenParents && s.expanded && !s.master && !h;
        if (!l && !f && !u && !d && this.addRowNodeToRowsToDisplay(e, s, r, i), !(n && s.leafGroup)) {
          if (a) {
            const y = u || d;
            if (s.expanded || y) {
              const C = e.groupTotalRow({ node: s });
              C || s.destroyFooter();
              const v = y ? i : i + 1;
              C === "top" && (s.createFooter(), this.addRowNodeToRowsToDisplay(e, s.sibling, r, v)), this.recursivelyAddToRowsToDisplay(
                e,
                s.childrenAfterSort,
                r,
                n,
                v
              ), C === "bottom" && (s.createFooter(), this.addRowNodeToRowsToDisplay(e, s.sibling, r, v));
            }
          } else if (s.master && s.expanded) {
            const y = this.createDetailNode(s);
            this.addRowNodeToRowsToDisplay(e, y, r, i);
          }
        }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, r, n, i) {
    i ? r.unshift(t) : r.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : n);
  }
  createDetailNode(e) {
    if (de(e.detailNode))
      return e.detailNode;
    const t = new Ti(this.beans);
    return t.detail = !0, t.selectable = !1, t.parent = e, de(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
}, h7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "immutableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    At(this.gos) && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()));
  }
  isActive() {
    const e = this.gos.exists("getRowId");
    return this.gos.get("resetRowDataOnUpdate") ? !1 : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t)
      return;
    const r = this.clientSideRowModel.getNodeManager(), { rowNodeTransaction: n, rowsInserted: i } = r.updateRowData(t);
    let o = !1;
    this.gos.get("suppressMaintainUnsortedOrder") || (o = r.updateRowOrderFromRowData(e)), this.clientSideRowModel.afterImmutableDataChange(n, o || i);
  }
  /** Converts the setRowData() command to a transaction */
  createTransactionForRowData(e) {
    if (!At(this.gos))
      return tt("ImmutableService only works with ClientSideRowModel"), null;
    const t = za(this.gos);
    if (t == null)
      return tt("ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!"), null;
    const r = this.clientSideRowModel.getNodeManager().getCopyOfNodesMap(), n = [], i = [], o = [];
    return de(e) && e.forEach((s) => {
      const a = t({ data: s, level: 0 }), l = r[a];
      l ? (l.data !== s && i.push(s), r[a] = void 0) : o.push(s);
    }), zn(r, (s, a) => {
      a && n.push(a.data);
    }), { remove: n, update: i, add: o };
  }
  onRowDataUpdated() {
    const e = this.gos.get("rowData");
    e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)));
  }
}, g7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "sortService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.rowNodeSorter = e.rowNodeSorter, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  sort(e, t, r, n, i, o) {
    const s = this.gos.get("groupMaintainOrder"), a = this.columnModel.getCols().some((f) => f.isRowGroupActive());
    let l = {};
    r && n && (l = this.calculateDirtyNodes(n));
    const u = this.columnModel.isPivotMode(), d = this.gos.getCallback("postSortRows"), h = (f) => {
      var C;
      this.pullDownGroupDataForHideOpenParents(f.childrenAfterAggFilter, !0);
      const p = u && f.leafGroup;
      if (s && a && !f.leafGroup && !o) {
        const v = (C = this.funcColsService.getRowGroupColumns()) == null ? void 0 : C[f.level + 1], w = (v == null ? void 0 : v.getSort()) === null, R = f.childrenAfterAggFilter.slice(0);
        if (f.childrenAfterSort && !w) {
          const b = {};
          f.childrenAfterSort.forEach((P, S) => {
            b[P.id] = S;
          }), R.sort(
            (P, S) => (b[P.id] ?? 0) - (b[S.id] ?? 0)
          );
        }
        f.childrenAfterSort = R;
      } else !t || p ? f.childrenAfterSort = f.childrenAfterAggFilter.slice(0) : r ? f.childrenAfterSort = this.doDeltaSort(f, l, i, e) : f.childrenAfterSort = this.rowNodeSorter.doFullSort(f.childrenAfterAggFilter, e);
      if (f.sibling && (f.sibling.childrenAfterSort = f.childrenAfterSort), this.updateChildIndexes(f), d) {
        const v = { nodes: f.childrenAfterSort };
        d(v);
      }
    };
    i && i.forEachChangedNodeDepthFirst(h), this.updateGroupDataForHideOpenParents(i);
  }
  calculateDirtyNodes(e) {
    const t = {}, r = (n) => {
      n && n.forEach((i) => t[i.id] = !0);
    };
    return e && e.forEach((n) => {
      r(n.add), r(n.update), r(n.remove);
    }), t;
  }
  doDeltaSort(e, t, r, n) {
    const i = e.childrenAfterAggFilter, o = e.childrenAfterSort;
    if (!o)
      return this.rowNodeSorter.doFullSort(i, n);
    const s = {}, a = [];
    i.forEach((h) => {
      t[h.id] || !r.canSkip(h) ? a.push(h) : s[h.id] = !0;
    });
    const l = o.filter((h) => s[h.id]), u = (h, f) => ({
      currentPos: f,
      rowNode: h
    }), d = a.map(u).sort((h, f) => this.rowNodeSorter.compareRowNodes(n, h, f));
    return this.mergeSortedArrays(n, d, l.map(u)).map(
      ({ rowNode: h }) => h
    );
  }
  // Merge two sorted arrays into each other
  mergeSortedArrays(e, t, r) {
    const n = [];
    let i = 0, o = 0;
    for (; i < t.length && o < r.length; )
      this.rowNodeSorter.compareRowNodes(e, t[i], r[o]) < 0 ? n.push(t[i++]) : n.push(r[o++]);
    for (; i < t.length; )
      n.push(t[i++]);
    for (; o < r.length; )
      n.push(r[o++]);
    return n;
  }
  updateChildIndexes(e) {
    if (Ke(e.childrenAfterSort))
      return;
    const t = e.childrenAfterSort;
    for (let r = 0; r < t.length; r++) {
      const n = t[r], i = r === 0, o = r === e.childrenAfterSort.length - 1;
      n.setFirstChild(i), n.setLastChild(o), n.setChildIndex(r);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents"))
      return;
    if (this.gos.get("treeData"))
      return ie(
        "The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."
      ), !1;
    const t = (r) => {
      this.pullDownGroupDataForHideOpenParents(r.childrenAfterSort, !1), r.childrenAfterSort.forEach((n) => {
        n.hasChildren() && t(n);
      });
    };
    e && e.executeFromRootNode((r) => t(r));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gos.get("groupHideOpenParents") || Ke(e) || e.forEach((r) => {
      var i;
      (((i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCols()) ?? []).forEach((o) => {
        const s = o.getColDef().showRowGroup;
        if (typeof s != "string") {
          tt(
            "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup"
          );
          return;
        }
        const a = s, l = this.columnModel.getColDefCol(a);
        if (l !== r.rowGroupColumn)
          if (t)
            r.setGroupValue(o.getId(), void 0);
          else {
            const d = this.getFirstChildOfFirstChild(r, l);
            d && r.setGroupValue(o.getId(), d.key);
          }
      });
    });
  }
  getFirstChildOfFirstChild(e, t) {
    let r = e;
    for (; r; ) {
      const n = r.parent;
      if (n && r.firstChild) {
        if (n.rowGroupColumn === t)
          return n;
      } else
        return null;
      r = n;
    }
    return null;
  }
}, f7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "sortStage";
  }
  wireBeans(e) {
    this.sortService = e.sortService, this.sortController = e.sortController;
  }
  execute(e) {
    const t = this.sortController.getSortOptions(), r = de(t) && t.length > 0, n = r && de(e.rowNodeTransactions) && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort"), i = t.some((o) => Zn(this.gos) ? o.column.isPrimary() && o.column.isRowGroupActive() : !!o.column.getColDef().showRowGroup);
    this.sortService.sort(
      t,
      r,
      n,
      e.rowNodeTransactions,
      e.changedPath,
      i
    );
  }
}, cy = "32.3.5", lA = {
  version: cy,
  moduleName: `${vo.ClientSideRowModelModule}-core`,
  rowModel: "clientSide",
  beans: [Qj, u7, f7, d7, g7, h7]
}, p7 = {
  version: cy,
  moduleName: `${vo.ClientSideRowModelModule}-api`,
  beans: [tA],
  apiFunctions: {
    onGroupExpandedOrCollapsed: Zj,
    refreshClientSideRowModel: e7,
    isRowDataEmpty: t7,
    forEachLeafNode: r7,
    forEachNodeAfterFilter: n7,
    forEachNodeAfterFilterAndSort: i7,
    resetRowHeights: o7,
    applyTransaction: s7,
    applyTransactionAsync: a7,
    flushAsyncTransactions: l7,
    getBestCostNodeSelection: c7
  },
  dependantModules: [lA, $5]
}, cA = {
  version: cy,
  moduleName: vo.ClientSideRowModelModule,
  dependantModules: [lA, p7]
}, m7 = class extends PH {
  wireBeans(e) {
    this.beans = e;
  }
  constructor(e, t, r) {
    super(e), this.parentCache = t, this.params = r, this.startRow = e * r.blockSize, this.endRow = this.startRow + r.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(e, t, r) {
    de(t) ? e.setDataAndId(t, r.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (Ke(this.params.datasource.getRows)) {
      ie("datasource is missing getRows method");
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    return {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gos.getGridCommonParams().context
    };
  }
  forEachNode(e, t, r) {
    this.rowNodes.forEach((n, i) => {
      this.startRow + i < r && e(n, t.next());
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.next());
    const r = e - this.startRow;
    return this.rowNodes[r];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  // creates empty row nodes, data is missing as not loaded yet
  createRowNodes() {
    this.rowNodes = [];
    for (let e = 0; e < this.params.blockSize; e++) {
      const t = this.startRow + e, r = new Ti(this.beans);
      r.setRowHeight(this.params.rowHeight), r.uiLevel = 0, r.setRowIndex(t), r.setRowTop(this.params.rowHeight * t), this.rowNodes.push(r);
    }
  }
  processServerResult(e) {
    this.rowNodes.forEach((r, n) => {
      const i = e.rowData ? e.rowData[n] : void 0;
      !r.id && r.alreadyRendered && i && (this.rowNodes[n] = new Ti(this.beans), this.rowNodes[n].setRowIndex(r.rowIndex), this.rowNodes[n].setRowTop(r.rowTop), this.rowNodes[n].setRowHeight(r.rowHeight), r.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[n], i, this.startRow + n);
    });
    const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, t);
  }
  destroy() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    }), super.destroy();
  }
}, v7 = 2, y7 = class extends J {
  constructor(e) {
    super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount, this.params = e;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.focusService = e.focusService;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const r = Math.floor(e / this.params.blockSize);
    let n = this.blocks[r];
    if (!n) {
      if (t)
        return;
      n = this.createBlock(r);
    }
    return n.getRow(e);
  }
  createBlock(e) {
    const t = this.createBean(new m7(e, this, this.params));
    return this.blocks[t.getId()] = t, this.blockCount++, this.purgeBlocksIfNeeded(t), this.params.rowNodeBlockLoader.addBlock(t), t;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)), super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (this.gos.get("debug") && Bn(`InfiniteCache - onPageLoaded: page = ${e.getId()}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((s) => s != e), r = (s, a) => a.getLastAccessed() - s.getLastAccessed();
    t.sort(r);
    const n = this.params.maxBlocksInCache > 0, i = n ? this.params.maxBlocksInCache - 1 : null, o = v7 - 1;
    t.forEach((s, a) => {
      const l = s.getState() === "needsLoading" && a >= o, u = n ? a >= i : !1;
      if (l || u) {
        if (this.isBlockCurrentlyDisplayed(s) || this.isBlockFocused(s))
          return;
        this.removeBlockFromCache(s);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const r = e.getStartRow(), n = e.getEndRow();
    return t.rowIndex >= r && t.rowIndex < n;
  }
  isBlockCurrentlyDisplayed(e) {
    const t = e.getStartRow(), r = e.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(t, r);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const n = (e.getId() + 1) * this.params.blockSize + this.params.overflowSize;
      this.rowCount < n && (this.rowCount = n);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, de(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = new sa();
    this.getBlocksInOrder().forEach((r) => r.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (r, n) => r.getId() - n.getId();
    return vm(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.getId()], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    this.isAlive() && (this.destroyAllBlocksPastVirtualRowCount(), this.eventService.dispatchEvent({
      type: "storeUpdated"
    }));
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.getId() * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const r = [];
    let n = -1, i = !1;
    const o = new sa();
    let s = !1;
    return this.getBlocksInOrder().forEach((l) => {
      if (!s) {
        if (i && n + 1 !== l.getId()) {
          s = !0;
          return;
        }
        n = l.getId(), l.forEachNode(
          (u) => {
            const d = u === e || u === t;
            (i || d) && r.push(u), d && (i = !i);
          },
          o,
          this.rowCount
        );
      }
    }), s || i ? [] : r;
  }
}, C7 = class extends J {
  constructor() {
    super(...arguments), this.beanName = "rowModel";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.sortController = e.sortController, this.selectionService = e.selectionService, this.rowRenderer = e.rowRenderer, this.rowNodeBlockLoader = e.rowNodeBlockLoader;
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  postConstruct() {
    this.gos.get("rowModelType") === "infinite" && (this.rowHeight = Zo(this.gos), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps());
  }
  verifyProps() {
    this.gos.exists("initialGroupOrderComparator") && ie(
      "initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side"
    );
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    this.datasource && (this.destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.onCacheUpdated.bind(this)
    }), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = Zo(this.gos), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let e;
    this.cacheParams ? e = this.isSortModelDifferent() : e = !0, e && this.reset();
  }
  isSortModelDifferent() {
    return !ec(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : [];
  }
  reset() {
    if (!this.datasource)
      return;
    za(this.gos) != null || this.selectionService.reset("rowDataChanged"), this.resetCache();
  }
  dispatchModelUpdatedEvent() {
    this.eventService.dispatchEvent({
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    });
  }
  resetCache() {
    var e;
    this.destroyCache(), this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: ((e = this.filterManager) == null ? void 0 : e.getFilterModel()) ?? {},
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: this.gos.get("infiniteInitialRowCount"),
      maxBlocksInCache: this.gos.get("maxBlocksInCache"),
      rowHeight: Zo(this.gos),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: this.gos.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: this.gos.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: new sa()
    }, this.infiniteCache = this.createBean(new y7(this.cacheParams)), this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    }), this.dispatchModelUpdatedEvent();
  }
  updateRowHeights() {
    this.forEachNode((e) => {
      e.setRowHeight(this.rowHeight), e.setRowTop(this.rowHeight * e.rowIndex);
    }), this.dispatchModelUpdatedEvent();
  }
  destroyCache() {
    this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache));
  }
  onCacheUpdated() {
    this.dispatchModelUpdatedEvent();
  }
  getRow(e) {
    if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
      return this.infiniteCache.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((r) => {
      r.id === e && (t = r);
    }), t;
  }
  forEachNode(e) {
    this.infiniteCache && this.infiniteCache.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), r = this.getRowCount() - 1;
      return t > r ? r : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    this.infiniteCache && this.infiniteCache.refreshCache();
  }
  purgeCache() {
    this.infiniteCache && this.infiniteCache.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1;
  }
  setRowCount(e, t) {
    this.infiniteCache && this.infiniteCache.setRowCount(e, t);
  }
};
function w7(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.refreshCache();
}
function b7(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.purgeCache();
}
function S7(e) {
  var t, r;
  return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null ? void 0 : r.getRowCount();
}
var uy = "32.3.5", uA = {
  version: uy,
  moduleName: `${vo.InfiniteRowModelModule}-core`,
  rowModel: "infinite",
  beans: [C7],
  dependantModules: [FH]
}, x7 = {
  version: uy,
  moduleName: `${vo.InfiniteRowModelModule}-api`,
  beans: [tA],
  apiFunctions: {
    refreshInfiniteCache: w7,
    purgeInfiniteCache: b7,
    getInfiniteRowCount: S7
  },
  dependantModules: [uA, j5]
}, R7 = {
  version: uy,
  moduleName: vo.InfiniteRowModelModule,
  dependantModules: [uA, x7]
}, kS = {};
function dA(e, t) {
  kS[t] || (e(), kS[t] = !0);
}
function E7(e, ...t) {
  dA(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function dy(e, ...t) {
  dA(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function LS(e) {
  return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
}
var hA = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel"
], P7 = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "scrollGapChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnGroupHeaderHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged",
  "overlayExclusiveChanged"
], A7 = [...hA, ...P7], gr = class {
};
gr.STRING_PROPERTIES = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
];
gr.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "theme",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterModel",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy",
  "cellSelection",
  "selectionColumnDef"
];
gr.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
gr.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
gr.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "suppressGroupMaintainValueType",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault"
];
gr.OTHER_PROPERTIES = [
  "suppressStickyTotalRow",
  // needs avoid coercion to boolean so that we can warn if it's unset
  "loadThemeGoogleFonts",
  "rowSelection"
];
gr.FUNCTION_PROPERTIES = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "groupIncludeFooter",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering",
  "chartMenuItems",
  "groupTotalRow"
];
gr.ALL_PROPERTIES = [
  ...gr.ARRAY_PROPERTIES,
  ...gr.OBJECT_PROPERTIES,
  ...gr.STRING_PROPERTIES,
  ...gr.NUMBER_PROPERTIES,
  ...gr.FUNCTION_PROPERTIES,
  ...gr.BOOLEAN_PROPERTIES,
  ...gr.OTHER_PROPERTIES
];
var Nd = gr, Wn = class {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
};
Wn.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
Wn.PUBLIC_EVENTS = hA;
Wn.EVENT_CALLBACKS = A7.map((e) => Wn.getCallbackForEvent(e));
Wn.BOOLEAN_PROPERTIES = Nd.BOOLEAN_PROPERTIES;
Wn.ALL_PROPERTIES = Nd.ALL_PROPERTIES;
Wn.ALL_PROPERTIES_AND_CALLBACKS = [...Wn.ALL_PROPERTIES, ...Wn.EVENT_CALLBACKS];
Wn.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Wn.ALL_PROPERTIES_AND_CALLBACKS);
var F7 = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on drag and drop image component icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on drag and drop image component icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on drag and drop image component icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on drag and drop image component icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on drag and drop image component icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  menuAlt: "menu-alt",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none",
  // Builder button in Advanced Filter
  advancedFilterBuilder: "group",
  // drag handle used to pick up Advanced Filter Builder rows
  advancedFilterBuilderDrag: "grip",
  // Advanced Filter Builder row validation error
  advancedFilterBuilderInvalid: "not-allowed",
  // shown on Advanced Filter Builder rows to move them up
  advancedFilterBuilderMoveUp: "up",
  // shown on Advanced Filter Builder rows to move them down
  advancedFilterBuilderMoveDown: "down",
  // shown on Advanced Filter Builder rows to add new rows
  advancedFilterBuilderAdd: "plus",
  // shown on Advanced Filter Builder rows to remove row
  advancedFilterBuilderRemove: "minus",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus",
  // checked checkbox
  checkboxChecked: "checkbox-checked",
  // indeterminate checkbox
  checkboxIndeterminate: "checkbox-indeterminate",
  // unchecked checkbox
  checkboxUnchecked: "checkbox-unchecked",
  // radio button on
  radioButtonOn: "radio-button-on",
  // radio button off
  radioButtonOff: "radio-button-off"
};
(() => {
  const e = new Set(Object.values(F7));
  return e.add("eye"), e;
})();
function gA(e) {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = parseInt(e);
    return isNaN(t) ? void 0 : t;
  }
}
function Jn(e, t = Number.MAX_VALUE) {
  return (r) => {
    const n = gA(r);
    if (!(n == null || n < e || n > t))
      return n;
  };
}
function El(e) {
  return e.map((t) => `<ag-row-container name="${t}"></ag-row-container>`).join("");
}
`${El(["topLeft", "topCenter", "topRight", "topFullWidth"])}${El(["left", "center", "right", "fullWidth"])}${El(["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}${El(["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}${El(["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}`;
var xr = (e, t) => {
  for (const r in t)
    t[r] = e;
  return t;
};
({
  ...xr("@ag-grid-community/core", {
    dispatchEvent: 0,
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0,
    getState: 0,
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0,
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRow: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRow: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0,
    getModel: 0,
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0,
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0,
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0,
    expireValueCache: 0,
    getValue: 0,
    getCellValue: 0,
    showColumnMenuAfterButtonClick: 0,
    showColumnMenuAfterMouseClick: 0,
    showColumnMenu: 0,
    hidePopupMenu: 0,
    onSortChanged: 0,
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0,
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0,
    setGridAriaProperty: 0,
    refreshCells: 0,
    flashCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0,
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0,
    getColumnDef: 0,
    getColumnDefs: 0,
    sizeColumnsToFit: 0,
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumn: 0,
    getDisplayNameForColumnGroup: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnVisible: 0,
    setColumnsVisible: 0,
    setColumnPinned: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0,
    moveColumn: 0,
    moveColumnByIndex: 0,
    moveColumns: 0,
    setColumnWidth: 0,
    setColumnWidths: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0,
    autoSizeColumn: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0,
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCellEditorInstances: 0,
    getEditingCells: 0,
    stopEditing: 0,
    startEditingCell: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0,
    isAnyFilterPresent: 0,
    onFilterChanged: 0,
    isColumnFilterPresent: 0,
    getFilterInstance: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0,
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0,
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0,
    // These may need updating to say which of multiple possible modules they could be missing from.
    expandAll: 0,
    collapseAll: 0,
    onRowHeightChanged: 0,
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...xr("@ag-grid-community/client-side-row-model", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    resetRowHeights: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0
  }),
  ...xr("@ag-grid-community/csv-export", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...xr("@ag-grid-community/infinite-row-model", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...xr("@ag-grid-enterprise/advanced-filter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...xr("@ag-grid-enterprise/charts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...xr("@ag-grid-enterprise/clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...xr("@ag-grid-enterprise/excel-export", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...xr("@ag-grid-enterprise/master-detail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...xr("@ag-grid-enterprise/menu", {
    showContextMenu: 0,
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...xr("@ag-grid-enterprise/range-selection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...xr("@ag-grid-enterprise/row-grouping", {
    addAggFunc: 0,
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0,
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumn: 0,
    removeValueColumns: 0,
    addValueColumn: 0,
    addValueColumns: 0,
    setRowGroupColumns: 0,
    removeRowGroupColumn: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumn: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0,
    setPivotColumns: 0,
    removePivotColumn: 0,
    removePivotColumns: 0,
    addPivotColumn: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...xr("@ag-grid-enterprise/server-side-row-model", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0
  }),
  ...xr("@ag-grid-enterprise/side-bar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...xr("@ag-grid-enterprise/status-bar", {
    getStatusPanel: 0
  })
});
var M7 = class {
};
Reflect.defineProperty(M7, "name", { value: "GridApi" });
var T7 = [
  // core beans only
  "rowPositionUtils",
  "cellPositionUtils",
  "headerPositionUtils",
  "paginationAutoPageSizeService",
  "apiFunctionService",
  "gridApi",
  "userComponentRegistry",
  "agComponentUtils",
  "componentMetadataProvider",
  "resizeObserverService",
  "userComponentFactory",
  "rowContainerHeightService",
  "horizontalResizeService",
  "localeService",
  "validationService",
  "pinnedRowModel",
  "dragService",
  "visibleColsService",
  "eventService",
  "gos",
  "popupService",
  "selectionService",
  "columnFilterService",
  "quickFilterService",
  "filterManager",
  "columnModel",
  "headerNavigationService",
  "pageBoundsService",
  "paginationService",
  "pageBoundsListener",
  "rowRenderer",
  "expressionService",
  "columnFactory",
  "alignedGridsService",
  "navigationService",
  "valueCache",
  "valueService",
  "loggerFactory",
  "autoWidthCalculator",
  "filterMenuFactory",
  "dragAndDropService",
  "focusService",
  "mouseEventService",
  "environment",
  "cellNavigationService",
  "stylingService",
  "scrollVisibleService",
  "sortController",
  "columnHoverService",
  "columnAnimationService",
  "selectableService",
  "autoColService",
  "controlsColService",
  "changeDetectionService",
  "animationFrameService",
  "undoRedoService",
  "columnDefFactory",
  "rowCssClassCalculator",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsService",
  "pinnedWidthService",
  "rowNodeEventThrottle",
  "ctrlsFactory",
  "dataTypeService",
  "syncService",
  "overlayService",
  "stateService",
  "expansionService",
  "apiEventService",
  "ariaAnnouncementService",
  "menuService",
  "columnApplyStateService",
  "columnEventDispatcher",
  "columnMoveService",
  "columnAutosizeService",
  "columnGetStateService",
  "columnGroupStateService",
  "columnSizeService",
  "funcColsService",
  "columnNameService",
  "columnViewportService",
  "pivotResultColsService",
  "showRowGroupColsService"
];
Object.fromEntries(
  T7.map((e, t) => [e, t])
);
new Map([
  ...Nd.BOOLEAN_PROPERTIES.map((e) => [e, LS]),
  ...Nd.NUMBER_PROPERTIES.map((e) => [e, gA]),
  ["groupAggFiltering", (e) => typeof e == "function" ? e : LS(e)],
  ["pageSize", Jn(1)],
  ["autoSizePadding", Jn(0)],
  ["keepDetailRowsCount", Jn(1)],
  ["rowBuffer", Jn(0)],
  ["infiniteInitialRowCount", Jn(1)],
  ["cacheOverflowSize", Jn(1)],
  ["cacheBlockSize", Jn(1)],
  ["serverSideInitialRowCount", Jn(1)],
  ["viewportRowModelPageSize", Jn(1)],
  ["viewportRowModelBufferSize", Jn(0)]
]);
var Va = typeof global > "u" ? {} : global;
Va.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Va.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Va.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Va.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Va.Node = typeof Node > "u" ? {} : Node;
Va.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var fA = (e, t) => new pA(e.feature, t, e.defaults, e.css), D7 = 0, $a = (e, t = `customPart${++D7}`) => /* @__PURE__ */ new pA(e, t), pA = class Om {
  constructor(t, r, n = {}, i = []) {
    this.feature = t, this.variant = r, this.defaults = n, this.css = i;
  }
  get id() {
    return this.feature ? `${this.feature}/${this.variant}` : this.variant;
  }
  withParams(t) {
    const r = { ...this.defaults };
    for (const [n, i] of Object.entries(t))
      i != null && (r[n] = i);
    return new Om(this.feature, this.variant, r, this.css);
  }
  withAdditionalParams(t) {
    return this.withParams(t);
  }
  withCSS(t) {
    return new Om(this.feature, this.variant, this.defaults, this.css.concat(t));
  }
}, _S = (
  /*css*/
  `:where([class^=ag-]){box-sizing:border-box;outline:none;&:after,&:before,&:focus,&:focus-within{box-sizing:border-box;outline:none}&:where(button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;padding:0}&:where(button){font-weight:inherit}&::-ms-clear{display:none}}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}.ag-virtual-list-viewport .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-watermark{bottom:20px;color:#9b9b9b;opacity:.7;position:absolute;right:25px;transition:opacity 1s ease-out 3s;&:before{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDkiIGhlaWdodD0iMzYiIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyMDkgMzYiPjxwYXRoIGZpbGw9IiM5QjlCOUIiIGQ9Ik0xOTIuOTkzIDIzLjY1OHYtNy45NDZoLTEzLjU0MWwtNy45NDcgNy45NDZ6TTIwOC4yNSAzLjk1aC0xNi45NzRsLTguMDEgNy45NDdoMjQuOTg0ek0xNjMuNjIyIDMxLjYwNWw0LjA2OS00LjA2OWgxMy43MzJ2Ny45NDdoLTE3LjgwMXoiLz48cGF0aCBmaWxsPSIjOUI5QjlCIiBkPSJNMTY2LjYxIDE5Ljc4aDguNzczbDguMDEtNy45NDZIMTY2LjYxek0xNTcuMDExIDMxLjYwNWg2LjYxMWw3Ljg4My03Ljk0N2gtMTQuNDk0ek0xOTEuMjc2IDMuOTVsLTQuMDY4IDQuMDdIMTYxLjI3Vi4wNzJoMzAuMDA2ek0yMC44NCAzMC4yMDZIOC4zNzhsLTIuMTYyIDUuMzRILjc1TDEyLjI1NyA4LjU5Mmg0Ljc2OEwyOC41MyAzNS41NDZoLTUuNTN6bS0xLjcxNy00LjI2TDE0LjYwOSAxNC45NWwtNC41MTQgMTAuOTk4ek0xMDQuNDM3IDE4LjUwOWMxLjU4OS0yLjM1MiA1LjU5NC0yLjYwNyA3LjI0Ny0yLjYwN3Y0LjU3OGMtMi4wMzQgMC00LjA2OS4wNjMtNS4yNzcuOTUzLTEuMjA3Ljg5LTEuODQzIDIuMDk4LTEuODQzIDMuNTZ2MTAuNTUzaC00Ljk1OVYxNS45MDJoNC43Njh6TTExOS4zNzYgMTUuOTAyaC00Ljk1OHYxOS42NDRoNC45NTh6TTExOS4zNzYgNy4xM2gtNC45NTh2NS44NDhoNC45NTh6TTE0My45NzkgNy4xM3YyOC40MTZoLTQuNzY4bC0uMTI3LTIuOTg4YTguMyA4LjMgMCAwIDEtMi42NyAyLjQ4Yy0xLjA4MS41NzItMi40MTYuODktMy45NDIuODktMS4zMzUgMC0yLjYwNi0uMjU1LTMuNjg3LS43LTEuMTQ0LS41MDgtMi4xNjItMS4xNDQtMi45ODgtMi4wMzRhOS42IDkuNiAwIDAgMS0xLjk3MS0zLjE3OWMtLjUwOC0xLjIwNy0uNjk5LTIuNjA2LS42OTktNC4xMzJzLjI1NC0yLjkyNC42OTktNC4xOTZjLjUwOS0xLjI3MSAxLjE0NS0yLjM1MiAxLjk3MS0zLjI0MnMxLjg0NC0xLjU4OSAyLjk4OC0yLjA5OCAyLjM1Mi0uNzYzIDMuNjg3LS43NjNjMS41MjYgMCAyLjc5Ny4yNTUgMy44NzguODI3czEuOTcxIDEuMzM1IDIuNjcgMi40MTZWNy4xOTNoNC45NTl6bS0xMC40MjYgMjQuNTM4YzEuNjUzIDAgMi45MjQtLjU3MiAzLjk0MS0xLjY1M3MxLjUyNi0yLjU0MyAxLjUyNi00LjMyMy0uNTA5LTMuMTc4LTEuNTI2LTQuMzIyYy0xLjAxNy0xLjA4MS0yLjI4OC0xLjY1My0zLjk0MS0xLjY1My0xLjU5IDAtMi45MjUuNTcyLTMuODc4IDEuNjUzLTEuMDE3IDEuMDgtMS41MjYgMi41NDMtMS41MjYgNC4zMjIgMCAxLjc4LjUwOSAzLjE4IDEuNTI2IDQuMjYgMS4wMTcgMS4xNDQgMi4yODggMS43MTYgMy44NzggMS43MTZNNTcuMjAyIDIwLjM1M0g0NC45MzN2NC4yNTloNi45OTNjLS4xOSAyLjE2MS0xLjAxNyAzLjgxNC0yLjQxNiA1LjE1LTEuMzk4IDEuMjctMy4xNzggMS45MDYtNS40NjcgMS45MDYtMS4yNzEgMC0yLjQ4LS4yNTQtMy40OTYtLjY5OWE3IDcgMCAwIDEtMi43MzQtMS45N2MtLjc2My0uODI3LTEuMzM1LTEuODQ0LTEuNzgtMy4wNTJzLS42MzYtMi40OC0uNjM2LTMuOTQyLjE5LTIuNzMzLjYzNi0zLjk0MWMuMzgxLTEuMjA4IDEuMDE3LTIuMTYyIDEuNzgtMy4wNTIuNzYzLS44MjYgMS42NTMtMS40NjIgMi43MzMtMS45N2E5LjEgOS4xIDAgMCAxIDMuNTYtLjdxNC4wMDUgMCA2LjEwMyAxLjkwN2wzLjMwNi0zLjMwNWMtMi40OC0xLjkwNy01LjY1OC0yLjkyNS05LjQwOS0yLjkyNS0yLjA5NyAwLTQuMDA0LjMxOC01LjcyMSAxLjAxOC0xLjcxNi42OTktMy4xNzkgMS41ODktNC4zODYgMi43OTdBMTIuMSAxMi4xIDAgMCAwIDMxLjIgMTYuMjJjLS42MzUgMS43MTctLjk1MyAzLjYyNC0uOTUzIDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1NyAxLjAxNyAyLjAzNSAwIDMuODc4LS4zMTggNS41MzEtMS4wMTcgMS42NTMtLjcgMy4wNTItMS41OSA0LjE5Ni0yLjc5N3ExLjcxNi0xLjgxMiAyLjY3LTQuMzg3Yy42MzYtMS43MTYuOTU0LTMuNjIzLjk1NC01LjY1OHYtLjgyNmMtLjE5MS0uMTI3LS4yNTUtLjQ0NS0uMjU1LS43TTk1Ljk4MiAyMC4zNTNoLTEyLjI3djQuMjU5aDYuOTkzYy0uMTkgMi4xNjEtMS4wMTcgMy44MTQtMi40MTYgNS4xNS0xLjM5OCAxLjI3LTMuMTc4IDEuOTA2LTUuNDY3IDEuOTA2LTEuMjcxIDAtMi40OC0uMjU0LTMuNDk2LS42OTlhNyA3IDAgMCAxLTIuNzM0LTEuOTdjLS43NjMtLjgyNy0xLjMzNS0xLjg0NC0xLjc4LTMuMDUycy0uNjM2LTIuNDgtLjYzNi0zLjk0Mi4xOS0yLjczMy42MzYtMy45NDFjLjM4MS0xLjIwOCAxLjAxNy0yLjE2MiAxLjc4LTMuMDUyLjc2My0uODI2IDEuNjUzLTEuNDYyIDIuNzM0LTEuOTdhOS4xIDkuMSAwIDAgMSAzLjU2LS43cTQuMDA1IDAgNi4xMDMgMS45MDdsMy4zMDUtMy4zMDVjLTIuNDc5LTEuOTA3LTUuNjU4LTIuOTI1LTkuNDA4LTIuOTI1LTIuMDk4IDAtNC4wMDUuMzE4LTUuNzIyIDEuMDE4LTEuNzE2LjY5OS0zLjE3OCAxLjU4OS00LjM4NiAyLjc5N2ExMi4xIDEyLjEgMCAwIDAtMi43OTcgNC4zODZjLS42MzYgMS43MTctLjk1NCAzLjYyNC0uOTU0IDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1OCAxLjAxNyAyLjAzNCAwIDMuODc4LS4zMTggNS41My0xLjAxNyAxLjY1My0uNyAzLjA1Mi0xLjU5IDQuMTk2LTIuNzk3cTEuNzE4LTEuODEyIDIuNjctNC4zODdjLjYzNi0xLjcxNi45NTQtMy42MjMuOTU0LTUuNjU4di0uODI2Yy0uMTktLjEyNy0uMjU1LS40NDUtLjI1NS0uNyIvPjwvc3ZnPg==);background-repeat:no-repeat;background-size:170px 40px;content:"";display:block;height:40px;width:170px}}.ag-watermark-text{font-family:Impact,sans-serif;font-size:19px;font-weight:700;opacity:.5}.ag-ltr .ag-watermark-text{padding-left:.7rem}.ag-rtl .ag-watermark-text{padding-right:.7rem}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&.ag-layout-normal{overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}.ag-ltr .ag-floating-bottom-full-width-container,.ag-ltr .ag-floating-top-full-width-container,.ag-ltr .ag-full-width-container,.ag-ltr .ag-sticky-bottom-full-width-container,.ag-ltr .ag-sticky-top-full-width-container{left:0}.ag-rtl .ag-floating-bottom-full-width-container,.ag-rtl .ag-floating-top-full-width-container,.ag-rtl .ag-full-width-container,.ag-rtl .ag-sticky-bottom-full-width-container,.ag-rtl .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&.ag-scrollbar-invisible{bottom:0;position:absolute;&.ag-apple-scrollbar{opacity:0;transition:opacity .4s;visibility:hidden;&.ag-scrollbar-active,&.ag-scrollbar-scrolling{opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&.ag-scrollbar-invisible{left:0;right:0}}.ag-body-vertical-scroll{height:100%;&.ag-scrollbar-invisible{top:0;z-index:10}}.ag-ltr .ag-body-vertical-scroll{&.ag-scrollbar-invisible{right:0}}.ag-rtl .ag-body-vertical-scroll{&.ag-scrollbar-invisible{left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&.ag-scroller-corner{overflow-x:hidden}}.ag-ltr .ag-column-moving{.ag-cell,.ag-header-cell{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}.ag-rtl .ag-column-moving{.ag-cell,.ag-header-cell{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}.ag-row-animation .ag-row{transition:transform .4s,top .4s,opacity .2s}.ag-row-animation .ag-row.ag-after-created{transition:transform .4s,top .4s,height .4s,opacity .2s}.ag-row-no-animation .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}.ag-sparkline-wrapper{height:100%;left:0;position:absolute;top:0;width:100%}.ag-full-width-row .ag-cell-wrapper.ag-row-group{align-items:center;height:100%}.ag-cell .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{border-bottom:var(--ag-pinned-row-border);display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}.ag-pinned-left-floating-top,.ag-pinned-right-floating-top{display:inline-block;min-width:0;overflow:hidden;position:relative}.ag-floating-bottom{border-top:var(--ag-pinned-row-border);display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}.ag-pinned-left-floating-bottom,.ag-pinned-right-floating-bottom{display:inline-block;min-width:0;overflow:hidden;position:relative}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-value-slide-out{opacity:1}.ag-ltr .ag-value-slide-out{margin-right:5px;transition:opacity 3s,margin-right 3s}.ag-rtl .ag-value-slide-out{margin-left:5px;transition:opacity 3s,margin-left 3s}:is(.ag-ltr,.ag-rtl) .ag-value-slide-out{transition-timing-function:linear}.ag-value-slide-out-end{opacity:0}.ag-ltr .ag-value-slide-out-end{margin-right:10px}.ag-rtl .ag-value-slide-out-end{margin-left:10px}.ag-opacity-zero{opacity:0!important}.ag-details-row{width:100%}.ag-details-row-fixed-height{height:100%}.ag-details-grid{width:100%}.ag-details-grid-fixed-height{height:100%}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}.ag-right-aligned-header{.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}.ag-pill-select{display:flex;flex-direction:column;.ag-column-drop-list{padding:0}.ag-select{padding-top:var(--ag-spacing)}.ag-picker-field-wrapper{background-color:transparent;border:0}.ag-picker-field-display{cursor:pointer}}.ag-ltr{direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}.ag-rtl{direction:rtl;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}.ag-rtl{.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}.ag-rtl{.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{overflow:hidden;visibility:hidden;width:0;& div{position:absolute}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-group-title-bar .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-direction:row;flex-wrap:wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}.ag-ltr .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}.ag-rtl .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}.ag-group-item-alignment-stretch .ag-group-item{align-items:stretch}.ag-group-item-alignment-start .ag-group-item{align-items:flex-start}.ag-group-item-alignment-end .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}.ag-rtl{text-align:right}.ag-ltr .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}.ag-rtl .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}.ag-ltr .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-rtl .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);color:var(--ag-cell-text-color);font-size:var(--ag-data-font-size);height:var(--ag-row-height);white-space:nowrap;width:100%;--ag-internal-content-line-height:min(calc(var(--ag-row-height) - 1px),var(--ag-line-height,1000px))}:where(.ag-body-vertical-content-no-gap) .ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important;display:none}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height)}.ag-ltr .ag-cell{border-right:var(--ag-column-border)}.ag-rtl .ag-cell{border-left:var(--ag-column-border)}.ag-ltr :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}.ag-rtl :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;&.ag-row-group{align-items:flex-start}>:not(.ag-cell-value):not(.ag-group-value){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}}.ag-ltr .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}.ag-rtl .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}.ag-ltr .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-rtl .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-ltr .ag-group-contracted,.ag-ltr .ag-group-expanded,.ag-ltr .ag-row-drag,.ag-ltr .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}.ag-rtl .ag-group-contracted,.ag-rtl .ag-group-expanded,.ag-rtl .ag-row-drag,.ag-rtl .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}.ag-ltr .ag-group-child-count{margin-left:3px}.ag-rtl .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;position:absolute;width:calc(100% - 1px)}.ag-ltr .ag-row-highlight-above:after,.ag-ltr .ag-row-highlight-below:after{left:1px}.ag-rtl .ag-row-highlight-above:after,.ag-rtl .ag-row-highlight-below:after{right:1px}.ag-row-highlight-above:after{top:-1px}.ag-row-highlight-above.ag-row-first:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row-hover.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}.ag-ltr .ag-right-aligned-cell{text-align:right}.ag-rtl .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}.ag-cell:not(.ag-cell-inline-editing),.ag-full-width-row .ag-cell-wrapper.ag-row-group{-webkit-font-smoothing:subpixel-antialiased}.ag-ltr .ag-cell:not(.ag-cell-inline-editing),.ag-ltr .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-rtl .ag-cell:not(.ag-cell-inline-editing),.ag-rtl .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.5)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}.ag-ltr .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}.ag-rtl .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{opacity:1}50%{opacity:.4}to{opacity:1}}.ag-loading{align-items:center;display:flex;height:100%}.ag-ltr .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}.ag-rtl .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}.ag-ltr .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}.ag-rtl .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-details-row{padding:calc(var(--ag-spacing)*3.75)}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left):not(.ag-cell-range-single-cell){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right):not(.ag-cell-range-single-cell){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header,.ag-pinned-right-header{height:100%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing),.ag-cell-range-selected:not(.ag-cell-focus){background-color:var(--ag-range-selection-background-color);&.ag-cell-range-chart{background-color:var(--ag-range-selection-chart-background-color)!important;&.ag-cell-range-chart-category{background-color:var(--ag-range-selection-chart-category-background-color)!important}}}.ag-cell-range-selected-1:not(.ag-cell-focus),.ag-root:not(.ag-context-menu-open) .ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-1:not(.ag-cell-inline-editing){background-color:var(--ag-range-selection-background-color)}.ag-cell-range-selected-2:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-3:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-4:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell){&.ag-cell-range-top{border-top-color:var(--ag-range-selection-border-color);border-top-style:var(--ag-range-selection-border-style)}&.ag-cell-range-right{border-right-color:var(--ag-range-selection-border-color);border-right-style:var(--ag-range-selection-border-style)}&.ag-cell-range-bottom{border-bottom-color:var(--ag-range-selection-border-color);border-bottom-style:var(--ag-range-selection-border-style)}&.ag-cell-range-left{border-left-color:var(--ag-range-selection-border-color);border-left-style:var(--ag-range-selection-border-style)}}.ag-ltr,.ag-rtl{.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}}.ag-cell.ag-selection-fill-top,.ag-cell.ag-selection-fill-top.ag-cell-range-selected{border-top:1px dashed;border-top-color:var(--ag-range-selection-border-color)}.ag-ltr .ag-cell.ag-selection-fill-right,.ag-ltr .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}.ag-rtl .ag-cell.ag-selection-fill-right,.ag-rtl .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}.ag-cell.ag-selection-fill-bottom,.ag-cell.ag-selection-fill-bottom.ag-cell-range-selected{border-bottom:1px dashed;border-bottom-color:var(--ag-range-selection-border-color)}.ag-ltr .ag-cell.ag-selection-fill-left,.ag-ltr .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}.ag-rtl .ag-cell.ag-selection-fill-left,.ag-rtl .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}.ag-fill-handle,.ag-range-handle{background-color:var(--ag-range-selection-border-color);bottom:-1px;height:6px;position:absolute;width:6px}.ag-ltr .ag-fill-handle,.ag-ltr .ag-range-handle{right:-1px}.ag-rtl .ag-fill-handle,.ag-rtl .ag-range-handle{left:-1px}.ag-fill-handle{cursor:cell}.ag-ltr .ag-range-handle{cursor:nwse-resize}.ag-rtl .ag-range-handle{cursor:nesw-resize}.ag-cell-inline-editing{border:var(--ag-input-focus-border)!important}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input{flex:1 1 auto}.ag-floating-filter-input .ag-input-field-input[type=date]{width:1px}.ag-input-field-input{min-width:0;width:100%}.ag-column-select-header-filter-wrapper,.ag-filter-filter,.ag-filter-toolpanel-search,.ag-mini-filter{.ag-input-wrapper:before{background-color:currentColor;content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:50%;position:absolute;width:12px}}.ag-ltr .ag-column-select-header-filter-wrapper,.ag-ltr .ag-filter-filter,.ag-ltr .ag-filter-toolpanel-search,.ag-ltr .ag-mini-filter{.ag-input-wrapper:before{margin-left:var(--ag-spacing)}& input.ag-number-field-input,& input.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}.ag-rtl .ag-column-select-header-filter-wrapper,.ag-rtl .ag-filter-filter,.ag-rtl .ag-filter-toolpanel-search,.ag-rtl .ag-mini-filter{.ag-input-wrapper:before{margin-right:var(--ag-spacing)}& input.ag-number-field-input,& input.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}.ag-advanced-filter-header{align-items:center;background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);display:flex;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);position:relative}.ag-advanced-filter{align-items:center;display:flex;width:100%}.ag-advanced-filter-apply-button,.ag-advanced-filter-builder-button{line-height:normal;white-space:nowrap}.ag-ltr .ag-advanced-filter-apply-button,.ag-ltr .ag-advanced-filter-builder-button{margin-left:calc(var(--ag-spacing)*2)}.ag-rtl .ag-advanced-filter-apply-button,.ag-rtl .ag-advanced-filter-builder-button{margin-right:calc(var(--ag-spacing)*2)}.ag-advanced-filter-builder-button{align-items:center;background-color:unset;border:0;display:flex;font-size:var(--ag-font-size);font-weight:600;padding:var(--ag-spacing);&:hover:not(:disabled){background-color:var(--ag-row-hover-color)}&:not(:disabled){cursor:pointer}}.ag-ltr .ag-advanced-filter-builder-button-label{margin-left:var(--ag-spacing)}.ag-rtl .ag-advanced-filter-builder-button-label{margin-right:var(--ag-spacing)}.ag-advanced-filter-builder{display:flex;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-advanced-filter-builder-list{flex:1;overflow:auto}.ag-advanced-filter-builder-button-panel{border-top:var(--ag-advanced-filter-builder-button-bar-border);display:flex;justify-content:flex-end;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-ltr .ag-advanced-filter-builder .ag-advanced-filter-builder-button-panel{.ag-advanced-filter-builder-apply-button,.ag-advanced-filter-builder-cancel-button{margin-left:calc(var(--ag-spacing)*2)}}.ag-rtl .ag-advanced-filter-builder .ag-advanced-filter-builder-button-panel{.ag-advanced-filter-builder-apply-button,.ag-advanced-filter-builder-cancel-button{margin-right:calc(var(--ag-spacing)*2)}}.ag-advanced-filter-builder-item-wrapper{align-items:center;display:flex;flex:1 1 auto;justify-content:space-between;overflow:hidden}.ag-ltr .ag-advanced-filter-builder-item-wrapper{padding-left:calc(var(--ag-icon-size)/2);padding-right:var(--ag-icon-size)}.ag-rtl .ag-advanced-filter-builder-item-wrapper{padding-left:var(--ag-icon-size);padding-right:calc(var(--ag-icon-size)/2)}.ag-virtual-list-viewport .ag-advanced-filter-builder-item-wrapper .ag-tab-guard{position:absolute}.ag-advanced-filter-builder-item-tree-lines>*{width:var(--ag-advanced-filter-builder-indent-size)}.ag-advanced-filter-builder-item-tree-lines .ag-advanced-filter-builder-item-tree-line-root{width:var(--ag-icon-size);&:before{height:50%;top:50%}}.ag-advanced-filter-builder-item-tree-line-horizontal,.ag-advanced-filter-builder-item-tree-line-vertical,.ag-advanced-filter-builder-item-tree-line-vertical-bottom,.ag-advanced-filter-builder-item-tree-line-vertical-top{align-items:center;display:flex;height:100%;position:relative;&:after,&:before{content:"";height:100%;position:absolute}}.ag-advanced-filter-builder-item-tree-line-horizontal:after{border-bottom:1px solid var(--ag-border-color);height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size))}.ag-ltr .ag-advanced-filter-builder-item-tree-line-horizontal:after{left:calc(var(--ag-icon-size)/2)}.ag-rtl .ag-advanced-filter-builder-item-tree-line-horizontal:after{right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical:before{top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}.ag-ltr .ag-advanced-filter-builder-item-tree-line-vertical:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}.ag-rtl .ag-advanced-filter-builder-item-tree-line-vertical:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-top:before{height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}.ag-ltr .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}.ag-rtl .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{height:calc(50% - var(--ag-icon-size)*1.5/2);top:calc(50% + var(--ag-icon-size)*1.5/2);width:calc(var(--ag-icon-size)/2)}.ag-ltr .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}.ag-rtl .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-condition{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing)}.ag-advanced-filter-builder-item,.ag-advanced-filter-builder-item-buttons,.ag-advanced-filter-builder-item-condition,.ag-advanced-filter-builder-item-tree-lines,.ag-advanced-filter-builder-pill,.ag-advanced-filter-builder-pill-wrapper{align-items:center;display:flex;height:100%}.ag-advanced-filter-builder-pill-wrapper{margin:0 var(--ag-spacing)}.ag-advanced-filter-builder-pill{border-radius:var(--ag-border-radius);min-height:calc(100% - var(--ag-spacing)*3);min-width:calc(var(--ag-spacing)*2);padding:var(--ag-spacing) calc(var(--ag-spacing)*2);position:relative;.ag-advanced-filter-builder-value-number{font-family:monospace;font-weight:700}.ag-advanced-filter-builder-value-empty{color:var(--ag-subtle-text-color)}}.ag-ltr .ag-advanced-filter-builder-pill{.ag-picker-field-display{margin-right:var(--ag-spacing)}}.ag-rtl .ag-advanced-filter-builder-pill{.ag-picker-field-display{margin-left:var(--ag-spacing)}}.ag-advanced-filter-builder-item-button,.ag-advanced-filter-builder-pill{&:focus-visible{shadow:var(--ag-focus-shadow)}}.ag-advanced-filter-builder-pill-display{font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-advanced-filter-builder-join-pill{background-color:var(--ag-advanced-filter-builder-join-pill-color);cursor:pointer}.ag-advanced-filter-builder-column-pill{background-color:var(--ag-advanced-filter-builder-column-pill-color);cursor:pointer}.ag-advanced-filter-builder-option-pill{background-color:var(--ag-advanced-filter-builder-option-pill-color);cursor:pointer}.ag-advanced-filter-builder-value-pill{background-color:var(--ag-advanced-filter-builder-value-pill-color);cursor:text;max-width:140px;.ag-advanced-filter-builder-pill-display{display:block}}.ag-advanced-filter-builder-item-buttons>*{margin:0 calc(var(--ag-spacing)*.5)}.ag-advanced-filter-builder-item-button{color:var(--ag-subtle-text-color);cursor:pointer;position:relative}.ag-advanced-filter-builder-item-button-disabled{cursor:default;opacity:.5}.ag-advanced-filter-builder-virtual-list-container{top:var(--ag-spacing)}.ag-advanced-filter-builder-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:hover{background-color:var(--ag-row-hover-color);.ag-advanced-filter-builder-item-button{opacity:100%}}}.ag-advanced-filter-builder-validation .ag-advanced-filter-builder-invalid,.ag-advanced-filter-builder-virtual-list-item-highlight .ag-advanced-filter-builder-item-button:focus-visible{opacity:100%}.ag-advanced-filter-builder-invalid{color:var(--ag-invalid-color);cursor:default;margin:0 var(--ag-spacing)}.ag-cell-inline-editing{border-radius:var(--ag-border-radius);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-editor .ag-wrapper,.ag-cell-editor input,.ag-cell-wrapper{height:100%;line-height:normal;width:100%}}.ag-autocomplete-list-popup,.ag-popup-editor .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{height:auto;padding:var(--ag-cell-horizontal-padding)}.ag-rtl .ag-large-text-input textarea{resize:none}.ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding)}.ag-chart{display:flex;height:100%;position:relative;width:100%}.ag-chart-components-wrapper{display:flex}.ag-chart-canvas-wrapper,.ag-chart-components-wrapper{flex:1 1 auto;position:relative}.ag-chart-menu{display:flex;flex-direction:column;position:absolute;top:16px}.ag-ltr .ag-chart-menu{right:20px}.ag-rtl .ag-chart-menu{left:20px}.ag-chart-docked-container{min-width:var(--ag-chart-menu-panel-width);position:relative}.ag-chart-menu-hidden~.ag-chart-docked-container{display:none}.ag-chart-tabbed-menu{display:flex;flex-direction:column;height:100%;overflow:hidden;width:100%}.ag-chart-tabbed-menu-header{cursor:default;flex:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-tabbed-menu-body{align-items:stretch;display:flex;flex:1 1 auto;overflow:hidden}.ag-chart-tab{overflow:hidden;overflow-y:auto;width:100%}.ag-chart-settings{overflow-x:hidden}.ag-chart-settings-wrapper{display:flex;flex-direction:column;height:100%;overflow:hidden;position:relative;width:100%}.ag-chart-settings-nav-bar{align-items:center;display:flex;height:30px;padding:0 10px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-chart-settings-card-selector{align-items:center;display:flex;flex:1 1 auto;height:100%;justify-content:space-around;padding:0 10px}.ag-chart-settings-card-item{background-color:var(--ag-foreground-color);border-radius:4px;cursor:pointer;height:10px;height:8px;position:relative;width:10px;width:8px;&.ag-not-selected{opacity:.2}&:before{background-color:transparent;content:" ";display:block;height:20px;left:50%;margin-left:-10px;margin-top:-10px;position:absolute;top:50%;width:20px}&.ag-selected{background-color:var(--ag-accent-color)}}.ag-chart-settings-next,.ag-chart-settings-prev{flex:none;position:relative;&:focus-within{border-radius:1px;box-shadow:var(--ag-focus-shadow)}}.ag-chart-settings-next-button,.ag-chart-settings-prev-button{cursor:pointer;height:100%;left:0;opacity:0;position:absolute;top:0;width:100%}.ag-chart-settings-mini-charts-container{flex:1 1 auto;overflow-x:hidden;overflow-y:auto;position:relative}.ag-chart-settings-mini-wrapper{display:flex;flex-direction:column;left:0;min-height:100%;overflow:hidden;position:absolute;top:0;width:100%;&.ag-animating{transition:left .3s;transition-timing-function:ease-in-out}}.ag-chart-mini-thumbnail{cursor:pointer}.ag-chart-mini-thumbnail-canvas{display:block}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper,.ag-chart-format-wrapper{display:flex;flex-direction:column;padding-bottom:16px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper{height:100%;overflow-y:auto}.ag-chart-advanced-settings{background-color:var(--ag-chrome-background-color)}.ag-chart-advanced-settings,.ag-chart-advanced-settings-wrapper{width:100%}.ag-chart-advanced-settings-wrapper{padding-bottom:0}.ag-chart-advanced-settings-section,.ag-chart-data-section,.ag-chart-format-section{display:flex;margin:0}.ag-chart-advanced-settings-section{border-bottom:1px solid var(--ag-border-color)}.ag-chart-empty-text{align-items:center;background-color:var(--ag-background-color);display:flex;height:100%;justify-content:center;top:0;width:100%}.ag-chart .ag-chart-menu{display:none}.ag-chart-menu-hidden:hover .ag-chart-menu{display:block}.ag-chart{.ag-chart-menu-wrapper{.ag-chart-menu{display:flex;flex-direction:row;gap:20px;top:8px;width:auto}}}.ag-ltr .ag-chart{.ag-chart-menu-wrapper{.ag-chart-menu{justify-content:right;right:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}}}.ag-rtl .ag-chart{.ag-chart-menu-wrapper{.ag-chart-menu{justify-content:left;left:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}}}.ag-charts-font-size-color{align-self:stretch;display:flex;justify-content:space-between}.ag-charts-data-group-item{position:relative}.ag-charts-data-group-item:not(:last-child){margin-bottom:var(--ag-spacing)}.ag-chart-menu{background:var(--ag-background-color);border-radius:var(--ag-border-radius)}.ag-chart-menu-icon{border-radius:var(--ag-border-radius);cursor:pointer;margin:2px 0;opacity:.5;opacity:.8;&:hover{opacity:1}}.ag-chart-menu-toolbar-button{background-color:unset;border:0;border-radius:1px;padding:0 2px}.ag-chart-mini-thumbnail{border:1px solid var(--ag-border-color);border-radius:5px;&.ag-selected{border-color:var(--ag-accent-color);border-width:2px}&:focus-visible{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}}.ag-chart-data-column-drag-handle{margin-left:var(--ag-spacing)}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-title-bar{position:relative}.ag-charts-advanced-settings-top-level-group-title-bar{background-color:unset;position:relative}.ag-charts-advanced-settings-top-level-group-title-bar:focus-visible,.ag-charts-data-group-title-bar:focus-visible,.ag-charts-format-top-level-group-title-bar:focus-visible,.ag-charts-settings-group-title-bar:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-charts-data-group-container{padding:calc(var(--ag-widget-container-vertical-padding)*.5) var(--ag-widget-container-horizontal-padding);.ag-charts-data-group-item:not(.ag-charts-format-sub-level-group):not(.ag-pill-select):not(.ag-select){height:var(--ag-list-item-height)}.ag-charts-data-group-item.ag-picker-field{margin-top:var(--ag-spacing)}}.ag-charts-advanced-settings-top-level-group-container,.ag-charts-format-top-level-group-container{margin-left:calc(var(--ag-spacing)*2);padding:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-item,.ag-charts-format-top-level-group-item{margin:var(--ag-spacing) 0}.ag-charts-format-sub-level-group-container{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-charts-settings-group-container{display:grid;grid-template-columns:60px 1fr 60px 1fr 60px;padding:var(--ag-spacing);row-gap:8px;.ag-chart-mini-thumbnail:nth-child(3n+1){grid-column:1}.ag-chart-mini-thumbnail:nth-child(3n+2){grid-column:3}.ag-chart-mini-thumbnail:nth-child(3n+3){grid-column:5}}.ag-chart-data-section,.ag-chart-format-section{display:flex;margin:0}.ag-chart-menu-panel{background-color:var(--ag-chrome-background-color)}.ag-ltr .ag-chart-menu-panel{border-left:1px solid var(--ag-border-color)}.ag-rtl .ag-chart-menu-panel{border-right:1px solid var(--ag-border-color)}.ag-chart-tabbed-menu-body{position:relative;&:after{background:linear-gradient(var(--ag-background-color),transparent);content:"";display:block;height:16px;left:0;position:absolute;right:0;top:0}}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar{border-top:none;font-weight:500;padding:0 calc(var(--ag-spacing)*1.5)}.ag-chart-settings-nav-bar{border-top:1px solid var(--ag-border-color)}.ag-charts-format-sub-level-group-title-bar{background:none;font-weight:500}.ag-chart-data-section,.ag-chart-format-section{.ag-label:not(.ag-group-title-bar){color:var(--ag-chart-menu-label-color)}.ag-label-align-top .ag-label{margin-bottom:var(--ag-widget-vertical-spacing);margin-top:calc(var(--ag-widget-vertical-spacing)*.5)}.ag-slider.ag-label-align-top .ag-label{margin-bottom:0}& label{display:inline-block}}.ag-chart-data-wrapper,.ag-chart-format-wrapper,.ag-charts-data-group-container,.ag-charts-data-group-title-bar,.ag-charts-format-sub-level-group,.ag-charts-format-sub-level-group-container,.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-group-item:last-child,.ag-charts-format-sub-level-group-title-bar,.ag-charts-format-top-level-group,.ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,.ag-charts-format-top-level-group-item,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar{margin:0;padding:0}.ag-charts-data-group,.ag-charts-format-top-level-group{border-top:1px solid var(--ag-border-color)}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-title-bar{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-charts-data-group .ag-charts-data-group-container,.ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,.ag-charts-settings-group .ag-charts-settings-group-container{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-charts-format-sub-level-group-title-bar{padding:var(--ag-widget-vertical-spacing) 0}.ag-charts-format-sub-level-group-container{padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-vertical-spacing)}.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-no-header-group-container>*,.ag-charts-format-top-level-group-container>*{margin-bottom:var(--ag-widget-vertical-spacing)}.ag-chart-advanced-settings-section,.ag-chart-settings-mini-wrapper,.ag-charts-data-group-item{padding-bottom:var(--ag-widget-container-vertical-padding)}.ag-chart-advanced-settings-section{padding-top:var(--ag-widget-container-vertical-padding)}.ag-charts-advanced-settings-top-level-group{.ag-charts-advanced-settings-top-level-group-container,.ag-charts-advanced-settings-top-level-group-title-bar{padding:0 var(--ag-widget-container-horizontal-padding)}}.ag-charts-advanced-settings-top-level-group-container{margin:0}.ag-charts-advanced-settings-top-level-group-item{margin-bottom:0;margin-top:calc(var(--ag-widget-vertical-spacing)*2)}.ag-chart-menu{--ag-icon-size:20px;background-color:color-mix(in srgb,transparent,var(--ag-background-color) 30%);padding:4px 2px}.ag-chart-settings-card-item.ag-not-selected:hover{opacity:.35}.ag-column-drop{align-items:center;display:inline-flex;overflow:auto;position:relative;width:100%}.ag-column-drop-cell,.ag-column-drop-list{align-items:center;display:flex}.ag-column-drop-cell{gap:var(--ag-spacing);position:relative}.ag-column-drop-cell-text{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-drop-vertical{align-items:stretch;display:flex;flex-direction:column;overflow:hidden}.ag-column-drop-vertical-title-bar{align-items:center;display:flex;flex:none}.ag-column-drop-vertical-list{align-items:stretch;flex-direction:column;flex-grow:1;overflow-x:auto;position:relative;>*{flex:none}}.ag-column-drop-empty .ag-column-drop-vertical-list{overflow:hidden}.ag-column-drop-vertical-empty-message{display:block}.ag-column-drop.ag-column-drop-horizontal{overflow:hidden;white-space:nowrap}.ag-column-drop-cell-button{cursor:pointer}.ag-column-drop-wrapper{display:flex}.ag-column-drop-horizontal-half-width{width:50%!important}.ag-column-drop-cell{background:var(--ag-column-drop-cell-background-color);border:var(--ag-column-drop-cell-border);border-radius:500px;padding:calc(var(--ag-spacing)*.5);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-ltr .ag-column-drop-cell{padding-left:calc(var(--ag-spacing)*.75)}.ag-rtl .ag-column-drop-cell{padding-right:calc(var(--ag-spacing)*.75)}.ag-column-drop-cell-button{min-width:calc(var(--ag-spacing)*4)}.ag-column-drop-cell-ghost{opacity:.5}.ag-column-drop-horizontal{gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height)}.ag-ltr .ag-column-drop-horizontal{padding-left:var(--ag-cell-horizontal-padding)}.ag-rtl .ag-column-drop-horizontal{padding-right:var(--ag-cell-horizontal-padding)}.ag-column-drop-horizontal-list{gap:var(--ag-cell-widget-spacing)}.ag-column-drop-vertical-list{padding-bottom:var(--ag-spacing);padding-left:var(--ag-spacing);padding-right:var(--ag-spacing)}.ag-column-drop-vertical-cell{margin-top:var(--ag-spacing)}.ag-ltr .ag-column-drop-vertical-icon{margin-right:var(--ag-widget-horizontal-spacing)}.ag-rtl .ag-column-drop-vertical-icon{margin-left:var(--ag-widget-horizontal-spacing)}.ag-column-drop-vertical-empty-message{bottom:0;left:0;margin-top:var(--ag-spacing);overflow:hidden;position:absolute;right:0;top:0}.ag-select-agg-func-popup{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);height:calc(var(--ag-spacing)*5*3.5);padding:0;position:absolute}.ag-select-agg-func-virtual-list-item{cursor:default;&:hover{background-color:var(--ag-selected-row-background-color)}&:focus-visible{shadow:var(--ag-focus-shadow)}}.ag-ltr .ag-select-agg-func-virtual-list-item{padding-left:calc(var(--ag-spacing)*2)}.ag-rtl .ag-select-agg-func-virtual-list-item{padding-right:calc(var(--ag-spacing)*2)}.ag-sort-indicator-container{display:contents}.ag-ltr .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}.ag-rtl .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-column-drop-horizontal{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border)}.ag-ltr .ag-column-drop-horizontal-half-width:not(:last-child){border-right:var(--ag-column-border)}.ag-rtl .ag-column-drop-horizontal-half-width:not(:last-child){border-left:var(--ag-column-border)}.ag-column-drop-cell-button{min-width:0;opacity:.75;&:hover{opacity:1}}.ag-column-drop-vertical{min-height:75px}.ag-column-drop-vertical-title-bar{padding:var(--ag-widget-container-vertical-padding) calc(var(--ag-spacing)*2) 0}.ag-column-drop-vertical-empty-message{align-items:center;border:1px dashed;border-color:var(--ag-border-color);display:flex;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);padding:calc(var(--ag-spacing)*2)}.ag-column-select{display:flex;flex:3 1 0px;flex-direction:column;overflow:hidden;position:relative}.ag-column-select-header{flex:none;height:var(--ag-header-height);padding-left:var(--ag-widget-container-horizontal-padding);padding-right:var(--ag-widget-container-horizontal-padding)}.ag-column-select-column,.ag-column-select-column-group,.ag-column-select-header{align-items:center;display:flex;gap:var(--ag-widget-horizontal-spacing);position:relative}.ag-column-select-column,.ag-column-select-column-group{height:100%}.ag-column-select-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-column-select-header-icon{border-radius:var(--ag-border-radius);cursor:pointer;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-column-select-header-filter-wrapper{flex:1 1 auto}.ag-column-select-header-filter{width:100%}.ag-column-select-list{flex:1 1 0px;overflow:hidden}.ag-ltr .ag-column-select-column,.ag-ltr .ag-column-select-column-group{padding-left:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}.ag-rtl .ag-column-select-column,.ag-rtl .ag-column-select-column-group{padding-right:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}.ag-ltr .ag-column-select-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}.ag-rtl .ag-column-select-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}.ag-column-select-column,.ag-column-select-column-group{&:not(:last-child){margin-bottom:var(--ag-widget-vertical-spacing)}}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly{opacity:.5;pointer-events:none}.ag-column-select-virtual-list-viewport{padding:calc(var(--ag-widget-container-vertical-padding)*.5) 0}.ag-column-select-virtual-list-item{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-column-select-column-label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-select-checkbox{display:flex}.ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}.ag-filter-body-wrapper{display:flex;flex-direction:column}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}.ag-floating-filter-full-body>div{flex:1 1 auto}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}}.ag-floating-filter-button{display:flex;flex:none}.ag-set-floating-filter-input input[disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1}.ag-column-panel{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.ag-pivot-mode-panel{display:flex;height:var(--ag-header-height)}.ag-pivot-mode-select{align-items:center;display:flex}.ag-ltr .ag-pivot-mode-select{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-rtl .ag-pivot-mode-select{margin-right:var(--ag-widget-container-horizontal-padding)}.ag-column-panel-column-select{border-bottom:var(--ag-tool-panel-separator-border);border-top:var(--ag-tool-panel-separator-border)}:where(.ag-column-panel) .ag-column-drop-vertical{flex:1 1 0px;min-height:50px;&:where(:not(.ag-last-column-drop)){border-bottom:var(--ag-tool-panel-separator-border)}}.ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);max-width:200px;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2))}.ag-dnd-ghost,.ag-header{display:flex;overflow:hidden;white-space:nowrap}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-header-row:not(:first-child){.ag-header-cell:not(.ag-header-span-height.ag-header-span-total),.ag-header-group-cell.ag-header-group-cell-with-group{border-top:var(--ag-header-row-border)}}.ag-header-row:not(.ag-header-row-column-group){overflow:hidden}.ag-header.ag-header-allow-overflow .ag-header-row{overflow:visible}.ag-header-cell,.ag-header-group-cell{align-items:center;display:inline-flex;gap:var(--ag-cell-widget-spacing);height:100%;overflow:hidden;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:not(.ag-floating-filter),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:hover:before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&.ag-header-cell-moving:before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-filter-button,.ag-header-cell.ag-header-active .ag-header-cell-menu-button{opacity:1}.ag-header-cell-menu-button:not(.ag-header-menu-always-show){opacity:0;transition:opacity .2s}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;gap:var(--ag-spacing);padding:5px 0}.ag-header-cell-label{overflow:hidden;text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;position:sticky}.ag-ltr .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}.ag-rtl .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-group-cell .ag-header-cell-comp-wrapper{display:flex}.ag-header-cell:not(.ag-header-cell-auto-height) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-comp-wrapper{width:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-right-aligned-header .ag-header-cell-label{flex-direction:row-reverse}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-cell-sortable .ag-header-cell-label,.ag-header-expand-icon,.ag-panel-title-bar-button{cursor:pointer}.ag-advanced-filter-header-cell,.ag-header-cell,.ag-header-group-cell{&:focus-visible{box-shadow:inset var(--ag-focus-shadow)}}.ag-ltr :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-rtl :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}.ag-ltr :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}.ag-rtl :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}.ag-ltr .ag-header-cell:after,.ag-ltr .ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group):after{border-right:var(--ag-header-column-border);right:0}.ag-rtl .ag-header-cell:after,.ag-rtl .ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}.ag-ltr .ag-header-highlight-before:after{left:0}.ag-ltr .ag-header-highlight-after:after,.ag-rtl .ag-header-highlight-before:after{right:0}.ag-rtl .ag-header-highlight-after:after{left:0}.ag-ltr .ag-pinned-left-header .ag-header-highlight-after:after{right:1px}.ag-rtl .ag-pinned-left-header .ag-header-highlight-after:after{left:1px}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}.ag-ltr .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}.ag-rtl .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}.ag-header-cell.ag-header-span-height .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group.ag-header-span-height .ag-header-cell-resize{display:none}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;min-width:180px;overflow-y:auto;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-menu-list{cursor:default;display:table;padding:var(--ag-spacing) 0;width:100%}.ag-menu-option,.ag-menu-separator{display:table-row}.ag-menu-option-part,.ag-menu-separator-part{display:table-cell;vertical-align:middle}.ag-menu-option-text{white-space:nowrap}.ag-menu-option-custom{display:contents}.ag-compact-menu-option{display:flex;flex-wrap:nowrap;width:100%}.ag-compact-menu-option-text{flex:1 1 auto;white-space:nowrap}.ag-menu-separator{height:calc(var(--ag-spacing)*2 + 1px)}.ag-menu-separator-part:after{border-top:1px solid var(--ag-menu-separator-color);content:"";display:block}.ag-compact-menu-option-active,.ag-menu-option-active{background-color:var(--ag-row-hover-color)}.ag-compact-menu-option-part,.ag-menu-option-part{line-height:var(--ag-icon-size);padding:calc(var(--ag-spacing) + 2px) 0}.ag-compact-menu-option-disabled,.ag-menu-option-disabled{cursor:not-allowed;opacity:.5}.ag-compact-menu-option-icon,.ag-menu-option-icon{width:var(--ag-icon-size)}.ag-ltr .ag-compact-menu-option-icon,.ag-ltr .ag-menu-option-icon{padding-left:calc(var(--ag-spacing)*2)}.ag-rtl .ag-compact-menu-option-icon,.ag-rtl .ag-menu-option-icon{padding-right:calc(var(--ag-spacing)*2)}.ag-compact-menu-option-text,.ag-menu-option-text{padding-left:calc(var(--ag-spacing)*2);padding-right:calc(var(--ag-spacing)*2)}.ag-ltr .ag-compact-menu-option-shortcut,.ag-ltr .ag-menu-option-shortcut{padding-right:var(--ag-spacing)}.ag-rtl .ag-compact-menu-option-shortcut,.ag-rtl .ag-menu-option-shortcut{padding-left:var(--ag-spacing)}.ag-ltr .ag-compact-menu-option-popup-pointer,.ag-ltr .ag-menu-option-popup-pointer{padding-right:var(--ag-spacing)}.ag-rtl .ag-compact-menu-option-popup-pointer,.ag-rtl .ag-menu-option-popup-pointer{padding-left:var(--ag-spacing)}.ag-menu-column-select-wrapper{height:265px;overflow:auto;.ag-column-select{height:100%}}.ag-menu.ag-tabs{min-width:290px}.ag-filter-separator{border-top:1px solid var(--menu-separator-color)}.ag-filter-select .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}.ag-ltr .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}.ag-rtl .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-ltr .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-rtl .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-ltr .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}.ag-rtl .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}.ag-ltr .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}.ag-rtl .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-menu .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}.ag-ltr .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}.ag-rtl .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}.ag-resizer-wrapper{margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-menu-option{cursor:pointer;font-weight:500}.ag-ltr .ag-menu-option-popup-pointer .ag-icon{text-align:right}.ag-rtl .ag-menu-option-popup-pointer .ag-icon{text-align:left}.ag-panel{background-color:var(--ag-panel-background-color);display:flex;flex-direction:column;overflow:hidden;position:relative}.ag-dialog{border:var(--ag-dialog-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dialog-shadow);position:absolute}.ag-panel-title-bar{align-items:center;background-color:var(--ag-panel-title-bar-background-color);border-bottom:var(--ag-panel-title-bar-border);color:var(--ag-header-text-color);cursor:default;display:flex;flex:none;height:var(--ag-header-height);padding:var(--ag-spacing) var(--ag-cell-horizontal-padding)}.ag-ltr .ag-panel-title-bar-button{margin-left:calc(var(--ag-spacing)*2);margin-right:var(--ag-spacing)}.ag-rtl .ag-panel-title-bar-button{margin-left:var(--ag-spacing);margin-right:calc(var(--ag-spacing)*2)}.ag-panel-title-bar-title{color:var(--ag-header-text-color);flex:1 1 auto;font-weight:500}.ag-panel-title-bar-buttons{display:flex}.ag-panel-title-bar-button{cursor:pointer}.ag-panel-content-wrapper{display:flex;flex:1 1 auto;overflow:hidden;position:relative}.ag-resizer{pointer-events:none;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1;&.ag-resizer-topLeft{height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}.ag-ltr .ag-resizer{&.ag-resizer-topLeft{cursor:nwse-resize}&.ag-resizer-topRight{cursor:nesw-resize}&.ag-resizer-bottomRight{cursor:nwse-resize}&.ag-resizer-bottomLeft{cursor:nesw-resize}}.ag-rtl .ag-resizer{&.ag-resizer-topLeft{cursor:nesw-resize}&.ag-resizer-topRight{cursor:nwse-resize}&.ag-resizer-bottomRight{cursor:nesw-resize}&.ag-resizer-bottomLeft{cursor:nwse-resize}}.ag-dragging-fill-handle .ag-dialog,.ag-dragging-range-handle .ag-dialog{opacity:.7;pointer-events:none}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}.ag-select{align-items:center;display:flex;flex-direction:row;.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}&.ag-disabled{opacity:.5}}.ag-ltr .ag-select{.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}.ag-rtl .ag-select{.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}.ag-rich-select{cursor:default;height:100%}.ag-rich-select-value{align-items:center;background-color:var(--ag-input-background-color);display:flex;height:100%;padding:var(--ag-spacing);.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;&.ag-display-as-placeholder{opacity:.5}}}.ag-rich-select-list{background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);box-shadow:var(--ag-dropdown-shadow);height:auto;position:relative;width:100%;.ag-loading-text{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}}.ag-rich-select-row{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;padding:0 var(--ag-spacing);white-space:nowrap}.ag-rich-select-row-selected{background-color:var(--ag-selected-row-background-color)}.ag-rich-select-row-highlighted,.ag-rich-select-row:hover{background-image:linear-gradient(var(--ag-row-hover-color),var(--ag-row-hover-color))}.ag-rich-select-row-text-highlight{font-weight:700}.ag-rich-select-field-input{flex:1 1 auto;.ag-input-field-input{border:none!important;box-shadow:none!important;padding:0!important;text-overflow:ellipsis;&::-moz-placeholder{opacity:.8}&::placeholder{opacity:.8}}}.ag-ltr .ag-rich-select-field-input{left:var(--ag-spacing)}.ag-rtl .ag-rich-select-field-input{right:var(--ag-spacing)}.ag-popup-editor .ag-rich-select-value{height:var(--ag-row-height);min-width:200px}.ag-rich-select-virtual-list-item{cursor:default;height:var(--ag-list-item-height)}.ag-pill-container{display:flex;flex-wrap:nowrap;gap:.25rem}.ag-pill{align-items:center;background:var(--ag-select-cell-background-color);border:var(--ag-select-cell-border);border-radius:var(--ag-border-radius);display:flex;padding:0 .25rem;white-space:nowrap;&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-pill .ag-pill-button{border:none;padding:0;&:hover{color:var(--ag-accent-color);cursor:pointer}}.ag-ltr .ag-pill .ag-pill-button{margin-left:var(--ag-spacing)}.ag-rtl .ag-pill .ag-pill-button{margin-right:var(--ag-spacing)}ag-grid,ag-grid-angular{display:block}.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-tool-panel-wrapper{cursor:default;display:flex;overflow-x:hidden;overflow-y:auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-side-bar-panel-width)}.ag-select-agg-func-item{align-items:center;display:flex;flex:1 1 auto;flex-direction:row;flex-wrap:nowrap;height:100%;overflow:hidden;position:relative;text-overflow:ellipsis;white-space:nowrap;>*{flex:none}}.ag-tool-panel-horizontal-resize{cursor:ew-resize;height:100%;position:absolute;top:0;width:5px;z-index:1}.ag-ltr .ag-side-bar-left .ag-tool-panel-horizontal-resize{right:-3px}.ag-ltr .ag-side-bar-right .ag-tool-panel-horizontal-resize,.ag-rtl .ag-side-bar-left .ag-tool-panel-horizontal-resize{left:-3px}.ag-rtl .ag-side-bar-right .ag-tool-panel-horizontal-resize{right:-3px}.ag-side-bar{background-color:var(--ag-side-bar-background-color);display:flex;flex-direction:row-reverse;position:relative}.ag-side-bar-left{flex-direction:row;order:-1}.ag-side-buttons{position:relative;width:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-side-button{&.ag-selected{background-color:var(--ag-background-color);border-bottom:1px solid var(--ag-border-color);&:not(:first-of-type){border-top:1px solid var(--ag-border-color)}}}.ag-side-button-button{align-items:center;cursor:pointer;display:flex;flex-direction:column;gap:var(--ag-spacing);padding:calc(var(--ag-spacing)*3) 0;position:relative;white-space:nowrap;width:100%;&:focus{box-shadow:none}}.ag-side-button-button:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-side-button-label{writing-mode:vertical-lr}@media (max-resolution:1.5x){.ag-side-button-label{font-family:"Segoe UI",var(--ag-font-family)}.ag-ltr .ag-side-button-label{transform:rotate(.05deg)}.ag-rtl .ag-side-button-label{transform:rotate(-.05deg)}}.ag-ltr .ag-side-bar-left,.ag-rtl .ag-side-bar-right{border-right:var(--ag-side-panel-border);.ag-tool-panel-wrapper{border-left:var(--ag-side-panel-border)}}.ag-ltr .ag-side-bar-right,.ag-rtl .ag-side-bar-left{border-left:var(--ag-side-panel-border);.ag-tool-panel-wrapper{border-right:var(--ag-side-panel-border)}}.ag-ltr .ag-chart-menu-panel{border-left:var(--ag-side-panel-border)}.ag-rtl .ag-chart-menu-panel{border-right:var(--ag-side-panel-border)}.ag-button{border-radius:0}.ag-standard-button{-moz-appearance:none;appearance:none;-webkit-appearance:none;background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);cursor:pointer;font-family:inherit;padding:var(--ag-spacing) calc(var(--ag-spacing)*2);&:hover{background-color:var(--ag-row-hover-color)}&:active{border-color:var(--ag-accent-color)}&:disabled{background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}}:where(input[class^=ag-][type=button],button[class^=ag-]):focus-visible{box-shadow:var(--ag-focus-shadow)}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow-x:hidden;overflow-y:auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;& span{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}.ag-ltr .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}.ag-rtl .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}.ag-range-field{align-items:center;display:flex;.ag-input-wrapper{height:100%}}& input[class^=ag-][type=range]{-webkit-appearance:none;background:none;height:100%;overflow:visible;padding:0;width:100%;&::-webkit-slider-runnable-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-moz-range-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-webkit-slider-thumb{-webkit-appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&::-moz-ag-range-thumb{-webkit-appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&:focus{&::-webkit-slider-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}&::-moz-ag-range-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}}&:active{&::-webkit-slider-runnable-track{background-color:var(--ag-accent-color)}&::-moz-ag-range-track{background-color:var(--ag-accent-color)}}&:disabled{opacity:.5}}.ag-toggle-button{flex:none;min-width:unset;width:unset}.ag-toggle-button-input-wrapper{background-color:var(--ag-toggle-button-off-background-color);border:solid var(--ag-toggle-button-border-width) var(--ag-toggle-button-off-border-color);border-radius:calc(var(--ag-toggle-button-height)*.5);flex:none;height:var(--ag-toggle-button-height);max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);position:relative;& input{-webkit-appearance:none;-moz-appearance:none;appearance:none;height:100%;opacity:0;width:100%}&:before{background-color:var(--ag-toggle-button-switch-background-color);border:var(--ag-toggle-button-border-width) solid var(--ag-toggle-button-switch-border-color);border-radius:100%;content:"";display:block;height:var(--ag-toggle-button-height);pointer-events:none;position:absolute;top:calc(0px - var(--ag-toggle-button-border-width));width:var(--ag-toggle-button-height)}&.ag-checked{background-color:var(--ag-toggle-button-on-background-color);border-color:var(--ag-toggle-button-on-border-color);&:before{border-color:var(--ag-toggle-button-on-border-color)}}&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{opacity:.5}}.ag-ltr .ag-toggle-button-input-wrapper{&:before{left:calc(0px - var(--ag-toggle-button-border-width));transition:left .1s}&.ag-checked{&:before{left:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-border-width))}}}.ag-rtl .ag-toggle-button-input-wrapper{&:before{right:calc(0px - var(--ag-toggle-button-border-width));transition:right .1s}&.ag-checked{&:before{right:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-border-width))}}}.ag-autocomplete{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}}.ag-autocomplete-list-popup{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-autocomplete-list{height:calc(var(--ag-row-height)*6.5);min-width:200px;position:relative;width:100%}.ag-autocomplete-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:focus-visible:after{content:none}&:hover{background-color:var(--ag-row-hover-color)}}.ag-autocomplete-row{align-items:center;display:flex;flex:1 1 auto;overflow:hidden}.ag-autocomplete-row-label{margin:0 var(--ag-widget-container-horizontal-padding);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-autocomplete-row-selected{background-color:var(--ag-selected-row-background-color)}.ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);white-space:normal}.ag-tooltip,.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:not(.ag-tooltip-interactive),.ag-tooltip:not(.ag-tooltip-interactive){pointer-events:none}.ag-tooltip-custom.ag-tooltip-animate,.ag-tooltip.ag-tooltip-animate{transition:opacity 1s;&.ag-tooltip-hiding{opacity:0}}.ag-angle-select{align-items:center;display:flex}.ag-angle-select-wrapper{display:flex}.ag-angle-select-parent-circle{display:block;position:relative}.ag-angle-select-child-circle{position:absolute}.ag-slider-wrapper{display:flex;.ag-input-field{flex:1 1 auto}}.ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-color-panel{display:flex;flex-direction:column;text-align:center;width:100%}.ag-spectrum-color{cursor:default;flex:1 1 auto;overflow:visible;position:relative}.ag-spectrum-fill{inset:0;position:absolute}.ag-spectrum-val{cursor:pointer}.ag-spectrum-dragger{cursor:pointer;pointer-events:none;position:absolute}.ag-spectrum-alpha,.ag-spectrum-hue{cursor:default}.ag-spectrum-hue-background{background:linear-gradient(270deg,red 3%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);height:100%;width:100%}.ag-spectrum-alpha-background{background:linear-gradient(to right,var(--ag-internal-spectrum-alpha-color-from),var(--ag-internal-spectrum-alpha-color-to)),url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><path d="M0 0H2V4H4V2H0Z" fill="%23b2b2b2"/></svg>') 0 0 /4px 4px;height:100%;width:100%}.ag-spectrum-tool{cursor:pointer;position:relative}.ag-spectrum-slider{pointer-events:none;position:absolute}.ag-spectrum-alpha .ag-spectrum-slider{background:linear-gradient(to bottom,var(--ag-internal-spectrum-alpha-color),var(--ag-internal-spectrum-alpha-color)) var(--ag-background-color)}.ag-recent-colors{display:flex;gap:6px;margin-top:10px}.ag-recent-color{cursor:pointer}.ag-angle-select[disabled]{opacity:.5;pointer-events:none}.ag-ltr .ag-angle-select-field,.ag-ltr .ag-slider-field{margin-right:calc(var(--ag-spacing)*2)}.ag-rtl .ag-angle-select-field,.ag-rtl .ag-slider-field{margin-left:calc(var(--ag-spacing)*2)}.ag-angle-select-parent-circle{background-color:var(--ag-background-color);border:1px solid;border-color:var(--ag-border-color);border-radius:12px;height:24px;width:24px}.ag-angle-select-child-circle{background-color:var(--ag-foreground-color);border-radius:3px;height:6px;left:12px;margin-left:-3px;margin-top:-4px;top:4px;width:6px}.ag-picker-field-wrapper{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:disabled{opacity:.5}&.ag-picker-has-focus,&:focus-within{border:var(--ag-input-focus-border);box-shadow:var(--ag-focus-shadow)}}.ag-picker-field-button{background-color:var(--ag-background-color)}.ag-dialog.ag-color-dialog{border-radius:5px}.ag-color-picker{.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:var(--ag-spacing)}.ag-picker-field-display{align-items:center;display:flex;flex-direction:row;min-height:var(--ag-list-item-height)}}.ag-ltr .ag-color-picker-color,.ag-ltr .ag-color-picker-value{margin-right:var(--ag-spacing)}.ag-rtl .ag-color-picker-color,.ag-rtl .ag-color-picker-value{margin-left:var(--ag-spacing)}.ag-color-panel{padding:var(--ag-spacing)}.ag-spectrum-tools{padding-bottom:0;padding-left:0;padding-right:0}.ag-spectrum-tool{height:12px}.ag-spectrum-alpha-background,.ag-spectrum-hue-background{border-radius:12px}.ag-spectrum-slider{border:3px solid #f8f8f8;border-radius:18px;height:18px;margin-top:-15px;width:18px}.ag-recent-colors{margin-bottom:2px;margin-left:var(--ag-spacing);margin-right:var(--ag-spacing)}.ag-color-input-color,.ag-color-picker-color,.ag-recent-color{border-radius:4px}.ag-recent-color{border:1px solid var(--ag-border-color)}.ag-spectrum-sat{background-image:linear-gradient(90deg,#fff,hsla(20,42%,65%,0))}.ag-spectrum-val{background-image:linear-gradient(0deg,#000,hsla(20,42%,65%,0))}.ag-spectrum-dragger{background:#000;border:3px solid #fff;border-radius:18px;box-shadow:0 0 2px 0 rgba(0,0,0,.24);height:18px;width:18px}.ag-spectrum-alpha-background,.ag-spectrum-hue-background{border-radius:2px}.ag-spectrum-tool{border-radius:2px;height:11px;margin-bottom:10px}.ag-spectrum-slider{border:2px solid #fff;border-radius:13px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:13px;margin-top:-12px;width:13px}.ag-recent-color,.ag-spectrum-color,.ag-spectrum-slider{&:focus-visible:not(:disabled):not([readonly]){box-shadow:var(--ag-focus-shadow)}}.ag-color-input{.ag-color-input-color{position:absolute}}.ag-ltr .ag-color-input{& input[class^=ag-][type=text].ag-input-field-input{padding-left:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-left:var(--ag-spacing)}}.ag-rtl .ag-color-input{& input[class^=ag-][type=text].ag-input-field-input{padding-right:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-right:var(--ag-spacing)}}.ag-color-input-color,.ag-color-picker-color{border:1px solid var(--ag-border-color);border-radius:2px;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-pill-select{.ag-picker-field-display{font-weight:500}.ag-picker-field-display,.ag-picker-field-icon .ag-icon{color:var(--ag-chart-menu-label-color)}}.ag-filter-toolpanel{flex:1 1 0px;min-width:0}.ag-filter-toolpanel-header{position:relative}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{align-items:center;display:flex;>*{align-items:center;display:flex}}.ag-filter-toolpanel-header{height:calc(var(--ag-spacing)*6);&:focus-visible{border-radius:var(--ag-border-radius);box-shadow:inset var(--ag-focus-shadow)}}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{padding:0 var(--ag-spacing)}.ag-filter-toolpanel-group:not(.ag-has-filter)>.ag-group-title-bar .ag-filter-toolpanel-group-instance-header-icon{display:none}.ag-filter-toolpanel-group-level-0-header{height:calc(var(--ag-spacing)*8)}.ag-filter-toolpanel-group-item{margin-bottom:calc(var(--ag-spacing)*.5);margin-top:calc(var(--ag-spacing)*.5)}.ag-filter-toolpanel-search{margin-bottom:var(--ag-spacing);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-toolpanel-search-input{flex-grow:1;height:calc(var(--ag-spacing)*4)}.ag-ltr .ag-filter-toolpanel-group-title-bar-icon{margin-right:var(--ag-spacing)}.ag-rtl .ag-filter-toolpanel-group-title-bar-icon{margin-left:var(--ag-spacing)}.ag-filter-toolpanel-expand{cursor:pointer}.ag-ltr .ag-filter-toolpanel-expand{margin-right:var(--ag-spacing)}.ag-rtl .ag-filter-toolpanel-expand{margin-left:var(--ag-spacing)}.ag-ltr .ag-filter-toolpanel-group-title-bar,.ag-ltr .ag-filter-toolpanel-instance-header{padding-left:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}.ag-rtl .ag-filter-toolpanel-group-title-bar,.ag-rtl .ag-filter-toolpanel-instance-header{padding-right:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}.ag-ltr .ag-filter-toolpanel-instance-body{margin-left:var(--ag-filter-tool-panel-group-indent)}.ag-rtl .ag-filter-toolpanel-instance-body{margin-right:var(--ag-filter-tool-panel-group-indent)}.ag-ltr .ag-filter-toolpanel-group-instance-header-icon,.ag-ltr .ag-filter-toolpanel-instance-header-icon{margin-left:var(--ag-spacing)}.ag-rtl .ag-filter-toolpanel-group-instance-header-icon,.ag-rtl .ag-filter-toolpanel-instance-header-icon{margin-right:var(--ag-spacing)}.ag-filter-toolpanel-instance-filter{background-color:var(--ag-chrome-background-color)}.ag-filter-toolpanel-group-level-0{border-top:none}.ag-filter-toolpanel-header{height:auto;padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing)}.ag-filter-toolpanel-group-item{margin:0}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{color:var(--ag-header-text-color);font-weight:500}.ag-paging-panel{align-items:center;border-top:var(--ag-footer-row-border);display:flex;gap:calc(var(--ag-spacing)*4);height:max(var(--ag-row-height),22px);justify-content:flex-end;padding:0 var(--ag-cell-horizontal-padding)}.ag-paging-page-size .ag-wrapper{min-width:50px}.ag-paging-page-summary-panel{align-items:center;display:flex;gap:var(--ag-cell-widget-spacing);.ag-disabled &{pointer-events:none}}.ag-paging-button{cursor:pointer;position:relative;&:focus-visible{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{cursor:default;opacity:.5}}.ag-paging-number,.ag-paging-row-summary-panel-number{font-weight:500}.ag-status-bar{border-top:var(--ag-footer-row-border);display:flex;justify-content:space-between;line-height:1.5;overflow:hidden;padding-left:calc(var(--ag-spacing)*4);padding-right:calc(var(--ag-spacing)*4)}.ag-status-panel{display:inline-flex}.ag-status-name-value{white-space:nowrap}.ag-status-bar-center,.ag-status-bar-left,.ag-status-bar-right{display:inline-flex}.ag-status-bar-center{text-align:center}.ag-status-name-value{margin-left:var(--ag-spacing);margin-right:var(--ag-spacing);padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding)}.ag-status-name-value-value{font-weight:500}.ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}.ag-icon{display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-column-select-column-group-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}}.ag-column-select-column-readonly .ag-icon-grip,.ag-column-select-column-readonly.ag-icon-grip{opacity:.35}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-contracted .ag-icon,.ag-group-expanded .ag-icon,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons{&:hover{background-color:var(--ag-icon-button-hover-color);border-radius:1px;box-shadow:0 0 0 4px var(--ag-icon-button-hover-color)}}.ag-filter-active{--ag-icon-button-hover-color:color-mix(in srgb,transparent,var(--ag-accent-color) 28%);background-color:color-mix(in srgb,transparent,var(--ag-accent-color) 14%);border-radius:1px;box-shadow:0 0 0 4px color-mix(in srgb,transparent,var(--ag-accent-color) 14%);position:relative;&:after{background-color:var(--ag-accent-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}.ag-icon-filter{clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z")}}.ag-ltr .ag-filter-active{&:after{right:-1px}}.ag-rtl .ag-filter-active{&:after{left:-1px}}.ag-label-align-right{.ag-label{order:1}>*{flex:none}}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-label{white-space:nowrap}.ag-ltr .ag-label{margin-right:var(--ag-spacing)}.ag-rtl .ag-label{margin-left:var(--ag-spacing)}.ag-label-align-top .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}.ag-ltr .ag-label-align-right .ag-label{margin-left:var(--ag-spacing)}.ag-rtl .ag-label-align-right .ag-label{margin-right:var(--ag-spacing)}`
), zS = {
  backgroundColor: "#FFF",
  foregroundColor: "#181d1f",
  textColor: {
    ref: "foregroundColor"
  },
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  borderColor: {
    ref: "foregroundColor",
    mix: 0.15
  },
  wrapperBorder: !0,
  rowBorder: !0,
  browserColorScheme: "light",
  headerRowBorder: {
    ref: "rowBorder"
  },
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: !1,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: !0,
  pinnedRowBorder: !0,
  sidePanelBorder: !0,
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  chromeBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.02,
    onto: "backgroundColor"
  },
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "backgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: {
    ref: "accentColor"
  },
  rangeSelectionBackgroundColor: {
    ref: "accentColor",
    mix: 0.2
  },
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: {
    ref: "accentColor",
    mix: 0.5
  },
  rowHoverColor: {
    ref: "accentColor",
    mix: 0.08
  },
  columnHoverColor: {
    ref: "accentColor",
    mix: 0.05
  },
  selectedRowBackgroundColor: {
    ref: "accentColor",
    mix: 0.12
  },
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: {
    ref: "backgroundColor"
  },
  borderRadius: 4,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  spacing: 8,
  fontSize: 14,
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  popupShadow: {
    radius: 16,
    color: "#00000026"
  },
  dropdownShadow: {
    radius: 4,
    spread: 1,
    offsetY: 1,
    color: "#babfc766"
  },
  dragAndDropImageBackgroundColor: {
    ref: "backgroundColor"
  },
  dragAndDropImageBorder: !0,
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  dragHandleColor: {
    ref: "foregroundColor",
    mix: 0.7
  },
  focusShadow: {
    spread: 3,
    color: { ref: "accentColor", mix: 0.5 }
  },
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  listItemHeight: {
    calc: "iconSize + widgetVerticalSpacing"
  },
  iconSize: 16,
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonBorderWidth: 2,
  toggleButtonOnBorderColor: {
    ref: "accentColor"
  },
  toggleButtonOnBackgroundColor: {
    ref: "accentColor"
  },
  toggleButtonOffBorderColor: {
    ref: "foregroundColor",
    mix: 0.3,
    onto: "backgroundColor"
  },
  toggleButtonOffBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.3,
    onto: "backgroundColor"
  },
  toggleButtonSwitchBorderColor: {
    ref: "toggleButtonOffBorderColor"
  },
  toggleButtonSwitchBackgroundColor: {
    ref: "backgroundColor"
  },
  menuBorder: {
    color: {
      ref: "foregroundColor",
      mix: 0.2
    }
  },
  menuBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.03,
    onto: "backgroundColor"
  },
  menuTextColor: {
    ref: "foregroundColor",
    mix: 0.95,
    onto: "backgroundColor"
  },
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: {
    ref: "foregroundColor",
    mix: 0.8
  },
  iconButtonHoverColor: {
    ref: "foregroundColor",
    mix: 0.1
  },
  dialogShadow: {
    ref: "popupShadow"
  },
  dialogBorder: {
    color: {
      ref: "foregroundColor",
      mix: 0.2
    }
  },
  panelBackgroundColor: {
    ref: "backgroundColor"
  },
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarBorder: !0,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: !0,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipBorder: !0,
  columnDropCellBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.07
  },
  columnDropCellBorder: {
    color: {
      ref: "foregroundColor",
      mix: 0.13
    }
  },
  selectCellBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.07
  },
  selectCellBorder: {
    color: {
      ref: "foregroundColor",
      mix: 0.13
    }
  },
  advancedFilterBuilderButtonBarBorder: !0,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  iconButtonHoverBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.1
  },
  rowLoadingSkeletonEffectColor: "rgba(66, 66, 66, 0.2)"
}, O7 = (e) => e.replace(/[A-Z]/g, (t) => `-${t}`).toLowerCase(), mA = (e) => `--ag-${O7(e)}`, fo = (e) => `var(${mA(e)})`, I7 = (e, t, r) => Math.max(t, Math.min(r, e)), k7 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (r) => {
    const n = r;
    return t.has(n) || t.set(n, e(r)), t.get(n);
  };
}, L7 = k7((e) => {
  if (/Color$/.test(e))
    return "color";
  if (/Scale?$/.test(e))
    return "scale";
  if (e === "spacing" || /(Padding|Spacing|Size|Width|Height|Radius|Indent|Start|End|Top|Bottom|Horizontal|Vertical)$/.test(e))
    return "length";
  if (/Border$/.test(e))
    return "border";
  if (/BorderStyle$/.test(e))
    return "borderStyle";
  if (/Shadow$/.test(e))
    return "shadow";
  if (/Image$/.test(e))
    return "image";
  if (/Family$/.test(e))
    return "fontFamily";
  if (/Weight$/.test(e))
    return "fontWeight";
  if (/Duration$/.test(e))
    return "duration";
  if (/ColorScheme$/.test(e))
    return "colorScheme";
  throw new Error(`"${e}" is not a valid theme parameter.`);
}), Zh = (e) => typeof e == "string" ? e : typeof e == "number" ? String(e) : !1, hy = (e) => {
  if (typeof e == "string")
    return e;
  if ("ref" in e) {
    const t = fo(e.ref);
    return e.mix == null ? t : `color-mix(in srgb, ${e.onto ? "var(--ag-background-color)" : "transparent"}, ${t} ${I7(e.mix * 100, 0, 100)}%)`;
  }
  return !1;
}, _7 = Zh, $s = (e) => typeof e == "string" ? e : typeof e == "number" ? `${e}px` : "calc" in e ? `calc(${e.calc.replace(/ ?[*/+] ?/g, " $& ").replace(/-?[a-z][a-z0-9]*\b(?![-(])/gi, (r) => r[0] === "-" ? r : ` ${fo(r)} `)})` : "ref" in e ? fo(e.ref) : !1, z7 = Zh, N7 = (e, t) => typeof e == "string" ? e : e === !0 ? "solid 1px var(--ag-border-color)" : e === !1 ? t === "columnBorder" ? "solid 1px transparent" : "none" : "ref" in e ? fo(e.ref) : vA(e.style ?? "solid") + " " + $s(e.width ?? 1) + " " + hy(e.color ?? { ref: "borderColor" }), B7 = (e) => typeof e == "string" ? e : e === !1 ? "none" : "ref" in e ? fo(e.ref) : [
  $s(e.offsetX ?? 0),
  $s(e.offsetY ?? 0),
  $s(e.radius ?? 0),
  $s(e.spread ?? 0),
  hy(e.color ?? { ref: "foregroundColor" })
].join(" "), vA = Zh, yA = (e) => typeof e == "string" ? e : "googleFont" in e ? yA(e.googleFont) : "ref" in e ? fo(e.ref) : Array.isArray(e) ? e.map((t) => (typeof t == "object" && "googleFont" in t && (t = t.googleFont), /^[\w-]+$/.test(t) ? t : JSON.stringify(t))).join(", ") : !1, G7 = Zh, CA = (e) => typeof e == "string" ? e : "url" in e ? `url(${JSON.stringify(e.url)})` : "svg" in e ? CA({ url: `data:image/svg+xml,${encodeURIComponent(e.svg)}` }) : "ref" in e ? fo(e.ref) : !1, H7 = (e, t) => typeof e == "string" ? e : typeof e == "number" ? (e > 50 && dy(
  `Numeric value ${e} passed to ${t} param will be interpreted as ${e} seconds. If this is intentional use "${e}s" to silence this warning.`
), `${e}s`) : "ref" in e ? fo(e.ref) : !1, W7 = {
  color: hy,
  colorScheme: _7,
  length: $s,
  scale: z7,
  border: N7,
  borderStyle: vA,
  shadow: B7,
  image: CA,
  fontFamily: yA,
  fontWeight: G7,
  duration: H7
}, V7 = (e, t) => {
  const r = L7(e);
  return W7[r](t, e);
}, $7 = 0, j7 = (e = `customTheme${++$7}`) => /* @__PURE__ */ new q7(e, [], {}), U7 = typeof window != "object" || !window || typeof document != "object" || window.document !== document, K7 = 0, NS = !1, q7 = class Im {
  constructor(t, r = [], n = {}) {
    this.id = t, this.dependencies = r, this.defaults = n, this.useCount = 0;
  }
  withPart(t) {
    return typeof t == "function" && (t = t()), new Im(
      this.id,
      this.dependencies.concat(t),
      this.defaults
    );
  }
  withParams(t) {
    const r = { ...this.defaults };
    for (const [n, i] of Object.entries(t))
      i != null && (r[n] = i);
    return new Im(this.id, this.dependencies, r);
  }
  getCSS() {
    return [_S, ...this._getCSSChunks().map((t) => t.css)].join(`

`);
  }
  startUse(t) {
    ++this.useCount, this.useCount === 1 && this._install(t);
  }
  stopUse() {
    --this.useCount, this.useCount === 0 && setTimeout(() => {
      this.useCount === 0 && BS(this.getCssClass(), this._installRoot);
    }, 1e3);
  }
  getCssClass() {
    return this._cssClass == null && (this._cssClass = `ag-theme-${++K7}`), this._cssClass;
  }
  getParams() {
    if (this._getParamsCache)
      return this._getParamsCache;
    const t = { ...zS };
    for (const r of this._getFlatUnits())
      for (const [n, i] of Object.entries(r.defaults)) {
        const o = i ?? zS[n];
        o != null && (t[n] = o);
      }
    return this._getParamsCache = t;
  }
  async _install({ container: t, loadThemeGoogleFonts: r }) {
    if (U7)
      return;
    NS || (NS = !0, BS("legacy", document.head), getComputedStyle(document.body).getPropertyValue("--ag-legacy-styles-loaded") && dy("both Theming API and the ag-grid.css are used on the same page, styling will be incorrect"));
    let n = t.getRootNode();
    n instanceof ShadowRoot || (n = document.head), this._installRoot = n;
    const i = [];
    i.push(km({ css: _S, part: "core", root: n }));
    for (const o of J7(this))
      r ? X7(o) : r == null && E7(
        `theme uses google font ${o} but no value for loadThemeGoogleFonts was provided. Pass true to load fonts from ${wA} or false to silence this warning.`
      );
    for (const o of this._getCSSChunks())
      km({ css: o.css, part: o.id, scope: this.getCssClass(), root: n });
    return Promise.all(i);
  }
  _getFlatUnits() {
    if (this._getFlatUnitsCache)
      return this._getFlatUnitsCache;
    const t = {};
    for (const n of this.dependencies)
      delete t[n.feature], t[n.feature] = n;
    const r = [
      ...Object.values(t),
      // add `this` at the end so that CSS and params added to the theme override anything added to parts
      this
    ];
    return this._getFlatUnitsCache = r;
  }
  _getCSSChunks() {
    if (this._getCssChunksCache)
      return this._getCssChunksCache;
    const t = [];
    t.push(Y7(this));
    for (const r of this._getFlatUnits())
      if (r.css && r.css.length > 0) {
        let n = `/* Part ${r.id} */`;
        n += r.css.map((i) => typeof i == "function" ? i() : i).join(`
`) + `
`, n = `.${this.getCssClass()} {
	${n}
}`, t.push({ css: n, id: r.id });
      }
    return this._getCssChunksCache = t;
  }
}, Y7 = (e) => {
  let t = "", r = "";
  for (const [o, s] of Object.entries(e.getParams())) {
    const a = V7(o, s);
    if (a === !1)
      dy(`Invalid value for param ${o} - ${Z7(s)}`);
    else {
      const l = mA(o), u = l.replace("--ag-", "--ag-inherited-");
      t += `	${l}: var(${u}, ${a});
`, r += `	${u}: var(${l});
`;
    }
  }
  const n = `:where(.${e.getCssClass()})`;
  let i = `${n} {
${t}}
`;
  return i += `:has(> ${n}):not(${n}) {
${r}}
`, {
    css: i,
    id: "variables"
  };
}, J7 = (e) => Array.from(
  new Set(
    Object.values(e.getParams()).flat().map((t) => t == null ? void 0 : t.googleFont).filter((t) => typeof t == "string")
  )
).sort(), km = async ({ root: e, part: t, scope: r, css: n }) => {
  let i = `:scope > style[data-ag-part="${t}"]`;
  r && (i += `[data-ag-scope="${r}"]`);
  let o = e.querySelector(i);
  if (!o) {
    o = document.createElement("style"), o.dataset.agPart = t, r && (o.dataset.agScope = r);
    const s = e.querySelectorAll(":scope > style[data-ag-part]"), a = s[s.length - 1];
    a ? a.insertAdjacentElement("afterend", o) : e.firstElementChild ? e.firstElementChild.insertAdjacentElement("beforebegin", o) : e.appendChild(o);
  }
  if (o._agTextContent !== n)
    return o.textContent = n, o._agTextContent = n, Q7(o);
}, BS = (e, t) => {
  for (const r of Array.from(t.querySelectorAll(`:scope > style[data-ag-scope="${e}"]`)))
    r.remove();
}, GS = /* @__PURE__ */ new Set(), X7 = async (e) => {
  if (GS.has(e))
    return;
  GS.add(e);
  const t = `@import url('https://${wA}/css2?family=${encodeURIComponent(e)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  return km({ css: t, part: `googleFont:${e}`, root: document.head });
}, wA = "fonts.googleapis.com", Q7 = (e) => new Promise((t) => {
  const r = () => {
    e.removeEventListener("load", r), t();
  };
  e.addEventListener("load", r);
}), Z7 = (e) => e == null ? String(e) : `${typeof e} ${e}`, eU = (
  /*css*/
  '.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);& input{-webkit-appearance:none;-moz-appearance:none;appearance:none;height:100%;opacity:0;width:100%}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&.ag-checked{background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:active,&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&.ag-checked:after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&.ag-indeterminate{background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-radio-button-input-wrapper{border-radius:100%;&.ag-checked:after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}'
), tU = /* @__PURE__ */ $a("checkboxStyle", "default").withAdditionalParams({
  checkboxBorderWidth: 1,
  checkboxBorderRadius: {
    ref: "borderRadius"
  },
  checkboxUncheckedBackgroundColor: {
    ref: "backgroundColor"
  },
  checkboxUncheckedBorderColor: {
    ref: "foregroundColor",
    mix: 0.3,
    onto: "backgroundColor"
  },
  checkboxCheckedBackgroundColor: {
    ref: "accentColor"
  },
  checkboxCheckedBorderColor: {
    ref: "accentColor"
  },
  checkboxCheckedShapeImage: {
    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
  },
  checkboxCheckedShapeColor: {
    ref: "backgroundColor"
  },
  checkboxIndeterminateBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.3,
    onto: "backgroundColor"
  },
  checkboxIndeterminateBorderColor: {
    ref: "foregroundColor",
    mix: 0.3,
    onto: "backgroundColor"
  },
  checkboxIndeterminateShapeImage: {
    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
  },
  checkboxIndeterminateShapeColor: {
    ref: "backgroundColor"
  },
  radioCheckedShapeImage: {
    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
  }
}).withCSS(eU), rU = /* @__PURE__ */ $a("colorScheme", "light"), bA = /* @__PURE__ */ $a("colorScheme", "dark").withParams({
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.05,
    onto: "backgroundColor"
  },
  browserColorScheme: "dark"
}), nU = (
  /*css*/
  `.ag-icon:before{background-color:currentColor;content:"";display:block;height:var(--ag-icon-size);-webkit-mask-image:linear-gradient(#0000,#0000);mask-image:linear-gradient(#0000,#0000);-webkit-mask-size:contain;mask-size:contain;width:var(--ag-icon-size)}.ag-icon-aggregation:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-arrows:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-asc:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cancel:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-chart:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-color-picker:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-columns:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E")}.ag-icon-contracted:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cross:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-csv:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-excel:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E")}.ag-icon-eye:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-filter:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-first:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-group:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E")}.ag-icon-last:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-left:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-linked:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-loading:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E")}.ag-icon-maximize:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E")}.ag-icon-menu:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E")}.ag-icon-minimize:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E")}.ag-icon-minus:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E")}.ag-icon-none:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-not-allowed:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-paste:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pin:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pivot:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-plus:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-right:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-save:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-left:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-right:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-up:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tick:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-up:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-grip:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-settings:before{-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}`
), iU = /* @__PURE__ */ $a("iconSet", "alpine").withCSS(nU), oU = (
  /*css*/
  ":where(input[class^=ag-][type=number]:not(.ag-number-field-input-stepper)){-moz-appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}}:where(input[class^=ag-]:not([type]),input[class^=ag-][type=text],input[class^=ag-][type=number],input[class^=ag-][type=tel],input[class^=ag-][type=date],input[class^=ag-][type=datetime-local],textarea[class^=ag-]){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);cursor:pointer;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color)}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}}&.ag-ltr :where(input[class^=ag-]:not([type]),input[class^=ag-][type=text],input[class^=ag-][type=number],input[class^=ag-][type=tel],input[class^=ag-][type=date],input[class^=ag-][type=datetime-local],textarea[class^=ag-]){padding-left:var(--ag-input-padding-start)}&.ag-rtl :where(input[class^=ag-]:not([type]),input[class^=ag-][type=text],input[class^=ag-][type=number],input[class^=ag-][type=tel],input[class^=ag-][type=date],input[class^=ag-][type=datetime-local],textarea[class^=ag-]){padding-right:var(--ag-input-padding-start)}"
), sU = /* @__PURE__ */ $a("inputStyle", "base").withAdditionalParams({
  inputBackgroundColor: "transparent",
  inputBorder: !1,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  }
}).withCSS(oU), aU = /* @__PURE__ */ fA(sU, "bordered").withParams({
  inputBackgroundColor: {
    ref: "backgroundColor"
  },
  inputBorder: !0,
  inputBorderRadius: {
    ref: "borderRadius"
  },
  inputPaddingStart: {
    ref: "spacing"
  },
  inputFocusBorder: {
    color: { ref: "accentColor" }
  },
  inputFocusShadow: {
    ref: "focusShadow"
  },
  inputDisabledBackgroundColor: {
    ref: "foregroundColor",
    mix: 0.06,
    onto: "backgroundColor"
  },
  inputDisabledTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  inputInvalidBorder: {
    color: { ref: "invalidColor" }
  }
}), lU = (
  /*css*/
  '.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex;.ag-tabs-header{flex:1}}.ag-tabs-close-button-wrapper{border:0;padding:var(--ag-spacing)}&.ag-ltr .ag-tabs-close-button-wrapper{border-right:1px solid var(--ag-border-color)}&.ag-rtl .ag-tabs-close-button-wrapper{border-left:1px solid var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}&:focus-visible{box-shadow:inset var(--ag-focus-shadow)}}&.ag-ltr .ag-tab{&.ag-tab-selected{&:not(:first-of-type){border-left-color:var(--ag-tab-selected-border-color)}&:not(:last-of-type){border-right-color:var(--ag-tab-selected-border-color)}}}&.ag-rtl .ag-tab{&.ag-tab-selected{&:not(:first-of-type){border-right-color:var(--ag-tab-selected-border-color)}&:not(:last-of-type){border-left-color:var(--ag-tab-selected-border-color)}}}'
), cU = /* @__PURE__ */ $a("tabStyle", "base").withAdditionalParams({
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: 1,
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: "0",
  tabSelectedUnderlineTransitionDuration: "0",
  tabBarBorder: !1
}).withCSS(lU), uU = /* @__PURE__ */ fA(cU, "alpine").withParams({
  tabBarBorder: !0,
  tabBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "accentColor"
  },
  tabSelectedTextColor: {
    ref: "accentColor"
  },
  tabSelectedUnderlineColor: {
    ref: "accentColor"
  },
  tabSelectedUnderlineWidth: 2,
  tabSelectedUnderlineTransitionDuration: "0.3s"
}), dU = (e) => j7(e).withPart(tU), SA = /* @__PURE__ */ dU("alpine").withPart(rU).withPart(iU).withPart(uU).withPart(aU).withParams({
  accentColor: "#2196f3",
  selectedRowBackgroundColor: {
    ref: "accentColor",
    mix: 0.3
  },
  inputFocusBorder: {
    color: { ref: "accentColor", mix: 0.4 }
  },
  fontSize: 13,
  dataFontSize: 14,
  headerFontWeight: 700,
  borderRadius: 3,
  wrapperBorderRadius: 3,
  tabSelectedUnderlineColor: { ref: "accentColor" },
  tabSelectedBorderWidth: 2,
  tabSelectedUnderlineTransitionDuration: 0.3
});
Cn.registerModules([cA]);
Cn.registerModules([R7]);
const hU = "#2196F3", gU = {
  rowSelection: "single",
  enableCellTextSelection: !0,
  tooltipShowDelay: 0,
  suppressFieldDotNotation: !0,
  onRowClicked: (e) => {
    var i;
    const t = document.getSelection();
    if (t === null)
      return;
    const r = document.createRange(), n = (i = e == null ? void 0 : e.event) == null ? void 0 : i.target;
    n != null && (r.selectNodeContents(n), t.removeAllRanges(), t.addRange(r));
  }
}, fU = (e, t) => ({
  ...gU,
  ...t || {},
  onCellClicked: (r) => {
    const n = r.column.getColId();
    if (!(e === void 0 || n === void 0)) {
      const i = r.context.activeCol, o = [n, r.column.colDef.headerName];
      e(o), r.context.activeCol = o;
      const s = {
        rowNodes: r.api.getRenderedNodes(),
        //@ts-ignore
        columns: [r.api.getColumn(n), r.api.getColumn(i[0])],
        force: !0
      };
      r.api.refreshCells(s);
    }
  }
});
function qc({
  data_wrapper: e,
  df_viewer_config: t,
  summary_stats_data: r,
  activeCol: n,
  setActiveCol: i,
  outside_df_params: o,
  error_info: s,
  max_rows_in_configs: a
}) {
  var v, w;
  const l = Se(() => Date.now(), []), u = 5, d = t == null ? void 0 : t.component_config, h = (v = t == null ? void 0 : t.extra_grid_config) == null ? void 0 : v.rowHeight, f = JSON.stringify([
    u,
    d,
    h
  ]), p = Se(
    () => {
      var R;
      return Rye(
        a || e.length,
        t.pinned_rows.length,
        t == null ? void 0 : t.component_config,
        (R = t == null ? void 0 : t.extra_grid_config) == null ? void 0 : R.rowHeight
      );
    },
    [f]
  ), y = ["", ""], C = ((w = t == null ? void 0 : t.component_config) == null ? void 0 : w.className) || "ag-theme-alpine-dark";
  return /* @__PURE__ */ He("div", { className: `df-viewer  ${p.classMode} ${p.inIframe}`, children: [
    /* @__PURE__ */ $("pre", { children: s || "" }),
    /* @__PURE__ */ $(
      "div",
      {
        style: p.applicableStyle,
        className: `theme-hanger ${C}`,
        children: /* @__PURE__ */ $(
          pU,
          {
            data_wrapper: e,
            df_viewer_config: t,
            summary_stats_data: r || [],
            activeCol: n || y,
            setActiveCol: i,
            outside_df_params: o,
            renderStartTime: l,
            hs: p
          }
        )
      }
    )
  ] });
}
function pU({
  data_wrapper: e,
  df_viewer_config: t,
  summary_stats_data: r,
  activeCol: n,
  setActiveCol: i,
  outside_df_params: o,
  renderStartTime: s,
  hs: a
}) {
  const l = Se(() => bye(t), [t]), u = Se(() => ({
    sortable: !0,
    type: "rightAligned",
    cellStyle: (M) => {
      var _;
      const z = M.column.getColDef().field, k = (_ = M.context) == null ? void 0 : _.activeCol[0];
      if (!M.node.isRowPinned())
        return k === z ? { background: hU } : { background: "inherit" };
    },
    enableCellChangeFlash: !1,
    cellRendererSelector: Sye(t.pinned_rows)
  }), [t.pinned_rows]), d = xye(r), h = {
    activeCol: n,
    histogram_stats: d,
    pinned_rows_config: t.pinned_rows
  }, f = t.pinned_rows, p = Se(
    () => Cye(r, f || []),
    [r, f]
  ), y = Qe(
    (M) => {
      var k, _;
      const I = JSON.stringify((k = M.context) == null ? void 0 : k.outside_df_params) || "";
      return `${String((_ = M == null ? void 0 : M.data) == null ? void 0 : _.index)}-${I}`;
    },
    [o]
  ), C = Se(() => SA.withPart(bA).withParams({
    spacing: 5,
    browserColorScheme: "dark",
    cellHorizontalPaddingScale: 0.3,
    columnBorder: !0,
    headerRowBorder: !0,
    headerColumnBorder: !0,
    headerColumnResizeHandleWidth: 0,
    rowBorder: !1,
    rowVerticalPaddingScale: 0.5,
    wrapperBorder: !1,
    fontSize: 12,
    dataFontSize: "12px",
    headerFontSize: 14,
    iconSize: 10,
    backgroundColor: "#121212",
    oddRowBackgroundColor: "#3f3f3f",
    headerVerticalPaddingScale: 0.6
    //    cellHorizontalPadding: 3,
  }), []), v = Se(() => ({
    ...fU(i, t.extra_grid_config),
    domLayout: a.domLayout,
    autoSizeStrategy: Aye(l.length),
    onFirstDataRendered: (M) => {
    },
    columnDefs: l,
    getRowId: y,
    rowModelType: "clientSide"
  }), [l.length, JSON.stringify(l), a, t.extra_grid_config, i, y, o]), w = Se(() => e.data_type === "DataSource" ? e.datasource : {
    rowCount: e.length,
    getRows: (M) => {
      throw console.debug("fake datasource getRows called, unexpected"), new Error("fake datasource getRows called, unexpected");
    }
  }, [e]), R = Se(
    () => mU(e, v, a),
    [e, v, a]
  ), b = ge(null), P = ge(null), S = Se(() => {
    try {
      return l.map((M) => M == null ? void 0 : M.field).filter(Boolean);
    } catch {
      return [];
    }
  }, [l]), E = Se(() => {
    const M = (p || []).map((z) => S.map((k) => z == null ? void 0 : z[k])), I = (f || []).map((z) => z.primary_key_val);
    return JSON.stringify({ k: I, f: S, v: M });
  }, [p, S, f]);
  pr(() => {
    var M, I;
    try {
      const z = (p || []).map((k) => ({ ...k }));
      P.current = z, (I = (M = b.current) == null ? void 0 : M.api) == null || I.setGridOption("pinnedTopRowData", z);
    } catch {
    }
  }, [E]);
  const A = Se(() => e.data_type === "Raw" ? JSON.stringify(e.data) : null, [e]);
  return pr(() => {
    var M;
    if (e.data_type === "Raw" && ((M = b.current) != null && M.api) && A)
      try {
        b.current.api.setGridOption("rowData", e.data);
      } catch {
      }
  }, [A, e.data_type, e]), /* @__PURE__ */ $(
    aA,
    {
      ref: b,
      theme: C,
      loadThemeGoogleFonts: !0,
      gridOptions: R,
      defaultColDef: u,
      datasource: w,
      columnDefs: l,
      onGridReady: (M) => {
        try {
          M.api.setGridOption("pinnedTopRowData", P.current || []);
        } catch {
        }
      },
      context: { outside_df_params: o, ...h }
    },
    JSON.stringify(o) || "no-outside-params"
  );
}
const mU = (e, t, r) => {
  if (e.data_type === "Raw")
    return {
      ...t,
      rowData: e.data,
      suppressNoRowsOverlay: !0
    };
  if (e.data_type === "DataSource")
    return vU(t, r.maxRowsWithoutScrolling);
  throw new Error(`Unexpected data_wrapper.data_type on  ${e}`);
}, vU = (e, t) => ({
  ...e,
  animateRows: !1,
  onSortChanged: (n) => {
    const i = n.api;
    console.log(
      "sortChanged",
      i.getFirstDisplayedRowIndex(),
      i.getLastDisplayedRowIndex(),
      n
    ), i.ensureIndexVisible(0);
  },
  rowBuffer: 20,
  rowModelType: "infinite",
  cacheBlockSize: t + 50,
  cacheOverflowSize: 0,
  maxConcurrentDatasourceRequests: 3,
  maxBlocksInCache: 0
  // setting infiniteInitialRowCount causes a bad flash 
  // for object displaye columns while waiting for data. they show a column of None
  //infiniteInitialRowCount: maxRowsWithoutScrolling + 50
});
function xA({
  df_data: e,
  df_viewer_config: t,
  summary_stats_data: r,
  activeCol: n,
  setActiveCol: i
}) {
  const s = i || ((a) => {
    console.log("defaultSetColumnFunc", a);
  });
  return /* @__PURE__ */ $(
    qc,
    {
      data_wrapper: {
        data_type: "Raw",
        data: e,
        length: e.length
      },
      df_viewer_config: t,
      summary_stats_data: r,
      activeCol: n,
      setActiveCol: s
    }
  );
}
const yU = (e) => (r) => {
  if (r.data.index === "histogram")
    return;
  const n = r.data[e].toString();
  return /* @__PURE__ */ $("div", { className: "ag-tooltip", children: n });
}, CU = (e) => {
  if (e === void 0)
    return {};
  switch (e.tooltip_type) {
    case "simple":
      return {
        tooltipComponent: yU(e.val_column),
        tooltipField: e.val_column
      };
    case "summary_series":
      return {};
  }
};
function RA(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = RA(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function Ze() {
  for (var e, t, r = 0, n = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = RA(e)) && (n && (n += " "), n += t);
  return n;
}
var wU = Array.isArray, Vr = wU, bU = typeof Ei == "object" && Ei && Ei.Object === Object && Ei, EA = bU, SU = EA, xU = typeof self == "object" && self && self.Object === Object && self, RU = SU || xU || Function("return this")(), gi = RU, EU = gi, PU = EU.Symbol, Yc = PU, HS = Yc, PA = Object.prototype, AU = PA.hasOwnProperty, FU = PA.toString, Pl = HS ? HS.toStringTag : void 0;
function MU(e) {
  var t = AU.call(e, Pl), r = e[Pl];
  try {
    e[Pl] = void 0;
    var n = !0;
  } catch {
  }
  var i = FU.call(e);
  return n && (t ? e[Pl] = r : delete e[Pl]), i;
}
var TU = MU, DU = Object.prototype, OU = DU.toString;
function IU(e) {
  return OU.call(e);
}
var kU = IU, WS = Yc, LU = TU, _U = kU, zU = "[object Null]", NU = "[object Undefined]", VS = WS ? WS.toStringTag : void 0;
function BU(e) {
  return e == null ? e === void 0 ? NU : zU : VS && VS in Object(e) ? LU(e) : _U(e);
}
var Bi = BU;
function GU(e) {
  return e != null && typeof e == "object";
}
var Gi = GU, HU = Bi, WU = Gi, VU = "[object Symbol]";
function $U(e) {
  return typeof e == "symbol" || WU(e) && HU(e) == VU;
}
var ja = $U, jU = Vr, UU = ja, KU = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, qU = /^\w*$/;
function YU(e, t) {
  if (jU(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || UU(e) ? !0 : qU.test(e) || !KU.test(e) || t != null && e in Object(t);
}
var gy = YU;
function JU(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var bo = JU;
const Ua = /* @__PURE__ */ bt(bo);
var XU = Bi, QU = bo, ZU = "[object AsyncFunction]", e9 = "[object Function]", t9 = "[object GeneratorFunction]", r9 = "[object Proxy]";
function n9(e) {
  if (!QU(e))
    return !1;
  var t = XU(e);
  return t == e9 || t == t9 || t == ZU || t == r9;
}
var fy = n9;
const We = /* @__PURE__ */ bt(fy);
var i9 = gi, o9 = i9["__core-js_shared__"], s9 = o9, Pp = s9, $S = function() {
  var e = /[^.]+$/.exec(Pp && Pp.keys && Pp.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function a9(e) {
  return !!$S && $S in e;
}
var l9 = a9, c9 = Function.prototype, u9 = c9.toString;
function d9(e) {
  if (e != null) {
    try {
      return u9.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var AA = d9, h9 = fy, g9 = l9, f9 = bo, p9 = AA, m9 = /[\\^$.*+?()[\]{}|]/g, v9 = /^\[object .+?Constructor\]$/, y9 = Function.prototype, C9 = Object.prototype, w9 = y9.toString, b9 = C9.hasOwnProperty, S9 = RegExp(
  "^" + w9.call(b9).replace(m9, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function x9(e) {
  if (!f9(e) || g9(e))
    return !1;
  var t = h9(e) ? S9 : v9;
  return t.test(p9(e));
}
var R9 = x9;
function E9(e, t) {
  return e == null ? void 0 : e[t];
}
var P9 = E9, A9 = R9, F9 = P9;
function M9(e, t) {
  var r = F9(e, t);
  return A9(r) ? r : void 0;
}
var ys = M9, T9 = ys, D9 = T9(Object, "create"), eg = D9, jS = eg;
function O9() {
  this.__data__ = jS ? jS(null) : {}, this.size = 0;
}
var I9 = O9;
function k9(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var L9 = k9, _9 = eg, z9 = "__lodash_hash_undefined__", N9 = Object.prototype, B9 = N9.hasOwnProperty;
function G9(e) {
  var t = this.__data__;
  if (_9) {
    var r = t[e];
    return r === z9 ? void 0 : r;
  }
  return B9.call(t, e) ? t[e] : void 0;
}
var H9 = G9, W9 = eg, V9 = Object.prototype, $9 = V9.hasOwnProperty;
function j9(e) {
  var t = this.__data__;
  return W9 ? t[e] !== void 0 : $9.call(t, e);
}
var U9 = j9, K9 = eg, q9 = "__lodash_hash_undefined__";
function Y9(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = K9 && t === void 0 ? q9 : t, this;
}
var J9 = Y9, X9 = I9, Q9 = L9, Z9 = H9, eK = U9, tK = J9;
function Ka(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Ka.prototype.clear = X9;
Ka.prototype.delete = Q9;
Ka.prototype.get = Z9;
Ka.prototype.has = eK;
Ka.prototype.set = tK;
var rK = Ka;
function nK() {
  this.__data__ = [], this.size = 0;
}
var iK = nK;
function oK(e, t) {
  return e === t || e !== e && t !== t;
}
var py = oK, sK = py;
function aK(e, t) {
  for (var r = e.length; r--; )
    if (sK(e[r][0], t))
      return r;
  return -1;
}
var tg = aK, lK = tg, cK = Array.prototype, uK = cK.splice;
function dK(e) {
  var t = this.__data__, r = lK(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : uK.call(t, r, 1), --this.size, !0;
}
var hK = dK, gK = tg;
function fK(e) {
  var t = this.__data__, r = gK(t, e);
  return r < 0 ? void 0 : t[r][1];
}
var pK = fK, mK = tg;
function vK(e) {
  return mK(this.__data__, e) > -1;
}
var yK = vK, CK = tg;
function wK(e, t) {
  var r = this.__data__, n = CK(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
var bK = wK, SK = iK, xK = hK, RK = pK, EK = yK, PK = bK;
function qa(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
qa.prototype.clear = SK;
qa.prototype.delete = xK;
qa.prototype.get = RK;
qa.prototype.has = EK;
qa.prototype.set = PK;
var rg = qa, AK = ys, FK = gi, MK = AK(FK, "Map"), my = MK, US = rK, TK = rg, DK = my;
function OK() {
  this.size = 0, this.__data__ = {
    hash: new US(),
    map: new (DK || TK)(),
    string: new US()
  };
}
var IK = OK;
function kK(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var LK = kK, _K = LK;
function zK(e, t) {
  var r = e.__data__;
  return _K(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
var ng = zK, NK = ng;
function BK(e) {
  var t = NK(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var GK = BK, HK = ng;
function WK(e) {
  return HK(this, e).get(e);
}
var VK = WK, $K = ng;
function jK(e) {
  return $K(this, e).has(e);
}
var UK = jK, KK = ng;
function qK(e, t) {
  var r = KK(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
var YK = qK, JK = IK, XK = GK, QK = VK, ZK = UK, eq = YK;
function Ya(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Ya.prototype.clear = JK;
Ya.prototype.delete = XK;
Ya.prototype.get = QK;
Ya.prototype.has = ZK;
Ya.prototype.set = eq;
var vy = Ya, FA = vy, tq = "Expected a function";
function yy(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(tq);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], o = r.cache;
    if (o.has(i))
      return o.get(i);
    var s = e.apply(this, n);
    return r.cache = o.set(i, s) || o, s;
  };
  return r.cache = new (yy.Cache || FA)(), r;
}
yy.Cache = FA;
var MA = yy;
const rq = /* @__PURE__ */ bt(MA);
var nq = MA, iq = 500;
function oq(e) {
  var t = nq(e, function(n) {
    return r.size === iq && r.clear(), n;
  }), r = t.cache;
  return t;
}
var sq = oq, aq = sq, lq = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, cq = /\\(\\)?/g, uq = aq(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(lq, function(r, n, i, o) {
    t.push(i ? o.replace(cq, "$1") : n || r);
  }), t;
}), dq = uq;
function hq(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var Cy = hq, KS = Yc, gq = Cy, fq = Vr, pq = ja, qS = KS ? KS.prototype : void 0, YS = qS ? qS.toString : void 0;
function TA(e) {
  if (typeof e == "string")
    return e;
  if (fq(e))
    return gq(e, TA) + "";
  if (pq(e))
    return YS ? YS.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var mq = TA, vq = mq;
function yq(e) {
  return e == null ? "" : vq(e);
}
var DA = yq, Cq = Vr, wq = gy, bq = dq, Sq = DA;
function xq(e, t) {
  return Cq(e) ? e : wq(e, t) ? [e] : bq(Sq(e));
}
var OA = xq, Rq = ja;
function Eq(e) {
  if (typeof e == "string" || Rq(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var ig = Eq, Pq = OA, Aq = ig;
function Fq(e, t) {
  t = Pq(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Aq(t[r++])];
  return r && r == n ? e : void 0;
}
var wy = Fq, Mq = wy;
function Tq(e, t, r) {
  var n = e == null ? void 0 : Mq(e, t);
  return n === void 0 ? r : n;
}
var IA = Tq;
const En = /* @__PURE__ */ bt(IA);
function Dq(e) {
  return e == null;
}
var Oq = Dq;
const _e = /* @__PURE__ */ bt(Oq);
var Iq = Bi, kq = Vr, Lq = Gi, _q = "[object String]";
function zq(e) {
  return typeof e == "string" || !kq(e) && Lq(e) && Iq(e) == _q;
}
var Nq = zq;
const us = /* @__PURE__ */ bt(Nq);
var Lm = { exports: {} }, lt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JS;
function Bq() {
  if (JS) return lt;
  JS = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), y;
  y = Symbol.for("react.module.reference");
  function C(v) {
    if (typeof v == "object" && v !== null) {
      var w = v.$$typeof;
      switch (w) {
        case e:
          switch (v = v.type, v) {
            case r:
            case i:
            case n:
            case u:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case s:
                case l:
                case f:
                case h:
                case o:
                  return v;
                default:
                  return w;
              }
          }
        case t:
          return w;
      }
    }
  }
  return lt.ContextConsumer = s, lt.ContextProvider = o, lt.Element = e, lt.ForwardRef = l, lt.Fragment = r, lt.Lazy = f, lt.Memo = h, lt.Portal = t, lt.Profiler = i, lt.StrictMode = n, lt.Suspense = u, lt.SuspenseList = d, lt.isAsyncMode = function() {
    return !1;
  }, lt.isConcurrentMode = function() {
    return !1;
  }, lt.isContextConsumer = function(v) {
    return C(v) === s;
  }, lt.isContextProvider = function(v) {
    return C(v) === o;
  }, lt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, lt.isForwardRef = function(v) {
    return C(v) === l;
  }, lt.isFragment = function(v) {
    return C(v) === r;
  }, lt.isLazy = function(v) {
    return C(v) === f;
  }, lt.isMemo = function(v) {
    return C(v) === h;
  }, lt.isPortal = function(v) {
    return C(v) === t;
  }, lt.isProfiler = function(v) {
    return C(v) === i;
  }, lt.isStrictMode = function(v) {
    return C(v) === n;
  }, lt.isSuspense = function(v) {
    return C(v) === u;
  }, lt.isSuspenseList = function(v) {
    return C(v) === d;
  }, lt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === i || v === n || v === u || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === h || v.$$typeof === o || v.$$typeof === s || v.$$typeof === l || v.$$typeof === y || v.getModuleId !== void 0);
  }, lt.typeOf = C, lt;
}
var ct = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XS;
function Gq() {
  return XS || (XS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), y = !1, C = !1, v = !1, w = !1, R = !1, b;
    b = Symbol.for("react.module.reference");
    function P(oe) {
      return !!(typeof oe == "string" || typeof oe == "function" || oe === r || oe === i || R || oe === n || oe === u || oe === d || w || oe === p || y || C || v || typeof oe == "object" && oe !== null && (oe.$$typeof === f || oe.$$typeof === h || oe.$$typeof === o || oe.$$typeof === s || oe.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      oe.$$typeof === b || oe.getModuleId !== void 0));
    }
    function S(oe) {
      if (typeof oe == "object" && oe !== null) {
        var Me = oe.$$typeof;
        switch (Me) {
          case e:
            var Je = oe.type;
            switch (Je) {
              case r:
              case i:
              case n:
              case u:
              case d:
                return Je;
              default:
                var nt = Je && Je.$$typeof;
                switch (nt) {
                  case a:
                  case s:
                  case l:
                  case f:
                  case h:
                  case o:
                    return nt;
                  default:
                    return Me;
                }
            }
          case t:
            return Me;
        }
      }
    }
    var E = s, A = o, M = e, I = l, z = r, k = f, _ = h, q = t, j = i, Q = n, K = u, Z = d, te = !1, se = !1;
    function W(oe) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function U(oe) {
      return se || (se = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function X(oe) {
      return S(oe) === s;
    }
    function he(oe) {
      return S(oe) === o;
    }
    function ce(oe) {
      return typeof oe == "object" && oe !== null && oe.$$typeof === e;
    }
    function me(oe) {
      return S(oe) === l;
    }
    function ve(oe) {
      return S(oe) === r;
    }
    function Pe(oe) {
      return S(oe) === f;
    }
    function Re(oe) {
      return S(oe) === h;
    }
    function ee(oe) {
      return S(oe) === t;
    }
    function fe(oe) {
      return S(oe) === i;
    }
    function ye(oe) {
      return S(oe) === n;
    }
    function B(oe) {
      return S(oe) === u;
    }
    function Ae(oe) {
      return S(oe) === d;
    }
    ct.ContextConsumer = E, ct.ContextProvider = A, ct.Element = M, ct.ForwardRef = I, ct.Fragment = z, ct.Lazy = k, ct.Memo = _, ct.Portal = q, ct.Profiler = j, ct.StrictMode = Q, ct.Suspense = K, ct.SuspenseList = Z, ct.isAsyncMode = W, ct.isConcurrentMode = U, ct.isContextConsumer = X, ct.isContextProvider = he, ct.isElement = ce, ct.isForwardRef = me, ct.isFragment = ve, ct.isLazy = Pe, ct.isMemo = Re, ct.isPortal = ee, ct.isProfiler = fe, ct.isStrictMode = ye, ct.isSuspense = B, ct.isSuspenseList = Ae, ct.isValidElementType = P, ct.typeOf = S;
  }()), ct;
}
process.env.NODE_ENV === "production" ? Lm.exports = Bq() : Lm.exports = Gq();
var Hq = Lm.exports, Wq = Bi, Vq = Gi, $q = "[object Number]";
function jq(e) {
  return typeof e == "number" || Vq(e) && Wq(e) == $q;
}
var kA = jq;
const Uq = /* @__PURE__ */ bt(kA);
var Kq = kA;
function qq(e) {
  return Kq(e) && e != +e;
}
var Yq = qq;
const Ja = /* @__PURE__ */ bt(Yq);
var Gn = function(t) {
  return t === 0 ? 0 : t > 0 ? 1 : -1;
}, _m = function(t) {
  return us(t) && t.indexOf("%") === t.length - 1;
}, Ce = function(t) {
  return Uq(t) && !Ja(t);
}, Jt = function(t) {
  return Ce(t) || us(t);
}, Jq = 0, Cs = function(t) {
  var r = ++Jq;
  return "".concat(t || "").concat(r);
}, ds = function(t, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!Ce(t) && !us(t))
    return n;
  var o;
  if (_m(t)) {
    var s = t.indexOf("%");
    o = r * parseFloat(t.slice(0, s)) / 100;
  } else
    o = +t;
  return Ja(o) && (o = n), i && o > r && (o = r), o;
}, Ws = function(t) {
  if (!t)
    return null;
  var r = Object.keys(t);
  return r && r.length ? t[r[0]] : null;
}, Xq = function(t) {
  if (!Array.isArray(t))
    return !1;
  for (var r = t.length, n = {}, i = 0; i < r; i++)
    if (!n[t[i]])
      n[t[i]] = !0;
    else
      return !0;
  return !1;
}, Ht = function(t, r) {
  return Ce(t) && Ce(r) ? function(n) {
    return t + n * (r - t);
  } : function() {
    return r;
  };
};
function Bd(e, t, r) {
  return !e || !e.length ? null : e.find(function(n) {
    return n && (typeof t == "function" ? t(n) : En(n, t)) === r;
  });
}
var Qq = function(t) {
  if (!t || !t.length)
    return null;
  for (var r = t.length, n = 0, i = 0, o = 0, s = 0, a = 1 / 0, l = -1 / 0, u = 0, d = 0, h = 0; h < r; h++)
    u = t[h].cx || 0, d = t[h].cy || 0, n += u, i += d, o += u * d, s += u * u, a = Math.min(a, u), l = Math.max(l, u);
  var f = r * s !== n * n ? (r * o - n * i) / (r * s - n * n) : 0;
  return {
    xmin: a,
    xmax: l,
    a: f,
    b: (i - f * n) / r
  };
}, Zq = function(t, r) {
  return Ce(t) && Ce(r) ? t - r : us(t) && us(r) ? t.localeCompare(r) : t instanceof Date && r instanceof Date ? t.getTime() - r.getTime() : String(t).localeCompare(String(r));
};
function Zs(e, t) {
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r) && (!{}.hasOwnProperty.call(t, r) || e[r] !== t[r]))
      return !1;
  for (var n in t)
    if ({}.hasOwnProperty.call(t, n) && !{}.hasOwnProperty.call(e, n))
      return !1;
  return !0;
}
function zm(e) {
  "@babel/helpers - typeof";
  return zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zm(e);
}
var eY = ["viewBox", "children"], tY = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
], QS = ["points", "pathLength"], Ap = {
  svg: eY,
  polygon: QS,
  polyline: QS
}, by = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], Gd = function(t, r) {
  if (!t || typeof t == "function" || typeof t == "boolean")
    return null;
  var n = t;
  if (/* @__PURE__ */ ri(t) && (n = t.props), !Ua(n))
    return null;
  var i = {};
  return Object.keys(n).forEach(function(o) {
    by.includes(o) && (i[o] = r || function(s) {
      return n[o](n, s);
    });
  }), i;
}, rY = function(t, r, n) {
  return function(i) {
    return t(r, n, i), null;
  };
}, lc = function(t, r, n) {
  if (!Ua(t) || zm(t) !== "object")
    return null;
  var i = null;
  return Object.keys(t).forEach(function(o) {
    var s = t[o];
    by.includes(o) && typeof s == "function" && (i || (i = {}), i[o] = rY(s, r, n));
  }), i;
}, nY = ["children"], iY = ["children"];
function ZS(e, t) {
  if (e == null) return {};
  var r = oY(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function oY(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Nm(e) {
  "@babel/helpers - typeof";
  return Nm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nm(e);
}
var e1 = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick"
}, co = function(t) {
  return typeof t == "string" ? t : t ? t.displayName || t.name || "Component" : "";
}, t1 = null, Fp = null, Sy = function e(t) {
  if (t === t1 && Array.isArray(Fp))
    return Fp;
  var r = [];
  return Xo.forEach(t, function(n) {
    _e(n) || (Hq.isFragment(n) ? r = r.concat(e(n.props.children)) : r.push(n));
  }), Fp = r, t1 = t, r;
};
function Wr(e, t) {
  var r = [], n = [];
  return Array.isArray(t) ? n = t.map(function(i) {
    return co(i);
  }) : n = [co(t)], Sy(e).forEach(function(i) {
    var o = En(i, "type.displayName") || En(i, "type.name");
    n.indexOf(o) !== -1 && r.push(i);
  }), r;
}
function Zr(e, t) {
  var r = Wr(e, t);
  return r && r[0];
}
var r1 = function(t) {
  if (!t || !t.props)
    return !1;
  var r = t.props, n = r.width, i = r.height;
  return !(!Ce(n) || n <= 0 || !Ce(i) || i <= 0);
}, sY = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"], aY = function(t) {
  return t && t.type && us(t.type) && sY.indexOf(t.type) >= 0;
}, LA = function(t) {
  return t && Nm(t) === "object" && "clipDot" in t;
}, lY = function(t, r, n, i) {
  var o, s = (o = Ap == null ? void 0 : Ap[i]) !== null && o !== void 0 ? o : [];
  return r.startsWith("data-") || !We(t) && (i && s.includes(r) || tY.includes(r)) || n && by.includes(r);
}, Ne = function(t, r, n) {
  if (!t || typeof t == "function" || typeof t == "boolean")
    return null;
  var i = t;
  if (/* @__PURE__ */ ri(t) && (i = t.props), !Ua(i))
    return null;
  var o = {};
  return Object.keys(i).forEach(function(s) {
    var a;
    lY((a = i) === null || a === void 0 ? void 0 : a[s], s, r, n) && (o[s] = i[s]);
  }), o;
}, Bm = function e(t, r) {
  if (t === r)
    return !0;
  var n = Xo.count(t);
  if (n !== Xo.count(r))
    return !1;
  if (n === 0)
    return !0;
  if (n === 1)
    return n1(Array.isArray(t) ? t[0] : t, Array.isArray(r) ? r[0] : r);
  for (var i = 0; i < n; i++) {
    var o = t[i], s = r[i];
    if (Array.isArray(o) || Array.isArray(s)) {
      if (!e(o, s))
        return !1;
    } else if (!n1(o, s))
      return !1;
  }
  return !0;
}, n1 = function(t, r) {
  if (_e(t) && _e(r))
    return !0;
  if (!_e(t) && !_e(r)) {
    var n = t.props || {}, i = n.children, o = ZS(n, nY), s = r.props || {}, a = s.children, l = ZS(s, iY);
    return i && a ? Zs(o, l) && Bm(i, a) : !i && !a ? Zs(o, l) : !1;
  }
  return !1;
}, i1 = function(t, r) {
  var n = [], i = {};
  return Sy(t).forEach(function(o, s) {
    if (aY(o))
      n.push(o);
    else if (o) {
      var a = co(o.type), l = r[a] || {}, u = l.handler, d = l.once;
      if (u && (!d || !i[a])) {
        var h = u(o, a, s);
        n.push(h), i[a] = !0;
      }
    }
  }), n;
}, cY = function(t) {
  var r = t && t.type;
  return r && e1[r] ? e1[r] : null;
}, uY = function(t, r) {
  return Sy(r).indexOf(t);
}, dY = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function Gm() {
  return Gm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Gm.apply(this, arguments);
}
function hY(e, t) {
  if (e == null) return {};
  var r = gY(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function gY(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Hm(e) {
  var t = e.children, r = e.width, n = e.height, i = e.viewBox, o = e.className, s = e.style, a = e.title, l = e.desc, u = hY(e, dY), d = i || {
    width: r,
    height: n,
    x: 0,
    y: 0
  }, h = Ze("recharts-surface", o);
  return /* @__PURE__ */ O.createElement("svg", Gm({}, Ne(u, !0, "svg"), {
    className: h,
    width: r,
    height: n,
    style: s,
    viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height)
  }), /* @__PURE__ */ O.createElement("title", null, a), /* @__PURE__ */ O.createElement("desc", null, l), t);
}
var fY = ["children", "className"];
function Wm() {
  return Wm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Wm.apply(this, arguments);
}
function pY(e, t) {
  if (e == null) return {};
  var r = mY(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function mY(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
var st = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var r = e.children, n = e.className, i = pY(e, fY), o = Ze("recharts-layer", n);
  return /* @__PURE__ */ O.createElement("g", Wm({
    className: o
  }, Ne(i, !0), {
    ref: t
  }), r);
}), vY = process.env.NODE_ENV !== "production", og = function(t, r) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    i[o - 2] = arguments[o];
  if (vY && typeof console < "u" && console.warn && (r === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (r === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var s = 0;
      console.warn(r.replace(/%s/g, function() {
        return i[s++];
      }));
    }
};
function yY(e, t, r) {
  var n = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), r = r > i ? i : r, r < 0 && (r += i), i = t > r ? 0 : r - t >>> 0, t >>>= 0;
  for (var o = Array(i); ++n < i; )
    o[n] = e[n + t];
  return o;
}
var CY = yY, wY = CY;
function bY(e, t, r) {
  var n = e.length;
  return r = r === void 0 ? n : r, !t && r >= n ? e : wY(e, t, r);
}
var SY = bY, xY = "\\ud800-\\udfff", RY = "\\u0300-\\u036f", EY = "\\ufe20-\\ufe2f", PY = "\\u20d0-\\u20ff", AY = RY + EY + PY, FY = "\\ufe0e\\ufe0f", MY = "\\u200d", TY = RegExp("[" + MY + xY + AY + FY + "]");
function DY(e) {
  return TY.test(e);
}
var _A = DY;
function OY(e) {
  return e.split("");
}
var IY = OY, zA = "\\ud800-\\udfff", kY = "\\u0300-\\u036f", LY = "\\ufe20-\\ufe2f", _Y = "\\u20d0-\\u20ff", zY = kY + LY + _Y, NY = "\\ufe0e\\ufe0f", BY = "[" + zA + "]", Vm = "[" + zY + "]", $m = "\\ud83c[\\udffb-\\udfff]", GY = "(?:" + Vm + "|" + $m + ")", NA = "[^" + zA + "]", BA = "(?:\\ud83c[\\udde6-\\uddff]){2}", GA = "[\\ud800-\\udbff][\\udc00-\\udfff]", HY = "\\u200d", HA = GY + "?", WA = "[" + NY + "]?", WY = "(?:" + HY + "(?:" + [NA, BA, GA].join("|") + ")" + WA + HA + ")*", VY = WA + HA + WY, $Y = "(?:" + [NA + Vm + "?", Vm, BA, GA, BY].join("|") + ")", jY = RegExp($m + "(?=" + $m + ")|" + $Y + VY, "g");
function UY(e) {
  return e.match(jY) || [];
}
var KY = UY, qY = IY, YY = _A, JY = KY;
function XY(e) {
  return YY(e) ? JY(e) : qY(e);
}
var QY = XY, ZY = SY, eJ = _A, tJ = QY, rJ = DA;
function nJ(e) {
  return function(t) {
    t = rJ(t);
    var r = eJ(t) ? tJ(t) : void 0, n = r ? r[0] : t.charAt(0), i = r ? ZY(r, 1).join("") : t.slice(1);
    return n[e]() + i;
  };
}
var iJ = nJ, oJ = iJ, sJ = oJ("toUpperCase"), aJ = sJ;
const sg = /* @__PURE__ */ bt(aJ);
function wt(e) {
  return function() {
    return e;
  };
}
const VA = Math.cos, Hd = Math.sin, jn = Math.sqrt, Wd = Math.PI, ag = 2 * Wd, jm = Math.PI, Um = 2 * jm, Bo = 1e-6, lJ = Um - Bo;
function $A(e) {
  this._ += e[0];
  for (let t = 1, r = e.length; t < r; ++t)
    this._ += arguments[t] + e[t];
}
function cJ(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return $A;
  const r = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let i = 1, o = n.length; i < o; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
class uJ {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? $A : cJ(t);
  }
  moveTo(t, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, r) {
    this._append`L${this._x1 = +t},${this._y1 = +r}`;
  }
  quadraticCurveTo(t, r, n, i) {
    this._append`Q${+t},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(t, r, n, i, o, s) {
    this._append`C${+t},${+r},${+n},${+i},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, r, n, i, o) {
    if (t = +t, r = +r, n = +n, i = +i, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, a = this._y1, l = n - t, u = i - r, d = s - t, h = a - r, f = d * d + h * h;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = r}`;
    else if (f > Bo) if (!(Math.abs(h * l - u * d) > Bo) || !o)
      this._append`L${this._x1 = t},${this._y1 = r}`;
    else {
      let p = n - s, y = i - a, C = l * l + u * u, v = p * p + y * y, w = Math.sqrt(C), R = Math.sqrt(f), b = o * Math.tan((jm - Math.acos((C + f - v) / (2 * w * R))) / 2), P = b / R, S = b / w;
      Math.abs(P - 1) > Bo && this._append`L${t + P * d},${r + P * h}`, this._append`A${o},${o},0,0,${+(h * p > d * y)},${this._x1 = t + S * l},${this._y1 = r + S * u}`;
    }
  }
  arc(t, r, n, i, o, s) {
    if (t = +t, r = +r, n = +n, s = !!s, n < 0) throw new Error(`negative radius: ${n}`);
    let a = n * Math.cos(i), l = n * Math.sin(i), u = t + a, d = r + l, h = 1 ^ s, f = s ? i - o : o - i;
    this._x1 === null ? this._append`M${u},${d}` : (Math.abs(this._x1 - u) > Bo || Math.abs(this._y1 - d) > Bo) && this._append`L${u},${d}`, n && (f < 0 && (f = f % Um + Um), f > lJ ? this._append`A${n},${n},0,1,${h},${t - a},${r - l}A${n},${n},0,1,${h},${this._x1 = u},${this._y1 = d}` : f > Bo && this._append`A${n},${n},0,${+(f >= jm)},${h},${this._x1 = t + n * Math.cos(o)},${this._y1 = r + n * Math.sin(o)}`);
  }
  rect(t, r, n, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
}
function xy(e) {
  let t = 3;
  return e.digits = function(r) {
    if (!arguments.length) return t;
    if (r == null)
      t = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      t = n;
    }
    return e;
  }, () => new uJ(t);
}
function Ry(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function jA(e) {
  this._context = e;
}
jA.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function lg(e) {
  return new jA(e);
}
function UA(e) {
  return e[0];
}
function KA(e) {
  return e[1];
}
function qA(e, t) {
  var r = wt(!0), n = null, i = lg, o = null, s = xy(a);
  e = typeof e == "function" ? e : e === void 0 ? UA : wt(e), t = typeof t == "function" ? t : t === void 0 ? KA : wt(t);
  function a(l) {
    var u, d = (l = Ry(l)).length, h, f = !1, p;
    for (n == null && (o = i(p = s())), u = 0; u <= d; ++u)
      !(u < d && r(h = l[u], u, l)) === f && ((f = !f) ? o.lineStart() : o.lineEnd()), f && o.point(+e(h, u, l), +t(h, u, l));
    if (p) return o = null, p + "" || null;
  }
  return a.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : wt(+l), a) : e;
  }, a.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : wt(+l), a) : t;
  }, a.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : wt(!!l), a) : r;
  }, a.curve = function(l) {
    return arguments.length ? (i = l, n != null && (o = i(n)), a) : i;
  }, a.context = function(l) {
    return arguments.length ? (l == null ? n = o = null : o = i(n = l), a) : n;
  }, a;
}
function Ju(e, t, r) {
  var n = null, i = wt(!0), o = null, s = lg, a = null, l = xy(u);
  e = typeof e == "function" ? e : e === void 0 ? UA : wt(+e), t = typeof t == "function" ? t : wt(t === void 0 ? 0 : +t), r = typeof r == "function" ? r : r === void 0 ? KA : wt(+r);
  function u(h) {
    var f, p, y, C = (h = Ry(h)).length, v, w = !1, R, b = new Array(C), P = new Array(C);
    for (o == null && (a = s(R = l())), f = 0; f <= C; ++f) {
      if (!(f < C && i(v = h[f], f, h)) === w)
        if (w = !w)
          p = f, a.areaStart(), a.lineStart();
        else {
          for (a.lineEnd(), a.lineStart(), y = f - 1; y >= p; --y)
            a.point(b[y], P[y]);
          a.lineEnd(), a.areaEnd();
        }
      w && (b[f] = +e(v, f, h), P[f] = +t(v, f, h), a.point(n ? +n(v, f, h) : b[f], r ? +r(v, f, h) : P[f]));
    }
    if (R) return a = null, R + "" || null;
  }
  function d() {
    return qA().defined(i).curve(s).context(o);
  }
  return u.x = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : wt(+h), n = null, u) : e;
  }, u.x0 = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : wt(+h), u) : e;
  }, u.x1 = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : wt(+h), u) : n;
  }, u.y = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : wt(+h), r = null, u) : t;
  }, u.y0 = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : wt(+h), u) : t;
  }, u.y1 = function(h) {
    return arguments.length ? (r = h == null ? null : typeof h == "function" ? h : wt(+h), u) : r;
  }, u.lineX0 = u.lineY0 = function() {
    return d().x(e).y(t);
  }, u.lineY1 = function() {
    return d().x(e).y(r);
  }, u.lineX1 = function() {
    return d().x(n).y(t);
  }, u.defined = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : wt(!!h), u) : i;
  }, u.curve = function(h) {
    return arguments.length ? (s = h, o != null && (a = s(o)), u) : s;
  }, u.context = function(h) {
    return arguments.length ? (h == null ? o = a = null : a = s(o = h), u) : o;
  }, u;
}
class YA {
  constructor(t, r) {
    this._context = t, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, r) {
    switch (t = +t, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, r, t, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, t, this._y0, t, r);
        break;
      }
    }
    this._x0 = t, this._y0 = r;
  }
}
function dJ(e) {
  return new YA(e, !0);
}
function hJ(e) {
  return new YA(e, !1);
}
const Ey = {
  draw(e, t) {
    const r = jn(t / Wd);
    e.moveTo(r, 0), e.arc(0, 0, r, 0, ag);
  }
}, gJ = {
  draw(e, t) {
    const r = jn(t / 5) / 2;
    e.moveTo(-3 * r, -r), e.lineTo(-r, -r), e.lineTo(-r, -3 * r), e.lineTo(r, -3 * r), e.lineTo(r, -r), e.lineTo(3 * r, -r), e.lineTo(3 * r, r), e.lineTo(r, r), e.lineTo(r, 3 * r), e.lineTo(-r, 3 * r), e.lineTo(-r, r), e.lineTo(-3 * r, r), e.closePath();
  }
}, JA = jn(1 / 3), fJ = JA * 2, pJ = {
  draw(e, t) {
    const r = jn(t / fJ), n = r * JA;
    e.moveTo(0, -r), e.lineTo(n, 0), e.lineTo(0, r), e.lineTo(-n, 0), e.closePath();
  }
}, mJ = {
  draw(e, t) {
    const r = jn(t), n = -r / 2;
    e.rect(n, n, r, r);
  }
}, vJ = 0.8908130915292852, XA = Hd(Wd / 10) / Hd(7 * Wd / 10), yJ = Hd(ag / 10) * XA, CJ = -VA(ag / 10) * XA, wJ = {
  draw(e, t) {
    const r = jn(t * vJ), n = yJ * r, i = CJ * r;
    e.moveTo(0, -r), e.lineTo(n, i);
    for (let o = 1; o < 5; ++o) {
      const s = ag * o / 5, a = VA(s), l = Hd(s);
      e.lineTo(l * r, -a * r), e.lineTo(a * n - l * i, l * n + a * i);
    }
    e.closePath();
  }
}, Mp = jn(3), bJ = {
  draw(e, t) {
    const r = -jn(t / (Mp * 3));
    e.moveTo(0, r * 2), e.lineTo(-Mp * r, -r), e.lineTo(Mp * r, -r), e.closePath();
  }
}, fn = -0.5, pn = jn(3) / 2, Km = 1 / jn(12), SJ = (Km / 2 + 1) * 3, xJ = {
  draw(e, t) {
    const r = jn(t / SJ), n = r / 2, i = r * Km, o = n, s = r * Km + r, a = -o, l = s;
    e.moveTo(n, i), e.lineTo(o, s), e.lineTo(a, l), e.lineTo(fn * n - pn * i, pn * n + fn * i), e.lineTo(fn * o - pn * s, pn * o + fn * s), e.lineTo(fn * a - pn * l, pn * a + fn * l), e.lineTo(fn * n + pn * i, fn * i - pn * n), e.lineTo(fn * o + pn * s, fn * s - pn * o), e.lineTo(fn * a + pn * l, fn * l - pn * a), e.closePath();
  }
};
function RJ(e, t) {
  let r = null, n = xy(i);
  e = typeof e == "function" ? e : wt(e || Ey), t = typeof t == "function" ? t : wt(t === void 0 ? 64 : +t);
  function i() {
    let o;
    if (r || (r = o = n()), e.apply(this, arguments).draw(r, +t.apply(this, arguments)), o) return r = null, o + "" || null;
  }
  return i.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : wt(o), i) : e;
  }, i.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : wt(+o), i) : t;
  }, i.context = function(o) {
    return arguments.length ? (r = o ?? null, i) : r;
  }, i;
}
function Vd() {
}
function $d(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function QA(e) {
  this._context = e;
}
QA.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        $d(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        $d(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function EJ(e) {
  return new QA(e);
}
function ZA(e) {
  this._context = e;
}
ZA.prototype = {
  areaStart: Vd,
  areaEnd: Vd,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        $d(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function PJ(e) {
  return new ZA(e);
}
function eF(e) {
  this._context = e;
}
eF.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, n = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      default:
        $d(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function AJ(e) {
  return new eF(e);
}
function tF(e) {
  this._context = e;
}
tF.prototype = {
  areaStart: Vd,
  areaEnd: Vd,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function FJ(e) {
  return new tF(e);
}
function o1(e) {
  return e < 0 ? -1 : 1;
}
function s1(e, t, r) {
  var n = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (n || i < 0 && -0), s = (r - e._y1) / (i || n < 0 && -0), a = (o * i + s * n) / (n + i);
  return (o1(o) + o1(s)) * Math.min(Math.abs(o), Math.abs(s), 0.5 * Math.abs(a)) || 0;
}
function a1(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function Tp(e, t, r) {
  var n = e._x0, i = e._y0, o = e._x1, s = e._y1, a = (o - n) / 3;
  e._context.bezierCurveTo(n + a, i + a * t, o - a, s - a * r, o, s);
}
function jd(e) {
  this._context = e;
}
jd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Tp(this, this._t0, a1(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Tp(this, a1(this, r = s1(this, e, t)), r);
          break;
        default:
          Tp(this, this._t0, r = s1(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function rF(e) {
  this._context = new nF(e);
}
(rF.prototype = Object.create(jd.prototype)).point = function(e, t) {
  jd.prototype.point.call(this, t, e);
};
function nF(e) {
  this._context = e;
}
nF.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, n, i, o) {
    this._context.bezierCurveTo(t, e, n, r, o, i);
  }
};
function MJ(e) {
  return new jd(e);
}
function TJ(e) {
  return new rF(e);
}
function iF(e) {
  this._context = e;
}
iF.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var n = l1(e), i = l1(t), o = 0, s = 1; s < r; ++o, ++s)
          this._context.bezierCurveTo(n[0][o], i[0][o], n[1][o], i[1][o], e[s], t[s]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function l1(e) {
  var t, r = e.length - 1, n, i = new Array(r), o = new Array(r), s = new Array(r);
  for (i[0] = 0, o[0] = 2, s[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t) i[t] = 1, o[t] = 4, s[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, o[r - 1] = 7, s[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t) n = i[t] / o[t - 1], o[t] -= n, s[t] -= n * s[t - 1];
  for (i[r - 1] = s[r - 1] / o[r - 1], t = r - 2; t >= 0; --t) i[t] = (s[t] - i[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t) o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function DJ(e) {
  return new iF(e);
}
function cg(e, t) {
  this._context = e, this._t = t;
}
cg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function OJ(e) {
  return new cg(e, 0.5);
}
function IJ(e) {
  return new cg(e, 0);
}
function kJ(e) {
  return new cg(e, 1);
}
function aa(e, t) {
  if ((s = e.length) > 1)
    for (var r = 1, n, i, o = e[t[0]], s, a = o.length; r < s; ++r)
      for (i = o, o = e[t[r]], n = 0; n < a; ++n)
        o[n][1] += o[n][0] = isNaN(i[n][1]) ? i[n][0] : i[n][1];
}
function qm(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; ) r[t] = t;
  return r;
}
function LJ(e, t) {
  return e[t];
}
function _J(e) {
  const t = [];
  return t.key = e, t;
}
function zJ() {
  var e = wt([]), t = qm, r = aa, n = LJ;
  function i(o) {
    var s = Array.from(e.apply(this, arguments), _J), a, l = s.length, u = -1, d;
    for (const h of o)
      for (a = 0, ++u; a < l; ++a)
        (s[a][u] = [0, +n(h, s[a].key, u, o)]).data = h;
    for (a = 0, d = Ry(t(s)); a < l; ++a)
      s[d[a]].index = a;
    return r(s, d), s;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : wt(Array.from(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : wt(+o), i) : n;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? qm : typeof o == "function" ? o : wt(Array.from(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (r = o ?? aa, i) : r;
  }, i;
}
function NJ(e, t) {
  if ((n = e.length) > 0) {
    for (var r, n, i = 0, o = e[0].length, s; i < o; ++i) {
      for (s = r = 0; r < n; ++r) s += e[r][i][1] || 0;
      if (s) for (r = 0; r < n; ++r) e[r][i][1] /= s;
    }
    aa(e, t);
  }
}
function BJ(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, n = e[t[0]], i, o = n.length; r < o; ++r) {
      for (var s = 0, a = 0; s < i; ++s) a += e[s][r][1] || 0;
      n[r][1] += n[r][0] = -a / 2;
    }
    aa(e, t);
  }
}
function GJ(e, t) {
  if (!(!((s = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, n = 1, i, o, s; n < o; ++n) {
      for (var a = 0, l = 0, u = 0; a < s; ++a) {
        for (var d = e[t[a]], h = d[n][1] || 0, f = d[n - 1][1] || 0, p = (h - f) / 2, y = 0; y < a; ++y) {
          var C = e[t[y]], v = C[n][1] || 0, w = C[n - 1][1] || 0;
          p += v - w;
        }
        l += h, u += p * h;
      }
      i[n - 1][1] += i[n - 1][0] = r, l && (r -= u / l);
    }
    i[n - 1][1] += i[n - 1][0] = r, aa(e, t);
  }
}
function cc(e) {
  "@babel/helpers - typeof";
  return cc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cc(e);
}
var HJ = ["type", "size", "sizeType"];
function Ym() {
  return Ym = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Ym.apply(this, arguments);
}
function c1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function u1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c1(Object(r), !0).forEach(function(n) {
      WJ(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : c1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function WJ(e, t, r) {
  return t = VJ(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function VJ(e) {
  var t = $J(e, "string");
  return cc(t) == "symbol" ? t : t + "";
}
function $J(e, t) {
  if (cc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (cc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function jJ(e, t) {
  if (e == null) return {};
  var r = UJ(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function UJ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
var oF = {
  symbolCircle: Ey,
  symbolCross: gJ,
  symbolDiamond: pJ,
  symbolSquare: mJ,
  symbolStar: wJ,
  symbolTriangle: bJ,
  symbolWye: xJ
}, KJ = Math.PI / 180, qJ = function(t) {
  var r = "symbol".concat(sg(t));
  return oF[r] || Ey;
}, YJ = function(t, r, n) {
  if (r === "area")
    return t;
  switch (n) {
    case "cross":
      return 5 * t * t / 9;
    case "diamond":
      return 0.5 * t * t / Math.sqrt(3);
    case "square":
      return t * t;
    case "star": {
      var i = 18 * KJ;
      return 1.25 * t * t * (Math.tan(i) - Math.tan(i * 2) * Math.pow(Math.tan(i), 2));
    }
    case "triangle":
      return Math.sqrt(3) * t * t / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * t * t / 8;
    default:
      return Math.PI * t * t / 4;
  }
}, JJ = function(t, r) {
  oF["symbol".concat(sg(t))] = r;
}, ug = function(t) {
  var r = t.type, n = r === void 0 ? "circle" : r, i = t.size, o = i === void 0 ? 64 : i, s = t.sizeType, a = s === void 0 ? "area" : s, l = jJ(t, HJ), u = u1(u1({}, l), {}, {
    type: n,
    size: o,
    sizeType: a
  }), d = function() {
    var v = qJ(n), w = RJ().type(v).size(YJ(o, a, n));
    return w();
  }, h = u.className, f = u.cx, p = u.cy, y = Ne(u, !0);
  return f === +f && p === +p && o === +o ? /* @__PURE__ */ O.createElement("path", Ym({}, y, {
    className: Ze("recharts-symbols", h),
    transform: "translate(".concat(f, ", ").concat(p, ")"),
    d: d()
  })) : null;
};
ug.registerSymbol = JJ;
function la(e) {
  "@babel/helpers - typeof";
  return la = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, la(e);
}
function Jm() {
  return Jm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Jm.apply(this, arguments);
}
function d1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function XJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d1(Object(r), !0).forEach(function(n) {
      uc(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : d1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function QJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ZJ(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, aF(n.key), n);
  }
}
function eX(e, t, r) {
  return t && ZJ(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function tX(e, t, r) {
  return t = Ud(t), rX(e, sF() ? Reflect.construct(t, r || [], Ud(e).constructor) : t.apply(e, r));
}
function rX(e, t) {
  if (t && (la(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return nX(e);
}
function nX(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function sF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (sF = function() {
    return !!e;
  })();
}
function Ud(e) {
  return Ud = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Ud(e);
}
function iX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Xm(e, t);
}
function Xm(e, t) {
  return Xm = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Xm(e, t);
}
function uc(e, t, r) {
  return t = aF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function aF(e) {
  var t = oX(e, "string");
  return la(t) == "symbol" ? t : t + "";
}
function oX(e, t) {
  if (la(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (la(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var mn = 32, Py = /* @__PURE__ */ function(e) {
  function t() {
    return QJ(this, t), tX(this, t, arguments);
  }
  return iX(t, e), eX(t, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function(n) {
        var i = this.props.inactiveColor, o = mn / 2, s = mn / 6, a = mn / 3, l = n.inactive ? i : n.color;
        if (n.type === "plainline")
          return /* @__PURE__ */ O.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            strokeDasharray: n.payload.strokeDasharray,
            x1: 0,
            y1: o,
            x2: mn,
            y2: o,
            className: "recharts-legend-icon"
          });
        if (n.type === "line")
          return /* @__PURE__ */ O.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            d: "M0,".concat(o, "h").concat(a, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(2 * a, ",").concat(o, `
            H`).concat(mn, "M").concat(2 * a, ",").concat(o, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(a, ",").concat(o),
            className: "recharts-legend-icon"
          });
        if (n.type === "rect")
          return /* @__PURE__ */ O.createElement("path", {
            stroke: "none",
            fill: l,
            d: "M0,".concat(mn / 8, "h").concat(mn, "v").concat(mn * 3 / 4, "h").concat(-mn, "z"),
            className: "recharts-legend-icon"
          });
        if (/* @__PURE__ */ O.isValidElement(n.legendIcon)) {
          var u = XJ({}, n);
          return delete u.legendIcon, /* @__PURE__ */ O.cloneElement(n.legendIcon, u);
        }
        return /* @__PURE__ */ O.createElement(ug, {
          fill: l,
          cx: o,
          cy: o,
          size: mn,
          sizeType: "diameter",
          type: n.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function() {
      var n = this, i = this.props, o = i.payload, s = i.iconSize, a = i.layout, l = i.formatter, u = i.inactiveColor, d = {
        x: 0,
        y: 0,
        width: mn,
        height: mn
      }, h = {
        display: a === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      }, f = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return o.map(function(p, y) {
        var C = p.formatter || l, v = Ze(uc(uc({
          "recharts-legend-item": !0
        }, "legend-item-".concat(y), !0), "inactive", p.inactive));
        if (p.type === "none")
          return null;
        var w = We(p.value) ? null : p.value;
        og(
          !We(p.value),
          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
          // eslint-disable-line max-len
        );
        var R = p.inactive ? u : p.color;
        return /* @__PURE__ */ O.createElement("li", Jm({
          className: v,
          style: h,
          key: "legend-item-".concat(y)
        }, lc(n.props, p, y)), /* @__PURE__ */ O.createElement(Hm, {
          width: s,
          height: s,
          viewBox: d,
          style: f
        }, n.renderIcon(p)), /* @__PURE__ */ O.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: R
          }
        }, C ? C(w, p, y) : w));
      });
    }
  }, {
    key: "render",
    value: function() {
      var n = this.props, i = n.payload, o = n.layout, s = n.align;
      if (!i || !i.length)
        return null;
      var a = {
        padding: 0,
        margin: 0,
        textAlign: o === "horizontal" ? s : "left"
      };
      return /* @__PURE__ */ O.createElement("ul", {
        className: "recharts-default-legend",
        style: a
      }, this.renderItems());
    }
  }]);
}(ui);
uc(Py, "displayName", "Legend");
uc(Py, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
var sX = rg;
function aX() {
  this.__data__ = new sX(), this.size = 0;
}
var lX = aX;
function cX(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
var uX = cX;
function dX(e) {
  return this.__data__.get(e);
}
var hX = dX;
function gX(e) {
  return this.__data__.has(e);
}
var fX = gX, pX = rg, mX = my, vX = vy, yX = 200;
function CX(e, t) {
  var r = this.__data__;
  if (r instanceof pX) {
    var n = r.__data__;
    if (!mX || n.length < yX - 1)
      return n.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new vX(n);
  }
  return r.set(e, t), this.size = r.size, this;
}
var wX = CX, bX = rg, SX = lX, xX = uX, RX = hX, EX = fX, PX = wX;
function Xa(e) {
  var t = this.__data__ = new bX(e);
  this.size = t.size;
}
Xa.prototype.clear = SX;
Xa.prototype.delete = xX;
Xa.prototype.get = RX;
Xa.prototype.has = EX;
Xa.prototype.set = PX;
var lF = Xa, AX = "__lodash_hash_undefined__";
function FX(e) {
  return this.__data__.set(e, AX), this;
}
var MX = FX;
function TX(e) {
  return this.__data__.has(e);
}
var DX = TX, OX = vy, IX = MX, kX = DX;
function Kd(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.__data__ = new OX(); ++t < r; )
    this.add(e[t]);
}
Kd.prototype.add = Kd.prototype.push = IX;
Kd.prototype.has = kX;
var cF = Kd;
function LX(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
    if (t(e[r], r, e))
      return !0;
  return !1;
}
var uF = LX;
function _X(e, t) {
  return e.has(t);
}
var dF = _X, zX = cF, NX = uF, BX = dF, GX = 1, HX = 2;
function WX(e, t, r, n, i, o) {
  var s = r & GX, a = e.length, l = t.length;
  if (a != l && !(s && l > a))
    return !1;
  var u = o.get(e), d = o.get(t);
  if (u && d)
    return u == t && d == e;
  var h = -1, f = !0, p = r & HX ? new zX() : void 0;
  for (o.set(e, t), o.set(t, e); ++h < a; ) {
    var y = e[h], C = t[h];
    if (n)
      var v = s ? n(C, y, h, t, e, o) : n(y, C, h, e, t, o);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!NX(t, function(w, R) {
        if (!BX(p, R) && (y === w || i(y, w, r, n, o)))
          return p.push(R);
      })) {
        f = !1;
        break;
      }
    } else if (!(y === C || i(y, C, r, n, o))) {
      f = !1;
      break;
    }
  }
  return o.delete(e), o.delete(t), f;
}
var hF = WX, VX = gi, $X = VX.Uint8Array, jX = $X;
function UX(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n, i) {
    r[++t] = [i, n];
  }), r;
}
var KX = UX;
function qX(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n) {
    r[++t] = n;
  }), r;
}
var Ay = qX, h1 = Yc, g1 = jX, YX = py, JX = hF, XX = KX, QX = Ay, ZX = 1, eQ = 2, tQ = "[object Boolean]", rQ = "[object Date]", nQ = "[object Error]", iQ = "[object Map]", oQ = "[object Number]", sQ = "[object RegExp]", aQ = "[object Set]", lQ = "[object String]", cQ = "[object Symbol]", uQ = "[object ArrayBuffer]", dQ = "[object DataView]", f1 = h1 ? h1.prototype : void 0, Dp = f1 ? f1.valueOf : void 0;
function hQ(e, t, r, n, i, o, s) {
  switch (r) {
    case dQ:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case uQ:
      return !(e.byteLength != t.byteLength || !o(new g1(e), new g1(t)));
    case tQ:
    case rQ:
    case oQ:
      return YX(+e, +t);
    case nQ:
      return e.name == t.name && e.message == t.message;
    case sQ:
    case lQ:
      return e == t + "";
    case iQ:
      var a = XX;
    case aQ:
      var l = n & ZX;
      if (a || (a = QX), e.size != t.size && !l)
        return !1;
      var u = s.get(e);
      if (u)
        return u == t;
      n |= eQ, s.set(e, t);
      var d = JX(a(e), a(t), n, i, o, s);
      return s.delete(e), d;
    case cQ:
      if (Dp)
        return Dp.call(e) == Dp.call(t);
  }
  return !1;
}
var gQ = hQ;
function fQ(e, t) {
  for (var r = -1, n = t.length, i = e.length; ++r < n; )
    e[i + r] = t[r];
  return e;
}
var gF = fQ, pQ = gF, mQ = Vr;
function vQ(e, t, r) {
  var n = t(e);
  return mQ(e) ? n : pQ(n, r(e));
}
var yQ = vQ;
function CQ(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = 0, o = []; ++r < n; ) {
    var s = e[r];
    t(s, r, e) && (o[i++] = s);
  }
  return o;
}
var wQ = CQ;
function bQ() {
  return [];
}
var SQ = bQ, xQ = wQ, RQ = SQ, EQ = Object.prototype, PQ = EQ.propertyIsEnumerable, p1 = Object.getOwnPropertySymbols, AQ = p1 ? function(e) {
  return e == null ? [] : (e = Object(e), xQ(p1(e), function(t) {
    return PQ.call(e, t);
  }));
} : RQ, FQ = AQ;
function MQ(e, t) {
  for (var r = -1, n = Array(e); ++r < e; )
    n[r] = t(r);
  return n;
}
var TQ = MQ, DQ = Bi, OQ = Gi, IQ = "[object Arguments]";
function kQ(e) {
  return OQ(e) && DQ(e) == IQ;
}
var LQ = kQ, m1 = LQ, _Q = Gi, fF = Object.prototype, zQ = fF.hasOwnProperty, NQ = fF.propertyIsEnumerable, BQ = m1(/* @__PURE__ */ function() {
  return arguments;
}()) ? m1 : function(e) {
  return _Q(e) && zQ.call(e, "callee") && !NQ.call(e, "callee");
}, Fy = BQ, qd = { exports: {} };
function GQ() {
  return !1;
}
var HQ = GQ;
qd.exports;
(function(e, t) {
  var r = gi, n = HQ, i = t && !t.nodeType && t, o = i && !0 && e && !e.nodeType && e, s = o && o.exports === i, a = s ? r.Buffer : void 0, l = a ? a.isBuffer : void 0, u = l || n;
  e.exports = u;
})(qd, qd.exports);
var pF = qd.exports, WQ = 9007199254740991, VQ = /^(?:0|[1-9]\d*)$/;
function $Q(e, t) {
  var r = typeof e;
  return t = t ?? WQ, !!t && (r == "number" || r != "symbol" && VQ.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var My = $Q, jQ = 9007199254740991;
function UQ(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= jQ;
}
var Ty = UQ, KQ = Bi, qQ = Ty, YQ = Gi, JQ = "[object Arguments]", XQ = "[object Array]", QQ = "[object Boolean]", ZQ = "[object Date]", eZ = "[object Error]", tZ = "[object Function]", rZ = "[object Map]", nZ = "[object Number]", iZ = "[object Object]", oZ = "[object RegExp]", sZ = "[object Set]", aZ = "[object String]", lZ = "[object WeakMap]", cZ = "[object ArrayBuffer]", uZ = "[object DataView]", dZ = "[object Float32Array]", hZ = "[object Float64Array]", gZ = "[object Int8Array]", fZ = "[object Int16Array]", pZ = "[object Int32Array]", mZ = "[object Uint8Array]", vZ = "[object Uint8ClampedArray]", yZ = "[object Uint16Array]", CZ = "[object Uint32Array]", xt = {};
xt[dZ] = xt[hZ] = xt[gZ] = xt[fZ] = xt[pZ] = xt[mZ] = xt[vZ] = xt[yZ] = xt[CZ] = !0;
xt[JQ] = xt[XQ] = xt[cZ] = xt[QQ] = xt[uZ] = xt[ZQ] = xt[eZ] = xt[tZ] = xt[rZ] = xt[nZ] = xt[iZ] = xt[oZ] = xt[sZ] = xt[aZ] = xt[lZ] = !1;
function wZ(e) {
  return YQ(e) && qQ(e.length) && !!xt[KQ(e)];
}
var bZ = wZ;
function SZ(e) {
  return function(t) {
    return e(t);
  };
}
var mF = SZ, Yd = { exports: {} };
Yd.exports;
(function(e, t) {
  var r = EA, n = t && !t.nodeType && t, i = n && !0 && e && !e.nodeType && e, o = i && i.exports === n, s = o && r.process, a = function() {
    try {
      var l = i && i.require && i.require("util").types;
      return l || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  e.exports = a;
})(Yd, Yd.exports);
var xZ = Yd.exports, RZ = bZ, EZ = mF, v1 = xZ, y1 = v1 && v1.isTypedArray, PZ = y1 ? EZ(y1) : RZ, vF = PZ, AZ = TQ, FZ = Fy, MZ = Vr, TZ = pF, DZ = My, OZ = vF, IZ = Object.prototype, kZ = IZ.hasOwnProperty;
function LZ(e, t) {
  var r = MZ(e), n = !r && FZ(e), i = !r && !n && TZ(e), o = !r && !n && !i && OZ(e), s = r || n || i || o, a = s ? AZ(e.length, String) : [], l = a.length;
  for (var u in e)
    (t || kZ.call(e, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    DZ(u, l))) && a.push(u);
  return a;
}
var _Z = LZ, zZ = Object.prototype;
function NZ(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || zZ;
  return e === r;
}
var BZ = NZ;
function GZ(e, t) {
  return function(r) {
    return e(t(r));
  };
}
var yF = GZ, HZ = yF, WZ = HZ(Object.keys, Object), VZ = WZ, $Z = BZ, jZ = VZ, UZ = Object.prototype, KZ = UZ.hasOwnProperty;
function qZ(e) {
  if (!$Z(e))
    return jZ(e);
  var t = [];
  for (var r in Object(e))
    KZ.call(e, r) && r != "constructor" && t.push(r);
  return t;
}
var YZ = qZ, JZ = fy, XZ = Ty;
function QZ(e) {
  return e != null && XZ(e.length) && !JZ(e);
}
var dg = QZ, ZZ = _Z, eee = YZ, tee = dg;
function ree(e) {
  return tee(e) ? ZZ(e) : eee(e);
}
var Dy = ree, nee = yQ, iee = FQ, oee = Dy;
function see(e) {
  return nee(e, oee, iee);
}
var aee = see, C1 = aee, lee = 1, cee = Object.prototype, uee = cee.hasOwnProperty;
function dee(e, t, r, n, i, o) {
  var s = r & lee, a = C1(e), l = a.length, u = C1(t), d = u.length;
  if (l != d && !s)
    return !1;
  for (var h = l; h--; ) {
    var f = a[h];
    if (!(s ? f in t : uee.call(t, f)))
      return !1;
  }
  var p = o.get(e), y = o.get(t);
  if (p && y)
    return p == t && y == e;
  var C = !0;
  o.set(e, t), o.set(t, e);
  for (var v = s; ++h < l; ) {
    f = a[h];
    var w = e[f], R = t[f];
    if (n)
      var b = s ? n(R, w, f, t, e, o) : n(w, R, f, e, t, o);
    if (!(b === void 0 ? w === R || i(w, R, r, n, o) : b)) {
      C = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (C && !v) {
    var P = e.constructor, S = t.constructor;
    P != S && "constructor" in e && "constructor" in t && !(typeof P == "function" && P instanceof P && typeof S == "function" && S instanceof S) && (C = !1);
  }
  return o.delete(e), o.delete(t), C;
}
var hee = dee, gee = ys, fee = gi, pee = gee(fee, "DataView"), mee = pee, vee = ys, yee = gi, Cee = vee(yee, "Promise"), wee = Cee, bee = ys, See = gi, xee = bee(See, "Set"), CF = xee, Ree = ys, Eee = gi, Pee = Ree(Eee, "WeakMap"), Aee = Pee, Qm = mee, Zm = my, ev = wee, tv = CF, rv = Aee, wF = Bi, Qa = AA, w1 = "[object Map]", Fee = "[object Object]", b1 = "[object Promise]", S1 = "[object Set]", x1 = "[object WeakMap]", R1 = "[object DataView]", Mee = Qa(Qm), Tee = Qa(Zm), Dee = Qa(ev), Oee = Qa(tv), Iee = Qa(rv), Go = wF;
(Qm && Go(new Qm(new ArrayBuffer(1))) != R1 || Zm && Go(new Zm()) != w1 || ev && Go(ev.resolve()) != b1 || tv && Go(new tv()) != S1 || rv && Go(new rv()) != x1) && (Go = function(e) {
  var t = wF(e), r = t == Fee ? e.constructor : void 0, n = r ? Qa(r) : "";
  if (n)
    switch (n) {
      case Mee:
        return R1;
      case Tee:
        return w1;
      case Dee:
        return b1;
      case Oee:
        return S1;
      case Iee:
        return x1;
    }
  return t;
});
var kee = Go, Op = lF, Lee = hF, _ee = gQ, zee = hee, E1 = kee, P1 = Vr, A1 = pF, Nee = vF, Bee = 1, F1 = "[object Arguments]", M1 = "[object Array]", Xu = "[object Object]", Gee = Object.prototype, T1 = Gee.hasOwnProperty;
function Hee(e, t, r, n, i, o) {
  var s = P1(e), a = P1(t), l = s ? M1 : E1(e), u = a ? M1 : E1(t);
  l = l == F1 ? Xu : l, u = u == F1 ? Xu : u;
  var d = l == Xu, h = u == Xu, f = l == u;
  if (f && A1(e)) {
    if (!A1(t))
      return !1;
    s = !0, d = !1;
  }
  if (f && !d)
    return o || (o = new Op()), s || Nee(e) ? Lee(e, t, r, n, i, o) : _ee(e, t, l, r, n, i, o);
  if (!(r & Bee)) {
    var p = d && T1.call(e, "__wrapped__"), y = h && T1.call(t, "__wrapped__");
    if (p || y) {
      var C = p ? e.value() : e, v = y ? t.value() : t;
      return o || (o = new Op()), i(C, v, r, n, o);
    }
  }
  return f ? (o || (o = new Op()), zee(e, t, r, n, i, o)) : !1;
}
var Wee = Hee, Vee = Wee, D1 = Gi;
function bF(e, t, r, n, i) {
  return e === t ? !0 : e == null || t == null || !D1(e) && !D1(t) ? e !== e && t !== t : Vee(e, t, r, n, bF, i);
}
var Oy = bF, $ee = lF, jee = Oy, Uee = 1, Kee = 2;
function qee(e, t, r, n) {
  var i = r.length, o = i, s = !n;
  if (e == null)
    return !o;
  for (e = Object(e); i--; ) {
    var a = r[i];
    if (s && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < o; ) {
    a = r[i];
    var l = a[0], u = e[l], d = a[1];
    if (s && a[2]) {
      if (u === void 0 && !(l in e))
        return !1;
    } else {
      var h = new $ee();
      if (n)
        var f = n(u, d, l, e, t, h);
      if (!(f === void 0 ? jee(d, u, Uee | Kee, n, h) : f))
        return !1;
    }
  }
  return !0;
}
var Yee = qee, Jee = bo;
function Xee(e) {
  return e === e && !Jee(e);
}
var SF = Xee, Qee = SF, Zee = Dy;
function ete(e) {
  for (var t = Zee(e), r = t.length; r--; ) {
    var n = t[r], i = e[n];
    t[r] = [n, i, Qee(i)];
  }
  return t;
}
var tte = ete;
function rte(e, t) {
  return function(r) {
    return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
var xF = rte, nte = Yee, ite = tte, ote = xF;
function ste(e) {
  var t = ite(e);
  return t.length == 1 && t[0][2] ? ote(t[0][0], t[0][1]) : function(r) {
    return r === e || nte(r, e, t);
  };
}
var ate = ste;
function lte(e, t) {
  return e != null && t in Object(e);
}
var cte = lte, ute = OA, dte = Fy, hte = Vr, gte = My, fte = Ty, pte = ig;
function mte(e, t, r) {
  t = ute(t, e);
  for (var n = -1, i = t.length, o = !1; ++n < i; ) {
    var s = pte(t[n]);
    if (!(o = e != null && r(e, s)))
      break;
    e = e[s];
  }
  return o || ++n != i ? o : (i = e == null ? 0 : e.length, !!i && fte(i) && gte(s, i) && (hte(e) || dte(e)));
}
var vte = mte, yte = cte, Cte = vte;
function wte(e, t) {
  return e != null && Cte(e, t, yte);
}
var bte = wte, Ste = Oy, xte = IA, Rte = bte, Ete = gy, Pte = SF, Ate = xF, Fte = ig, Mte = 1, Tte = 2;
function Dte(e, t) {
  return Ete(e) && Pte(t) ? Ate(Fte(e), t) : function(r) {
    var n = xte(r, e);
    return n === void 0 && n === t ? Rte(r, e) : Ste(t, n, Mte | Tte);
  };
}
var Ote = Dte;
function Ite(e) {
  return e;
}
var Za = Ite;
function kte(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var Lte = kte, _te = wy;
function zte(e) {
  return function(t) {
    return _te(t, e);
  };
}
var Nte = zte, Bte = Lte, Gte = Nte, Hte = gy, Wte = ig;
function Vte(e) {
  return Hte(e) ? Bte(Wte(e)) : Gte(e);
}
var $te = Vte, jte = ate, Ute = Ote, Kte = Za, qte = Vr, Yte = $te;
function Jte(e) {
  return typeof e == "function" ? e : e == null ? Kte : typeof e == "object" ? qte(e) ? Ute(e[0], e[1]) : jte(e) : Yte(e);
}
var el = Jte;
function Xte(e, t, r, n) {
  for (var i = e.length, o = r + (n ? 1 : -1); n ? o-- : ++o < i; )
    if (t(e[o], o, e))
      return o;
  return -1;
}
var Qte = Xte;
function Zte(e) {
  return e !== e;
}
var ere = Zte;
function tre(e, t, r) {
  for (var n = r - 1, i = e.length; ++n < i; )
    if (e[n] === t)
      return n;
  return -1;
}
var rre = tre, nre = Qte, ire = ere, ore = rre;
function sre(e, t, r) {
  return t === t ? ore(e, t, r) : nre(e, ire, r);
}
var are = sre, lre = are;
function cre(e, t) {
  var r = e == null ? 0 : e.length;
  return !!r && lre(e, t, 0) > -1;
}
var ure = cre;
function dre(e, t, r) {
  for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
    if (r(t, e[n]))
      return !0;
  return !1;
}
var hre = dre;
function gre() {
}
var fre = gre, Ip = CF, pre = fre, mre = Ay, vre = 1 / 0, yre = Ip && 1 / mre(new Ip([, -0]))[1] == vre ? function(e) {
  return new Ip(e);
} : pre, Cre = yre, wre = cF, bre = ure, Sre = hre, xre = dF, Rre = Cre, Ere = Ay, Pre = 200;
function Are(e, t, r) {
  var n = -1, i = bre, o = e.length, s = !0, a = [], l = a;
  if (r)
    s = !1, i = Sre;
  else if (o >= Pre) {
    var u = t ? null : Rre(e);
    if (u)
      return Ere(u);
    s = !1, i = xre, l = new wre();
  } else
    l = t ? [] : a;
  e:
    for (; ++n < o; ) {
      var d = e[n], h = t ? t(d) : d;
      if (d = r || d !== 0 ? d : 0, s && h === h) {
        for (var f = l.length; f--; )
          if (l[f] === h)
            continue e;
        t && l.push(h), a.push(d);
      } else i(l, h, r) || (l !== a && l.push(h), a.push(d));
    }
  return a;
}
var Fre = Are, Mre = el, Tre = Fre;
function Dre(e, t) {
  return e && e.length ? Tre(e, Mre(t)) : [];
}
var Ore = Dre;
const O1 = /* @__PURE__ */ bt(Ore);
function RF(e, t, r) {
  return t === !0 ? O1(e, r) : We(t) ? O1(e, t) : e;
}
function ca(e) {
  "@babel/helpers - typeof";
  return ca = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ca(e);
}
var Ire = ["ref"];
function I1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function xi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I1(Object(r), !0).forEach(function(n) {
      hg(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : I1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function kre(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function k1(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, PF(n.key), n);
  }
}
function Lre(e, t, r) {
  return t && k1(e.prototype, t), r && k1(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function _re(e, t, r) {
  return t = Jd(t), zre(e, EF() ? Reflect.construct(t, r || [], Jd(e).constructor) : t.apply(e, r));
}
function zre(e, t) {
  if (t && (ca(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Nre(e);
}
function Nre(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function EF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (EF = function() {
    return !!e;
  })();
}
function Jd(e) {
  return Jd = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Jd(e);
}
function Bre(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && nv(e, t);
}
function nv(e, t) {
  return nv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, nv(e, t);
}
function hg(e, t, r) {
  return t = PF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function PF(e) {
  var t = Gre(e, "string");
  return ca(t) == "symbol" ? t : t + "";
}
function Gre(e, t) {
  if (ca(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (ca(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function Hre(e, t) {
  if (e == null) return {};
  var r = Wre(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Wre(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Vre(e) {
  return e.value;
}
function $re(e, t) {
  if (/* @__PURE__ */ O.isValidElement(e))
    return /* @__PURE__ */ O.cloneElement(e, t);
  if (typeof e == "function")
    return /* @__PURE__ */ O.createElement(e, t);
  t.ref;
  var r = Hre(t, Ire);
  return /* @__PURE__ */ O.createElement(Py, r);
}
var L1 = 1, ea = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    kre(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = _re(this, t, [].concat(i)), hg(r, "lastBoundingBox", {
      width: -1,
      height: -1
    }), r;
  }
  return Bre(t, e), Lre(t, [{
    key: "componentDidMount",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var n = this.wrapperNode.getBoundingClientRect();
        return n.height = this.wrapperNode.offsetHeight, n.width = this.wrapperNode.offsetWidth, n;
      }
      return null;
    }
  }, {
    key: "updateBBox",
    value: function() {
      var n = this.props.onBBoxUpdate, i = this.getBBox();
      i ? (Math.abs(i.width - this.lastBoundingBox.width) > L1 || Math.abs(i.height - this.lastBoundingBox.height) > L1) && (this.lastBoundingBox.width = i.width, this.lastBoundingBox.height = i.height, n && n(i)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, n && n(null));
    }
  }, {
    key: "getBBoxSnapshot",
    value: function() {
      return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? xi({}, this.lastBoundingBox) : {
        width: 0,
        height: 0
      };
    }
  }, {
    key: "getDefaultPosition",
    value: function(n) {
      var i = this.props, o = i.layout, s = i.align, a = i.verticalAlign, l = i.margin, u = i.chartWidth, d = i.chartHeight, h, f;
      if (!n || (n.left === void 0 || n.left === null) && (n.right === void 0 || n.right === null))
        if (s === "center" && o === "vertical") {
          var p = this.getBBoxSnapshot();
          h = {
            left: ((u || 0) - p.width) / 2
          };
        } else
          h = s === "right" ? {
            right: l && l.right || 0
          } : {
            left: l && l.left || 0
          };
      if (!n || (n.top === void 0 || n.top === null) && (n.bottom === void 0 || n.bottom === null))
        if (a === "middle") {
          var y = this.getBBoxSnapshot();
          f = {
            top: ((d || 0) - y.height) / 2
          };
        } else
          f = a === "bottom" ? {
            bottom: l && l.bottom || 0
          } : {
            top: l && l.top || 0
          };
      return xi(xi({}, h), f);
    }
  }, {
    key: "render",
    value: function() {
      var n = this, i = this.props, o = i.content, s = i.width, a = i.height, l = i.wrapperStyle, u = i.payloadUniqBy, d = i.payload, h = xi(xi({
        position: "absolute",
        width: s || "auto",
        height: a || "auto"
      }, this.getDefaultPosition(l)), l);
      return /* @__PURE__ */ O.createElement("div", {
        className: "recharts-legend-wrapper",
        style: h,
        ref: function(p) {
          n.wrapperNode = p;
        }
      }, $re(o, xi(xi({}, this.props), {}, {
        payload: RF(d, u, Vre)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function(n, i) {
      var o = xi(xi({}, this.defaultProps), n.props), s = o.layout;
      return s === "vertical" && Ce(n.props.height) ? {
        height: n.props.height
      } : s === "horizontal" ? {
        width: n.props.width || i
      } : null;
    }
  }]);
}(ui);
hg(ea, "displayName", "Legend");
hg(ea, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var _1 = Yc, jre = Fy, Ure = Vr, z1 = _1 ? _1.isConcatSpreadable : void 0;
function Kre(e) {
  return Ure(e) || jre(e) || !!(z1 && e && e[z1]);
}
var qre = Kre, Yre = gF, Jre = qre;
function AF(e, t, r, n, i) {
  var o = -1, s = e.length;
  for (r || (r = Jre), i || (i = []); ++o < s; ) {
    var a = e[o];
    t > 0 && r(a) ? t > 1 ? AF(a, t - 1, r, n, i) : Yre(i, a) : n || (i[i.length] = a);
  }
  return i;
}
var FF = AF;
function Xre(e) {
  return function(t, r, n) {
    for (var i = -1, o = Object(t), s = n(t), a = s.length; a--; ) {
      var l = s[e ? a : ++i];
      if (r(o[l], l, o) === !1)
        break;
    }
    return t;
  };
}
var Qre = Xre, Zre = Qre, ene = Zre(), tne = ene, rne = tne, nne = Dy;
function ine(e, t) {
  return e && rne(e, t, nne);
}
var MF = ine, one = dg;
function sne(e, t) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!one(r))
      return e(r, n);
    for (var i = r.length, o = t ? i : -1, s = Object(r); (t ? o-- : ++o < i) && n(s[o], o, s) !== !1; )
      ;
    return r;
  };
}
var ane = sne, lne = MF, cne = ane, une = cne(lne), Iy = une, dne = Iy, hne = dg;
function gne(e, t) {
  var r = -1, n = hne(e) ? Array(e.length) : [];
  return dne(e, function(i, o, s) {
    n[++r] = t(i, o, s);
  }), n;
}
var TF = gne;
function fne(e, t) {
  var r = e.length;
  for (e.sort(t); r--; )
    e[r] = e[r].value;
  return e;
}
var pne = fne, N1 = ja;
function mne(e, t) {
  if (e !== t) {
    var r = e !== void 0, n = e === null, i = e === e, o = N1(e), s = t !== void 0, a = t === null, l = t === t, u = N1(t);
    if (!a && !u && !o && e > t || o && s && l && !a && !u || n && s && l || !r && l || !i)
      return 1;
    if (!n && !o && !u && e < t || u && r && i && !n && !o || a && r && i || !s && i || !l)
      return -1;
  }
  return 0;
}
var vne = mne, yne = vne;
function Cne(e, t, r) {
  for (var n = -1, i = e.criteria, o = t.criteria, s = i.length, a = r.length; ++n < s; ) {
    var l = yne(i[n], o[n]);
    if (l) {
      if (n >= a)
        return l;
      var u = r[n];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
var wne = Cne, kp = Cy, bne = wy, Sne = el, xne = TF, Rne = pne, Ene = mF, Pne = wne, Ane = Za, Fne = Vr;
function Mne(e, t, r) {
  t.length ? t = kp(t, function(o) {
    return Fne(o) ? function(s) {
      return bne(s, o.length === 1 ? o[0] : o);
    } : o;
  }) : t = [Ane];
  var n = -1;
  t = kp(t, Ene(Sne));
  var i = xne(e, function(o, s, a) {
    var l = kp(t, function(u) {
      return u(o);
    });
    return { criteria: l, index: ++n, value: o };
  });
  return Rne(i, function(o, s) {
    return Pne(o, s, r);
  });
}
var Tne = Mne;
function Dne(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
var One = Dne, Ine = One, B1 = Math.max;
function kne(e, t, r) {
  return t = B1(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var n = arguments, i = -1, o = B1(n.length - t, 0), s = Array(o); ++i < o; )
      s[i] = n[t + i];
    i = -1;
    for (var a = Array(t + 1); ++i < t; )
      a[i] = n[i];
    return a[t] = r(s), Ine(e, this, a);
  };
}
var Lne = kne;
function _ne(e) {
  return function() {
    return e;
  };
}
var zne = _ne, Nne = ys, Bne = function() {
  try {
    var e = Nne(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), DF = Bne, Gne = zne, G1 = DF, Hne = Za, Wne = G1 ? function(e, t) {
  return G1(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Gne(t),
    writable: !0
  });
} : Hne, Vne = Wne, $ne = 800, jne = 16, Une = Date.now;
function Kne(e) {
  var t = 0, r = 0;
  return function() {
    var n = Une(), i = jne - (n - r);
    if (r = n, i > 0) {
      if (++t >= $ne)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var qne = Kne, Yne = Vne, Jne = qne, Xne = Jne(Yne), Qne = Xne, Zne = Za, eie = Lne, tie = Qne;
function rie(e, t) {
  return tie(eie(e, t, Zne), e + "");
}
var nie = rie, iie = py, oie = dg, sie = My, aie = bo;
function lie(e, t, r) {
  if (!aie(r))
    return !1;
  var n = typeof t;
  return (n == "number" ? oie(r) && sie(t, r.length) : n == "string" && t in r) ? iie(r[t], e) : !1;
}
var gg = lie, cie = FF, uie = Tne, die = nie, H1 = gg, hie = die(function(e, t) {
  if (e == null)
    return [];
  var r = t.length;
  return r > 1 && H1(e, t[0], t[1]) ? t = [] : r > 2 && H1(t[0], t[1], t[2]) && (t = [t[0]]), uie(e, cie(t, 1), []);
}), gie = hie;
const ky = /* @__PURE__ */ bt(gie);
function dc(e) {
  "@babel/helpers - typeof";
  return dc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dc(e);
}
function iv() {
  return iv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, iv.apply(this, arguments);
}
function fie(e, t) {
  return yie(e) || vie(e, t) || mie(e, t) || pie();
}
function pie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mie(e, t) {
  if (e) {
    if (typeof e == "string") return W1(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return W1(e, t);
  }
}
function W1(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function vie(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function yie(e) {
  if (Array.isArray(e)) return e;
}
function V1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Lp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V1(Object(r), !0).forEach(function(n) {
      Cie(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : V1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Cie(e, t, r) {
  return t = wie(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function wie(e) {
  var t = bie(e, "string");
  return dc(t) == "symbol" ? t : t + "";
}
function bie(e, t) {
  if (dc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (dc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Sie(e) {
  return Array.isArray(e) && Jt(e[0]) && Jt(e[1]) ? e.join(" ~ ") : e;
}
var xie = function(t) {
  var r = t.separator, n = r === void 0 ? " : " : r, i = t.contentStyle, o = i === void 0 ? {} : i, s = t.itemStyle, a = s === void 0 ? {} : s, l = t.labelStyle, u = l === void 0 ? {} : l, d = t.payload, h = t.formatter, f = t.itemSorter, p = t.wrapperClassName, y = t.labelClassName, C = t.label, v = t.labelFormatter, w = t.accessibilityLayer, R = w === void 0 ? !1 : w, b = function() {
    if (d && d.length) {
      var _ = {
        padding: 0,
        margin: 0
      }, q = (f ? ky(d, f) : d).map(function(j, Q) {
        if (j.type === "none")
          return null;
        var K = Lp({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: j.color || "#000"
        }, a), Z = j.formatter || h || Sie, te = j.value, se = j.name, W = te, U = se;
        if (Z && W != null && U != null) {
          var X = Z(te, se, j, Q, d);
          if (Array.isArray(X)) {
            var he = fie(X, 2);
            W = he[0], U = he[1];
          } else
            W = X;
        }
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ O.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(Q),
            style: K
          }, Jt(U) ? /* @__PURE__ */ O.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, U) : null, Jt(U) ? /* @__PURE__ */ O.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, n) : null, /* @__PURE__ */ O.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, W), /* @__PURE__ */ O.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, j.unit || ""))
        );
      });
      return /* @__PURE__ */ O.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: _
      }, q);
    }
    return null;
  }, P = Lp({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, o), S = Lp({
    margin: 0
  }, u), E = !_e(C), A = E ? C : "", M = Ze("recharts-default-tooltip", p), I = Ze("recharts-tooltip-label", y);
  E && v && d !== void 0 && d !== null && (A = v(C, d));
  var z = R ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ O.createElement("div", iv({
    className: M,
    style: P
  }, z), /* @__PURE__ */ O.createElement("p", {
    className: I,
    style: S
  }, /* @__PURE__ */ O.isValidElement(A) ? A : "".concat(A)), b());
};
function hc(e) {
  "@babel/helpers - typeof";
  return hc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hc(e);
}
function Qu(e, t, r) {
  return t = Rie(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Rie(e) {
  var t = Eie(e, "string");
  return hc(t) == "symbol" ? t : t + "";
}
function Eie(e, t) {
  if (hc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (hc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Al = "recharts-tooltip-wrapper", Pie = {
  visibility: "hidden"
};
function Aie(e) {
  var t = e.coordinate, r = e.translateX, n = e.translateY;
  return Ze(Al, Qu(Qu(Qu(Qu({}, "".concat(Al, "-right"), Ce(r) && t && Ce(t.x) && r >= t.x), "".concat(Al, "-left"), Ce(r) && t && Ce(t.x) && r < t.x), "".concat(Al, "-bottom"), Ce(n) && t && Ce(t.y) && n >= t.y), "".concat(Al, "-top"), Ce(n) && t && Ce(t.y) && n < t.y));
}
function $1(e) {
  var t = e.allowEscapeViewBox, r = e.coordinate, n = e.key, i = e.offsetTopLeft, o = e.position, s = e.reverseDirection, a = e.tooltipDimension, l = e.viewBox, u = e.viewBoxDimension;
  if (o && Ce(o[n]))
    return o[n];
  var d = r[n] - a - i, h = r[n] + i;
  if (t[n])
    return s[n] ? d : h;
  if (s[n]) {
    var f = d, p = l[n];
    return f < p ? Math.max(h, l[n]) : Math.max(d, l[n]);
  }
  var y = h + a, C = l[n] + u;
  return y > C ? Math.max(d, l[n]) : Math.max(h, l[n]);
}
function Fie(e) {
  var t = e.translateX, r = e.translateY, n = e.useTranslate3d;
  return {
    transform: n ? "translate3d(".concat(t, "px, ").concat(r, "px, 0)") : "translate(".concat(t, "px, ").concat(r, "px)")
  };
}
function Mie(e) {
  var t = e.allowEscapeViewBox, r = e.coordinate, n = e.offsetTopLeft, i = e.position, o = e.reverseDirection, s = e.tooltipBox, a = e.useTranslate3d, l = e.viewBox, u, d, h;
  return s.height > 0 && s.width > 0 && r ? (d = $1({
    allowEscapeViewBox: t,
    coordinate: r,
    key: "x",
    offsetTopLeft: n,
    position: i,
    reverseDirection: o,
    tooltipDimension: s.width,
    viewBox: l,
    viewBoxDimension: l.width
  }), h = $1({
    allowEscapeViewBox: t,
    coordinate: r,
    key: "y",
    offsetTopLeft: n,
    position: i,
    reverseDirection: o,
    tooltipDimension: s.height,
    viewBox: l,
    viewBoxDimension: l.height
  }), u = Fie({
    translateX: d,
    translateY: h,
    useTranslate3d: a
  })) : u = Pie, {
    cssProperties: u,
    cssClasses: Aie({
      translateX: d,
      translateY: h,
      coordinate: r
    })
  };
}
function ua(e) {
  "@babel/helpers - typeof";
  return ua = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ua(e);
}
function j1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function U1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j1(Object(r), !0).forEach(function(n) {
      sv(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : j1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Tie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Die(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, IF(n.key), n);
  }
}
function Oie(e, t, r) {
  return t && Die(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Iie(e, t, r) {
  return t = Xd(t), kie(e, OF() ? Reflect.construct(t, r || [], Xd(e).constructor) : t.apply(e, r));
}
function kie(e, t) {
  if (t && (ua(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Lie(e);
}
function Lie(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function OF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (OF = function() {
    return !!e;
  })();
}
function Xd(e) {
  return Xd = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Xd(e);
}
function _ie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ov(e, t);
}
function ov(e, t) {
  return ov = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, ov(e, t);
}
function sv(e, t, r) {
  return t = IF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function IF(e) {
  var t = zie(e, "string");
  return ua(t) == "symbol" ? t : t + "";
}
function zie(e, t) {
  if (ua(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (ua(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var K1 = 1, Nie = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    Tie(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = Iie(this, t, [].concat(i)), sv(r, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      },
      lastBoundingBox: {
        width: -1,
        height: -1
      }
    }), sv(r, "handleKeyDown", function(s) {
      if (s.key === "Escape") {
        var a, l, u, d;
        r.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (a = (l = r.props.coordinate) === null || l === void 0 ? void 0 : l.x) !== null && a !== void 0 ? a : 0,
            y: (u = (d = r.props.coordinate) === null || d === void 0 ? void 0 : d.y) !== null && u !== void 0 ? u : 0
          }
        });
      }
    }), r;
  }
  return _ie(t, e), Oie(t, [{
    key: "updateBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var n = this.wrapperNode.getBoundingClientRect();
        (Math.abs(n.width - this.state.lastBoundingBox.width) > K1 || Math.abs(n.height - this.state.lastBoundingBox.height) > K1) && this.setState({
          lastBoundingBox: {
            width: n.width,
            height: n.height
          }
        });
      } else (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({
        lastBoundingBox: {
          width: -1,
          height: -1
        }
      });
    }
  }, {
    key: "componentDidMount",
    value: function() {
      document.addEventListener("keydown", this.handleKeyDown), this.updateBBox();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      var n, i;
      this.props.active && this.updateBBox(), this.state.dismissed && (((n = this.props.coordinate) === null || n === void 0 ? void 0 : n.x) !== this.state.dismissedAtCoordinate.x || ((i = this.props.coordinate) === null || i === void 0 ? void 0 : i.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
    }
  }, {
    key: "render",
    value: function() {
      var n = this, i = this.props, o = i.active, s = i.allowEscapeViewBox, a = i.animationDuration, l = i.animationEasing, u = i.children, d = i.coordinate, h = i.hasPayload, f = i.isAnimationActive, p = i.offset, y = i.position, C = i.reverseDirection, v = i.useTranslate3d, w = i.viewBox, R = i.wrapperStyle, b = Mie({
        allowEscapeViewBox: s,
        coordinate: d,
        offsetTopLeft: p,
        position: y,
        reverseDirection: C,
        tooltipBox: this.state.lastBoundingBox,
        useTranslate3d: v,
        viewBox: w
      }), P = b.cssClasses, S = b.cssProperties, E = U1(U1({
        transition: f && o ? "transform ".concat(a, "ms ").concat(l) : void 0
      }, S), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && o && h ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, R);
      return (
        // This element allow listening to the `Escape` key.
        // See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ O.createElement("div", {
          tabIndex: -1,
          className: P,
          style: E,
          ref: function(M) {
            n.wrapperNode = M;
          }
        }, u)
      );
    }
  }]);
}(ui), Bie = function() {
  return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout);
}, So = {
  isSsr: Bie()
};
function da(e) {
  "@babel/helpers - typeof";
  return da = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, da(e);
}
function q1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Y1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q1(Object(r), !0).forEach(function(n) {
      Ly(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : q1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Gie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hie(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, LF(n.key), n);
  }
}
function Wie(e, t, r) {
  return t && Hie(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Vie(e, t, r) {
  return t = Qd(t), $ie(e, kF() ? Reflect.construct(t, r || [], Qd(e).constructor) : t.apply(e, r));
}
function $ie(e, t) {
  if (t && (da(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return jie(e);
}
function jie(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function kF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (kF = function() {
    return !!e;
  })();
}
function Qd(e) {
  return Qd = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Qd(e);
}
function Uie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && av(e, t);
}
function av(e, t) {
  return av = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, av(e, t);
}
function Ly(e, t, r) {
  return t = LF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function LF(e) {
  var t = Kie(e, "string");
  return da(t) == "symbol" ? t : t + "";
}
function Kie(e, t) {
  if (da(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (da(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function qie(e) {
  return e.dataKey;
}
function Yie(e, t) {
  return /* @__PURE__ */ O.isValidElement(e) ? /* @__PURE__ */ O.cloneElement(e, t) : typeof e == "function" ? /* @__PURE__ */ O.createElement(e, t) : /* @__PURE__ */ O.createElement(xie, t);
}
var kn = /* @__PURE__ */ function(e) {
  function t() {
    return Gie(this, t), Vie(this, t, arguments);
  }
  return Uie(t, e), Wie(t, [{
    key: "render",
    value: function() {
      var n = this, i = this.props, o = i.active, s = i.allowEscapeViewBox, a = i.animationDuration, l = i.animationEasing, u = i.content, d = i.coordinate, h = i.filterNull, f = i.isAnimationActive, p = i.offset, y = i.payload, C = i.payloadUniqBy, v = i.position, w = i.reverseDirection, R = i.useTranslate3d, b = i.viewBox, P = i.wrapperStyle, S = y ?? [];
      h && S.length && (S = RF(y.filter(function(A) {
        return A.value != null && (A.hide !== !0 || n.props.includeHidden);
      }), C, qie));
      var E = S.length > 0;
      return /* @__PURE__ */ O.createElement(Nie, {
        allowEscapeViewBox: s,
        animationDuration: a,
        animationEasing: l,
        isAnimationActive: f,
        active: o,
        coordinate: d,
        hasPayload: E,
        offset: p,
        position: v,
        reverseDirection: w,
        useTranslate3d: R,
        viewBox: b,
        wrapperStyle: P
      }, Yie(u, Y1(Y1({}, this.props), {}, {
        payload: S
      })));
    }
  }]);
}(ui);
Ly(kn, "displayName", "Tooltip");
Ly(kn, "defaultProps", {
  accessibilityLayer: !1,
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: {
    x: 0,
    y: 0
  },
  cursor: !0,
  cursorStyle: {},
  filterNull: !0,
  isAnimationActive: !So.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  wrapperStyle: {}
});
var Jie = gi, Xie = function() {
  return Jie.Date.now();
}, Qie = Xie, Zie = /\s/;
function eoe(e) {
  for (var t = e.length; t-- && Zie.test(e.charAt(t)); )
    ;
  return t;
}
var toe = eoe, roe = toe, noe = /^\s+/;
function ioe(e) {
  return e && e.slice(0, roe(e) + 1).replace(noe, "");
}
var ooe = ioe, soe = ooe, J1 = bo, aoe = ja, X1 = NaN, loe = /^[-+]0x[0-9a-f]+$/i, coe = /^0b[01]+$/i, uoe = /^0o[0-7]+$/i, doe = parseInt;
function hoe(e) {
  if (typeof e == "number")
    return e;
  if (aoe(e))
    return X1;
  if (J1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = J1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = soe(e);
  var r = coe.test(e);
  return r || uoe.test(e) ? doe(e.slice(2), r ? 2 : 8) : loe.test(e) ? X1 : +e;
}
var _F = hoe, goe = bo, _p = Qie, Q1 = _F, foe = "Expected a function", poe = Math.max, moe = Math.min;
function voe(e, t, r) {
  var n, i, o, s, a, l, u = 0, d = !1, h = !1, f = !0;
  if (typeof e != "function")
    throw new TypeError(foe);
  t = Q1(t) || 0, goe(r) && (d = !!r.leading, h = "maxWait" in r, o = h ? poe(Q1(r.maxWait) || 0, t) : o, f = "trailing" in r ? !!r.trailing : f);
  function p(E) {
    var A = n, M = i;
    return n = i = void 0, u = E, s = e.apply(M, A), s;
  }
  function y(E) {
    return u = E, a = setTimeout(w, t), d ? p(E) : s;
  }
  function C(E) {
    var A = E - l, M = E - u, I = t - A;
    return h ? moe(I, o - M) : I;
  }
  function v(E) {
    var A = E - l, M = E - u;
    return l === void 0 || A >= t || A < 0 || h && M >= o;
  }
  function w() {
    var E = _p();
    if (v(E))
      return R(E);
    a = setTimeout(w, C(E));
  }
  function R(E) {
    return a = void 0, f && n ? p(E) : (n = i = void 0, s);
  }
  function b() {
    a !== void 0 && clearTimeout(a), u = 0, n = l = i = a = void 0;
  }
  function P() {
    return a === void 0 ? s : R(_p());
  }
  function S() {
    var E = _p(), A = v(E);
    if (n = arguments, i = this, l = E, A) {
      if (a === void 0)
        return y(l);
      if (h)
        return clearTimeout(a), a = setTimeout(w, t), p(l);
    }
    return a === void 0 && (a = setTimeout(w, t)), s;
  }
  return S.cancel = b, S.flush = P, S;
}
var yoe = voe, Coe = yoe, woe = bo, boe = "Expected a function";
function Soe(e, t, r) {
  var n = !0, i = !0;
  if (typeof e != "function")
    throw new TypeError(boe);
  return woe(r) && (n = "leading" in r ? !!r.leading : n, i = "trailing" in r ? !!r.trailing : i), Coe(e, t, {
    leading: n,
    maxWait: t,
    trailing: i
  });
}
var xoe = Soe;
const Roe = /* @__PURE__ */ bt(xoe);
var _y = function(t) {
  return null;
};
_y.displayName = "Cell";
function gc(e) {
  "@babel/helpers - typeof";
  return gc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gc(e);
}
function Z1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function lv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z1(Object(r), !0).forEach(function(n) {
      Eoe(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Z1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Eoe(e, t, r) {
  return t = Poe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Poe(e) {
  var t = Aoe(e, "string");
  return gc(t) == "symbol" ? t : t + "";
}
function Aoe(e, t) {
  if (gc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (gc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Ns = {
  widthCache: {},
  cacheCount: 0
}, Foe = 2e3, Moe = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, e2 = "recharts_measurement_span";
function Toe(e) {
  var t = lv({}, e);
  return Object.keys(t).forEach(function(r) {
    t[r] || delete t[r];
  }), t;
}
var Kl = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (t == null || So.isSsr)
    return {
      width: 0,
      height: 0
    };
  var n = Toe(r), i = JSON.stringify({
    text: t,
    copyStyle: n
  });
  if (Ns.widthCache[i])
    return Ns.widthCache[i];
  try {
    var o = document.getElementById(e2);
    o || (o = document.createElement("span"), o.setAttribute("id", e2), o.setAttribute("aria-hidden", "true"), document.body.appendChild(o));
    var s = lv(lv({}, Moe), n);
    Object.assign(o.style, s), o.textContent = "".concat(t);
    var a = o.getBoundingClientRect(), l = {
      width: a.width,
      height: a.height
    };
    return Ns.widthCache[i] = l, ++Ns.cacheCount > Foe && (Ns.cacheCount = 0, Ns.widthCache = {}), l;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, Doe = function(t) {
  return {
    top: t.top + window.scrollY - document.documentElement.clientTop,
    left: t.left + window.scrollX - document.documentElement.clientLeft
  };
};
function fc(e) {
  "@babel/helpers - typeof";
  return fc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fc(e);
}
function Zd(e, t) {
  return Loe(e) || koe(e, t) || Ioe(e, t) || Ooe();
}
function Ooe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ioe(e, t) {
  if (e) {
    if (typeof e == "string") return t2(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return t2(e, t);
  }
}
function t2(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function koe(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Loe(e) {
  if (Array.isArray(e)) return e;
}
function _oe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function r2(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, Noe(n.key), n);
  }
}
function zoe(e, t, r) {
  return t && r2(e.prototype, t), r && r2(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Noe(e) {
  var t = Boe(e, "string");
  return fc(t) == "symbol" ? t : t + "";
}
function Boe(e, t) {
  if (fc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (fc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var n2 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, i2 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, Goe = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, Hoe = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, zF = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, Woe = Object.keys(zF), js = "NaN";
function Voe(e, t) {
  return e * zF[t];
}
var Zu = /* @__PURE__ */ function() {
  function e(t, r) {
    _oe(this, e), this.num = t, this.unit = r, this.num = t, this.unit = r, Number.isNaN(t) && (this.unit = ""), r !== "" && !Goe.test(r) && (this.num = NaN, this.unit = ""), Woe.includes(r) && (this.num = Voe(t, r), this.unit = "px");
  }
  return zoe(e, [{
    key: "add",
    value: function(r) {
      return this.unit !== r.unit ? new e(NaN, "") : new e(this.num + r.num, this.unit);
    }
  }, {
    key: "subtract",
    value: function(r) {
      return this.unit !== r.unit ? new e(NaN, "") : new e(this.num - r.num, this.unit);
    }
  }, {
    key: "multiply",
    value: function(r) {
      return this.unit !== "" && r.unit !== "" && this.unit !== r.unit ? new e(NaN, "") : new e(this.num * r.num, this.unit || r.unit);
    }
  }, {
    key: "divide",
    value: function(r) {
      return this.unit !== "" && r.unit !== "" && this.unit !== r.unit ? new e(NaN, "") : new e(this.num / r.num, this.unit || r.unit);
    }
  }, {
    key: "toString",
    value: function() {
      return "".concat(this.num).concat(this.unit);
    }
  }, {
    key: "isNaN",
    value: function() {
      return Number.isNaN(this.num);
    }
  }], [{
    key: "parse",
    value: function(r) {
      var n, i = (n = Hoe.exec(r)) !== null && n !== void 0 ? n : [], o = Zd(i, 3), s = o[1], a = o[2];
      return new e(parseFloat(s), a ?? "");
    }
  }]);
}();
function NF(e) {
  if (e.includes(js))
    return js;
  for (var t = e; t.includes("*") || t.includes("/"); ) {
    var r, n = (r = n2.exec(t)) !== null && r !== void 0 ? r : [], i = Zd(n, 4), o = i[1], s = i[2], a = i[3], l = Zu.parse(o ?? ""), u = Zu.parse(a ?? ""), d = s === "*" ? l.multiply(u) : l.divide(u);
    if (d.isNaN())
      return js;
    t = t.replace(n2, d.toString());
  }
  for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t); ) {
    var h, f = (h = i2.exec(t)) !== null && h !== void 0 ? h : [], p = Zd(f, 4), y = p[1], C = p[2], v = p[3], w = Zu.parse(y ?? ""), R = Zu.parse(v ?? ""), b = C === "+" ? w.add(R) : w.subtract(R);
    if (b.isNaN())
      return js;
    t = t.replace(i2, b.toString());
  }
  return t;
}
var o2 = /\(([^()]*)\)/;
function $oe(e) {
  for (var t = e; t.includes("("); ) {
    var r = o2.exec(t), n = Zd(r, 2), i = n[1];
    t = t.replace(o2, NF(i));
  }
  return t;
}
function joe(e) {
  var t = e.replace(/\s+/g, "");
  return t = $oe(t), t = NF(t), t;
}
function Uoe(e) {
  try {
    return joe(e);
  } catch {
    return js;
  }
}
function zp(e) {
  var t = Uoe(e.slice(5, -1));
  return t === js ? "" : t;
}
var Koe = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], qoe = ["dx", "dy", "angle", "className", "breakAll"];
function cv() {
  return cv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, cv.apply(this, arguments);
}
function s2(e, t) {
  if (e == null) return {};
  var r = Yoe(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Yoe(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function a2(e, t) {
  return Zoe(e) || Qoe(e, t) || Xoe(e, t) || Joe();
}
function Joe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Xoe(e, t) {
  if (e) {
    if (typeof e == "string") return l2(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return l2(e, t);
  }
}
function l2(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Qoe(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Zoe(e) {
  if (Array.isArray(e)) return e;
}
var BF = /[ \f\n\r\t\v\u2028\u2029]+/, GF = function(t) {
  var r = t.children, n = t.breakAll, i = t.style;
  try {
    var o = [];
    _e(r) || (n ? o = r.toString().split("") : o = r.toString().split(BF));
    var s = o.map(function(l) {
      return {
        word: l,
        width: Kl(l, i).width
      };
    }), a = n ? 0 : Kl(" ", i).width;
    return {
      wordsWithComputedWidth: s,
      spaceWidth: a
    };
  } catch {
    return null;
  }
}, ese = function(t, r, n, i, o) {
  var s = t.maxLines, a = t.children, l = t.style, u = t.breakAll, d = Ce(s), h = a, f = function() {
    var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Q.reduce(function(K, Z) {
      var te = Z.word, se = Z.width, W = K[K.length - 1];
      if (W && (i == null || o || W.width + se + n < Number(i)))
        W.words.push(te), W.width += se + n;
      else {
        var U = {
          words: [te],
          width: se
        };
        K.push(U);
      }
      return K;
    }, []);
  }, p = f(r), y = function(Q) {
    return Q.reduce(function(K, Z) {
      return K.width > Z.width ? K : Z;
    });
  };
  if (!d)
    return p;
  for (var C = "…", v = function(Q) {
    var K = h.slice(0, Q), Z = GF({
      breakAll: u,
      style: l,
      children: K + C
    }).wordsWithComputedWidth, te = f(Z), se = te.length > s || y(te).width > Number(i);
    return [se, te];
  }, w = 0, R = h.length - 1, b = 0, P; w <= R && b <= h.length - 1; ) {
    var S = Math.floor((w + R) / 2), E = S - 1, A = v(E), M = a2(A, 2), I = M[0], z = M[1], k = v(S), _ = a2(k, 1), q = _[0];
    if (!I && !q && (w = S + 1), I && q && (R = S - 1), !I && q) {
      P = z;
      break;
    }
    b++;
  }
  return P || p;
}, c2 = function(t) {
  var r = _e(t) ? [] : t.toString().split(BF);
  return [{
    words: r
  }];
}, tse = function(t) {
  var r = t.width, n = t.scaleToFit, i = t.children, o = t.style, s = t.breakAll, a = t.maxLines;
  if ((r || n) && !So.isSsr) {
    var l, u, d = GF({
      breakAll: s,
      children: i,
      style: o
    });
    if (d) {
      var h = d.wordsWithComputedWidth, f = d.spaceWidth;
      l = h, u = f;
    } else
      return c2(i);
    return ese({
      breakAll: s,
      children: i,
      maxLines: a,
      style: o
    }, l, u, r, n);
  }
  return c2(i);
}, u2 = "#808080", eh = function(t) {
  var r = t.x, n = r === void 0 ? 0 : r, i = t.y, o = i === void 0 ? 0 : i, s = t.lineHeight, a = s === void 0 ? "1em" : s, l = t.capHeight, u = l === void 0 ? "0.71em" : l, d = t.scaleToFit, h = d === void 0 ? !1 : d, f = t.textAnchor, p = f === void 0 ? "start" : f, y = t.verticalAnchor, C = y === void 0 ? "end" : y, v = t.fill, w = v === void 0 ? u2 : v, R = s2(t, Koe), b = Se(function() {
    return tse({
      breakAll: R.breakAll,
      children: R.children,
      maxLines: R.maxLines,
      scaleToFit: h,
      style: R.style,
      width: R.width
    });
  }, [R.breakAll, R.children, R.maxLines, h, R.style, R.width]), P = R.dx, S = R.dy, E = R.angle, A = R.className, M = R.breakAll, I = s2(R, qoe);
  if (!Jt(n) || !Jt(o))
    return null;
  var z = n + (Ce(P) ? P : 0), k = o + (Ce(S) ? S : 0), _;
  switch (C) {
    case "start":
      _ = zp("calc(".concat(u, ")"));
      break;
    case "middle":
      _ = zp("calc(".concat((b.length - 1) / 2, " * -").concat(a, " + (").concat(u, " / 2))"));
      break;
    default:
      _ = zp("calc(".concat(b.length - 1, " * -").concat(a, ")"));
      break;
  }
  var q = [];
  if (h) {
    var j = b[0].width, Q = R.width;
    q.push("scale(".concat((Ce(Q) ? Q / j : 1) / j, ")"));
  }
  return E && q.push("rotate(".concat(E, ", ").concat(z, ", ").concat(k, ")")), q.length && (I.transform = q.join(" ")), /* @__PURE__ */ O.createElement("text", cv({}, Ne(I, !0), {
    x: z,
    y: k,
    className: Ze("recharts-text", A),
    textAnchor: p,
    fill: w.includes("url") ? u2 : w
  }), b.map(function(K, Z) {
    var te = K.words.join(M ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ O.createElement("tspan", {
        x: z,
        dy: Z === 0 ? _ : a,
        key: "".concat(te, "-").concat(Z)
      }, te)
    );
  }));
};
function uo(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function rse(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function zy(e) {
  let t, r, n;
  e.length !== 2 ? (t = uo, r = (a, l) => uo(e(a), l), n = (a, l) => e(a) - l) : (t = e === uo || e === rse ? e : nse, r = e, n = e);
  function i(a, l, u = 0, d = a.length) {
    if (u < d) {
      if (t(l, l) !== 0) return d;
      do {
        const h = u + d >>> 1;
        r(a[h], l) < 0 ? u = h + 1 : d = h;
      } while (u < d);
    }
    return u;
  }
  function o(a, l, u = 0, d = a.length) {
    if (u < d) {
      if (t(l, l) !== 0) return d;
      do {
        const h = u + d >>> 1;
        r(a[h], l) <= 0 ? u = h + 1 : d = h;
      } while (u < d);
    }
    return u;
  }
  function s(a, l, u = 0, d = a.length) {
    const h = i(a, l, u, d - 1);
    return h > u && n(a[h - 1], l) > -n(a[h], l) ? h - 1 : h;
  }
  return { left: i, center: s, right: o };
}
function nse() {
  return 0;
}
function HF(e) {
  return e === null ? NaN : +e;
}
function* ise(e, t) {
  for (let r of e)
    r != null && (r = +r) >= r && (yield r);
}
const ose = zy(uo), Jc = ose.right;
zy(HF).center;
class d2 extends Map {
  constructor(t, r = lse) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null) for (const [n, i] of t) this.set(n, i);
  }
  get(t) {
    return super.get(h2(this, t));
  }
  has(t) {
    return super.has(h2(this, t));
  }
  set(t, r) {
    return super.set(sse(this, t), r);
  }
  delete(t) {
    return super.delete(ase(this, t));
  }
}
function h2({ _intern: e, _key: t }, r) {
  const n = t(r);
  return e.has(n) ? e.get(n) : r;
}
function sse({ _intern: e, _key: t }, r) {
  const n = t(r);
  return e.has(n) ? e.get(n) : (e.set(n, r), r);
}
function ase({ _intern: e, _key: t }, r) {
  const n = t(r);
  return e.has(n) && (r = e.get(n), e.delete(n)), r;
}
function lse(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function cse(e = uo) {
  if (e === uo) return WF;
  if (typeof e != "function") throw new TypeError("compare is not a function");
  return (t, r) => {
    const n = e(t, r);
    return n || n === 0 ? n : (e(r, r) === 0) - (e(t, t) === 0);
  };
}
function WF(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const use = Math.sqrt(50), dse = Math.sqrt(10), hse = Math.sqrt(2);
function th(e, t, r) {
  const n = (t - e) / Math.max(0, r), i = Math.floor(Math.log10(n)), o = n / Math.pow(10, i), s = o >= use ? 10 : o >= dse ? 5 : o >= hse ? 2 : 1;
  let a, l, u;
  return i < 0 ? (u = Math.pow(10, -i) / s, a = Math.round(e * u), l = Math.round(t * u), a / u < e && ++a, l / u > t && --l, u = -u) : (u = Math.pow(10, i) * s, a = Math.round(e / u), l = Math.round(t / u), a * u < e && ++a, l * u > t && --l), l < a && 0.5 <= r && r < 2 ? th(e, t, r * 2) : [a, l, u];
}
function uv(e, t, r) {
  if (t = +t, e = +e, r = +r, !(r > 0)) return [];
  if (e === t) return [e];
  const n = t < e, [i, o, s] = n ? th(t, e, r) : th(e, t, r);
  if (!(o >= i)) return [];
  const a = o - i + 1, l = new Array(a);
  if (n)
    if (s < 0) for (let u = 0; u < a; ++u) l[u] = (o - u) / -s;
    else for (let u = 0; u < a; ++u) l[u] = (o - u) * s;
  else if (s < 0) for (let u = 0; u < a; ++u) l[u] = (i + u) / -s;
  else for (let u = 0; u < a; ++u) l[u] = (i + u) * s;
  return l;
}
function dv(e, t, r) {
  return t = +t, e = +e, r = +r, th(e, t, r)[2];
}
function hv(e, t, r) {
  t = +t, e = +e, r = +r;
  const n = t < e, i = n ? dv(t, e, r) : dv(e, t, r);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function g2(e, t) {
  let r;
  for (const n of e)
    n != null && (r < n || r === void 0 && n >= n) && (r = n);
  return r;
}
function f2(e, t) {
  let r;
  for (const n of e)
    n != null && (r > n || r === void 0 && n >= n) && (r = n);
  return r;
}
function VF(e, t, r = 0, n = 1 / 0, i) {
  if (t = Math.floor(t), r = Math.floor(Math.max(0, r)), n = Math.floor(Math.min(e.length - 1, n)), !(r <= t && t <= n)) return e;
  for (i = i === void 0 ? WF : cse(i); n > r; ) {
    if (n - r > 600) {
      const l = n - r + 1, u = t - r + 1, d = Math.log(l), h = 0.5 * Math.exp(2 * d / 3), f = 0.5 * Math.sqrt(d * h * (l - h) / l) * (u - l / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(t - u * h / l + f)), y = Math.min(n, Math.floor(t + (l - u) * h / l + f));
      VF(e, t, p, y, i);
    }
    const o = e[t];
    let s = r, a = n;
    for (Fl(e, r, t), i(e[n], o) > 0 && Fl(e, r, n); s < a; ) {
      for (Fl(e, s, a), ++s, --a; i(e[s], o) < 0; ) ++s;
      for (; i(e[a], o) > 0; ) --a;
    }
    i(e[r], o) === 0 ? Fl(e, r, a) : (++a, Fl(e, a, n)), a <= t && (r = a + 1), t <= a && (n = a - 1);
  }
  return e;
}
function Fl(e, t, r) {
  const n = e[t];
  e[t] = e[r], e[r] = n;
}
function gse(e, t, r) {
  if (e = Float64Array.from(ise(e)), !(!(n = e.length) || isNaN(t = +t))) {
    if (t <= 0 || n < 2) return f2(e);
    if (t >= 1) return g2(e);
    var n, i = (n - 1) * t, o = Math.floor(i), s = g2(VF(e, o).subarray(0, o + 1)), a = f2(e.subarray(o + 1));
    return s + (a - s) * (i - o);
  }
}
function fse(e, t, r = HF) {
  if (!(!(n = e.length) || isNaN(t = +t))) {
    if (t <= 0 || n < 2) return +r(e[0], 0, e);
    if (t >= 1) return +r(e[n - 1], n - 1, e);
    var n, i = (n - 1) * t, o = Math.floor(i), s = +r(e[o], o, e), a = +r(e[o + 1], o + 1, e);
    return s + (a - s) * (i - o);
  }
}
function pse(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var n = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(i); ++n < i; )
    o[n] = e + n * r;
  return o;
}
function An(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Hi(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const gv = Symbol("implicit");
function Ny() {
  var e = new d2(), t = [], r = [], n = gv;
  function i(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (n !== gv) return n;
      e.set(o, s = t.push(o) - 1);
    }
    return r[s % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new d2();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return Ny(t, r).unknown(n);
  }, An.apply(i, arguments), i;
}
function pc() {
  var e = Ny().unknown(void 0), t = e.domain, r = e.range, n = 0, i = 1, o, s, a = !1, l = 0, u = 0, d = 0.5;
  delete e.unknown;
  function h() {
    var f = t().length, p = i < n, y = p ? i : n, C = p ? n : i;
    o = (C - y) / Math.max(1, f - l + u * 2), a && (o = Math.floor(o)), y += (C - y - o * (f - l)) * d, s = o * (1 - l), a && (y = Math.round(y), s = Math.round(s));
    var v = pse(f).map(function(w) {
      return y + o * w;
    });
    return r(p ? v.reverse() : v);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), h()) : t();
  }, e.range = function(f) {
    return arguments.length ? ([n, i] = f, n = +n, i = +i, h()) : [n, i];
  }, e.rangeRound = function(f) {
    return [n, i] = f, n = +n, i = +i, a = !0, h();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(f) {
    return arguments.length ? (a = !!f, h()) : a;
  }, e.padding = function(f) {
    return arguments.length ? (l = Math.min(1, u = +f), h()) : l;
  }, e.paddingInner = function(f) {
    return arguments.length ? (l = Math.min(1, f), h()) : l;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = +f, h()) : u;
  }, e.align = function(f) {
    return arguments.length ? (d = Math.max(0, Math.min(1, f)), h()) : d;
  }, e.copy = function() {
    return pc(t(), [n, i]).round(a).paddingInner(l).paddingOuter(u).align(d);
  }, An.apply(h(), arguments);
}
function $F(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return $F(t());
  }, e;
}
function ql() {
  return $F(pc.apply(null, arguments).paddingInner(1));
}
function By(e, t, r) {
  e.prototype = t.prototype = r, r.constructor = e;
}
function jF(e, t) {
  var r = Object.create(e.prototype);
  for (var n in t) r[n] = t[n];
  return r;
}
function Xc() {
}
var mc = 0.7, rh = 1 / mc, ta = "\\s*([+-]?\\d+)\\s*", vc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ii = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", mse = /^#([0-9a-f]{3,8})$/, vse = new RegExp(`^rgb\\(${ta},${ta},${ta}\\)$`), yse = new RegExp(`^rgb\\(${ii},${ii},${ii}\\)$`), Cse = new RegExp(`^rgba\\(${ta},${ta},${ta},${vc}\\)$`), wse = new RegExp(`^rgba\\(${ii},${ii},${ii},${vc}\\)$`), bse = new RegExp(`^hsl\\(${vc},${ii},${ii}\\)$`), Sse = new RegExp(`^hsla\\(${vc},${ii},${ii},${vc}\\)$`), p2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
By(Xc, yc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: m2,
  // Deprecated! Use color.formatHex.
  formatHex: m2,
  formatHex8: xse,
  formatHsl: Rse,
  formatRgb: v2,
  toString: v2
});
function m2() {
  return this.rgb().formatHex();
}
function xse() {
  return this.rgb().formatHex8();
}
function Rse() {
  return UF(this).formatHsl();
}
function v2() {
  return this.rgb().formatRgb();
}
function yc(e) {
  var t, r;
  return e = (e + "").trim().toLowerCase(), (t = mse.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), r === 6 ? y2(t) : r === 3 ? new Gr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? ed(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? ed(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = vse.exec(e)) ? new Gr(t[1], t[2], t[3], 1) : (t = yse.exec(e)) ? new Gr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Cse.exec(e)) ? ed(t[1], t[2], t[3], t[4]) : (t = wse.exec(e)) ? ed(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = bse.exec(e)) ? b2(t[1], t[2] / 100, t[3] / 100, 1) : (t = Sse.exec(e)) ? b2(t[1], t[2] / 100, t[3] / 100, t[4]) : p2.hasOwnProperty(e) ? y2(p2[e]) : e === "transparent" ? new Gr(NaN, NaN, NaN, 0) : null;
}
function y2(e) {
  return new Gr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function ed(e, t, r, n) {
  return n <= 0 && (e = t = r = NaN), new Gr(e, t, r, n);
}
function Ese(e) {
  return e instanceof Xc || (e = yc(e)), e ? (e = e.rgb(), new Gr(e.r, e.g, e.b, e.opacity)) : new Gr();
}
function fv(e, t, r, n) {
  return arguments.length === 1 ? Ese(e) : new Gr(e, t, r, n ?? 1);
}
function Gr(e, t, r, n) {
  this.r = +e, this.g = +t, this.b = +r, this.opacity = +n;
}
By(Gr, fv, jF(Xc, {
  brighter(e) {
    return e = e == null ? rh : Math.pow(rh, e), new Gr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? mc : Math.pow(mc, e), new Gr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Gr(ns(this.r), ns(this.g), ns(this.b), nh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: C2,
  // Deprecated! Use color.formatHex.
  formatHex: C2,
  formatHex8: Pse,
  formatRgb: w2,
  toString: w2
}));
function C2() {
  return `#${Ko(this.r)}${Ko(this.g)}${Ko(this.b)}`;
}
function Pse() {
  return `#${Ko(this.r)}${Ko(this.g)}${Ko(this.b)}${Ko((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function w2() {
  const e = nh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${ns(this.r)}, ${ns(this.g)}, ${ns(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function nh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function ns(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ko(e) {
  return e = ns(e), (e < 16 ? "0" : "") + e.toString(16);
}
function b2(e, t, r, n) {
  return n <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Nn(e, t, r, n);
}
function UF(e) {
  if (e instanceof Nn) return new Nn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Xc || (e = yc(e)), !e) return new Nn();
  if (e instanceof Nn) return e;
  e = e.rgb();
  var t = e.r / 255, r = e.g / 255, n = e.b / 255, i = Math.min(t, r, n), o = Math.max(t, r, n), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (t === o ? s = (r - n) / a + (r < n) * 6 : r === o ? s = (n - t) / a + 2 : s = (t - r) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new Nn(s, a, l, e.opacity);
}
function Ase(e, t, r, n) {
  return arguments.length === 1 ? UF(e) : new Nn(e, t, r, n ?? 1);
}
function Nn(e, t, r, n) {
  this.h = +e, this.s = +t, this.l = +r, this.opacity = +n;
}
By(Nn, Ase, jF(Xc, {
  brighter(e) {
    return e = e == null ? rh : Math.pow(rh, e), new Nn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? mc : Math.pow(mc, e), new Nn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * t, i = 2 * r - n;
    return new Gr(
      Np(e >= 240 ? e - 240 : e + 120, i, n),
      Np(e, i, n),
      Np(e < 120 ? e + 240 : e - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Nn(S2(this.h), td(this.s), td(this.l), nh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = nh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${S2(this.h)}, ${td(this.s) * 100}%, ${td(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function S2(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function td(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Np(e, t, r) {
  return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
const Gy = (e) => () => e;
function Fse(e, t) {
  return function(r) {
    return e + r * t;
  };
}
function Mse(e, t, r) {
  return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(n) {
    return Math.pow(e + n * t, r);
  };
}
function Tse(e) {
  return (e = +e) == 1 ? KF : function(t, r) {
    return r - t ? Mse(t, r, e) : Gy(isNaN(t) ? r : t);
  };
}
function KF(e, t) {
  var r = t - e;
  return r ? Fse(e, r) : Gy(isNaN(e) ? t : e);
}
const x2 = function e(t) {
  var r = Tse(t);
  function n(i, o) {
    var s = r((i = fv(i)).r, (o = fv(o)).r), a = r(i.g, o.g), l = r(i.b, o.b), u = KF(i.opacity, o.opacity);
    return function(d) {
      return i.r = s(d), i.g = a(d), i.b = l(d), i.opacity = u(d), i + "";
    };
  }
  return n.gamma = e, n;
}(1);
function Dse(e, t) {
  t || (t = []);
  var r = e ? Math.min(t.length, e.length) : 0, n = t.slice(), i;
  return function(o) {
    for (i = 0; i < r; ++i) n[i] = e[i] * (1 - o) + t[i] * o;
    return n;
  };
}
function Ose(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function Ise(e, t) {
  var r = t ? t.length : 0, n = e ? Math.min(r, e.length) : 0, i = new Array(n), o = new Array(r), s;
  for (s = 0; s < n; ++s) i[s] = tl(e[s], t[s]);
  for (; s < r; ++s) o[s] = t[s];
  return function(a) {
    for (s = 0; s < n; ++s) o[s] = i[s](a);
    return o;
  };
}
function kse(e, t) {
  var r = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(n) {
    return r.setTime(e * (1 - n) + t * n), r;
  };
}
function ih(e, t) {
  return e = +e, t = +t, function(r) {
    return e * (1 - r) + t * r;
  };
}
function Lse(e, t) {
  var r = {}, n = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? r[i] = tl(e[i], t[i]) : n[i] = t[i];
  return function(o) {
    for (i in r) n[i] = r[i](o);
    return n;
  };
}
var pv = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Bp = new RegExp(pv.source, "g");
function _se(e) {
  return function() {
    return e;
  };
}
function zse(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Nse(e, t) {
  var r = pv.lastIndex = Bp.lastIndex = 0, n, i, o, s = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (n = pv.exec(e)) && (i = Bp.exec(t)); )
    (o = i.index) > r && (o = t.slice(r, o), a[s] ? a[s] += o : a[++s] = o), (n = n[0]) === (i = i[0]) ? a[s] ? a[s] += i : a[++s] = i : (a[++s] = null, l.push({ i: s, x: ih(n, i) })), r = Bp.lastIndex;
  return r < t.length && (o = t.slice(r), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? zse(l[0].x) : _se(t) : (t = l.length, function(u) {
    for (var d = 0, h; d < t; ++d) a[(h = l[d]).i] = h.x(u);
    return a.join("");
  });
}
function tl(e, t) {
  var r = typeof t, n;
  return t == null || r === "boolean" ? Gy(t) : (r === "number" ? ih : r === "string" ? (n = yc(t)) ? (t = n, x2) : Nse : t instanceof yc ? x2 : t instanceof Date ? kse : Ose(t) ? Dse : Array.isArray(t) ? Ise : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Lse : ih)(e, t);
}
function Hy(e, t) {
  return e = +e, t = +t, function(r) {
    return Math.round(e * (1 - r) + t * r);
  };
}
function Bse(e, t) {
  t === void 0 && (t = e, e = tl);
  for (var r = 0, n = t.length - 1, i = t[0], o = new Array(n < 0 ? 0 : n); r < n; ) o[r] = e(i, i = t[++r]);
  return function(s) {
    var a = Math.max(0, Math.min(n - 1, Math.floor(s *= n)));
    return o[a](s - a);
  };
}
function Gse(e) {
  return function() {
    return e;
  };
}
function oh(e) {
  return +e;
}
var R2 = [0, 1];
function Mr(e) {
  return e;
}
function mv(e, t) {
  return (t -= e = +e) ? function(r) {
    return (r - e) / t;
  } : Gse(isNaN(t) ? NaN : 0.5);
}
function Hse(e, t) {
  var r;
  return e > t && (r = e, e = t, t = r), function(n) {
    return Math.max(e, Math.min(t, n));
  };
}
function Wse(e, t, r) {
  var n = e[0], i = e[1], o = t[0], s = t[1];
  return i < n ? (n = mv(i, n), o = r(s, o)) : (n = mv(n, i), o = r(o, s)), function(a) {
    return o(n(a));
  };
}
function Vse(e, t, r) {
  var n = Math.min(e.length, t.length) - 1, i = new Array(n), o = new Array(n), s = -1;
  for (e[n] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < n; )
    i[s] = mv(e[s], e[s + 1]), o[s] = r(t[s], t[s + 1]);
  return function(a) {
    var l = Jc(e, a, 1, n) - 1;
    return o[l](i[l](a));
  };
}
function Qc(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function fg() {
  var e = R2, t = R2, r = tl, n, i, o, s = Mr, a, l, u;
  function d() {
    var f = Math.min(e.length, t.length);
    return s !== Mr && (s = Hse(e[0], e[f - 1])), a = f > 2 ? Vse : Wse, l = u = null, h;
  }
  function h(f) {
    return f == null || isNaN(f = +f) ? o : (l || (l = a(e.map(n), t, r)))(n(s(f)));
  }
  return h.invert = function(f) {
    return s(i((u || (u = a(t, e.map(n), ih)))(f)));
  }, h.domain = function(f) {
    return arguments.length ? (e = Array.from(f, oh), d()) : e.slice();
  }, h.range = function(f) {
    return arguments.length ? (t = Array.from(f), d()) : t.slice();
  }, h.rangeRound = function(f) {
    return t = Array.from(f), r = Hy, d();
  }, h.clamp = function(f) {
    return arguments.length ? (s = f ? !0 : Mr, d()) : s !== Mr;
  }, h.interpolate = function(f) {
    return arguments.length ? (r = f, d()) : r;
  }, h.unknown = function(f) {
    return arguments.length ? (o = f, h) : o;
  }, function(f, p) {
    return n = f, i = p, d();
  };
}
function Wy() {
  return fg()(Mr, Mr);
}
function $se(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function sh(e, t) {
  if ((r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var r, n = e.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +e.slice(r + 1)
  ];
}
function ha(e) {
  return e = sh(Math.abs(e)), e ? e[1] : NaN;
}
function jse(e, t) {
  return function(r, n) {
    for (var i = r.length, o = [], s = 0, a = e[0], l = 0; i > 0 && a > 0 && (l + a + 1 > n && (a = Math.max(1, n - l)), o.push(r.substring(i -= a, i + a)), !((l += a + 1) > n)); )
      a = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function Use(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(r) {
      return e[+r];
    });
  };
}
var Kse = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Cc(e) {
  if (!(t = Kse.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Vy({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Cc.prototype = Vy.prototype;
function Vy(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Vy.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function qse(e) {
  e: for (var t = e.length, r = 1, n = -1, i; r < t; ++r)
    switch (e[r]) {
      case ".":
        n = i = r;
        break;
      case "0":
        n === 0 && (n = r), i = r;
        break;
      default:
        if (!+e[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? e.slice(0, n) + e.slice(i + 1) : e;
}
var qF;
function Yse(e, t) {
  var r = sh(e, t);
  if (!r) return e + "";
  var n = r[0], i = r[1], o = i - (qF = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = n.length;
  return o === s ? n : o > s ? n + new Array(o - s + 1).join("0") : o > 0 ? n.slice(0, o) + "." + n.slice(o) : "0." + new Array(1 - o).join("0") + sh(e, Math.max(0, t + o - 1))[0];
}
function E2(e, t) {
  var r = sh(e, t);
  if (!r) return e + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const P2 = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: $se,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => E2(e * 100, t),
  r: E2,
  s: Yse,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function A2(e) {
  return e;
}
var F2 = Array.prototype.map, M2 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Jse(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? A2 : jse(F2.call(e.grouping, Number), e.thousands + ""), r = e.currency === void 0 ? "" : e.currency[0] + "", n = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? A2 : Use(F2.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "−" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function u(h) {
    h = Cc(h);
    var f = h.fill, p = h.align, y = h.sign, C = h.symbol, v = h.zero, w = h.width, R = h.comma, b = h.precision, P = h.trim, S = h.type;
    S === "n" ? (R = !0, S = "g") : P2[S] || (b === void 0 && (b = 12), P = !0, S = "g"), (v || f === "0" && p === "=") && (v = !0, f = "0", p = "=");
    var E = C === "$" ? r : C === "#" && /[boxX]/.test(S) ? "0" + S.toLowerCase() : "", A = C === "$" ? n : /[%p]/.test(S) ? s : "", M = P2[S], I = /[defgprs%]/.test(S);
    b = b === void 0 ? 6 : /[gprs]/.test(S) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
    function z(k) {
      var _ = E, q = A, j, Q, K;
      if (S === "c")
        q = M(k) + q, k = "";
      else {
        k = +k;
        var Z = k < 0 || 1 / k < 0;
        if (k = isNaN(k) ? l : M(Math.abs(k), b), P && (k = qse(k)), Z && +k == 0 && y !== "+" && (Z = !1), _ = (Z ? y === "(" ? y : a : y === "-" || y === "(" ? "" : y) + _, q = (S === "s" ? M2[8 + qF / 3] : "") + q + (Z && y === "(" ? ")" : ""), I) {
          for (j = -1, Q = k.length; ++j < Q; )
            if (K = k.charCodeAt(j), 48 > K || K > 57) {
              q = (K === 46 ? i + k.slice(j + 1) : k.slice(j)) + q, k = k.slice(0, j);
              break;
            }
        }
      }
      R && !v && (k = t(k, 1 / 0));
      var te = _.length + k.length + q.length, se = te < w ? new Array(w - te + 1).join(f) : "";
      switch (R && v && (k = t(se + k, se.length ? w - q.length : 1 / 0), se = ""), p) {
        case "<":
          k = _ + k + q + se;
          break;
        case "=":
          k = _ + se + k + q;
          break;
        case "^":
          k = se.slice(0, te = se.length >> 1) + _ + k + q + se.slice(te);
          break;
        default:
          k = se + _ + k + q;
          break;
      }
      return o(k);
    }
    return z.toString = function() {
      return h + "";
    }, z;
  }
  function d(h, f) {
    var p = u((h = Cc(h), h.type = "f", h)), y = Math.max(-8, Math.min(8, Math.floor(ha(f) / 3))) * 3, C = Math.pow(10, -y), v = M2[8 + y / 3];
    return function(w) {
      return p(C * w) + v;
    };
  }
  return {
    format: u,
    formatPrefix: d
  };
}
var rd, $y, YF;
Xse({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Xse(e) {
  return rd = Jse(e), $y = rd.format, YF = rd.formatPrefix, rd;
}
function Qse(e) {
  return Math.max(0, -ha(Math.abs(e)));
}
function Zse(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(ha(t) / 3))) * 3 - ha(Math.abs(e)));
}
function eae(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, ha(t) - ha(e)) + 1;
}
function JF(e, t, r, n) {
  var i = hv(e, t, r), o;
  switch (n = Cc(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return n.precision == null && !isNaN(o = Zse(i, s)) && (n.precision = o), YF(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(o = eae(i, Math.max(Math.abs(e), Math.abs(t)))) && (n.precision = o - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(o = Qse(i)) && (n.precision = o - (n.type === "%") * 2);
      break;
    }
  }
  return $y(n);
}
function xo(e) {
  var t = e.domain;
  return e.ticks = function(r) {
    var n = t();
    return uv(n[0], n[n.length - 1], r ?? 10);
  }, e.tickFormat = function(r, n) {
    var i = t();
    return JF(i[0], i[i.length - 1], r ?? 10, n);
  }, e.nice = function(r) {
    r == null && (r = 10);
    var n = t(), i = 0, o = n.length - 1, s = n[i], a = n[o], l, u, d = 10;
    for (a < s && (u = s, s = a, a = u, u = i, i = o, o = u); d-- > 0; ) {
      if (u = dv(s, a, r), u === l)
        return n[i] = s, n[o] = a, t(n);
      if (u > 0)
        s = Math.floor(s / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return e;
  }, e;
}
function ah() {
  var e = Wy();
  return e.copy = function() {
    return Qc(e, ah());
  }, An.apply(e, arguments), xo(e);
}
function XF(e) {
  var t;
  function r(n) {
    return n == null || isNaN(n = +n) ? t : n;
  }
  return r.invert = r, r.domain = r.range = function(n) {
    return arguments.length ? (e = Array.from(n, oh), r) : e.slice();
  }, r.unknown = function(n) {
    return arguments.length ? (t = n, r) : t;
  }, r.copy = function() {
    return XF(e).unknown(t);
  }, e = arguments.length ? Array.from(e, oh) : [0, 1], xo(r);
}
function QF(e, t) {
  e = e.slice();
  var r = 0, n = e.length - 1, i = e[r], o = e[n], s;
  return o < i && (s = r, r = n, n = s, s = i, i = o, o = s), e[r] = t.floor(i), e[n] = t.ceil(o), e;
}
function T2(e) {
  return Math.log(e);
}
function D2(e) {
  return Math.exp(e);
}
function tae(e) {
  return -Math.log(-e);
}
function rae(e) {
  return -Math.exp(-e);
}
function nae(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function iae(e) {
  return e === 10 ? nae : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function oae(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function O2(e) {
  return (t, r) => -e(-t, r);
}
function jy(e) {
  const t = e(T2, D2), r = t.domain;
  let n = 10, i, o;
  function s() {
    return i = oae(n), o = iae(n), r()[0] < 0 ? (i = O2(i), o = O2(o), e(tae, rae)) : e(T2, D2), t;
  }
  return t.base = function(a) {
    return arguments.length ? (n = +a, s()) : n;
  }, t.domain = function(a) {
    return arguments.length ? (r(a), s()) : r();
  }, t.ticks = (a) => {
    const l = r();
    let u = l[0], d = l[l.length - 1];
    const h = d < u;
    h && ([u, d] = [d, u]);
    let f = i(u), p = i(d), y, C;
    const v = a == null ? 10 : +a;
    let w = [];
    if (!(n % 1) && p - f < v) {
      if (f = Math.floor(f), p = Math.ceil(p), u > 0) {
        for (; f <= p; ++f)
          for (y = 1; y < n; ++y)
            if (C = f < 0 ? y / o(-f) : y * o(f), !(C < u)) {
              if (C > d) break;
              w.push(C);
            }
      } else for (; f <= p; ++f)
        for (y = n - 1; y >= 1; --y)
          if (C = f > 0 ? y / o(-f) : y * o(f), !(C < u)) {
            if (C > d) break;
            w.push(C);
          }
      w.length * 2 < v && (w = uv(u, d, v));
    } else
      w = uv(f, p, Math.min(p - f, v)).map(o);
    return h ? w.reverse() : w;
  }, t.tickFormat = (a, l) => {
    if (a == null && (a = 10), l == null && (l = n === 10 ? "s" : ","), typeof l != "function" && (!(n % 1) && (l = Cc(l)).precision == null && (l.trim = !0), l = $y(l)), a === 1 / 0) return l;
    const u = Math.max(1, n * a / t.ticks().length);
    return (d) => {
      let h = d / o(Math.round(i(d)));
      return h * n < n - 0.5 && (h *= n), h <= u ? l(d) : "";
    };
  }, t.nice = () => r(QF(r(), {
    floor: (a) => o(Math.floor(i(a))),
    ceil: (a) => o(Math.ceil(i(a)))
  })), t;
}
function ZF() {
  const e = jy(fg()).domain([1, 10]);
  return e.copy = () => Qc(e, ZF()).base(e.base()), An.apply(e, arguments), e;
}
function I2(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function k2(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function Uy(e) {
  var t = 1, r = e(I2(t), k2(t));
  return r.constant = function(n) {
    return arguments.length ? e(I2(t = +n), k2(t)) : t;
  }, xo(r);
}
function eM() {
  var e = Uy(fg());
  return e.copy = function() {
    return Qc(e, eM()).constant(e.constant());
  }, An.apply(e, arguments);
}
function L2(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function sae(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function aae(e) {
  return e < 0 ? -e * e : e * e;
}
function Ky(e) {
  var t = e(Mr, Mr), r = 1;
  function n() {
    return r === 1 ? e(Mr, Mr) : r === 0.5 ? e(sae, aae) : e(L2(r), L2(1 / r));
  }
  return t.exponent = function(i) {
    return arguments.length ? (r = +i, n()) : r;
  }, xo(t);
}
function qy() {
  var e = Ky(fg());
  return e.copy = function() {
    return Qc(e, qy()).exponent(e.exponent());
  }, An.apply(e, arguments), e;
}
function lae() {
  return qy.apply(null, arguments).exponent(0.5);
}
function _2(e) {
  return Math.sign(e) * e * e;
}
function cae(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e));
}
function tM() {
  var e = Wy(), t = [0, 1], r = !1, n;
  function i(o) {
    var s = cae(e(o));
    return isNaN(s) ? n : r ? Math.round(s) : s;
  }
  return i.invert = function(o) {
    return e.invert(_2(o));
  }, i.domain = function(o) {
    return arguments.length ? (e.domain(o), i) : e.domain();
  }, i.range = function(o) {
    return arguments.length ? (e.range((t = Array.from(o, oh)).map(_2)), i) : t.slice();
  }, i.rangeRound = function(o) {
    return i.range(o).round(!0);
  }, i.round = function(o) {
    return arguments.length ? (r = !!o, i) : r;
  }, i.clamp = function(o) {
    return arguments.length ? (e.clamp(o), i) : e.clamp();
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return tM(e.domain(), t).round(r).clamp(e.clamp()).unknown(n);
  }, An.apply(i, arguments), xo(i);
}
function rM() {
  var e = [], t = [], r = [], n;
  function i() {
    var s = 0, a = Math.max(1, t.length);
    for (r = new Array(a - 1); ++s < a; ) r[s - 1] = fse(e, s / a);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? n : t[Jc(r, s)];
  }
  return o.invertExtent = function(s) {
    var a = t.indexOf(s);
    return a < 0 ? [NaN, NaN] : [
      a > 0 ? r[a - 1] : e[0],
      a < r.length ? r[a] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let a of s) a != null && !isNaN(a = +a) && e.push(a);
    return e.sort(uo), i();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), i()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (n = s, o) : n;
  }, o.quantiles = function() {
    return r.slice();
  }, o.copy = function() {
    return rM().domain(e).range(t).unknown(n);
  }, An.apply(o, arguments);
}
function nM() {
  var e = 0, t = 1, r = 1, n = [0.5], i = [0, 1], o;
  function s(l) {
    return l != null && l <= l ? i[Jc(n, l, 0, r)] : o;
  }
  function a() {
    var l = -1;
    for (n = new Array(r); ++l < r; ) n[l] = ((l + 1) * t - (l - r) * e) / (r + 1);
    return s;
  }
  return s.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, a()) : [e, t];
  }, s.range = function(l) {
    return arguments.length ? (r = (i = Array.from(l)).length - 1, a()) : i.slice();
  }, s.invertExtent = function(l) {
    var u = i.indexOf(l);
    return u < 0 ? [NaN, NaN] : u < 1 ? [e, n[0]] : u >= r ? [n[r - 1], t] : [n[u - 1], n[u]];
  }, s.unknown = function(l) {
    return arguments.length && (o = l), s;
  }, s.thresholds = function() {
    return n.slice();
  }, s.copy = function() {
    return nM().domain([e, t]).range(i).unknown(o);
  }, An.apply(xo(s), arguments);
}
function iM() {
  var e = [0.5], t = [0, 1], r, n = 1;
  function i(o) {
    return o != null && o <= o ? t[Jc(e, o, 0, n)] : r;
  }
  return i.domain = function(o) {
    return arguments.length ? (e = Array.from(o), n = Math.min(e.length, t.length - 1), i) : e.slice();
  }, i.range = function(o) {
    return arguments.length ? (t = Array.from(o), n = Math.min(e.length, t.length - 1), i) : t.slice();
  }, i.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return iM().domain(e).range(t).unknown(r);
  }, An.apply(i, arguments);
}
const Gp = /* @__PURE__ */ new Date(), Hp = /* @__PURE__ */ new Date();
function Qt(e, t, r, n) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), i.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = (o) => {
    const s = i(o), a = i.ceil(o);
    return o - s < a - o ? s : a;
  }, i.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), i.range = (o, s, a) => {
    const l = [];
    if (o = i.ceil(o), a = a == null ? 1 : Math.floor(a), !(o < s) || !(a > 0)) return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+o)), t(o, a), e(o);
    while (u < o && o < s);
    return l;
  }, i.filter = (o) => Qt((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, a) => {
    if (s >= s)
      if (a < 0) for (; ++a <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --a >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), r && (i.count = (o, s) => (Gp.setTime(+o), Hp.setTime(+s), e(Gp), e(Hp), Math.floor(r(Gp, Hp))), i.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(n ? (s) => n(s) % o === 0 : (s) => i.count(0, s) % o === 0) : i)), i;
}
const lh = Qt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
lh.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Qt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : lh);
lh.range;
const Pi = 1e3, bn = Pi * 60, Ai = bn * 60, Li = Ai * 24, Yy = Li * 7, z2 = Li * 30, Wp = Li * 365, qo = Qt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * Pi);
}, (e, t) => (t - e) / Pi, (e) => e.getUTCSeconds());
qo.range;
const Jy = Qt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Pi);
}, (e, t) => {
  e.setTime(+e + t * bn);
}, (e, t) => (t - e) / bn, (e) => e.getMinutes());
Jy.range;
const Xy = Qt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * bn);
}, (e, t) => (t - e) / bn, (e) => e.getUTCMinutes());
Xy.range;
const Qy = Qt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Pi - e.getMinutes() * bn);
}, (e, t) => {
  e.setTime(+e + t * Ai);
}, (e, t) => (t - e) / Ai, (e) => e.getHours());
Qy.range;
const Zy = Qt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Ai);
}, (e, t) => (t - e) / Ai, (e) => e.getUTCHours());
Zy.range;
const Zc = Qt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * bn) / Li,
  (e) => e.getDate() - 1
);
Zc.range;
const pg = Qt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Li, (e) => e.getUTCDate() - 1);
pg.range;
const oM = Qt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Li, (e) => Math.floor(e / Li));
oM.range;
function ws(e) {
  return Qt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setDate(t.getDate() + r * 7);
  }, (t, r) => (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * bn) / Yy);
}
const mg = ws(0), ch = ws(1), uae = ws(2), dae = ws(3), ga = ws(4), hae = ws(5), gae = ws(6);
mg.range;
ch.range;
uae.range;
dae.range;
ga.range;
hae.range;
gae.range;
function bs(e) {
  return Qt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, (t, r) => (r - t) / Yy);
}
const vg = bs(0), uh = bs(1), fae = bs(2), pae = bs(3), fa = bs(4), mae = bs(5), vae = bs(6);
vg.range;
uh.range;
fae.range;
pae.range;
fa.range;
mae.range;
vae.range;
const eC = Qt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
eC.range;
const tC = Qt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
tC.range;
const _i = Qt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
_i.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Qt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, r) => {
  t.setFullYear(t.getFullYear() + r * e);
});
_i.range;
const zi = Qt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
zi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Qt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, r) => {
  t.setUTCFullYear(t.getUTCFullYear() + r * e);
});
zi.range;
function sM(e, t, r, n, i, o) {
  const s = [
    [qo, 1, Pi],
    [qo, 5, 5 * Pi],
    [qo, 15, 15 * Pi],
    [qo, 30, 30 * Pi],
    [o, 1, bn],
    [o, 5, 5 * bn],
    [o, 15, 15 * bn],
    [o, 30, 30 * bn],
    [i, 1, Ai],
    [i, 3, 3 * Ai],
    [i, 6, 6 * Ai],
    [i, 12, 12 * Ai],
    [n, 1, Li],
    [n, 2, 2 * Li],
    [r, 1, Yy],
    [t, 1, z2],
    [t, 3, 3 * z2],
    [e, 1, Wp]
  ];
  function a(u, d, h) {
    const f = d < u;
    f && ([u, d] = [d, u]);
    const p = h && typeof h.range == "function" ? h : l(u, d, h), y = p ? p.range(u, +d + 1) : [];
    return f ? y.reverse() : y;
  }
  function l(u, d, h) {
    const f = Math.abs(d - u) / h, p = zy(([, , v]) => v).right(s, f);
    if (p === s.length) return e.every(hv(u / Wp, d / Wp, h));
    if (p === 0) return lh.every(Math.max(hv(u, d, h), 1));
    const [y, C] = s[f / s[p - 1][2] < s[p][2] / f ? p - 1 : p];
    return y.every(C);
  }
  return [a, l];
}
const [yae, Cae] = sM(zi, tC, vg, oM, Zy, Xy), [wae, bae] = sM(_i, eC, mg, Zc, Qy, Jy);
function Vp(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function $p(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Ml(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function Sae(e) {
  var t = e.dateTime, r = e.date, n = e.time, i = e.periods, o = e.days, s = e.shortDays, a = e.months, l = e.shortMonths, u = Tl(i), d = Dl(i), h = Tl(o), f = Dl(o), p = Tl(s), y = Dl(s), C = Tl(a), v = Dl(a), w = Tl(l), R = Dl(l), b = {
    a: Z,
    A: te,
    b: se,
    B: W,
    c: null,
    d: V2,
    e: V2,
    f: jae,
    g: tle,
    G: nle,
    H: Wae,
    I: Vae,
    j: $ae,
    L: aM,
    m: Uae,
    M: Kae,
    p: U,
    q: X,
    Q: U2,
    s: K2,
    S: qae,
    u: Yae,
    U: Jae,
    V: Xae,
    w: Qae,
    W: Zae,
    x: null,
    X: null,
    y: ele,
    Y: rle,
    Z: ile,
    "%": j2
  }, P = {
    a: he,
    A: ce,
    b: me,
    B: ve,
    c: null,
    d: $2,
    e: $2,
    f: lle,
    g: yle,
    G: wle,
    H: ole,
    I: sle,
    j: ale,
    L: cM,
    m: cle,
    M: ule,
    p: Pe,
    q: Re,
    Q: U2,
    s: K2,
    S: dle,
    u: hle,
    U: gle,
    V: fle,
    w: ple,
    W: mle,
    x: null,
    X: null,
    y: vle,
    Y: Cle,
    Z: ble,
    "%": j2
  }, S = {
    a: z,
    A: k,
    b: _,
    B: q,
    c: j,
    d: H2,
    e: H2,
    f: Nae,
    g: G2,
    G: B2,
    H: W2,
    I: W2,
    j: kae,
    L: zae,
    m: Iae,
    M: Lae,
    p: I,
    q: Oae,
    Q: Gae,
    s: Hae,
    S: _ae,
    u: Aae,
    U: Fae,
    V: Mae,
    w: Pae,
    W: Tae,
    x: Q,
    X: K,
    y: G2,
    Y: B2,
    Z: Dae,
    "%": Bae
  };
  b.x = E(r, b), b.X = E(n, b), b.c = E(t, b), P.x = E(r, P), P.X = E(n, P), P.c = E(t, P);
  function E(ee, fe) {
    return function(ye) {
      var B = [], Ae = -1, oe = 0, Me = ee.length, Je, nt, $r;
      for (ye instanceof Date || (ye = /* @__PURE__ */ new Date(+ye)); ++Ae < Me; )
        ee.charCodeAt(Ae) === 37 && (B.push(ee.slice(oe, Ae)), (nt = N2[Je = ee.charAt(++Ae)]) != null ? Je = ee.charAt(++Ae) : nt = Je === "e" ? " " : "0", ($r = fe[Je]) && (Je = $r(ye, nt)), B.push(Je), oe = Ae + 1);
      return B.push(ee.slice(oe, Ae)), B.join("");
    };
  }
  function A(ee, fe) {
    return function(ye) {
      var B = Ml(1900, void 0, 1), Ae = M(B, ee, ye += "", 0), oe, Me;
      if (Ae != ye.length) return null;
      if ("Q" in B) return new Date(B.Q);
      if ("s" in B) return new Date(B.s * 1e3 + ("L" in B ? B.L : 0));
      if (fe && !("Z" in B) && (B.Z = 0), "p" in B && (B.H = B.H % 12 + B.p * 12), B.m === void 0 && (B.m = "q" in B ? B.q : 0), "V" in B) {
        if (B.V < 1 || B.V > 53) return null;
        "w" in B || (B.w = 1), "Z" in B ? (oe = $p(Ml(B.y, 0, 1)), Me = oe.getUTCDay(), oe = Me > 4 || Me === 0 ? uh.ceil(oe) : uh(oe), oe = pg.offset(oe, (B.V - 1) * 7), B.y = oe.getUTCFullYear(), B.m = oe.getUTCMonth(), B.d = oe.getUTCDate() + (B.w + 6) % 7) : (oe = Vp(Ml(B.y, 0, 1)), Me = oe.getDay(), oe = Me > 4 || Me === 0 ? ch.ceil(oe) : ch(oe), oe = Zc.offset(oe, (B.V - 1) * 7), B.y = oe.getFullYear(), B.m = oe.getMonth(), B.d = oe.getDate() + (B.w + 6) % 7);
      } else ("W" in B || "U" in B) && ("w" in B || (B.w = "u" in B ? B.u % 7 : "W" in B ? 1 : 0), Me = "Z" in B ? $p(Ml(B.y, 0, 1)).getUTCDay() : Vp(Ml(B.y, 0, 1)).getDay(), B.m = 0, B.d = "W" in B ? (B.w + 6) % 7 + B.W * 7 - (Me + 5) % 7 : B.w + B.U * 7 - (Me + 6) % 7);
      return "Z" in B ? (B.H += B.Z / 100 | 0, B.M += B.Z % 100, $p(B)) : Vp(B);
    };
  }
  function M(ee, fe, ye, B) {
    for (var Ae = 0, oe = fe.length, Me = ye.length, Je, nt; Ae < oe; ) {
      if (B >= Me) return -1;
      if (Je = fe.charCodeAt(Ae++), Je === 37) {
        if (Je = fe.charAt(Ae++), nt = S[Je in N2 ? fe.charAt(Ae++) : Je], !nt || (B = nt(ee, ye, B)) < 0) return -1;
      } else if (Je != ye.charCodeAt(B++))
        return -1;
    }
    return B;
  }
  function I(ee, fe, ye) {
    var B = u.exec(fe.slice(ye));
    return B ? (ee.p = d.get(B[0].toLowerCase()), ye + B[0].length) : -1;
  }
  function z(ee, fe, ye) {
    var B = p.exec(fe.slice(ye));
    return B ? (ee.w = y.get(B[0].toLowerCase()), ye + B[0].length) : -1;
  }
  function k(ee, fe, ye) {
    var B = h.exec(fe.slice(ye));
    return B ? (ee.w = f.get(B[0].toLowerCase()), ye + B[0].length) : -1;
  }
  function _(ee, fe, ye) {
    var B = w.exec(fe.slice(ye));
    return B ? (ee.m = R.get(B[0].toLowerCase()), ye + B[0].length) : -1;
  }
  function q(ee, fe, ye) {
    var B = C.exec(fe.slice(ye));
    return B ? (ee.m = v.get(B[0].toLowerCase()), ye + B[0].length) : -1;
  }
  function j(ee, fe, ye) {
    return M(ee, t, fe, ye);
  }
  function Q(ee, fe, ye) {
    return M(ee, r, fe, ye);
  }
  function K(ee, fe, ye) {
    return M(ee, n, fe, ye);
  }
  function Z(ee) {
    return s[ee.getDay()];
  }
  function te(ee) {
    return o[ee.getDay()];
  }
  function se(ee) {
    return l[ee.getMonth()];
  }
  function W(ee) {
    return a[ee.getMonth()];
  }
  function U(ee) {
    return i[+(ee.getHours() >= 12)];
  }
  function X(ee) {
    return 1 + ~~(ee.getMonth() / 3);
  }
  function he(ee) {
    return s[ee.getUTCDay()];
  }
  function ce(ee) {
    return o[ee.getUTCDay()];
  }
  function me(ee) {
    return l[ee.getUTCMonth()];
  }
  function ve(ee) {
    return a[ee.getUTCMonth()];
  }
  function Pe(ee) {
    return i[+(ee.getUTCHours() >= 12)];
  }
  function Re(ee) {
    return 1 + ~~(ee.getUTCMonth() / 3);
  }
  return {
    format: function(ee) {
      var fe = E(ee += "", b);
      return fe.toString = function() {
        return ee;
      }, fe;
    },
    parse: function(ee) {
      var fe = A(ee += "", !1);
      return fe.toString = function() {
        return ee;
      }, fe;
    },
    utcFormat: function(ee) {
      var fe = E(ee += "", P);
      return fe.toString = function() {
        return ee;
      }, fe;
    },
    utcParse: function(ee) {
      var fe = A(ee += "", !0);
      return fe.toString = function() {
        return ee;
      }, fe;
    }
  };
}
var N2 = { "-": "", _: " ", 0: "0" }, rr = /^\s*\d+/, xae = /^%/, Rae = /[\\^$*+?|[\]().{}]/g;
function rt(e, t, r) {
  var n = e < 0 ? "-" : "", i = (n ? -e : e) + "", o = i.length;
  return n + (o < r ? new Array(r - o + 1).join(t) + i : i);
}
function Eae(e) {
  return e.replace(Rae, "\\$&");
}
function Tl(e) {
  return new RegExp("^(?:" + e.map(Eae).join("|") + ")", "i");
}
function Dl(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function Pae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 1));
  return n ? (e.w = +n[0], r + n[0].length) : -1;
}
function Aae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 1));
  return n ? (e.u = +n[0], r + n[0].length) : -1;
}
function Fae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.U = +n[0], r + n[0].length) : -1;
}
function Mae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.V = +n[0], r + n[0].length) : -1;
}
function Tae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.W = +n[0], r + n[0].length) : -1;
}
function B2(e, t, r) {
  var n = rr.exec(t.slice(r, r + 4));
  return n ? (e.y = +n[0], r + n[0].length) : -1;
}
function G2(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), r + n[0].length) : -1;
}
function Dae(e, t, r) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return n ? (e.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), r + n[0].length) : -1;
}
function Oae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 1));
  return n ? (e.q = n[0] * 3 - 3, r + n[0].length) : -1;
}
function Iae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.m = n[0] - 1, r + n[0].length) : -1;
}
function H2(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.d = +n[0], r + n[0].length) : -1;
}
function kae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 3));
  return n ? (e.m = 0, e.d = +n[0], r + n[0].length) : -1;
}
function W2(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.H = +n[0], r + n[0].length) : -1;
}
function Lae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.M = +n[0], r + n[0].length) : -1;
}
function _ae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 2));
  return n ? (e.S = +n[0], r + n[0].length) : -1;
}
function zae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 3));
  return n ? (e.L = +n[0], r + n[0].length) : -1;
}
function Nae(e, t, r) {
  var n = rr.exec(t.slice(r, r + 6));
  return n ? (e.L = Math.floor(n[0] / 1e3), r + n[0].length) : -1;
}
function Bae(e, t, r) {
  var n = xae.exec(t.slice(r, r + 1));
  return n ? r + n[0].length : -1;
}
function Gae(e, t, r) {
  var n = rr.exec(t.slice(r));
  return n ? (e.Q = +n[0], r + n[0].length) : -1;
}
function Hae(e, t, r) {
  var n = rr.exec(t.slice(r));
  return n ? (e.s = +n[0], r + n[0].length) : -1;
}
function V2(e, t) {
  return rt(e.getDate(), t, 2);
}
function Wae(e, t) {
  return rt(e.getHours(), t, 2);
}
function Vae(e, t) {
  return rt(e.getHours() % 12 || 12, t, 2);
}
function $ae(e, t) {
  return rt(1 + Zc.count(_i(e), e), t, 3);
}
function aM(e, t) {
  return rt(e.getMilliseconds(), t, 3);
}
function jae(e, t) {
  return aM(e, t) + "000";
}
function Uae(e, t) {
  return rt(e.getMonth() + 1, t, 2);
}
function Kae(e, t) {
  return rt(e.getMinutes(), t, 2);
}
function qae(e, t) {
  return rt(e.getSeconds(), t, 2);
}
function Yae(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Jae(e, t) {
  return rt(mg.count(_i(e) - 1, e), t, 2);
}
function lM(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ga(e) : ga.ceil(e);
}
function Xae(e, t) {
  return e = lM(e), rt(ga.count(_i(e), e) + (_i(e).getDay() === 4), t, 2);
}
function Qae(e) {
  return e.getDay();
}
function Zae(e, t) {
  return rt(ch.count(_i(e) - 1, e), t, 2);
}
function ele(e, t) {
  return rt(e.getFullYear() % 100, t, 2);
}
function tle(e, t) {
  return e = lM(e), rt(e.getFullYear() % 100, t, 2);
}
function rle(e, t) {
  return rt(e.getFullYear() % 1e4, t, 4);
}
function nle(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? ga(e) : ga.ceil(e), rt(e.getFullYear() % 1e4, t, 4);
}
function ile(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + rt(t / 60 | 0, "0", 2) + rt(t % 60, "0", 2);
}
function $2(e, t) {
  return rt(e.getUTCDate(), t, 2);
}
function ole(e, t) {
  return rt(e.getUTCHours(), t, 2);
}
function sle(e, t) {
  return rt(e.getUTCHours() % 12 || 12, t, 2);
}
function ale(e, t) {
  return rt(1 + pg.count(zi(e), e), t, 3);
}
function cM(e, t) {
  return rt(e.getUTCMilliseconds(), t, 3);
}
function lle(e, t) {
  return cM(e, t) + "000";
}
function cle(e, t) {
  return rt(e.getUTCMonth() + 1, t, 2);
}
function ule(e, t) {
  return rt(e.getUTCMinutes(), t, 2);
}
function dle(e, t) {
  return rt(e.getUTCSeconds(), t, 2);
}
function hle(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function gle(e, t) {
  return rt(vg.count(zi(e) - 1, e), t, 2);
}
function uM(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? fa(e) : fa.ceil(e);
}
function fle(e, t) {
  return e = uM(e), rt(fa.count(zi(e), e) + (zi(e).getUTCDay() === 4), t, 2);
}
function ple(e) {
  return e.getUTCDay();
}
function mle(e, t) {
  return rt(uh.count(zi(e) - 1, e), t, 2);
}
function vle(e, t) {
  return rt(e.getUTCFullYear() % 100, t, 2);
}
function yle(e, t) {
  return e = uM(e), rt(e.getUTCFullYear() % 100, t, 2);
}
function Cle(e, t) {
  return rt(e.getUTCFullYear() % 1e4, t, 4);
}
function wle(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? fa(e) : fa.ceil(e), rt(e.getUTCFullYear() % 1e4, t, 4);
}
function ble() {
  return "+0000";
}
function j2() {
  return "%";
}
function U2(e) {
  return +e;
}
function K2(e) {
  return Math.floor(+e / 1e3);
}
var Bs, dM, hM;
Sle({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Sle(e) {
  return Bs = Sae(e), dM = Bs.format, Bs.parse, hM = Bs.utcFormat, Bs.utcParse, Bs;
}
function xle(e) {
  return new Date(e);
}
function Rle(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function rC(e, t, r, n, i, o, s, a, l, u) {
  var d = Wy(), h = d.invert, f = d.domain, p = u(".%L"), y = u(":%S"), C = u("%I:%M"), v = u("%I %p"), w = u("%a %d"), R = u("%b %d"), b = u("%B"), P = u("%Y");
  function S(E) {
    return (l(E) < E ? p : a(E) < E ? y : s(E) < E ? C : o(E) < E ? v : n(E) < E ? i(E) < E ? w : R : r(E) < E ? b : P)(E);
  }
  return d.invert = function(E) {
    return new Date(h(E));
  }, d.domain = function(E) {
    return arguments.length ? f(Array.from(E, Rle)) : f().map(xle);
  }, d.ticks = function(E) {
    var A = f();
    return e(A[0], A[A.length - 1], E ?? 10);
  }, d.tickFormat = function(E, A) {
    return A == null ? S : u(A);
  }, d.nice = function(E) {
    var A = f();
    return (!E || typeof E.range != "function") && (E = t(A[0], A[A.length - 1], E ?? 10)), E ? f(QF(A, E)) : d;
  }, d.copy = function() {
    return Qc(d, rC(e, t, r, n, i, o, s, a, l, u));
  }, d;
}
function Ele() {
  return An.apply(rC(wae, bae, _i, eC, mg, Zc, Qy, Jy, qo, dM).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Ple() {
  return An.apply(rC(yae, Cae, zi, tC, vg, pg, Zy, Xy, qo, hM).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function yg() {
  var e = 0, t = 1, r, n, i, o, s = Mr, a = !1, l;
  function u(h) {
    return h == null || isNaN(h = +h) ? l : s(i === 0 ? 0.5 : (h = (o(h) - r) * i, a ? Math.max(0, Math.min(1, h)) : h));
  }
  u.domain = function(h) {
    return arguments.length ? ([e, t] = h, r = o(e = +e), n = o(t = +t), i = r === n ? 0 : 1 / (n - r), u) : [e, t];
  }, u.clamp = function(h) {
    return arguments.length ? (a = !!h, u) : a;
  }, u.interpolator = function(h) {
    return arguments.length ? (s = h, u) : s;
  };
  function d(h) {
    return function(f) {
      var p, y;
      return arguments.length ? ([p, y] = f, s = h(p, y), u) : [s(0), s(1)];
    };
  }
  return u.range = d(tl), u.rangeRound = d(Hy), u.unknown = function(h) {
    return arguments.length ? (l = h, u) : l;
  }, function(h) {
    return o = h, r = h(e), n = h(t), i = r === n ? 0 : 1 / (n - r), u;
  };
}
function Ro(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function gM() {
  var e = xo(yg()(Mr));
  return e.copy = function() {
    return Ro(e, gM());
  }, Hi.apply(e, arguments);
}
function fM() {
  var e = jy(yg()).domain([1, 10]);
  return e.copy = function() {
    return Ro(e, fM()).base(e.base());
  }, Hi.apply(e, arguments);
}
function pM() {
  var e = Uy(yg());
  return e.copy = function() {
    return Ro(e, pM()).constant(e.constant());
  }, Hi.apply(e, arguments);
}
function nC() {
  var e = Ky(yg());
  return e.copy = function() {
    return Ro(e, nC()).exponent(e.exponent());
  }, Hi.apply(e, arguments);
}
function Ale() {
  return nC.apply(null, arguments).exponent(0.5);
}
function mM() {
  var e = [], t = Mr;
  function r(n) {
    if (n != null && !isNaN(n = +n)) return t((Jc(e, n, 1) - 1) / (e.length - 1));
  }
  return r.domain = function(n) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of n) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(uo), r;
  }, r.interpolator = function(n) {
    return arguments.length ? (t = n, r) : t;
  }, r.range = function() {
    return e.map((n, i) => t(i / (e.length - 1)));
  }, r.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (i, o) => gse(e, o / n));
  }, r.copy = function() {
    return mM(t).domain(e);
  }, Hi.apply(r, arguments);
}
function Cg() {
  var e = 0, t = 0.5, r = 1, n = 1, i, o, s, a, l, u = Mr, d, h = !1, f;
  function p(C) {
    return isNaN(C = +C) ? f : (C = 0.5 + ((C = +d(C)) - o) * (n * C < n * o ? a : l), u(h ? Math.max(0, Math.min(1, C)) : C));
  }
  p.domain = function(C) {
    return arguments.length ? ([e, t, r] = C, i = d(e = +e), o = d(t = +t), s = d(r = +r), a = i === o ? 0 : 0.5 / (o - i), l = o === s ? 0 : 0.5 / (s - o), n = o < i ? -1 : 1, p) : [e, t, r];
  }, p.clamp = function(C) {
    return arguments.length ? (h = !!C, p) : h;
  }, p.interpolator = function(C) {
    return arguments.length ? (u = C, p) : u;
  };
  function y(C) {
    return function(v) {
      var w, R, b;
      return arguments.length ? ([w, R, b] = v, u = Bse(C, [w, R, b]), p) : [u(0), u(0.5), u(1)];
    };
  }
  return p.range = y(tl), p.rangeRound = y(Hy), p.unknown = function(C) {
    return arguments.length ? (f = C, p) : f;
  }, function(C) {
    return d = C, i = C(e), o = C(t), s = C(r), a = i === o ? 0 : 0.5 / (o - i), l = o === s ? 0 : 0.5 / (s - o), n = o < i ? -1 : 1, p;
  };
}
function vM() {
  var e = xo(Cg()(Mr));
  return e.copy = function() {
    return Ro(e, vM());
  }, Hi.apply(e, arguments);
}
function yM() {
  var e = jy(Cg()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return Ro(e, yM()).base(e.base());
  }, Hi.apply(e, arguments);
}
function CM() {
  var e = Uy(Cg());
  return e.copy = function() {
    return Ro(e, CM()).constant(e.constant());
  }, Hi.apply(e, arguments);
}
function iC() {
  var e = Ky(Cg());
  return e.copy = function() {
    return Ro(e, iC()).exponent(e.exponent());
  }, Hi.apply(e, arguments);
}
function Fle() {
  return iC.apply(null, arguments).exponent(0.5);
}
const q2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: pc,
  scaleDiverging: vM,
  scaleDivergingLog: yM,
  scaleDivergingPow: iC,
  scaleDivergingSqrt: Fle,
  scaleDivergingSymlog: CM,
  scaleIdentity: XF,
  scaleImplicit: gv,
  scaleLinear: ah,
  scaleLog: ZF,
  scaleOrdinal: Ny,
  scalePoint: ql,
  scalePow: qy,
  scaleQuantile: rM,
  scaleQuantize: nM,
  scaleRadial: tM,
  scaleSequential: gM,
  scaleSequentialLog: fM,
  scaleSequentialPow: nC,
  scaleSequentialQuantile: mM,
  scaleSequentialSqrt: Ale,
  scaleSequentialSymlog: pM,
  scaleSqrt: lae,
  scaleSymlog: eM,
  scaleThreshold: iM,
  scaleTime: Ele,
  scaleUtc: Ple,
  tickFormat: JF
}, Symbol.toStringTag, { value: "Module" }));
var Mle = ja;
function Tle(e, t, r) {
  for (var n = -1, i = e.length; ++n < i; ) {
    var o = e[n], s = t(o);
    if (s != null && (a === void 0 ? s === s && !Mle(s) : r(s, a)))
      var a = s, l = o;
  }
  return l;
}
var wM = Tle;
function Dle(e, t) {
  return e > t;
}
var Ole = Dle, Ile = wM, kle = Ole, Lle = Za;
function _le(e) {
  return e && e.length ? Ile(e, Lle, kle) : void 0;
}
var zle = _le;
const io = /* @__PURE__ */ bt(zle);
function Nle(e, t) {
  return e < t;
}
var Ble = Nle, Gle = wM, Hle = Ble, Wle = Za;
function Vle(e) {
  return e && e.length ? Gle(e, Wle, Hle) : void 0;
}
var $le = Vle;
const wg = /* @__PURE__ */ bt($le);
var jle = Cy, Ule = el, Kle = TF, qle = Vr;
function Yle(e, t) {
  var r = qle(e) ? jle : Kle;
  return r(e, Ule(t));
}
var Jle = Yle, Xle = FF, Qle = Jle;
function Zle(e, t) {
  return Xle(Qle(e, t), 1);
}
var ece = Zle;
const tce = /* @__PURE__ */ bt(ece);
var rce = Oy;
function nce(e, t) {
  return rce(e, t);
}
var ice = nce;
const hs = /* @__PURE__ */ bt(ice);
var rl = 1e9, oce = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, sC, Ft = !0, Pn = "[DecimalError] ", is = Pn + "Invalid argument: ", oC = Pn + "Exponent out of range: ", nl = Math.floor, Ho = Math.pow, sce = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, en, tr = 1e7, Rt = 7, bM = 9007199254740991, dh = nl(bM / Rt), xe = {};
xe.absoluteValue = xe.abs = function() {
  var e = new this.constructor(this);
  return e.s && (e.s = 1), e;
};
xe.comparedTo = xe.cmp = function(e) {
  var t, r, n, i, o = this;
  if (e = new o.constructor(e), o.s !== e.s) return o.s || -e.s;
  if (o.e !== e.e) return o.e > e.e ^ o.s < 0 ? 1 : -1;
  for (n = o.d.length, i = e.d.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o.d[t] !== e.d[t]) return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ o.s < 0 ? 1 : -1;
};
xe.decimalPlaces = xe.dp = function() {
  var e = this, t = e.d.length - 1, r = (t - e.e) * Rt;
  if (t = e.d[t], t) for (; t % 10 == 0; t /= 10) r--;
  return r < 0 ? 0 : r;
};
xe.dividedBy = xe.div = function(e) {
  return Di(this, new this.constructor(e));
};
xe.dividedToIntegerBy = xe.idiv = function(e) {
  var t = this, r = t.constructor;
  return mt(Di(t, new r(e), 0, 1), r.precision);
};
xe.equals = xe.eq = function(e) {
  return !this.cmp(e);
};
xe.exponent = function() {
  return jt(this);
};
xe.greaterThan = xe.gt = function(e) {
  return this.cmp(e) > 0;
};
xe.greaterThanOrEqualTo = xe.gte = function(e) {
  return this.cmp(e) >= 0;
};
xe.isInteger = xe.isint = function() {
  return this.e > this.d.length - 2;
};
xe.isNegative = xe.isneg = function() {
  return this.s < 0;
};
xe.isPositive = xe.ispos = function() {
  return this.s > 0;
};
xe.isZero = function() {
  return this.s === 0;
};
xe.lessThan = xe.lt = function(e) {
  return this.cmp(e) < 0;
};
xe.lessThanOrEqualTo = xe.lte = function(e) {
  return this.cmp(e) < 1;
};
xe.logarithm = xe.log = function(e) {
  var t, r = this, n = r.constructor, i = n.precision, o = i + 5;
  if (e === void 0)
    e = new n(10);
  else if (e = new n(e), e.s < 1 || e.eq(en)) throw Error(Pn + "NaN");
  if (r.s < 1) throw Error(Pn + (r.s ? "NaN" : "-Infinity"));
  return r.eq(en) ? new n(0) : (Ft = !1, t = Di(wc(r, o), wc(e, o), o), Ft = !0, mt(t, i));
};
xe.minus = xe.sub = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? RM(t, e) : SM(t, (e.s = -e.s, e));
};
xe.modulo = xe.mod = function(e) {
  var t, r = this, n = r.constructor, i = n.precision;
  if (e = new n(e), !e.s) throw Error(Pn + "NaN");
  return r.s ? (Ft = !1, t = Di(r, e, 0, 1).times(e), Ft = !0, r.minus(t)) : mt(new n(r), i);
};
xe.naturalExponential = xe.exp = function() {
  return xM(this);
};
xe.naturalLogarithm = xe.ln = function() {
  return wc(this);
};
xe.negated = xe.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s || 0, e;
};
xe.plus = xe.add = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? SM(t, e) : RM(t, (e.s = -e.s, e));
};
xe.precision = xe.sd = function(e) {
  var t, r, n, i = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(is + e);
  if (t = jt(i) + 1, n = i.d.length - 1, r = n * Rt + 1, n = i.d[n], n) {
    for (; n % 10 == 0; n /= 10) r--;
    for (n = i.d[0]; n >= 10; n /= 10) r++;
  }
  return e && t > r ? t : r;
};
xe.squareRoot = xe.sqrt = function() {
  var e, t, r, n, i, o, s, a = this, l = a.constructor;
  if (a.s < 1) {
    if (!a.s) return new l(0);
    throw Error(Pn + "NaN");
  }
  for (e = jt(a), Ft = !1, i = Math.sqrt(+a), i == 0 || i == 1 / 0 ? (t = ei(a.d), (t.length + e) % 2 == 0 && (t += "0"), i = Math.sqrt(t), e = nl((e + 1) / 2) - (e < 0 || e % 2), i == 1 / 0 ? t = "5e" + e : (t = i.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), n = new l(t)) : n = new l(i.toString()), r = l.precision, i = s = r + 3; ; )
    if (o = n, n = o.plus(Di(a, o, s + 2)).times(0.5), ei(o.d).slice(0, s) === (t = ei(n.d)).slice(0, s)) {
      if (t = t.slice(s - 3, s + 1), i == s && t == "4999") {
        if (mt(o, r + 1, 0), o.times(o).eq(a)) {
          n = o;
          break;
        }
      } else if (t != "9999")
        break;
      s += 4;
    }
  return Ft = !0, mt(n, r);
};
xe.times = xe.mul = function(e) {
  var t, r, n, i, o, s, a, l, u, d = this, h = d.constructor, f = d.d, p = (e = new h(e)).d;
  if (!d.s || !e.s) return new h(0);
  for (e.s *= d.s, r = d.e + e.e, l = f.length, u = p.length, l < u && (o = f, f = p, p = o, s = l, l = u, u = s), o = [], s = l + u, n = s; n--; ) o.push(0);
  for (n = u; --n >= 0; ) {
    for (t = 0, i = l + n; i > n; )
      a = o[i] + p[n] * f[i - n - 1] + t, o[i--] = a % tr | 0, t = a / tr | 0;
    o[i] = (o[i] + t) % tr | 0;
  }
  for (; !o[--s]; ) o.pop();
  return t ? ++r : o.shift(), e.d = o, e.e = r, Ft ? mt(e, h.precision) : e;
};
xe.toDecimalPlaces = xe.todp = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : (ci(e, 0, rl), t === void 0 ? t = n.rounding : ci(t, 0, 8), mt(r, e + jt(r) + 1, t));
};
xe.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = gs(n, !0) : (ci(e, 0, rl), t === void 0 ? t = i.rounding : ci(t, 0, 8), n = mt(new i(n), e + 1, t), r = gs(n, !0, e + 1)), r;
};
xe.toFixed = function(e, t) {
  var r, n, i = this, o = i.constructor;
  return e === void 0 ? gs(i) : (ci(e, 0, rl), t === void 0 ? t = o.rounding : ci(t, 0, 8), n = mt(new o(i), e + jt(i) + 1, t), r = gs(n.abs(), !1, e + jt(n) + 1), i.isneg() && !i.isZero() ? "-" + r : r);
};
xe.toInteger = xe.toint = function() {
  var e = this, t = e.constructor;
  return mt(new t(e), jt(e) + 1, t.rounding);
};
xe.toNumber = function() {
  return +this;
};
xe.toPower = xe.pow = function(e) {
  var t, r, n, i, o, s, a = this, l = a.constructor, u = 12, d = +(e = new l(e));
  if (!e.s) return new l(en);
  if (a = new l(a), !a.s) {
    if (e.s < 1) throw Error(Pn + "Infinity");
    return a;
  }
  if (a.eq(en)) return a;
  if (n = l.precision, e.eq(en)) return mt(a, n);
  if (t = e.e, r = e.d.length - 1, s = t >= r, o = a.s, s) {
    if ((r = d < 0 ? -d : d) <= bM) {
      for (i = new l(en), t = Math.ceil(n / Rt + 4), Ft = !1; r % 2 && (i = i.times(a), J2(i.d, t)), r = nl(r / 2), r !== 0; )
        a = a.times(a), J2(a.d, t);
      return Ft = !0, e.s < 0 ? new l(en).div(i) : mt(i, n);
    }
  } else if (o < 0) throw Error(Pn + "NaN");
  return o = o < 0 && e.d[Math.max(t, r)] & 1 ? -1 : 1, a.s = 1, Ft = !1, i = e.times(wc(a, n + u)), Ft = !0, i = xM(i), i.s = o, i;
};
xe.toPrecision = function(e, t) {
  var r, n, i = this, o = i.constructor;
  return e === void 0 ? (r = jt(i), n = gs(i, r <= o.toExpNeg || r >= o.toExpPos)) : (ci(e, 1, rl), t === void 0 ? t = o.rounding : ci(t, 0, 8), i = mt(new o(i), e, t), r = jt(i), n = gs(i, e <= r || r <= o.toExpNeg, e)), n;
};
xe.toSignificantDigits = xe.tosd = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : (ci(e, 1, rl), t === void 0 ? t = n.rounding : ci(t, 0, 8)), mt(new n(r), e, t);
};
xe.toString = xe.valueOf = xe.val = xe.toJSON = xe[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var e = this, t = jt(e), r = e.constructor;
  return gs(e, t <= r.toExpNeg || t >= r.toExpPos);
};
function SM(e, t) {
  var r, n, i, o, s, a, l, u, d = e.constructor, h = d.precision;
  if (!e.s || !t.s)
    return t.s || (t = new d(e)), Ft ? mt(t, h) : t;
  if (l = e.d, u = t.d, s = e.e, i = t.e, l = l.slice(), o = s - i, o) {
    for (o < 0 ? (n = l, o = -o, a = u.length) : (n = u, i = s, a = l.length), s = Math.ceil(h / Rt), a = s > a ? s + 1 : a + 1, o > a && (o = a, n.length = 1), n.reverse(); o--; ) n.push(0);
    n.reverse();
  }
  for (a = l.length, o = u.length, a - o < 0 && (o = a, n = u, u = l, l = n), r = 0; o; )
    r = (l[--o] = l[o] + u[o] + r) / tr | 0, l[o] %= tr;
  for (r && (l.unshift(r), ++i), a = l.length; l[--a] == 0; ) l.pop();
  return t.d = l, t.e = i, Ft ? mt(t, h) : t;
}
function ci(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(is + e);
}
function ei(e) {
  var t, r, n, i = e.length - 1, o = "", s = e[0];
  if (i > 0) {
    for (o += s, t = 1; t < i; t++)
      n = e[t] + "", r = Rt - n.length, r && (o += no(r)), o += n;
    s = e[t], n = s + "", r = Rt - n.length, r && (o += no(r));
  } else if (s === 0)
    return "0";
  for (; s % 10 === 0; ) s /= 10;
  return o + s;
}
var Di = /* @__PURE__ */ function() {
  function e(n, i) {
    var o, s = 0, a = n.length;
    for (n = n.slice(); a--; )
      o = n[a] * i + s, n[a] = o % tr | 0, s = o / tr | 0;
    return s && n.unshift(s), n;
  }
  function t(n, i, o, s) {
    var a, l;
    if (o != s)
      l = o > s ? 1 : -1;
    else
      for (a = l = 0; a < o; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, o) {
    for (var s = 0; o--; )
      n[o] -= s, s = n[o] < i[o] ? 1 : 0, n[o] = s * tr + n[o] - i[o];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, o, s) {
    var a, l, u, d, h, f, p, y, C, v, w, R, b, P, S, E, A, M, I = n.constructor, z = n.s == i.s ? 1 : -1, k = n.d, _ = i.d;
    if (!n.s) return new I(n);
    if (!i.s) throw Error(Pn + "Division by zero");
    for (l = n.e - i.e, A = _.length, S = k.length, p = new I(z), y = p.d = [], u = 0; _[u] == (k[u] || 0); ) ++u;
    if (_[u] > (k[u] || 0) && --l, o == null ? R = o = I.precision : s ? R = o + (jt(n) - jt(i)) + 1 : R = o, R < 0) return new I(0);
    if (R = R / Rt + 2 | 0, u = 0, A == 1)
      for (d = 0, _ = _[0], R++; (u < S || d) && R--; u++)
        b = d * tr + (k[u] || 0), y[u] = b / _ | 0, d = b % _ | 0;
    else {
      for (d = tr / (_[0] + 1) | 0, d > 1 && (_ = e(_, d), k = e(k, d), A = _.length, S = k.length), P = A, C = k.slice(0, A), v = C.length; v < A; ) C[v++] = 0;
      M = _.slice(), M.unshift(0), E = _[0], _[1] >= tr / 2 && ++E;
      do
        d = 0, a = t(_, C, A, v), a < 0 ? (w = C[0], A != v && (w = w * tr + (C[1] || 0)), d = w / E | 0, d > 1 ? (d >= tr && (d = tr - 1), h = e(_, d), f = h.length, v = C.length, a = t(h, C, f, v), a == 1 && (d--, r(h, A < f ? M : _, f))) : (d == 0 && (a = d = 1), h = _.slice()), f = h.length, f < v && h.unshift(0), r(C, h, v), a == -1 && (v = C.length, a = t(_, C, A, v), a < 1 && (d++, r(C, A < v ? M : _, v))), v = C.length) : a === 0 && (d++, C = [0]), y[u++] = d, a && C[0] ? C[v++] = k[P] || 0 : (C = [k[P]], v = 1);
      while ((P++ < S || C[0] !== void 0) && R--);
    }
    return y[0] || y.shift(), p.e = l, mt(p, s ? o + jt(p) + 1 : o);
  };
}();
function xM(e, t) {
  var r, n, i, o, s, a, l = 0, u = 0, d = e.constructor, h = d.precision;
  if (jt(e) > 16) throw Error(oC + jt(e));
  if (!e.s) return new d(en);
  for (Ft = !1, a = h, s = new d(0.03125); e.abs().gte(0.1); )
    e = e.times(s), u += 5;
  for (n = Math.log(Ho(2, u)) / Math.LN10 * 2 + 5 | 0, a += n, r = i = o = new d(en), d.precision = a; ; ) {
    if (i = mt(i.times(e), a), r = r.times(++l), s = o.plus(Di(i, r, a)), ei(s.d).slice(0, a) === ei(o.d).slice(0, a)) {
      for (; u--; ) o = mt(o.times(o), a);
      return d.precision = h, t == null ? (Ft = !0, mt(o, h)) : o;
    }
    o = s;
  }
}
function jt(e) {
  for (var t = e.e * Rt, r = e.d[0]; r >= 10; r /= 10) t++;
  return t;
}
function jp(e, t, r) {
  if (t > e.LN10.sd())
    throw Ft = !0, r && (e.precision = r), Error(Pn + "LN10 precision limit exceeded");
  return mt(new e(e.LN10), t);
}
function no(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function wc(e, t) {
  var r, n, i, o, s, a, l, u, d, h = 1, f = 10, p = e, y = p.d, C = p.constructor, v = C.precision;
  if (p.s < 1) throw Error(Pn + (p.s ? "NaN" : "-Infinity"));
  if (p.eq(en)) return new C(0);
  if (t == null ? (Ft = !1, u = v) : u = t, p.eq(10))
    return t == null && (Ft = !0), jp(C, u);
  if (u += f, C.precision = u, r = ei(y), n = r.charAt(0), o = jt(p), Math.abs(o) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      p = p.times(e), r = ei(p.d), n = r.charAt(0), h++;
    o = jt(p), n > 1 ? (p = new C("0." + r), o++) : p = new C(n + "." + r.slice(1));
  } else
    return l = jp(C, u + 2, v).times(o + ""), p = wc(new C(n + "." + r.slice(1)), u - f).plus(l), C.precision = v, t == null ? (Ft = !0, mt(p, v)) : p;
  for (a = s = p = Di(p.minus(en), p.plus(en), u), d = mt(p.times(p), u), i = 3; ; ) {
    if (s = mt(s.times(d), u), l = a.plus(Di(s, new C(i), u)), ei(l.d).slice(0, u) === ei(a.d).slice(0, u))
      return a = a.times(2), o !== 0 && (a = a.plus(jp(C, u + 2, v).times(o + ""))), a = Di(a, new C(h), u), C.precision = v, t == null ? (Ft = !0, mt(a, v)) : a;
    a = l, i += 2;
  }
}
function Y2(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; ) ++n;
  for (i = t.length; t.charCodeAt(i - 1) === 48; ) --i;
  if (t = t.slice(n, i), t) {
    if (i -= n, r = r - n - 1, e.e = nl(r / Rt), e.d = [], n = (r + 1) % Rt, r < 0 && (n += Rt), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= Rt; n < i; ) e.d.push(+t.slice(n, n += Rt));
      t = t.slice(n), n = Rt - t.length;
    } else
      n -= i;
    for (; n--; ) t += "0";
    if (e.d.push(+t), Ft && (e.e > dh || e.e < -dh)) throw Error(oC + r);
  } else
    e.s = 0, e.e = 0, e.d = [0];
  return e;
}
function mt(e, t, r) {
  var n, i, o, s, a, l, u, d, h = e.d;
  for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
  if (n = t - s, n < 0)
    n += Rt, i = t, u = h[d = 0];
  else {
    if (d = Math.ceil((n + 1) / Rt), o = h.length, d >= o) return e;
    for (u = o = h[d], s = 1; o >= 10; o /= 10) s++;
    n %= Rt, i = n - Rt + s;
  }
  if (r !== void 0 && (o = Ho(10, s - i - 1), a = u / o % 10 | 0, l = t < 0 || h[d + 1] !== void 0 || u % o, l = r < 4 ? (a || l) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : a > 5 || a == 5 && (r == 4 || l || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (n > 0 ? i > 0 ? u / Ho(10, s - i) : 0 : h[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7))), t < 1 || !h[0])
    return l ? (o = jt(e), h.length = 1, t = t - o - 1, h[0] = Ho(10, (Rt - t % Rt) % Rt), e.e = nl(-t / Rt) || 0) : (h.length = 1, h[0] = e.e = e.s = 0), e;
  if (n == 0 ? (h.length = d, o = 1, d--) : (h.length = d + 1, o = Ho(10, Rt - n), h[d] = i > 0 ? (u / Ho(10, s - i) % Ho(10, i) | 0) * o : 0), l)
    for (; ; )
      if (d == 0) {
        (h[0] += o) == tr && (h[0] = 1, ++e.e);
        break;
      } else {
        if (h[d] += o, h[d] != tr) break;
        h[d--] = 0, o = 1;
      }
  for (n = h.length; h[--n] === 0; ) h.pop();
  if (Ft && (e.e > dh || e.e < -dh))
    throw Error(oC + jt(e));
  return e;
}
function RM(e, t) {
  var r, n, i, o, s, a, l, u, d, h, f = e.constructor, p = f.precision;
  if (!e.s || !t.s)
    return t.s ? t.s = -t.s : t = new f(e), Ft ? mt(t, p) : t;
  if (l = e.d, h = t.d, n = t.e, u = e.e, l = l.slice(), s = u - n, s) {
    for (d = s < 0, d ? (r = l, s = -s, a = h.length) : (r = h, n = u, a = l.length), i = Math.max(Math.ceil(p / Rt), a) + 2, s > i && (s = i, r.length = 1), r.reverse(), i = s; i--; ) r.push(0);
    r.reverse();
  } else {
    for (i = l.length, a = h.length, d = i < a, d && (a = i), i = 0; i < a; i++)
      if (l[i] != h[i]) {
        d = l[i] < h[i];
        break;
      }
    s = 0;
  }
  for (d && (r = l, l = h, h = r, t.s = -t.s), a = l.length, i = h.length - a; i > 0; --i) l[a++] = 0;
  for (i = h.length; i > s; ) {
    if (l[--i] < h[i]) {
      for (o = i; o && l[--o] === 0; ) l[o] = tr - 1;
      --l[o], l[i] += tr;
    }
    l[i] -= h[i];
  }
  for (; l[--a] === 0; ) l.pop();
  for (; l[0] === 0; l.shift()) --n;
  return l[0] ? (t.d = l, t.e = n, Ft ? mt(t, p) : t) : new f(0);
}
function gs(e, t, r) {
  var n, i = jt(e), o = ei(e.d), s = o.length;
  return t ? (r && (n = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + no(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (i < 0 ? "e" : "e+") + i) : i < 0 ? (o = "0." + no(-i - 1) + o, r && (n = r - s) > 0 && (o += no(n))) : i >= s ? (o += no(i + 1 - s), r && (n = r - i - 1) > 0 && (o = o + "." + no(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (o += "."), o += no(n))), e.s < 0 ? "-" + o : o;
}
function J2(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function EM(e) {
  var t, r, n;
  function i(o) {
    var s = this;
    if (!(s instanceof i)) return new i(o);
    if (s.constructor = i, o instanceof i) {
      s.s = o.s, s.e = o.e, s.d = (o = o.d) ? o.slice() : o;
      return;
    }
    if (typeof o == "number") {
      if (o * 0 !== 0)
        throw Error(is + o);
      if (o > 0)
        s.s = 1;
      else if (o < 0)
        o = -o, s.s = -1;
      else {
        s.s = 0, s.e = 0, s.d = [0];
        return;
      }
      if (o === ~~o && o < 1e7) {
        s.e = 0, s.d = [o];
        return;
      }
      return Y2(s, o.toString());
    } else if (typeof o != "string")
      throw Error(is + o);
    if (o.charCodeAt(0) === 45 ? (o = o.slice(1), s.s = -1) : s.s = 1, sce.test(o)) Y2(s, o);
    else throw Error(is + o);
  }
  if (i.prototype = xe, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = EM, i.config = i.set = ace, e === void 0 && (e = {}), e)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < n.length; ) e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function ace(e) {
  if (!e || typeof e != "object")
    throw Error(Pn + "Object expected");
  var t, r, n, i = [
    "precision",
    1,
    rl,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (t = 0; t < i.length; t += 3)
    if ((n = e[r = i[t]]) !== void 0)
      if (nl(n) === n && n >= i[t + 1] && n <= i[t + 2]) this[r] = n;
      else throw Error(is + r + ": " + n);
  if ((n = e[r = "LN10"]) !== void 0)
    if (n == Math.LN10) this[r] = new this(n);
    else throw Error(is + r + ": " + n);
  return this;
}
var sC = EM(oce);
en = new sC(1);
const ft = sC;
function lce(e) {
  return hce(e) || dce(e) || uce(e) || cce();
}
function cce() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function uce(e, t) {
  if (e) {
    if (typeof e == "string") return vv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return vv(e, t);
  }
}
function dce(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function hce(e) {
  if (Array.isArray(e)) return vv(e);
}
function vv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
var gce = function(t) {
  return t;
}, PM = {}, AM = function(t) {
  return t === PM;
}, X2 = function(t) {
  return function r() {
    return arguments.length === 0 || arguments.length === 1 && AM(arguments.length <= 0 ? void 0 : arguments[0]) ? r : t.apply(void 0, arguments);
  };
}, fce = function e(t, r) {
  return t === 1 ? r : X2(function() {
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    var s = i.filter(function(a) {
      return a !== PM;
    }).length;
    return s >= t ? r.apply(void 0, i) : e(t - s, X2(function() {
      for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++)
        l[u] = arguments[u];
      var d = i.map(function(h) {
        return AM(h) ? l.shift() : h;
      });
      return r.apply(void 0, lce(d).concat(l));
    }));
  });
}, bg = function(t) {
  return fce(t.length, t);
}, yv = function(t, r) {
  for (var n = [], i = t; i < r; ++i)
    n[i - t] = i;
  return n;
}, pce = bg(function(e, t) {
  return Array.isArray(t) ? t.map(e) : Object.keys(t).map(function(r) {
    return t[r];
  }).map(e);
}), mce = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  if (!r.length)
    return gce;
  var i = r.reverse(), o = i[0], s = i.slice(1);
  return function() {
    return s.reduce(function(a, l) {
      return l(a);
    }, o.apply(void 0, arguments));
  };
}, Cv = function(t) {
  return Array.isArray(t) ? t.reverse() : t.split("").reverse.join("");
}, FM = function(t) {
  var r = null, n = null;
  return function() {
    for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return r && o.every(function(a, l) {
      return a === r[l];
    }) || (r = o, n = t.apply(void 0, o)), n;
  };
};
function vce(e) {
  var t;
  return e === 0 ? t = 1 : t = Math.floor(new ft(e).abs().log(10).toNumber()) + 1, t;
}
function yce(e, t, r) {
  for (var n = new ft(e), i = 0, o = []; n.lt(t) && i < 1e5; )
    o.push(n.toNumber()), n = n.add(r), i++;
  return o;
}
var Cce = bg(function(e, t, r) {
  var n = +e, i = +t;
  return n + r * (i - n);
}), wce = bg(function(e, t, r) {
  var n = t - +e;
  return n = n || 1 / 0, (r - e) / n;
}), bce = bg(function(e, t, r) {
  var n = t - +e;
  return n = n || 1 / 0, Math.max(0, Math.min(1, (r - e) / n));
});
const Sg = {
  rangeStep: yce,
  getDigitCount: vce,
  interpolateNumber: Cce,
  uninterpolateNumber: wce,
  uninterpolateTruncation: bce
};
function wv(e) {
  return Rce(e) || xce(e) || MM(e) || Sce();
}
function Sce() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xce(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function Rce(e) {
  if (Array.isArray(e)) return bv(e);
}
function bc(e, t) {
  return Ace(e) || Pce(e, t) || MM(e, t) || Ece();
}
function Ece() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function MM(e, t) {
  if (e) {
    if (typeof e == "string") return bv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return bv(e, t);
  }
}
function bv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function Pce(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var r = [], n = !0, i = !1, o = void 0;
    try {
      for (var s = e[Symbol.iterator](), a; !(n = (a = s.next()).done) && (r.push(a.value), !(t && r.length === t)); n = !0)
        ;
    } catch (l) {
      i = !0, o = l;
    } finally {
      try {
        !n && s.return != null && s.return();
      } finally {
        if (i) throw o;
      }
    }
    return r;
  }
}
function Ace(e) {
  if (Array.isArray(e)) return e;
}
function TM(e) {
  var t = bc(e, 2), r = t[0], n = t[1], i = r, o = n;
  return r > n && (i = n, o = r), [i, o];
}
function DM(e, t, r) {
  if (e.lte(0))
    return new ft(0);
  var n = Sg.getDigitCount(e.toNumber()), i = new ft(10).pow(n), o = e.div(i), s = n !== 1 ? 0.05 : 0.1, a = new ft(Math.ceil(o.div(s).toNumber())).add(r).mul(s), l = a.mul(i);
  return t ? l : new ft(Math.ceil(l));
}
function Fce(e, t, r) {
  var n = 1, i = new ft(e);
  if (!i.isint() && r) {
    var o = Math.abs(e);
    o < 1 ? (n = new ft(10).pow(Sg.getDigitCount(e) - 1), i = new ft(Math.floor(i.div(n).toNumber())).mul(n)) : o > 1 && (i = new ft(Math.floor(e)));
  } else e === 0 ? i = new ft(Math.floor((t - 1) / 2)) : r || (i = new ft(Math.floor(e)));
  var s = Math.floor((t - 1) / 2), a = mce(pce(function(l) {
    return i.add(new ft(l - s).mul(n)).toNumber();
  }), yv);
  return a(0, t);
}
function OM(e, t, r, n) {
  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((t - e) / (r - 1)))
    return {
      step: new ft(0),
      tickMin: new ft(0),
      tickMax: new ft(0)
    };
  var o = DM(new ft(t).sub(e).div(r - 1), n, i), s;
  e <= 0 && t >= 0 ? s = new ft(0) : (s = new ft(e).add(t).div(2), s = s.sub(new ft(s).mod(o)));
  var a = Math.ceil(s.sub(e).div(o).toNumber()), l = Math.ceil(new ft(t).sub(s).div(o).toNumber()), u = a + l + 1;
  return u > r ? OM(e, t, r, n, i + 1) : (u < r && (l = t > 0 ? l + (r - u) : l, a = t > 0 ? a : a + (r - u)), {
    step: o,
    tickMin: s.sub(new ft(a).mul(o)),
    tickMax: s.add(new ft(l).mul(o))
  });
}
function Mce(e) {
  var t = bc(e, 2), r = t[0], n = t[1], i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = Math.max(i, 2), a = TM([r, n]), l = bc(a, 2), u = l[0], d = l[1];
  if (u === -1 / 0 || d === 1 / 0) {
    var h = d === 1 / 0 ? [u].concat(wv(yv(0, i - 1).map(function() {
      return 1 / 0;
    }))) : [].concat(wv(yv(0, i - 1).map(function() {
      return -1 / 0;
    })), [d]);
    return r > n ? Cv(h) : h;
  }
  if (u === d)
    return Fce(u, i, o);
  var f = OM(u, d, s, o), p = f.step, y = f.tickMin, C = f.tickMax, v = Sg.rangeStep(y, C.add(new ft(0.1).mul(p)), p);
  return r > n ? Cv(v) : v;
}
function Tce(e, t) {
  var r = bc(e, 2), n = r[0], i = r[1], o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = TM([n, i]), a = bc(s, 2), l = a[0], u = a[1];
  if (l === -1 / 0 || u === 1 / 0)
    return [n, i];
  if (l === u)
    return [l];
  var d = Math.max(t, 2), h = DM(new ft(u).sub(l).div(d - 1), o, 0), f = [].concat(wv(Sg.rangeStep(new ft(l), new ft(u).sub(new ft(0.99).mul(h)), h)), [u]);
  return n > i ? Cv(f) : f;
}
var Dce = FM(Mce), Oce = FM(Tce), Ice = process.env.NODE_ENV === "production", Up = "Invariant failed";
function Hr(e, t) {
  if (Ice)
    throw new Error(Up);
  var r = typeof t == "function" ? t() : t, n = r ? "".concat(Up, ": ").concat(r) : Up;
  throw new Error(n);
}
var kce = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function pa(e) {
  "@babel/helpers - typeof";
  return pa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pa(e);
}
function hh() {
  return hh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, hh.apply(this, arguments);
}
function Lce(e, t) {
  return Bce(e) || Nce(e, t) || zce(e, t) || _ce();
}
function _ce() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function zce(e, t) {
  if (e) {
    if (typeof e == "string") return Q2(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Q2(e, t);
  }
}
function Q2(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Nce(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Bce(e) {
  if (Array.isArray(e)) return e;
}
function Gce(e, t) {
  if (e == null) return {};
  var r = Hce(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Hce(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Wce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Vce(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, LM(n.key), n);
  }
}
function $ce(e, t, r) {
  return t && Vce(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function jce(e, t, r) {
  return t = gh(t), Uce(e, IM() ? Reflect.construct(t, r || [], gh(e).constructor) : t.apply(e, r));
}
function Uce(e, t) {
  if (t && (pa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Kce(e);
}
function Kce(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function IM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (IM = function() {
    return !!e;
  })();
}
function gh(e) {
  return gh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, gh(e);
}
function qce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Sv(e, t);
}
function Sv(e, t) {
  return Sv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Sv(e, t);
}
function kM(e, t, r) {
  return t = LM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function LM(e) {
  var t = Yce(e, "string");
  return pa(t) == "symbol" ? t : t + "";
}
function Yce(e, t) {
  if (pa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (pa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var il = /* @__PURE__ */ function(e) {
  function t() {
    return Wce(this, t), jce(this, t, arguments);
  }
  return qce(t, e), $ce(t, [{
    key: "render",
    value: function() {
      var n = this.props, i = n.offset, o = n.layout, s = n.width, a = n.dataKey, l = n.data, u = n.dataPointFormatter, d = n.xAxis, h = n.yAxis, f = Gce(n, kce), p = Ne(f, !1);
      this.props.direction === "x" && d.type !== "number" && (process.env.NODE_ENV !== "production" ? Hr(!1, 'ErrorBar requires Axis type property to be "number".') : Hr());
      var y = l.map(function(C) {
        var v = u(C, a), w = v.x, R = v.y, b = v.value, P = v.errorVal;
        if (!P)
          return null;
        var S = [], E, A;
        if (Array.isArray(P)) {
          var M = Lce(P, 2);
          E = M[0], A = M[1];
        } else
          E = A = P;
        if (o === "vertical") {
          var I = d.scale, z = R + i, k = z + s, _ = z - s, q = I(b - E), j = I(b + A);
          S.push({
            x1: j,
            y1: k,
            x2: j,
            y2: _
          }), S.push({
            x1: q,
            y1: z,
            x2: j,
            y2: z
          }), S.push({
            x1: q,
            y1: k,
            x2: q,
            y2: _
          });
        } else if (o === "horizontal") {
          var Q = h.scale, K = w + i, Z = K - s, te = K + s, se = Q(b - E), W = Q(b + A);
          S.push({
            x1: Z,
            y1: W,
            x2: te,
            y2: W
          }), S.push({
            x1: K,
            y1: se,
            x2: K,
            y2: W
          }), S.push({
            x1: Z,
            y1: se,
            x2: te,
            y2: se
          });
        }
        return /* @__PURE__ */ O.createElement(st, hh({
          className: "recharts-errorBar",
          key: "bar-".concat(S.map(function(U) {
            return "".concat(U.x1, "-").concat(U.x2, "-").concat(U.y1, "-").concat(U.y2);
          }))
        }, p), S.map(function(U) {
          return /* @__PURE__ */ O.createElement("line", hh({}, U, {
            key: "line-".concat(U.x1, "-").concat(U.x2, "-").concat(U.y1, "-").concat(U.y2)
          }));
        }));
      });
      return /* @__PURE__ */ O.createElement(st, {
        className: "recharts-errorBars"
      }, y);
    }
  }]);
}(O.Component);
kM(il, "defaultProps", {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
});
kM(il, "displayName", "ErrorBar");
function Sc(e) {
  "@babel/helpers - typeof";
  return Sc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sc(e);
}
function Z2(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function _o(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z2(Object(r), !0).forEach(function(n) {
      Jce(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Z2(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Jce(e, t, r) {
  return t = Xce(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Xce(e) {
  var t = Qce(e, "string");
  return Sc(t) == "symbol" ? t : t + "";
}
function Qce(e, t) {
  if (Sc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Sc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var _M = function(t) {
  var r = t.children, n = t.formattedGraphicalItems, i = t.legendWidth, o = t.legendContent, s = Zr(r, ea);
  if (!s)
    return null;
  var a = ea.defaultProps, l = a !== void 0 ? _o(_o({}, a), s.props) : {}, u;
  return s.props && s.props.payload ? u = s.props && s.props.payload : o === "children" ? u = (n || []).reduce(function(d, h) {
    var f = h.item, p = h.props, y = p.sectors || p.data || [];
    return d.concat(y.map(function(C) {
      return {
        type: s.props.iconType || f.props.legendType,
        value: C.name,
        color: C.fill,
        payload: C
      };
    }));
  }, []) : u = (n || []).map(function(d) {
    var h = d.item, f = h.type.defaultProps, p = f !== void 0 ? _o(_o({}, f), h.props) : {}, y = p.dataKey, C = p.name, v = p.legendType, w = p.hide;
    return {
      inactive: w,
      dataKey: y,
      type: l.iconType || v || "square",
      color: aC(h),
      value: C || y,
      // @ts-expect-error property strokeDasharray is required in Payload but optional in props
      payload: p
    };
  }), _o(_o(_o({}, l), ea.getWithHeight(s, i)), {}, {
    payload: u,
    item: s
  });
};
function xc(e) {
  "@babel/helpers - typeof";
  return xc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xc(e);
}
function ex(e) {
  return rue(e) || tue(e) || eue(e) || Zce();
}
function Zce() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function eue(e, t) {
  if (e) {
    if (typeof e == "string") return xv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return xv(e, t);
  }
}
function tue(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function rue(e) {
  if (Array.isArray(e)) return xv(e);
}
function xv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function tx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Lt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tx(Object(r), !0).forEach(function(n) {
      ra(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : tx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function ra(e, t, r) {
  return t = nue(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function nue(e) {
  var t = iue(e, "string");
  return xc(t) == "symbol" ? t : t + "";
}
function iue(e, t) {
  if (xc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (xc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Xt(e, t, r) {
  return _e(e) || _e(t) ? r : Jt(t) ? En(e, t, r) : We(t) ? t(e) : r;
}
function Yl(e, t, r, n) {
  var i = tce(e, function(a) {
    return Xt(a, t);
  });
  if (r === "number") {
    var o = i.filter(function(a) {
      return Ce(a) || parseFloat(a);
    });
    return o.length ? [wg(o), io(o)] : [1 / 0, -1 / 0];
  }
  var s = n ? i.filter(function(a) {
    return !_e(a);
  }) : i;
  return s.map(function(a) {
    return Jt(a) || a instanceof Date ? a : "";
  });
}
var oue = function(t) {
  var r, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0, s = -1, a = (r = n == null ? void 0 : n.length) !== null && r !== void 0 ? r : 0;
  if (a <= 1)
    return 0;
  if (o && o.axisType === "angleAxis" && Math.abs(Math.abs(o.range[1] - o.range[0]) - 360) <= 1e-6)
    for (var l = o.range, u = 0; u < a; u++) {
      var d = u > 0 ? i[u - 1].coordinate : i[a - 1].coordinate, h = i[u].coordinate, f = u >= a - 1 ? i[0].coordinate : i[u + 1].coordinate, p = void 0;
      if (Gn(h - d) !== Gn(f - h)) {
        var y = [];
        if (Gn(f - h) === Gn(l[1] - l[0])) {
          p = f;
          var C = h + l[1] - l[0];
          y[0] = Math.min(C, (C + d) / 2), y[1] = Math.max(C, (C + d) / 2);
        } else {
          p = d;
          var v = f + l[1] - l[0];
          y[0] = Math.min(h, (v + h) / 2), y[1] = Math.max(h, (v + h) / 2);
        }
        var w = [Math.min(h, (p + h) / 2), Math.max(h, (p + h) / 2)];
        if (t > w[0] && t <= w[1] || t >= y[0] && t <= y[1]) {
          s = i[u].index;
          break;
        }
      } else {
        var R = Math.min(d, f), b = Math.max(d, f);
        if (t > (R + h) / 2 && t <= (b + h) / 2) {
          s = i[u].index;
          break;
        }
      }
    }
  else
    for (var P = 0; P < a; P++)
      if (P === 0 && t <= (n[P].coordinate + n[P + 1].coordinate) / 2 || P > 0 && P < a - 1 && t > (n[P].coordinate + n[P - 1].coordinate) / 2 && t <= (n[P].coordinate + n[P + 1].coordinate) / 2 || P === a - 1 && t > (n[P].coordinate + n[P - 1].coordinate) / 2) {
        s = n[P].index;
        break;
      }
  return s;
}, aC = function(t) {
  var r, n = t, i = n.type.displayName, o = (r = t.type) !== null && r !== void 0 && r.defaultProps ? Lt(Lt({}, t.type.defaultProps), t.props) : t.props, s = o.stroke, a = o.fill, l;
  switch (i) {
    case "Line":
      l = s;
      break;
    case "Area":
    case "Radar":
      l = s && s !== "none" ? s : a;
      break;
    default:
      l = a;
      break;
  }
  return l;
}, sue = function(t) {
  var r = t.barSize, n = t.totalSize, i = t.stackGroups, o = i === void 0 ? {} : i;
  if (!o)
    return {};
  for (var s = {}, a = Object.keys(o), l = 0, u = a.length; l < u; l++)
    for (var d = o[a[l]].stackGroups, h = Object.keys(d), f = 0, p = h.length; f < p; f++) {
      var y = d[h[f]], C = y.items, v = y.cateAxisId, w = C.filter(function(A) {
        return co(A.type).indexOf("Bar") >= 0;
      });
      if (w && w.length) {
        var R = w[0].type.defaultProps, b = R !== void 0 ? Lt(Lt({}, R), w[0].props) : w[0].props, P = b.barSize, S = b[v];
        s[S] || (s[S] = []);
        var E = _e(P) ? r : P;
        s[S].push({
          item: w[0],
          stackList: w.slice(1),
          barSize: _e(E) ? void 0 : ds(E, n, 0)
        });
      }
    }
  return s;
}, aue = function(t) {
  var r = t.barGap, n = t.barCategoryGap, i = t.bandSize, o = t.sizeList, s = o === void 0 ? [] : o, a = t.maxBarSize, l = s.length;
  if (l < 1) return null;
  var u = ds(r, i, 0, !0), d, h = [];
  if (s[0].barSize === +s[0].barSize) {
    var f = !1, p = i / l, y = s.reduce(function(P, S) {
      return P + S.barSize || 0;
    }, 0);
    y += (l - 1) * u, y >= i && (y -= (l - 1) * u, u = 0), y >= i && p > 0 && (f = !0, p *= 0.9, y = l * p);
    var C = (i - y) / 2 >> 0, v = {
      offset: C - u,
      size: 0
    };
    d = s.reduce(function(P, S) {
      var E = {
        item: S.item,
        position: {
          offset: v.offset + v.size + u,
          // @ts-expect-error the type check above does not check for type number explicitly
          size: f ? p : S.barSize
        }
      }, A = [].concat(ex(P), [E]);
      return v = A[A.length - 1].position, S.stackList && S.stackList.length && S.stackList.forEach(function(M) {
        A.push({
          item: M,
          position: v
        });
      }), A;
    }, h);
  } else {
    var w = ds(n, i, 0, !0);
    i - 2 * w - (l - 1) * u <= 0 && (u = 0);
    var R = (i - 2 * w - (l - 1) * u) / l;
    R > 1 && (R >>= 0);
    var b = a === +a ? Math.min(R, a) : R;
    d = s.reduce(function(P, S, E) {
      var A = [].concat(ex(P), [{
        item: S.item,
        position: {
          offset: w + (R + u) * E + (R - b) / 2,
          size: b
        }
      }]);
      return S.stackList && S.stackList.length && S.stackList.forEach(function(M) {
        A.push({
          item: M,
          position: A[A.length - 1].position
        });
      }), A;
    }, h);
  }
  return d;
}, lue = function(t, r, n, i) {
  var o = n.children, s = n.width, a = n.margin, l = s - (a.left || 0) - (a.right || 0), u = _M({
    children: o,
    legendWidth: l
  });
  if (u) {
    var d = i || {}, h = d.width, f = d.height, p = u.align, y = u.verticalAlign, C = u.layout;
    if ((C === "vertical" || C === "horizontal" && y === "middle") && p !== "center" && Ce(t[p]))
      return Lt(Lt({}, t), {}, ra({}, p, t[p] + (h || 0)));
    if ((C === "horizontal" || C === "vertical" && p === "center") && y !== "middle" && Ce(t[y]))
      return Lt(Lt({}, t), {}, ra({}, y, t[y] + (f || 0)));
  }
  return t;
}, cue = function(t, r, n) {
  return _e(r) ? !0 : t === "horizontal" ? r === "yAxis" : t === "vertical" || n === "x" ? r === "xAxis" : n === "y" ? r === "yAxis" : !0;
}, zM = function(t, r, n, i, o) {
  var s = r.props.children, a = Wr(s, il).filter(function(u) {
    return cue(i, o, u.props.direction);
  });
  if (a && a.length) {
    var l = a.map(function(u) {
      return u.props.dataKey;
    });
    return t.reduce(function(u, d) {
      var h = Xt(d, n);
      if (_e(h)) return u;
      var f = Array.isArray(h) ? [wg(h), io(h)] : [h, h], p = l.reduce(function(y, C) {
        var v = Xt(d, C, 0), w = f[0] - Math.abs(Array.isArray(v) ? v[0] : v), R = f[1] + Math.abs(Array.isArray(v) ? v[1] : v);
        return [Math.min(w, y[0]), Math.max(R, y[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(p[0], u[0]), Math.max(p[1], u[1])];
    }, [1 / 0, -1 / 0]);
  }
  return null;
}, uue = function(t, r, n, i, o) {
  var s = r.map(function(a) {
    return zM(t, a, n, o, i);
  }).filter(function(a) {
    return !_e(a);
  });
  return s && s.length ? s.reduce(function(a, l) {
    return [Math.min(a[0], l[0]), Math.max(a[1], l[1])];
  }, [1 / 0, -1 / 0]) : null;
}, NM = function(t, r, n, i, o) {
  var s = r.map(function(l) {
    var u = l.props.dataKey;
    return n === "number" && u && zM(t, l, u, i) || Yl(t, u, n, o);
  });
  if (n === "number")
    return s.reduce(
      // @ts-expect-error if (type === number) means that the domain is numerical type
      // - but this link is missing in the type definition
      function(l, u) {
        return [Math.min(l[0], u[0]), Math.max(l[1], u[1])];
      },
      [1 / 0, -1 / 0]
    );
  var a = {};
  return s.reduce(function(l, u) {
    for (var d = 0, h = u.length; d < h; d++)
      a[u[d]] || (a[u[d]] = !0, l.push(u[d]));
    return l;
  }, []);
}, BM = function(t, r) {
  return t === "horizontal" && r === "xAxis" || t === "vertical" && r === "yAxis" || t === "centric" && r === "angleAxis" || t === "radial" && r === "radiusAxis";
}, Yo = function(t, r, n) {
  if (!t) return null;
  var i = t.scale, o = t.duplicateDomain, s = t.type, a = t.range, l = t.realScaleType === "scaleBand" ? i.bandwidth() / 2 : 2, u = (r || n) && s === "category" && i.bandwidth ? i.bandwidth() / l : 0;
  if (u = t.axisType === "angleAxis" && (a == null ? void 0 : a.length) >= 2 ? Gn(a[0] - a[1]) * 2 * u : u, r && (t.ticks || t.niceTicks)) {
    var d = (t.ticks || t.niceTicks).map(function(h) {
      var f = o ? o.indexOf(h) : h;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: i(f) + u,
        value: h,
        offset: u
      };
    });
    return d.filter(function(h) {
      return !Ja(h.coordinate);
    });
  }
  return t.isCategorical && t.categoricalDomain ? t.categoricalDomain.map(function(h, f) {
    return {
      coordinate: i(h) + u,
      value: h,
      index: f,
      offset: u
    };
  }) : i.ticks && !n ? i.ticks(t.tickCount).map(function(h) {
    return {
      coordinate: i(h) + u,
      value: h,
      offset: u
    };
  }) : i.domain().map(function(h, f) {
    return {
      coordinate: i(h) + u,
      value: o ? o[h] : h,
      index: f,
      offset: u
    };
  });
}, Kp = /* @__PURE__ */ new WeakMap(), nd = function(t, r) {
  if (typeof r != "function")
    return t;
  Kp.has(t) || Kp.set(t, /* @__PURE__ */ new WeakMap());
  var n = Kp.get(t);
  if (n.has(r))
    return n.get(r);
  var i = function() {
    t.apply(void 0, arguments), r.apply(void 0, arguments);
  };
  return n.set(r, i), i;
}, due = function(t, r, n) {
  var i = t.scale, o = t.type, s = t.layout, a = t.axisType;
  if (i === "auto")
    return s === "radial" && a === "radiusAxis" ? {
      scale: pc(),
      realScaleType: "band"
    } : s === "radial" && a === "angleAxis" ? {
      scale: ah(),
      realScaleType: "linear"
    } : o === "category" && r && (r.indexOf("LineChart") >= 0 || r.indexOf("AreaChart") >= 0 || r.indexOf("ComposedChart") >= 0 && !n) ? {
      scale: ql(),
      realScaleType: "point"
    } : o === "category" ? {
      scale: pc(),
      realScaleType: "band"
    } : {
      scale: ah(),
      realScaleType: "linear"
    };
  if (us(i)) {
    var l = "scale".concat(sg(i));
    return {
      scale: (q2[l] || ql)(),
      realScaleType: q2[l] ? l : "point"
    };
  }
  return We(i) ? {
    scale: i
  } : {
    scale: ql(),
    realScaleType: "point"
  };
}, rx = 1e-4, hue = function(t) {
  var r = t.domain();
  if (!(!r || r.length <= 2)) {
    var n = r.length, i = t.range(), o = Math.min(i[0], i[1]) - rx, s = Math.max(i[0], i[1]) + rx, a = t(r[0]), l = t(r[n - 1]);
    (a < o || a > s || l < o || l > s) && t.domain([r[0], r[n - 1]]);
  }
}, gue = function(t, r) {
  if (!t)
    return null;
  for (var n = 0, i = t.length; n < i; n++)
    if (t[n].item === r)
      return t[n].position;
  return null;
}, fue = function(t, r) {
  if (!r || r.length !== 2 || !Ce(r[0]) || !Ce(r[1]))
    return t;
  var n = Math.min(r[0], r[1]), i = Math.max(r[0], r[1]), o = [t[0], t[1]];
  return (!Ce(t[0]) || t[0] < n) && (o[0] = n), (!Ce(t[1]) || t[1] > i) && (o[1] = i), o[0] > i && (o[0] = i), o[1] < n && (o[1] = n), o;
}, pue = function(t) {
  var r = t.length;
  if (!(r <= 0))
    for (var n = 0, i = t[0].length; n < i; ++n)
      for (var o = 0, s = 0, a = 0; a < r; ++a) {
        var l = Ja(t[a][n][1]) ? t[a][n][0] : t[a][n][1];
        l >= 0 ? (t[a][n][0] = o, t[a][n][1] = o + l, o = t[a][n][1]) : (t[a][n][0] = s, t[a][n][1] = s + l, s = t[a][n][1]);
      }
}, mue = function(t) {
  var r = t.length;
  if (!(r <= 0))
    for (var n = 0, i = t[0].length; n < i; ++n)
      for (var o = 0, s = 0; s < r; ++s) {
        var a = Ja(t[s][n][1]) ? t[s][n][0] : t[s][n][1];
        a >= 0 ? (t[s][n][0] = o, t[s][n][1] = o + a, o = t[s][n][1]) : (t[s][n][0] = 0, t[s][n][1] = 0);
      }
}, vue = {
  sign: pue,
  // @ts-expect-error definitelytyped types are incorrect
  expand: NJ,
  // @ts-expect-error definitelytyped types are incorrect
  none: aa,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: BJ,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: GJ,
  positive: mue
}, yue = function(t, r, n) {
  var i = r.map(function(a) {
    return a.props.dataKey;
  }), o = vue[n], s = zJ().keys(i).value(function(a, l) {
    return +Xt(a, l, 0);
  }).order(qm).offset(o);
  return s(t);
}, Cue = function(t, r, n, i, o, s) {
  if (!t)
    return null;
  var a = s ? r.reverse() : r, l = {}, u = a.reduce(function(h, f) {
    var p, y = (p = f.type) !== null && p !== void 0 && p.defaultProps ? Lt(Lt({}, f.type.defaultProps), f.props) : f.props, C = y.stackId, v = y.hide;
    if (v)
      return h;
    var w = y[n], R = h[w] || {
      hasStack: !1,
      stackGroups: {}
    };
    if (Jt(C)) {
      var b = R.stackGroups[C] || {
        numericAxisId: n,
        cateAxisId: i,
        items: []
      };
      b.items.push(f), R.hasStack = !0, R.stackGroups[C] = b;
    } else
      R.stackGroups[Cs("_stackId_")] = {
        numericAxisId: n,
        cateAxisId: i,
        items: [f]
      };
    return Lt(Lt({}, h), {}, ra({}, w, R));
  }, l), d = {};
  return Object.keys(u).reduce(function(h, f) {
    var p = u[f];
    if (p.hasStack) {
      var y = {};
      p.stackGroups = Object.keys(p.stackGroups).reduce(function(C, v) {
        var w = p.stackGroups[v];
        return Lt(Lt({}, C), {}, ra({}, v, {
          numericAxisId: n,
          cateAxisId: i,
          items: w.items,
          stackedData: yue(t, w.items, o)
        }));
      }, y);
    }
    return Lt(Lt({}, h), {}, ra({}, f, p));
  }, d);
}, wue = function(t, r) {
  var n = r.realScaleType, i = r.type, o = r.tickCount, s = r.originalDomain, a = r.allowDecimals, l = n || r.scale;
  if (l !== "auto" && l !== "linear")
    return null;
  if (o && i === "number" && s && (s[0] === "auto" || s[1] === "auto")) {
    var u = t.domain();
    if (!u.length)
      return null;
    var d = Dce(u, o, a);
    return t.domain([wg(d), io(d)]), {
      niceTicks: d
    };
  }
  if (o && i === "number") {
    var h = t.domain(), f = Oce(h, o, a);
    return {
      niceTicks: f
    };
  }
  return null;
};
function ma(e) {
  var t = e.axis, r = e.ticks, n = e.bandSize, i = e.entry, o = e.index, s = e.dataKey;
  if (t.type === "category") {
    if (!t.allowDuplicatedCategory && t.dataKey && !_e(i[t.dataKey])) {
      var a = Bd(r, "value", i[t.dataKey]);
      if (a)
        return a.coordinate + n / 2;
    }
    return r[o] ? r[o].coordinate + n / 2 : null;
  }
  var l = Xt(i, _e(s) ? t.dataKey : s);
  return _e(l) ? null : t.scale(l);
}
var nx = function(t) {
  var r = t.axis, n = t.ticks, i = t.offset, o = t.bandSize, s = t.entry, a = t.index;
  if (r.type === "category")
    return n[a] ? n[a].coordinate + i : null;
  var l = Xt(s, r.dataKey, r.domain[a]);
  return _e(l) ? null : r.scale(l) - o / 2 + i;
}, bue = function(t) {
  var r = t.numericAxis, n = r.scale.domain();
  if (r.type === "number") {
    var i = Math.min(n[0], n[1]), o = Math.max(n[0], n[1]);
    return i <= 0 && o >= 0 ? 0 : o < 0 ? o : i;
  }
  return n[0];
}, Sue = function(t, r) {
  var n, i = (n = t.type) !== null && n !== void 0 && n.defaultProps ? Lt(Lt({}, t.type.defaultProps), t.props) : t.props, o = i.stackId;
  if (Jt(o)) {
    var s = r[o];
    if (s) {
      var a = s.items.indexOf(t);
      return a >= 0 ? s.stackedData[a] : null;
    }
  }
  return null;
}, xue = function(t) {
  return t.reduce(function(r, n) {
    return [wg(n.concat([r[0]]).filter(Ce)), io(n.concat([r[1]]).filter(Ce))];
  }, [1 / 0, -1 / 0]);
}, GM = function(t, r, n) {
  return Object.keys(t).reduce(function(i, o) {
    var s = t[o], a = s.stackedData, l = a.reduce(function(u, d) {
      var h = xue(d.slice(r, n + 1));
      return [Math.min(u[0], h[0]), Math.max(u[1], h[1])];
    }, [1 / 0, -1 / 0]);
    return [Math.min(l[0], i[0]), Math.max(l[1], i[1])];
  }, [1 / 0, -1 / 0]).map(function(i) {
    return i === 1 / 0 || i === -1 / 0 ? 0 : i;
  });
}, ix = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, ox = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Rv = function(t, r, n) {
  if (We(t))
    return t(r, n);
  if (!Array.isArray(t))
    return r;
  var i = [];
  if (Ce(t[0]))
    i[0] = n ? t[0] : Math.min(t[0], r[0]);
  else if (ix.test(t[0])) {
    var o = +ix.exec(t[0])[1];
    i[0] = r[0] - o;
  } else We(t[0]) ? i[0] = t[0](r[0]) : i[0] = r[0];
  if (Ce(t[1]))
    i[1] = n ? t[1] : Math.max(t[1], r[1]);
  else if (ox.test(t[1])) {
    var s = +ox.exec(t[1])[1];
    i[1] = r[1] + s;
  } else We(t[1]) ? i[1] = t[1](r[1]) : i[1] = r[1];
  return i;
}, fh = function(t, r, n) {
  if (t && t.scale && t.scale.bandwidth) {
    var i = t.scale.bandwidth();
    if (!n || i > 0)
      return i;
  }
  if (t && r && r.length >= 2) {
    for (var o = ky(r, function(h) {
      return h.coordinate;
    }), s = 1 / 0, a = 1, l = o.length; a < l; a++) {
      var u = o[a], d = o[a - 1];
      s = Math.min((u.coordinate || 0) - (d.coordinate || 0), s);
    }
    return s === 1 / 0 ? 0 : s;
  }
  return n ? void 0 : 0;
}, sx = function(t, r, n) {
  return !t || !t.length || hs(t, En(n, "type.defaultProps.domain")) ? r : t;
}, HM = function(t, r) {
  var n = t.type.defaultProps ? Lt(Lt({}, t.type.defaultProps), t.props) : t.props, i = n.dataKey, o = n.name, s = n.unit, a = n.formatter, l = n.tooltipType, u = n.chartType, d = n.hide;
  return Lt(Lt({}, Ne(t, !1)), {}, {
    dataKey: i,
    unit: s,
    formatter: a,
    name: o || i,
    color: aC(t),
    value: Xt(r, i),
    type: l,
    payload: r,
    chartType: u,
    hide: d
  });
};
function Rc(e) {
  "@babel/helpers - typeof";
  return Rc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rc(e);
}
function ax(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function lx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ax(Object(r), !0).forEach(function(n) {
      Rue(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ax(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Rue(e, t, r) {
  return t = Eue(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Eue(e) {
  var t = Pue(e, "string");
  return Rc(t) == "symbol" ? t : t + "";
}
function Pue(e, t) {
  if (Rc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Rc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var ph = Math.PI / 180, Aue = function(t) {
  return t * 180 / Math.PI;
}, sr = function(t, r, n, i) {
  return {
    x: t + Math.cos(-ph * i) * n,
    y: r + Math.sin(-ph * i) * n
  };
}, Fue = function(t, r) {
  var n = t.x, i = t.y, o = r.x, s = r.y;
  return Math.sqrt(Math.pow(n - o, 2) + Math.pow(i - s, 2));
}, Mue = function(t, r) {
  var n = t.x, i = t.y, o = r.cx, s = r.cy, a = Fue({
    x: n,
    y: i
  }, {
    x: o,
    y: s
  });
  if (a <= 0)
    return {
      radius: a
    };
  var l = (n - o) / a, u = Math.acos(l);
  return i > s && (u = 2 * Math.PI - u), {
    radius: a,
    angle: Aue(u),
    angleInRadian: u
  };
}, Tue = function(t) {
  var r = t.startAngle, n = t.endAngle, i = Math.floor(r / 360), o = Math.floor(n / 360), s = Math.min(i, o);
  return {
    startAngle: r - s * 360,
    endAngle: n - s * 360
  };
}, Due = function(t, r) {
  var n = r.startAngle, i = r.endAngle, o = Math.floor(n / 360), s = Math.floor(i / 360), a = Math.min(o, s);
  return t + a * 360;
}, cx = function(t, r) {
  var n = t.x, i = t.y, o = Mue({
    x: n,
    y: i
  }, r), s = o.radius, a = o.angle, l = r.innerRadius, u = r.outerRadius;
  if (s < l || s > u)
    return !1;
  if (s === 0)
    return !0;
  var d = Tue(r), h = d.startAngle, f = d.endAngle, p = a, y;
  if (h <= f) {
    for (; p > f; )
      p -= 360;
    for (; p < h; )
      p += 360;
    y = p >= h && p <= f;
  } else {
    for (; p > h; )
      p -= 360;
    for (; p < f; )
      p += 360;
    y = p >= f && p <= h;
  }
  return y ? lx(lx({}, r), {}, {
    radius: s,
    angle: Due(p, r)
  }) : null;
};
function Ec(e) {
  "@babel/helpers - typeof";
  return Ec = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ec(e);
}
var Oue = ["offset"];
function Iue(e) {
  return zue(e) || _ue(e) || Lue(e) || kue();
}
function kue() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Lue(e, t) {
  if (e) {
    if (typeof e == "string") return Ev(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Ev(e, t);
  }
}
function _ue(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function zue(e) {
  if (Array.isArray(e)) return Ev(e);
}
function Ev(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Nue(e, t) {
  if (e == null) return {};
  var r = Bue(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Bue(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function ux(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Yt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ux(Object(r), !0).forEach(function(n) {
      Gue(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ux(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Gue(e, t, r) {
  return t = Hue(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Hue(e) {
  var t = Wue(e, "string");
  return Ec(t) == "symbol" ? t : t + "";
}
function Wue(e, t) {
  if (Ec(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ec(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Pc() {
  return Pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Pc.apply(this, arguments);
}
var Vue = function(t) {
  var r = t.value, n = t.formatter, i = _e(t.children) ? r : t.children;
  return We(n) ? n(i) : i;
}, $ue = function(t, r) {
  var n = Gn(r - t), i = Math.min(Math.abs(r - t), 360);
  return n * i;
}, jue = function(t, r, n) {
  var i = t.position, o = t.viewBox, s = t.offset, a = t.className, l = o, u = l.cx, d = l.cy, h = l.innerRadius, f = l.outerRadius, p = l.startAngle, y = l.endAngle, C = l.clockWise, v = (h + f) / 2, w = $ue(p, y), R = w >= 0 ? 1 : -1, b, P;
  i === "insideStart" ? (b = p + R * s, P = C) : i === "insideEnd" ? (b = y - R * s, P = !C) : i === "end" && (b = y + R * s, P = C), P = w <= 0 ? P : !P;
  var S = sr(u, d, v, b), E = sr(u, d, v, b + (P ? 1 : -1) * 359), A = "M".concat(S.x, ",").concat(S.y, `
    A`).concat(v, ",").concat(v, ",0,1,").concat(P ? 0 : 1, `,
    `).concat(E.x, ",").concat(E.y), M = _e(t.id) ? Cs("recharts-radial-line-") : t.id;
  return /* @__PURE__ */ O.createElement("text", Pc({}, n, {
    dominantBaseline: "central",
    className: Ze("recharts-radial-bar-label", a)
  }), /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("path", {
    id: M,
    d: A
  })), /* @__PURE__ */ O.createElement("textPath", {
    xlinkHref: "#".concat(M)
  }, r));
}, Uue = function(t) {
  var r = t.viewBox, n = t.offset, i = t.position, o = r, s = o.cx, a = o.cy, l = o.innerRadius, u = o.outerRadius, d = o.startAngle, h = o.endAngle, f = (d + h) / 2;
  if (i === "outside") {
    var p = sr(s, a, u + n, f), y = p.x, C = p.y;
    return {
      x: y,
      y: C,
      textAnchor: y >= s ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (i === "center")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (i === "centerTop")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (i === "centerBottom")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var v = (l + u) / 2, w = sr(s, a, v, f), R = w.x, b = w.y;
  return {
    x: R,
    y: b,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, Kue = function(t) {
  var r = t.viewBox, n = t.parentViewBox, i = t.offset, o = t.position, s = r, a = s.x, l = s.y, u = s.width, d = s.height, h = d >= 0 ? 1 : -1, f = h * i, p = h > 0 ? "end" : "start", y = h > 0 ? "start" : "end", C = u >= 0 ? 1 : -1, v = C * i, w = C > 0 ? "end" : "start", R = C > 0 ? "start" : "end";
  if (o === "top") {
    var b = {
      x: a + u / 2,
      y: l - h * i,
      textAnchor: "middle",
      verticalAnchor: p
    };
    return Yt(Yt({}, b), n ? {
      height: Math.max(l - n.y, 0),
      width: u
    } : {});
  }
  if (o === "bottom") {
    var P = {
      x: a + u / 2,
      y: l + d + f,
      textAnchor: "middle",
      verticalAnchor: y
    };
    return Yt(Yt({}, P), n ? {
      height: Math.max(n.y + n.height - (l + d), 0),
      width: u
    } : {});
  }
  if (o === "left") {
    var S = {
      x: a - v,
      y: l + d / 2,
      textAnchor: w,
      verticalAnchor: "middle"
    };
    return Yt(Yt({}, S), n ? {
      width: Math.max(S.x - n.x, 0),
      height: d
    } : {});
  }
  if (o === "right") {
    var E = {
      x: a + u + v,
      y: l + d / 2,
      textAnchor: R,
      verticalAnchor: "middle"
    };
    return Yt(Yt({}, E), n ? {
      width: Math.max(n.x + n.width - E.x, 0),
      height: d
    } : {});
  }
  var A = n ? {
    width: u,
    height: d
  } : {};
  return o === "insideLeft" ? Yt({
    x: a + v,
    y: l + d / 2,
    textAnchor: R,
    verticalAnchor: "middle"
  }, A) : o === "insideRight" ? Yt({
    x: a + u - v,
    y: l + d / 2,
    textAnchor: w,
    verticalAnchor: "middle"
  }, A) : o === "insideTop" ? Yt({
    x: a + u / 2,
    y: l + f,
    textAnchor: "middle",
    verticalAnchor: y
  }, A) : o === "insideBottom" ? Yt({
    x: a + u / 2,
    y: l + d - f,
    textAnchor: "middle",
    verticalAnchor: p
  }, A) : o === "insideTopLeft" ? Yt({
    x: a + v,
    y: l + f,
    textAnchor: R,
    verticalAnchor: y
  }, A) : o === "insideTopRight" ? Yt({
    x: a + u - v,
    y: l + f,
    textAnchor: w,
    verticalAnchor: y
  }, A) : o === "insideBottomLeft" ? Yt({
    x: a + v,
    y: l + d - f,
    textAnchor: R,
    verticalAnchor: p
  }, A) : o === "insideBottomRight" ? Yt({
    x: a + u - v,
    y: l + d - f,
    textAnchor: w,
    verticalAnchor: p
  }, A) : Ua(o) && (Ce(o.x) || _m(o.x)) && (Ce(o.y) || _m(o.y)) ? Yt({
    x: a + ds(o.x, u),
    y: l + ds(o.y, d),
    textAnchor: "end",
    verticalAnchor: "end"
  }, A) : Yt({
    x: a + u / 2,
    y: l + d / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, A);
}, que = function(t) {
  return "cx" in t && Ce(t.cx);
};
function fr(e) {
  var t = e.offset, r = t === void 0 ? 5 : t, n = Nue(e, Oue), i = Yt({
    offset: r
  }, n), o = i.viewBox, s = i.position, a = i.value, l = i.children, u = i.content, d = i.className, h = d === void 0 ? "" : d, f = i.textBreakAll;
  if (!o || _e(a) && _e(l) && !/* @__PURE__ */ ri(u) && !We(u))
    return null;
  if (/* @__PURE__ */ ri(u))
    return /* @__PURE__ */ er(u, i);
  var p;
  if (We(u)) {
    if (p = /* @__PURE__ */ x0(u, i), /* @__PURE__ */ ri(p))
      return p;
  } else
    p = Vue(i);
  var y = que(o), C = Ne(i, !0);
  if (y && (s === "insideStart" || s === "insideEnd" || s === "end"))
    return jue(i, p, C);
  var v = y ? Uue(i) : Kue(i);
  return /* @__PURE__ */ O.createElement(eh, Pc({
    className: Ze("recharts-label", h)
  }, C, v, {
    breakAll: f
  }), p);
}
fr.displayName = "Label";
var WM = function(t) {
  var r = t.cx, n = t.cy, i = t.angle, o = t.startAngle, s = t.endAngle, a = t.r, l = t.radius, u = t.innerRadius, d = t.outerRadius, h = t.x, f = t.y, p = t.top, y = t.left, C = t.width, v = t.height, w = t.clockWise, R = t.labelViewBox;
  if (R)
    return R;
  if (Ce(C) && Ce(v)) {
    if (Ce(h) && Ce(f))
      return {
        x: h,
        y: f,
        width: C,
        height: v
      };
    if (Ce(p) && Ce(y))
      return {
        x: p,
        y,
        width: C,
        height: v
      };
  }
  return Ce(h) && Ce(f) ? {
    x: h,
    y: f,
    width: 0,
    height: 0
  } : Ce(r) && Ce(n) ? {
    cx: r,
    cy: n,
    startAngle: o || i || 0,
    endAngle: s || i || 0,
    innerRadius: u || 0,
    outerRadius: d || l || a || 0,
    clockWise: w
  } : t.viewBox ? t.viewBox : {};
}, Yue = function(t, r) {
  return t ? t === !0 ? /* @__PURE__ */ O.createElement(fr, {
    key: "label-implicit",
    viewBox: r
  }) : Jt(t) ? /* @__PURE__ */ O.createElement(fr, {
    key: "label-implicit",
    viewBox: r,
    value: t
  }) : /* @__PURE__ */ ri(t) ? t.type === fr ? /* @__PURE__ */ er(t, {
    key: "label-implicit",
    viewBox: r
  }) : /* @__PURE__ */ O.createElement(fr, {
    key: "label-implicit",
    content: t,
    viewBox: r
  }) : We(t) ? /* @__PURE__ */ O.createElement(fr, {
    key: "label-implicit",
    content: t,
    viewBox: r
  }) : Ua(t) ? /* @__PURE__ */ O.createElement(fr, Pc({
    viewBox: r
  }, t, {
    key: "label-implicit"
  })) : null : null;
}, Jue = function(t, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!t || !t.children && n && !t.label)
    return null;
  var i = t.children, o = WM(t), s = Wr(i, fr).map(function(l, u) {
    return /* @__PURE__ */ er(l, {
      viewBox: r || o,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(u)
    });
  });
  if (!n)
    return s;
  var a = Yue(t.label, r || o);
  return [a].concat(Iue(s));
};
fr.parseViewBox = WM;
fr.renderCallByParent = Jue;
function Xue(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var Que = Xue;
const Zue = /* @__PURE__ */ bt(Que);
function Ac(e) {
  "@babel/helpers - typeof";
  return Ac = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ac(e);
}
var ede = ["valueAccessor"], tde = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
function rde(e) {
  return sde(e) || ode(e) || ide(e) || nde();
}
function nde() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ide(e, t) {
  if (e) {
    if (typeof e == "string") return Pv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Pv(e, t);
  }
}
function ode(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function sde(e) {
  if (Array.isArray(e)) return Pv(e);
}
function Pv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function mh() {
  return mh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, mh.apply(this, arguments);
}
function dx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function hx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dx(Object(r), !0).forEach(function(n) {
      ade(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : dx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function ade(e, t, r) {
  return t = lde(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function lde(e) {
  var t = cde(e, "string");
  return Ac(t) == "symbol" ? t : t + "";
}
function cde(e, t) {
  if (Ac(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ac(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function gx(e, t) {
  if (e == null) return {};
  var r = ude(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function ude(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
var dde = function(t) {
  return Array.isArray(t.value) ? Zue(t.value) : t.value;
};
function oi(e) {
  var t = e.valueAccessor, r = t === void 0 ? dde : t, n = gx(e, ede), i = n.data, o = n.dataKey, s = n.clockWise, a = n.id, l = n.textBreakAll, u = gx(n, tde);
  return !i || !i.length ? null : /* @__PURE__ */ O.createElement(st, {
    className: "recharts-label-list"
  }, i.map(function(d, h) {
    var f = _e(o) ? r(d, h) : Xt(d && d.payload, o), p = _e(a) ? {} : {
      id: "".concat(a, "-").concat(h)
    };
    return /* @__PURE__ */ O.createElement(fr, mh({}, Ne(d, !0), u, p, {
      parentViewBox: d.parentViewBox,
      value: f,
      textBreakAll: l,
      viewBox: fr.parseViewBox(_e(s) ? d : hx(hx({}, d), {}, {
        clockWise: s
      })),
      key: "label-".concat(h),
      index: h
    }));
  }));
}
oi.displayName = "LabelList";
function hde(e, t) {
  return e ? e === !0 ? /* @__PURE__ */ O.createElement(oi, {
    key: "labelList-implicit",
    data: t
  }) : /* @__PURE__ */ O.isValidElement(e) || We(e) ? /* @__PURE__ */ O.createElement(oi, {
    key: "labelList-implicit",
    data: t,
    content: e
  }) : Ua(e) ? /* @__PURE__ */ O.createElement(oi, mh({
    data: t
  }, e, {
    key: "labelList-implicit"
  })) : null : null;
}
function gde(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!e || !e.children && r && !e.label)
    return null;
  var n = e.children, i = Wr(n, oi).map(function(s, a) {
    return /* @__PURE__ */ er(s, {
      data: t,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(a)
    });
  });
  if (!r)
    return i;
  var o = hde(e.label, t);
  return [o].concat(rde(i));
}
oi.renderCallByParent = gde;
function Fc(e) {
  "@babel/helpers - typeof";
  return Fc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fc(e);
}
function Av() {
  return Av = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Av.apply(this, arguments);
}
function fx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function px(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fx(Object(r), !0).forEach(function(n) {
      fde(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : fx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function fde(e, t, r) {
  return t = pde(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function pde(e) {
  var t = mde(e, "string");
  return Fc(t) == "symbol" ? t : t + "";
}
function mde(e, t) {
  if (Fc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Fc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var vde = function(t, r) {
  var n = Gn(r - t), i = Math.min(Math.abs(r - t), 359.999);
  return n * i;
}, id = function(t) {
  var r = t.cx, n = t.cy, i = t.radius, o = t.angle, s = t.sign, a = t.isExternal, l = t.cornerRadius, u = t.cornerIsExternal, d = l * (a ? 1 : -1) + i, h = Math.asin(l / d) / ph, f = u ? o : o + s * h, p = sr(r, n, d, f), y = sr(r, n, i, f), C = u ? o - s * h : o, v = sr(r, n, d * Math.cos(h * ph), C);
  return {
    center: p,
    circleTangency: y,
    lineTangency: v,
    theta: h
  };
}, VM = function(t) {
  var r = t.cx, n = t.cy, i = t.innerRadius, o = t.outerRadius, s = t.startAngle, a = t.endAngle, l = vde(s, a), u = s + l, d = sr(r, n, o, s), h = sr(r, n, o, u), f = "M ".concat(d.x, ",").concat(d.y, `
    A `).concat(o, ",").concat(o, `,0,
    `).concat(+(Math.abs(l) > 180), ",").concat(+(s > u), `,
    `).concat(h.x, ",").concat(h.y, `
  `);
  if (i > 0) {
    var p = sr(r, n, i, s), y = sr(r, n, i, u);
    f += "L ".concat(y.x, ",").concat(y.y, `
            A `).concat(i, ",").concat(i, `,0,
            `).concat(+(Math.abs(l) > 180), ",").concat(+(s <= u), `,
            `).concat(p.x, ",").concat(p.y, " Z");
  } else
    f += "L ".concat(r, ",").concat(n, " Z");
  return f;
}, yde = function(t) {
  var r = t.cx, n = t.cy, i = t.innerRadius, o = t.outerRadius, s = t.cornerRadius, a = t.forceCornerRadius, l = t.cornerIsExternal, u = t.startAngle, d = t.endAngle, h = Gn(d - u), f = id({
    cx: r,
    cy: n,
    radius: o,
    angle: u,
    sign: h,
    cornerRadius: s,
    cornerIsExternal: l
  }), p = f.circleTangency, y = f.lineTangency, C = f.theta, v = id({
    cx: r,
    cy: n,
    radius: o,
    angle: d,
    sign: -h,
    cornerRadius: s,
    cornerIsExternal: l
  }), w = v.circleTangency, R = v.lineTangency, b = v.theta, P = l ? Math.abs(u - d) : Math.abs(u - d) - C - b;
  if (P < 0)
    return a ? "M ".concat(y.x, ",").concat(y.y, `
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(s * 2, `,0
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(-s * 2, `,0
      `) : VM({
      cx: r,
      cy: n,
      innerRadius: i,
      outerRadius: o,
      startAngle: u,
      endAngle: d
    });
  var S = "M ".concat(y.x, ",").concat(y.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(h < 0), ",").concat(p.x, ",").concat(p.y, `
    A`).concat(o, ",").concat(o, ",0,").concat(+(P > 180), ",").concat(+(h < 0), ",").concat(w.x, ",").concat(w.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(h < 0), ",").concat(R.x, ",").concat(R.y, `
  `);
  if (i > 0) {
    var E = id({
      cx: r,
      cy: n,
      radius: i,
      angle: u,
      sign: h,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: l
    }), A = E.circleTangency, M = E.lineTangency, I = E.theta, z = id({
      cx: r,
      cy: n,
      radius: i,
      angle: d,
      sign: -h,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: l
    }), k = z.circleTangency, _ = z.lineTangency, q = z.theta, j = l ? Math.abs(u - d) : Math.abs(u - d) - I - q;
    if (j < 0 && s === 0)
      return "".concat(S, "L").concat(r, ",").concat(n, "Z");
    S += "L".concat(_.x, ",").concat(_.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(h < 0), ",").concat(k.x, ",").concat(k.y, `
      A`).concat(i, ",").concat(i, ",0,").concat(+(j > 180), ",").concat(+(h > 0), ",").concat(A.x, ",").concat(A.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(h < 0), ",").concat(M.x, ",").concat(M.y, "Z");
  } else
    S += "L".concat(r, ",").concat(n, "Z");
  return S;
}, Cde = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, $M = function(t) {
  var r = px(px({}, Cde), t), n = r.cx, i = r.cy, o = r.innerRadius, s = r.outerRadius, a = r.cornerRadius, l = r.forceCornerRadius, u = r.cornerIsExternal, d = r.startAngle, h = r.endAngle, f = r.className;
  if (s < o || d === h)
    return null;
  var p = Ze("recharts-sector", f), y = s - o, C = ds(a, y, 0, !0), v;
  return C > 0 && Math.abs(d - h) < 360 ? v = yde({
    cx: n,
    cy: i,
    innerRadius: o,
    outerRadius: s,
    cornerRadius: Math.min(C, y / 2),
    forceCornerRadius: l,
    cornerIsExternal: u,
    startAngle: d,
    endAngle: h
  }) : v = VM({
    cx: n,
    cy: i,
    innerRadius: o,
    outerRadius: s,
    startAngle: d,
    endAngle: h
  }), /* @__PURE__ */ O.createElement("path", Av({}, Ne(r, !0), {
    className: p,
    d: v,
    role: "img"
  }));
};
function Mc(e) {
  "@babel/helpers - typeof";
  return Mc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mc(e);
}
function Fv() {
  return Fv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Fv.apply(this, arguments);
}
function mx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function vx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mx(Object(r), !0).forEach(function(n) {
      wde(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : mx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function wde(e, t, r) {
  return t = bde(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function bde(e) {
  var t = Sde(e, "string");
  return Mc(t) == "symbol" ? t : t + "";
}
function Sde(e, t) {
  if (Mc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Mc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var yx = {
  curveBasisClosed: PJ,
  curveBasisOpen: AJ,
  curveBasis: EJ,
  curveBumpX: dJ,
  curveBumpY: hJ,
  curveLinearClosed: FJ,
  curveLinear: lg,
  curveMonotoneX: MJ,
  curveMonotoneY: TJ,
  curveNatural: DJ,
  curveStep: OJ,
  curveStepAfter: kJ,
  curveStepBefore: IJ
}, od = function(t) {
  return t.x === +t.x && t.y === +t.y;
}, Ol = function(t) {
  return t.x;
}, Il = function(t) {
  return t.y;
}, xde = function(t, r) {
  if (We(t))
    return t;
  var n = "curve".concat(sg(t));
  return (n === "curveMonotone" || n === "curveBump") && r ? yx["".concat(n).concat(r === "vertical" ? "Y" : "X")] : yx[n] || lg;
}, Rde = function(t) {
  var r = t.type, n = r === void 0 ? "linear" : r, i = t.points, o = i === void 0 ? [] : i, s = t.baseLine, a = t.layout, l = t.connectNulls, u = l === void 0 ? !1 : l, d = xde(n, a), h = u ? o.filter(function(C) {
    return od(C);
  }) : o, f;
  if (Array.isArray(s)) {
    var p = u ? s.filter(function(C) {
      return od(C);
    }) : s, y = h.map(function(C, v) {
      return vx(vx({}, C), {}, {
        base: p[v]
      });
    });
    return a === "vertical" ? f = Ju().y(Il).x1(Ol).x0(function(C) {
      return C.base.x;
    }) : f = Ju().x(Ol).y1(Il).y0(function(C) {
      return C.base.y;
    }), f.defined(od).curve(d), f(y);
  }
  return a === "vertical" && Ce(s) ? f = Ju().y(Il).x1(Ol).x0(s) : Ce(s) ? f = Ju().x(Ol).y1(Il).y0(s) : f = qA().x(Ol).y(Il), f.defined(od).curve(d), f(h);
}, os = function(t) {
  var r = t.className, n = t.points, i = t.path, o = t.pathRef;
  if ((!n || !n.length) && !i)
    return null;
  var s = n && n.length ? Rde(t) : i;
  return /* @__PURE__ */ O.createElement("path", Fv({}, Ne(t, !1), Gd(t), {
    className: Ze("recharts-curve", r),
    d: s,
    ref: o
  }));
}, Mv = { exports: {} }, sd = { exports: {} }, ut = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cx;
function Ede() {
  if (Cx) return ut;
  Cx = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, C = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, R = e ? Symbol.for("react.scope") : 60119;
  function b(S) {
    if (typeof S == "object" && S !== null) {
      var E = S.$$typeof;
      switch (E) {
        case t:
          switch (S = S.type, S) {
            case l:
            case u:
            case n:
            case o:
            case i:
            case h:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case a:
                case d:
                case y:
                case p:
                case s:
                  return S;
                default:
                  return E;
              }
          }
        case r:
          return E;
      }
    }
  }
  function P(S) {
    return b(S) === u;
  }
  return ut.AsyncMode = l, ut.ConcurrentMode = u, ut.ContextConsumer = a, ut.ContextProvider = s, ut.Element = t, ut.ForwardRef = d, ut.Fragment = n, ut.Lazy = y, ut.Memo = p, ut.Portal = r, ut.Profiler = o, ut.StrictMode = i, ut.Suspense = h, ut.isAsyncMode = function(S) {
    return P(S) || b(S) === l;
  }, ut.isConcurrentMode = P, ut.isContextConsumer = function(S) {
    return b(S) === a;
  }, ut.isContextProvider = function(S) {
    return b(S) === s;
  }, ut.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === t;
  }, ut.isForwardRef = function(S) {
    return b(S) === d;
  }, ut.isFragment = function(S) {
    return b(S) === n;
  }, ut.isLazy = function(S) {
    return b(S) === y;
  }, ut.isMemo = function(S) {
    return b(S) === p;
  }, ut.isPortal = function(S) {
    return b(S) === r;
  }, ut.isProfiler = function(S) {
    return b(S) === o;
  }, ut.isStrictMode = function(S) {
    return b(S) === i;
  }, ut.isSuspense = function(S) {
    return b(S) === h;
  }, ut.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === n || S === u || S === o || S === i || S === h || S === f || typeof S == "object" && S !== null && (S.$$typeof === y || S.$$typeof === p || S.$$typeof === s || S.$$typeof === a || S.$$typeof === d || S.$$typeof === v || S.$$typeof === w || S.$$typeof === R || S.$$typeof === C);
  }, ut.typeOf = b, ut;
}
var dt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wx;
function Pde() {
  return wx || (wx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, C = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, R = e ? Symbol.for("react.scope") : 60119;
    function b(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === n || B === u || B === o || B === i || B === h || B === f || typeof B == "object" && B !== null && (B.$$typeof === y || B.$$typeof === p || B.$$typeof === s || B.$$typeof === a || B.$$typeof === d || B.$$typeof === v || B.$$typeof === w || B.$$typeof === R || B.$$typeof === C);
    }
    function P(B) {
      if (typeof B == "object" && B !== null) {
        var Ae = B.$$typeof;
        switch (Ae) {
          case t:
            var oe = B.type;
            switch (oe) {
              case l:
              case u:
              case n:
              case o:
              case i:
              case h:
                return oe;
              default:
                var Me = oe && oe.$$typeof;
                switch (Me) {
                  case a:
                  case d:
                  case y:
                  case p:
                  case s:
                    return Me;
                  default:
                    return Ae;
                }
            }
          case r:
            return Ae;
        }
      }
    }
    var S = l, E = u, A = a, M = s, I = t, z = d, k = n, _ = y, q = p, j = r, Q = o, K = i, Z = h, te = !1;
    function se(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), W(B) || P(B) === l;
    }
    function W(B) {
      return P(B) === u;
    }
    function U(B) {
      return P(B) === a;
    }
    function X(B) {
      return P(B) === s;
    }
    function he(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function ce(B) {
      return P(B) === d;
    }
    function me(B) {
      return P(B) === n;
    }
    function ve(B) {
      return P(B) === y;
    }
    function Pe(B) {
      return P(B) === p;
    }
    function Re(B) {
      return P(B) === r;
    }
    function ee(B) {
      return P(B) === o;
    }
    function fe(B) {
      return P(B) === i;
    }
    function ye(B) {
      return P(B) === h;
    }
    dt.AsyncMode = S, dt.ConcurrentMode = E, dt.ContextConsumer = A, dt.ContextProvider = M, dt.Element = I, dt.ForwardRef = z, dt.Fragment = k, dt.Lazy = _, dt.Memo = q, dt.Portal = j, dt.Profiler = Q, dt.StrictMode = K, dt.Suspense = Z, dt.isAsyncMode = se, dt.isConcurrentMode = W, dt.isContextConsumer = U, dt.isContextProvider = X, dt.isElement = he, dt.isForwardRef = ce, dt.isFragment = me, dt.isLazy = ve, dt.isMemo = Pe, dt.isPortal = Re, dt.isProfiler = ee, dt.isStrictMode = fe, dt.isSuspense = ye, dt.isValidElementType = b, dt.typeOf = P;
  }()), dt;
}
var bx;
function jM() {
  return bx || (bx = 1, process.env.NODE_ENV === "production" ? sd.exports = Ede() : sd.exports = Pde()), sd.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var qp, Sx;
function Ade() {
  if (Sx) return qp;
  Sx = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(d) {
        return s[d];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        u[d] = d;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return qp = i() ? Object.assign : function(o, s) {
    for (var a, l = n(o), u, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var h in a)
        t.call(a, h) && (l[h] = a[h]);
      if (e) {
        u = e(a);
        for (var f = 0; f < u.length; f++)
          r.call(a, u[f]) && (l[u[f]] = a[u[f]]);
      }
    }
    return l;
  }, qp;
}
var Yp, xx;
function lC() {
  if (xx) return Yp;
  xx = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Yp = e, Yp;
}
var Jp, Rx;
function UM() {
  return Rx || (Rx = 1, Jp = Function.call.bind(Object.prototype.hasOwnProperty)), Jp;
}
var Xp, Ex;
function Fde() {
  if (Ex) return Xp;
  Ex = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = lC(), r = {}, n = UM();
    e = function(o) {
      var s = "Warning: " + o;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function i(o, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in o)
        if (n(o, d)) {
          var h;
          try {
            if (typeof o[d] != "function") {
              var f = Error(
                (l || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            h = o[d](s, d, l, a, null, t);
          } catch (y) {
            h = y;
          }
          if (h && !(h instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof h + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), h instanceof Error && !(h.message in r)) {
            r[h.message] = !0;
            var p = u ? u() : "";
            e(
              "Failed " + a + " type: " + h.message + (p ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, Xp = i, Xp;
}
var Qp, Px;
function Mde() {
  if (Px) return Qp;
  Px = 1;
  var e = jM(), t = Ade(), r = lC(), n = UM(), i = Fde(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Qp = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function h(W) {
      var U = W && (u && W[u] || W[d]);
      if (typeof U == "function")
        return U;
    }
    var f = "<<anonymous>>", p = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: R(),
      arrayOf: b,
      element: P(),
      elementType: S(),
      instanceOf: E,
      node: z(),
      objectOf: M,
      oneOf: A,
      oneOfType: I,
      shape: _,
      exact: q
    };
    function y(W, U) {
      return W === U ? W !== 0 || 1 / W === 1 / U : W !== W && U !== U;
    }
    function C(W, U) {
      this.message = W, this.data = U && typeof U == "object" ? U : {}, this.stack = "";
    }
    C.prototype = Error.prototype;
    function v(W) {
      if (process.env.NODE_ENV !== "production")
        var U = {}, X = 0;
      function he(me, ve, Pe, Re, ee, fe, ye) {
        if (Re = Re || f, fe = fe || Pe, ye !== r) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ae = Re + ":" + Pe;
            !U[Ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            X < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + fe + "` prop on `" + Re + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), U[Ae] = !0, X++);
          }
        }
        return ve[Pe] == null ? me ? ve[Pe] === null ? new C("The " + ee + " `" + fe + "` is marked as required " + ("in `" + Re + "`, but its value is `null`.")) : new C("The " + ee + " `" + fe + "` is marked as required in " + ("`" + Re + "`, but its value is `undefined`.")) : null : W(ve, Pe, Re, ee, fe);
      }
      var ce = he.bind(null, !1);
      return ce.isRequired = he.bind(null, !0), ce;
    }
    function w(W) {
      function U(X, he, ce, me, ve, Pe) {
        var Re = X[he], ee = K(Re);
        if (ee !== W) {
          var fe = Z(Re);
          return new C(
            "Invalid " + me + " `" + ve + "` of type " + ("`" + fe + "` supplied to `" + ce + "`, expected ") + ("`" + W + "`."),
            { expectedType: W }
          );
        }
        return null;
      }
      return v(U);
    }
    function R() {
      return v(s);
    }
    function b(W) {
      function U(X, he, ce, me, ve) {
        if (typeof W != "function")
          return new C("Property `" + ve + "` of component `" + ce + "` has invalid PropType notation inside arrayOf.");
        var Pe = X[he];
        if (!Array.isArray(Pe)) {
          var Re = K(Pe);
          return new C("Invalid " + me + " `" + ve + "` of type " + ("`" + Re + "` supplied to `" + ce + "`, expected an array."));
        }
        for (var ee = 0; ee < Pe.length; ee++) {
          var fe = W(Pe, ee, ce, me, ve + "[" + ee + "]", r);
          if (fe instanceof Error)
            return fe;
        }
        return null;
      }
      return v(U);
    }
    function P() {
      function W(U, X, he, ce, me) {
        var ve = U[X];
        if (!a(ve)) {
          var Pe = K(ve);
          return new C("Invalid " + ce + " `" + me + "` of type " + ("`" + Pe + "` supplied to `" + he + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(W);
    }
    function S() {
      function W(U, X, he, ce, me) {
        var ve = U[X];
        if (!e.isValidElementType(ve)) {
          var Pe = K(ve);
          return new C("Invalid " + ce + " `" + me + "` of type " + ("`" + Pe + "` supplied to `" + he + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(W);
    }
    function E(W) {
      function U(X, he, ce, me, ve) {
        if (!(X[he] instanceof W)) {
          var Pe = W.name || f, Re = se(X[he]);
          return new C("Invalid " + me + " `" + ve + "` of type " + ("`" + Re + "` supplied to `" + ce + "`, expected ") + ("instance of `" + Pe + "`."));
        }
        return null;
      }
      return v(U);
    }
    function A(W) {
      if (!Array.isArray(W))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
      function U(X, he, ce, me, ve) {
        for (var Pe = X[he], Re = 0; Re < W.length; Re++)
          if (y(Pe, W[Re]))
            return null;
        var ee = JSON.stringify(W, function(ye, B) {
          var Ae = Z(B);
          return Ae === "symbol" ? String(B) : B;
        });
        return new C("Invalid " + me + " `" + ve + "` of value `" + String(Pe) + "` " + ("supplied to `" + ce + "`, expected one of " + ee + "."));
      }
      return v(U);
    }
    function M(W) {
      function U(X, he, ce, me, ve) {
        if (typeof W != "function")
          return new C("Property `" + ve + "` of component `" + ce + "` has invalid PropType notation inside objectOf.");
        var Pe = X[he], Re = K(Pe);
        if (Re !== "object")
          return new C("Invalid " + me + " `" + ve + "` of type " + ("`" + Re + "` supplied to `" + ce + "`, expected an object."));
        for (var ee in Pe)
          if (n(Pe, ee)) {
            var fe = W(Pe, ee, ce, me, ve + "." + ee, r);
            if (fe instanceof Error)
              return fe;
          }
        return null;
      }
      return v(U);
    }
    function I(W) {
      if (!Array.isArray(W))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var U = 0; U < W.length; U++) {
        var X = W[U];
        if (typeof X != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(X) + " at index " + U + "."
          ), s;
      }
      function he(ce, me, ve, Pe, Re) {
        for (var ee = [], fe = 0; fe < W.length; fe++) {
          var ye = W[fe], B = ye(ce, me, ve, Pe, Re, r);
          if (B == null)
            return null;
          B.data && n(B.data, "expectedType") && ee.push(B.data.expectedType);
        }
        var Ae = ee.length > 0 ? ", expected one of type [" + ee.join(", ") + "]" : "";
        return new C("Invalid " + Pe + " `" + Re + "` supplied to " + ("`" + ve + "`" + Ae + "."));
      }
      return v(he);
    }
    function z() {
      function W(U, X, he, ce, me) {
        return j(U[X]) ? null : new C("Invalid " + ce + " `" + me + "` supplied to " + ("`" + he + "`, expected a ReactNode."));
      }
      return v(W);
    }
    function k(W, U, X, he, ce) {
      return new C(
        (W || "React class") + ": " + U + " type `" + X + "." + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ce + "`."
      );
    }
    function _(W) {
      function U(X, he, ce, me, ve) {
        var Pe = X[he], Re = K(Pe);
        if (Re !== "object")
          return new C("Invalid " + me + " `" + ve + "` of type `" + Re + "` " + ("supplied to `" + ce + "`, expected `object`."));
        for (var ee in W) {
          var fe = W[ee];
          if (typeof fe != "function")
            return k(ce, me, ve, ee, Z(fe));
          var ye = fe(Pe, ee, ce, me, ve + "." + ee, r);
          if (ye)
            return ye;
        }
        return null;
      }
      return v(U);
    }
    function q(W) {
      function U(X, he, ce, me, ve) {
        var Pe = X[he], Re = K(Pe);
        if (Re !== "object")
          return new C("Invalid " + me + " `" + ve + "` of type `" + Re + "` " + ("supplied to `" + ce + "`, expected `object`."));
        var ee = t({}, X[he], W);
        for (var fe in ee) {
          var ye = W[fe];
          if (n(W, fe) && typeof ye != "function")
            return k(ce, me, ve, fe, Z(ye));
          if (!ye)
            return new C(
              "Invalid " + me + " `" + ve + "` key `" + fe + "` supplied to `" + ce + "`.\nBad object: " + JSON.stringify(X[he], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(W), null, "  ")
            );
          var B = ye(Pe, fe, ce, me, ve + "." + fe, r);
          if (B)
            return B;
        }
        return null;
      }
      return v(U);
    }
    function j(W) {
      switch (typeof W) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !W;
        case "object":
          if (Array.isArray(W))
            return W.every(j);
          if (W === null || a(W))
            return !0;
          var U = h(W);
          if (U) {
            var X = U.call(W), he;
            if (U !== W.entries) {
              for (; !(he = X.next()).done; )
                if (!j(he.value))
                  return !1;
            } else
              for (; !(he = X.next()).done; ) {
                var ce = he.value;
                if (ce && !j(ce[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Q(W, U) {
      return W === "symbol" ? !0 : U ? U["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && U instanceof Symbol : !1;
    }
    function K(W) {
      var U = typeof W;
      return Array.isArray(W) ? "array" : W instanceof RegExp ? "object" : Q(U, W) ? "symbol" : U;
    }
    function Z(W) {
      if (typeof W > "u" || W === null)
        return "" + W;
      var U = K(W);
      if (U === "object") {
        if (W instanceof Date)
          return "date";
        if (W instanceof RegExp)
          return "regexp";
      }
      return U;
    }
    function te(W) {
      var U = Z(W);
      switch (U) {
        case "array":
        case "object":
          return "an " + U;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + U;
        default:
          return U;
      }
    }
    function se(W) {
      return !W.constructor || !W.constructor.name ? f : W.constructor.name;
    }
    return p.checkPropTypes = i, p.resetWarningCache = i.resetWarningCache, p.PropTypes = p, p;
  }, Qp;
}
var Zp, Ax;
function Tde() {
  if (Ax) return Zp;
  Ax = 1;
  var e = lC();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, Zp = function() {
    function n(s, a, l, u, d, h) {
      if (h !== e) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var o = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, Zp;
}
if (process.env.NODE_ENV !== "production") {
  var Dde = jM(), Ode = !0;
  Mv.exports = Mde()(Dde.isElement, Ode);
} else
  Mv.exports = Tde()();
var Ide = Mv.exports;
const ht = /* @__PURE__ */ bt(Ide);
var kde = Object.getOwnPropertyNames, Lde = Object.getOwnPropertySymbols, _de = Object.prototype.hasOwnProperty;
function Fx(e, t) {
  return function(n, i, o) {
    return e(n, i, o) && t(n, i, o);
  };
}
function ad(e) {
  return function(r, n, i) {
    if (!r || !n || typeof r != "object" || typeof n != "object")
      return e(r, n, i);
    var o = i.cache, s = o.get(r), a = o.get(n);
    if (s && a)
      return s === n && a === r;
    o.set(r, n), o.set(n, r);
    var l = e(r, n, i);
    return o.delete(r), o.delete(n), l;
  };
}
function Mx(e) {
  return kde(e).concat(Lde(e));
}
var zde = Object.hasOwn || function(e, t) {
  return _de.call(e, t);
};
function Ss(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
var Nde = "__v", Bde = "__o", Gde = "_owner", Tx = Object.getOwnPropertyDescriptor, Dx = Object.keys;
function Hde(e, t, r) {
  var n = e.length;
  if (t.length !== n)
    return !1;
  for (; n-- > 0; )
    if (!r.equals(e[n], t[n], n, n, e, t, r))
      return !1;
  return !0;
}
function Wde(e, t) {
  return Ss(e.getTime(), t.getTime());
}
function Vde(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function $de(e, t) {
  return e === t;
}
function Ox(e, t, r) {
  var n = e.size;
  if (n !== t.size)
    return !1;
  if (!n)
    return !0;
  for (var i = new Array(n), o = e.entries(), s, a, l = 0; (s = o.next()) && !s.done; ) {
    for (var u = t.entries(), d = !1, h = 0; (a = u.next()) && !a.done; ) {
      if (i[h]) {
        h++;
        continue;
      }
      var f = s.value, p = a.value;
      if (r.equals(f[0], p[0], l, h, e, t, r) && r.equals(f[1], p[1], f[0], p[0], e, t, r)) {
        d = i[h] = !0;
        break;
      }
      h++;
    }
    if (!d)
      return !1;
    l++;
  }
  return !0;
}
var jde = Ss;
function Ude(e, t, r) {
  var n = Dx(e), i = n.length;
  if (Dx(t).length !== i)
    return !1;
  for (; i-- > 0; )
    if (!KM(e, t, r, n[i]))
      return !1;
  return !0;
}
function kl(e, t, r) {
  var n = Mx(e), i = n.length;
  if (Mx(t).length !== i)
    return !1;
  for (var o, s, a; i-- > 0; )
    if (o = n[i], !KM(e, t, r, o) || (s = Tx(e, o), a = Tx(t, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function Kde(e, t) {
  return Ss(e.valueOf(), t.valueOf());
}
function qde(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function Ix(e, t, r) {
  var n = e.size;
  if (n !== t.size)
    return !1;
  if (!n)
    return !0;
  for (var i = new Array(n), o = e.values(), s, a; (s = o.next()) && !s.done; ) {
    for (var l = t.values(), u = !1, d = 0; (a = l.next()) && !a.done; ) {
      if (!i[d] && r.equals(s.value, a.value, s.value, a.value, e, t, r)) {
        u = i[d] = !0;
        break;
      }
      d++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function Yde(e, t) {
  var r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Jde(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function KM(e, t, r, n) {
  return (n === Gde || n === Bde || n === Nde) && (e.$$typeof || t.$$typeof) ? !0 : zde(t, n) && r.equals(e[n], t[n], n, n, e, t, r);
}
var Xde = "[object Arguments]", Qde = "[object Boolean]", Zde = "[object Date]", ehe = "[object Error]", the = "[object Map]", rhe = "[object Number]", nhe = "[object Object]", ihe = "[object RegExp]", ohe = "[object Set]", she = "[object String]", ahe = "[object URL]", lhe = Array.isArray, kx = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, Lx = Object.assign, che = Object.prototype.toString.call.bind(Object.prototype.toString);
function uhe(e) {
  var t = e.areArraysEqual, r = e.areDatesEqual, n = e.areErrorsEqual, i = e.areFunctionsEqual, o = e.areMapsEqual, s = e.areNumbersEqual, a = e.areObjectsEqual, l = e.arePrimitiveWrappersEqual, u = e.areRegExpsEqual, d = e.areSetsEqual, h = e.areTypedArraysEqual, f = e.areUrlsEqual;
  return function(y, C, v) {
    if (y === C)
      return !0;
    if (y == null || C == null)
      return !1;
    var w = typeof y;
    if (w !== typeof C)
      return !1;
    if (w !== "object")
      return w === "number" ? s(y, C, v) : w === "function" ? i(y, C, v) : !1;
    var R = y.constructor;
    if (R !== C.constructor)
      return !1;
    if (R === Object)
      return a(y, C, v);
    if (lhe(y))
      return t(y, C, v);
    if (kx != null && kx(y))
      return h(y, C, v);
    if (R === Date)
      return r(y, C, v);
    if (R === RegExp)
      return u(y, C, v);
    if (R === Map)
      return o(y, C, v);
    if (R === Set)
      return d(y, C, v);
    var b = che(y);
    return b === Zde ? r(y, C, v) : b === ihe ? u(y, C, v) : b === the ? o(y, C, v) : b === ohe ? d(y, C, v) : b === nhe ? typeof y.then != "function" && typeof C.then != "function" && a(y, C, v) : b === ahe ? f(y, C, v) : b === ehe ? n(y, C, v) : b === Xde ? a(y, C, v) : b === Qde || b === rhe || b === she ? l(y, C, v) : !1;
  };
}
function dhe(e) {
  var t = e.circular, r = e.createCustomConfig, n = e.strict, i = {
    areArraysEqual: n ? kl : Hde,
    areDatesEqual: Wde,
    areErrorsEqual: Vde,
    areFunctionsEqual: $de,
    areMapsEqual: n ? Fx(Ox, kl) : Ox,
    areNumbersEqual: jde,
    areObjectsEqual: n ? kl : Ude,
    arePrimitiveWrappersEqual: Kde,
    areRegExpsEqual: qde,
    areSetsEqual: n ? Fx(Ix, kl) : Ix,
    areTypedArraysEqual: n ? kl : Yde,
    areUrlsEqual: Jde
  };
  if (r && (i = Lx({}, i, r(i))), t) {
    var o = ad(i.areArraysEqual), s = ad(i.areMapsEqual), a = ad(i.areObjectsEqual), l = ad(i.areSetsEqual);
    i = Lx({}, i, {
      areArraysEqual: o,
      areMapsEqual: s,
      areObjectsEqual: a,
      areSetsEqual: l
    });
  }
  return i;
}
function hhe(e) {
  return function(t, r, n, i, o, s, a) {
    return e(t, r, a);
  };
}
function ghe(e) {
  var t = e.circular, r = e.comparator, n = e.createState, i = e.equals, o = e.strict;
  if (n)
    return function(l, u) {
      var d = n(), h = d.cache, f = h === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : h, p = d.meta;
      return r(l, u, {
        cache: f,
        equals: i,
        meta: p,
        strict: o
      });
    };
  if (t)
    return function(l, u) {
      return r(l, u, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: i,
        meta: void 0,
        strict: o
      });
    };
  var s = {
    cache: void 0,
    equals: i,
    meta: void 0,
    strict: o
  };
  return function(l, u) {
    return r(l, u, s);
  };
}
var fhe = Eo();
Eo({ strict: !0 });
Eo({ circular: !0 });
Eo({
  circular: !0,
  strict: !0
});
Eo({
  createInternalComparator: function() {
    return Ss;
  }
});
Eo({
  strict: !0,
  createInternalComparator: function() {
    return Ss;
  }
});
Eo({
  circular: !0,
  createInternalComparator: function() {
    return Ss;
  }
});
Eo({
  circular: !0,
  createInternalComparator: function() {
    return Ss;
  },
  strict: !0
});
function Eo(e) {
  e === void 0 && (e = {});
  var t = e.circular, r = t === void 0 ? !1 : t, n = e.createInternalComparator, i = e.createState, o = e.strict, s = o === void 0 ? !1 : o, a = dhe(e), l = uhe(a), u = n ? n(l) : hhe(l);
  return ghe({ circular: r, comparator: l, createState: i, equals: u, strict: s });
}
function phe(e) {
  typeof requestAnimationFrame < "u" && requestAnimationFrame(e);
}
function _x(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = -1, n = function i(o) {
    r < 0 && (r = o), o - r > t ? (e(o), r = -1) : phe(i);
  };
  requestAnimationFrame(n);
}
function Tv(e) {
  "@babel/helpers - typeof";
  return Tv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Tv(e);
}
function mhe(e) {
  return whe(e) || Che(e) || yhe(e) || vhe();
}
function vhe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yhe(e, t) {
  if (e) {
    if (typeof e == "string") return zx(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return zx(e, t);
  }
}
function zx(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Che(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function whe(e) {
  if (Array.isArray(e)) return e;
}
function bhe() {
  var e = {}, t = function() {
    return null;
  }, r = !1, n = function i(o) {
    if (!r) {
      if (Array.isArray(o)) {
        if (!o.length)
          return;
        var s = o, a = mhe(s), l = a[0], u = a.slice(1);
        if (typeof l == "number") {
          _x(i.bind(null, u), l);
          return;
        }
        i(l), _x(i.bind(null, u));
        return;
      }
      Tv(o) === "object" && (e = o, t(e)), typeof o == "function" && o();
    }
  };
  return {
    stop: function() {
      r = !0;
    },
    start: function(o) {
      r = !1, n(o);
    },
    subscribe: function(o) {
      return t = o, function() {
        t = function() {
          return null;
        };
      };
    }
  };
}
function Tc(e) {
  "@babel/helpers - typeof";
  return Tc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Tc(e);
}
function Nx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Bx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nx(Object(r), !0).forEach(function(n) {
      qM(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Nx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function qM(e, t, r) {
  return t = She(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function She(e) {
  var t = xhe(e, "string");
  return Tc(t) === "symbol" ? t : String(t);
}
function xhe(e, t) {
  if (Tc(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Tc(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Rhe = function(t, r) {
  return [Object.keys(t), Object.keys(r)].reduce(function(n, i) {
    return n.filter(function(o) {
      return i.includes(o);
    });
  });
}, Ehe = function(t) {
  return t;
}, Phe = function(t) {
  return t.replace(/([A-Z])/g, function(r) {
    return "-".concat(r.toLowerCase());
  });
}, Jl = function(t, r) {
  return Object.keys(r).reduce(function(n, i) {
    return Bx(Bx({}, n), {}, qM({}, i, t(i, r[i])));
  }, {});
}, Gx = function(t, r, n) {
  return t.map(function(i) {
    return "".concat(Phe(i), " ").concat(r, "ms ").concat(n);
  }).join(",");
}, Ahe = process.env.NODE_ENV !== "production", vh = function(t, r, n, i, o, s, a, l) {
  if (Ahe && typeof console < "u" && console.warn && (r === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (r === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var u = [n, i, o, s, a, l], d = 0;
      console.warn(r.replace(/%s/g, function() {
        return u[d++];
      }));
    }
};
function Fhe(e, t) {
  return Dhe(e) || The(e, t) || YM(e, t) || Mhe();
}
function Mhe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function The(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Dhe(e) {
  if (Array.isArray(e)) return e;
}
function Ohe(e) {
  return Lhe(e) || khe(e) || YM(e) || Ihe();
}
function Ihe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function YM(e, t) {
  if (e) {
    if (typeof e == "string") return Dv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Dv(e, t);
  }
}
function khe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Lhe(e) {
  if (Array.isArray(e)) return Dv(e);
}
function Dv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
var yh = 1e-4, JM = function(t, r) {
  return [0, 3 * t, 3 * r - 6 * t, 3 * t - 3 * r + 1];
}, XM = function(t, r) {
  return t.map(function(n, i) {
    return n * Math.pow(r, i);
  }).reduce(function(n, i) {
    return n + i;
  });
}, Hx = function(t, r) {
  return function(n) {
    var i = JM(t, r);
    return XM(i, n);
  };
}, _he = function(t, r) {
  return function(n) {
    var i = JM(t, r), o = [].concat(Ohe(i.map(function(s, a) {
      return s * a;
    }).slice(1)), [0]);
    return XM(o, n);
  };
}, Wx = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  var i = r[0], o = r[1], s = r[2], a = r[3];
  if (r.length === 1)
    switch (r[0]) {
      case "linear":
        i = 0, o = 0, s = 1, a = 1;
        break;
      case "ease":
        i = 0.25, o = 0.1, s = 0.25, a = 1;
        break;
      case "ease-in":
        i = 0.42, o = 0, s = 1, a = 1;
        break;
      case "ease-out":
        i = 0.42, o = 0, s = 0.58, a = 1;
        break;
      case "ease-in-out":
        i = 0, o = 0, s = 0.58, a = 1;
        break;
      default: {
        var l = r[0].split("(");
        if (l[0] === "cubic-bezier" && l[1].split(")")[0].split(",").length === 4) {
          var u = l[1].split(")")[0].split(",").map(function(v) {
            return parseFloat(v);
          }), d = Fhe(u, 4);
          i = d[0], o = d[1], s = d[2], a = d[3];
        } else
          vh(!1, "[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", r);
      }
    }
  vh([i, s, o, a].every(function(v) {
    return typeof v == "number" && v >= 0 && v <= 1;
  }), "[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s", r);
  var h = Hx(i, s), f = Hx(o, a), p = _he(i, s), y = function(w) {
    return w > 1 ? 1 : w < 0 ? 0 : w;
  }, C = function(w) {
    for (var R = w > 1 ? 1 : w, b = R, P = 0; P < 8; ++P) {
      var S = h(b) - R, E = p(b);
      if (Math.abs(S - R) < yh || E < yh)
        return f(b);
      b = y(b - S / E);
    }
    return f(b);
  };
  return C.isStepper = !1, C;
}, zhe = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = t.stiff, n = r === void 0 ? 100 : r, i = t.damping, o = i === void 0 ? 8 : i, s = t.dt, a = s === void 0 ? 17 : s, l = function(d, h, f) {
    var p = -(d - h) * n, y = f * o, C = f + (p - y) * a / 1e3, v = f * a / 1e3 + d;
    return Math.abs(v - h) < yh && Math.abs(C) < yh ? [h, 0] : [v, C];
  };
  return l.isStepper = !0, l.dt = a, l;
}, Nhe = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  var i = r[0];
  if (typeof i == "string")
    switch (i) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return Wx(i);
      case "spring":
        return zhe();
      default:
        if (i.split("(")[0] === "cubic-bezier")
          return Wx(i);
        vh(!1, "[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", r);
    }
  return typeof i == "function" ? i : (vh(!1, "[configEasing]: first argument type should be function or string, instead received %s", r), null);
};
function Dc(e) {
  "@babel/helpers - typeof";
  return Dc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dc(e);
}
function Vx(e) {
  return Hhe(e) || Ghe(e) || QM(e) || Bhe();
}
function Bhe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ghe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Hhe(e) {
  if (Array.isArray(e)) return Iv(e);
}
function $x(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function or(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $x(Object(r), !0).forEach(function(n) {
      Ov(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : $x(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Ov(e, t, r) {
  return t = Whe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Whe(e) {
  var t = Vhe(e, "string");
  return Dc(t) === "symbol" ? t : String(t);
}
function Vhe(e, t) {
  if (Dc(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Dc(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function $he(e, t) {
  return Khe(e) || Uhe(e, t) || QM(e, t) || jhe();
}
function jhe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QM(e, t) {
  if (e) {
    if (typeof e == "string") return Iv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Iv(e, t);
  }
}
function Iv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Uhe(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Khe(e) {
  if (Array.isArray(e)) return e;
}
var Ch = function(t, r, n) {
  return t + (r - t) * n;
}, kv = function(t) {
  var r = t.from, n = t.to;
  return r !== n;
}, qhe = function e(t, r, n) {
  var i = Jl(function(o, s) {
    if (kv(s)) {
      var a = t(s.from, s.to, s.velocity), l = $he(a, 2), u = l[0], d = l[1];
      return or(or({}, s), {}, {
        from: u,
        velocity: d
      });
    }
    return s;
  }, r);
  return n < 1 ? Jl(function(o, s) {
    return kv(s) ? or(or({}, s), {}, {
      velocity: Ch(s.velocity, i[o].velocity, n),
      from: Ch(s.from, i[o].from, n)
    }) : s;
  }, r) : e(t, i, n - 1);
};
const Yhe = function(e, t, r, n, i) {
  var o = Rhe(e, t), s = o.reduce(function(v, w) {
    return or(or({}, v), {}, Ov({}, w, [e[w], t[w]]));
  }, {}), a = o.reduce(function(v, w) {
    return or(or({}, v), {}, Ov({}, w, {
      from: e[w],
      velocity: 0,
      to: t[w]
    }));
  }, {}), l = -1, u, d, h = function() {
    return null;
  }, f = function() {
    return Jl(function(w, R) {
      return R.from;
    }, a);
  }, p = function() {
    return !Object.values(a).filter(kv).length;
  }, y = function(w) {
    u || (u = w);
    var R = w - u, b = R / r.dt;
    a = qhe(r, a, b), i(or(or(or({}, e), t), f())), u = w, p() || (l = requestAnimationFrame(h));
  }, C = function(w) {
    d || (d = w);
    var R = (w - d) / n, b = Jl(function(S, E) {
      return Ch.apply(void 0, Vx(E).concat([r(R)]));
    }, s);
    if (i(or(or(or({}, e), t), b)), R < 1)
      l = requestAnimationFrame(h);
    else {
      var P = Jl(function(S, E) {
        return Ch.apply(void 0, Vx(E).concat([r(1)]));
      }, s);
      i(or(or(or({}, e), t), P));
    }
  };
  return h = r.isStepper ? y : C, function() {
    return requestAnimationFrame(h), function() {
      cancelAnimationFrame(l);
    };
  };
};
function va(e) {
  "@babel/helpers - typeof";
  return va = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, va(e);
}
var Jhe = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
function Xhe(e, t) {
  if (e == null) return {};
  var r = Qhe(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Qhe(e, t) {
  if (e == null) return {};
  var r = {}, n = Object.keys(e), i, o;
  for (o = 0; o < n.length; o++)
    i = n[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function em(e) {
  return rge(e) || tge(e) || ege(e) || Zhe();
}
function Zhe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ege(e, t) {
  if (e) {
    if (typeof e == "string") return Lv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Lv(e, t);
  }
}
function tge(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function rge(e) {
  if (Array.isArray(e)) return Lv(e);
}
function Lv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function jx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function On(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jx(Object(r), !0).forEach(function(n) {
      Bl(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : jx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Bl(e, t, r) {
  return t = ZM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function nge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ige(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, ZM(n.key), n);
  }
}
function oge(e, t, r) {
  return t && ige(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function ZM(e) {
  var t = sge(e, "string");
  return va(t) === "symbol" ? t : String(t);
}
function sge(e, t) {
  if (va(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (va(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function age(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && _v(e, t);
}
function _v(e, t) {
  return _v = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, _v(e, t);
}
function lge(e) {
  var t = cge();
  return function() {
    var n = wh(e), i;
    if (t) {
      var o = wh(this).constructor;
      i = Reflect.construct(n, arguments, o);
    } else
      i = n.apply(this, arguments);
    return zv(this, i);
  };
}
function zv(e, t) {
  if (t && (va(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Nv(e);
}
function Nv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function cge() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function wh(e) {
  return wh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, wh(e);
}
var $n = /* @__PURE__ */ function(e) {
  age(r, e);
  var t = lge(r);
  function r(n, i) {
    var o;
    nge(this, r), o = t.call(this, n, i);
    var s = o.props, a = s.isActive, l = s.attributeName, u = s.from, d = s.to, h = s.steps, f = s.children, p = s.duration;
    if (o.handleStyleChange = o.handleStyleChange.bind(Nv(o)), o.changeStyle = o.changeStyle.bind(Nv(o)), !a || p <= 0)
      return o.state = {
        style: {}
      }, typeof f == "function" && (o.state = {
        style: d
      }), zv(o);
    if (h && h.length)
      o.state = {
        style: h[0].style
      };
    else if (u) {
      if (typeof f == "function")
        return o.state = {
          style: u
        }, zv(o);
      o.state = {
        style: l ? Bl({}, l, u) : u
      };
    } else
      o.state = {
        style: {}
      };
    return o;
  }
  return oge(r, [{
    key: "componentDidMount",
    value: function() {
      var i = this.props, o = i.isActive, s = i.canBegin;
      this.mounted = !0, !(!o || !s) && this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function(i) {
      var o = this.props, s = o.isActive, a = o.canBegin, l = o.attributeName, u = o.shouldReAnimate, d = o.to, h = o.from, f = this.state.style;
      if (a) {
        if (!s) {
          var p = {
            style: l ? Bl({}, l, d) : d
          };
          this.state && f && (l && f[l] !== d || !l && f !== d) && this.setState(p);
          return;
        }
        if (!(fhe(i.to, d) && i.canBegin && i.isActive)) {
          var y = !i.canBegin || !i.isActive;
          this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();
          var C = y || u ? h : i.to;
          if (this.state && f) {
            var v = {
              style: l ? Bl({}, l, C) : C
            };
            (l && f[l] !== C || !l && f !== C) && this.setState(v);
          }
          this.runAnimation(On(On({}, this.props), {}, {
            from: C,
            begin: 0
          }));
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.mounted = !1;
      var i = this.props.onAnimationEnd;
      this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), i && i();
    }
  }, {
    key: "handleStyleChange",
    value: function(i) {
      this.changeStyle(i);
    }
  }, {
    key: "changeStyle",
    value: function(i) {
      this.mounted && this.setState({
        style: i
      });
    }
  }, {
    key: "runJSAnimation",
    value: function(i) {
      var o = this, s = i.from, a = i.to, l = i.duration, u = i.easing, d = i.begin, h = i.onAnimationEnd, f = i.onAnimationStart, p = Yhe(s, a, Nhe(u), l, this.changeStyle), y = function() {
        o.stopJSAnimation = p();
      };
      this.manager.start([f, d, y, l, h]);
    }
  }, {
    key: "runStepAnimation",
    value: function(i) {
      var o = this, s = i.steps, a = i.begin, l = i.onAnimationStart, u = s[0], d = u.style, h = u.duration, f = h === void 0 ? 0 : h, p = function(C, v, w) {
        if (w === 0)
          return C;
        var R = v.duration, b = v.easing, P = b === void 0 ? "ease" : b, S = v.style, E = v.properties, A = v.onAnimationEnd, M = w > 0 ? s[w - 1] : v, I = E || Object.keys(S);
        if (typeof P == "function" || P === "spring")
          return [].concat(em(C), [o.runJSAnimation.bind(o, {
            from: M.style,
            to: S,
            duration: R,
            easing: P
          }), R]);
        var z = Gx(I, R, P), k = On(On(On({}, M.style), S), {}, {
          transition: z
        });
        return [].concat(em(C), [k, R, A]).filter(Ehe);
      };
      return this.manager.start([l].concat(em(s.reduce(p, [d, Math.max(f, a)])), [i.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function(i) {
      this.manager || (this.manager = bhe());
      var o = i.begin, s = i.duration, a = i.attributeName, l = i.to, u = i.easing, d = i.onAnimationStart, h = i.onAnimationEnd, f = i.steps, p = i.children, y = this.manager;
      if (this.unSubscribe = y.subscribe(this.handleStyleChange), typeof u == "function" || typeof p == "function" || u === "spring") {
        this.runJSAnimation(i);
        return;
      }
      if (f.length > 1) {
        this.runStepAnimation(i);
        return;
      }
      var C = a ? Bl({}, a, l) : l, v = Gx(Object.keys(C), s, u);
      y.start([d, o, On(On({}, C), {}, {
        transition: v
      }), s, h]);
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, o = i.children;
      i.begin;
      var s = i.duration;
      i.attributeName, i.easing;
      var a = i.isActive;
      i.steps, i.from, i.to, i.canBegin, i.onAnimationEnd, i.shouldReAnimate, i.onAnimationReStart;
      var l = Xhe(i, Jhe), u = Xo.count(o), d = this.state.style;
      if (typeof o == "function")
        return o(d);
      if (!a || u === 0 || s <= 0)
        return o;
      var h = function(p) {
        var y = p.props, C = y.style, v = C === void 0 ? {} : C, w = y.className, R = /* @__PURE__ */ er(p, On(On({}, l), {}, {
          style: On(On({}, v), d),
          className: w
        }));
        return R;
      };
      return u === 1 ? h(Xo.only(o)) : /* @__PURE__ */ O.createElement("div", null, Xo.map(o, function(f) {
        return h(f);
      }));
    }
  }]), r;
}(ui);
$n.displayName = "Animate";
$n.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  steps: [],
  onAnimationEnd: function() {
  },
  onAnimationStart: function() {
  }
};
$n.propTypes = {
  from: ht.oneOfType([ht.object, ht.string]),
  to: ht.oneOfType([ht.object, ht.string]),
  attributeName: ht.string,
  // animation duration
  duration: ht.number,
  begin: ht.number,
  easing: ht.oneOfType([ht.string, ht.func]),
  steps: ht.arrayOf(ht.shape({
    duration: ht.number.isRequired,
    style: ht.object.isRequired,
    easing: ht.oneOfType([ht.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), ht.func]),
    // transition css properties(dash case), optional
    properties: ht.arrayOf("string"),
    onAnimationEnd: ht.func
  })),
  children: ht.oneOfType([ht.node, ht.func]),
  isActive: ht.bool,
  canBegin: ht.bool,
  onAnimationEnd: ht.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: ht.bool,
  onAnimationStart: ht.func,
  onAnimationReStart: ht.func
};
function Oc(e) {
  "@babel/helpers - typeof";
  return Oc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Oc(e);
}
function bh() {
  return bh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, bh.apply(this, arguments);
}
function uge(e, t) {
  return fge(e) || gge(e, t) || hge(e, t) || dge();
}
function dge() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hge(e, t) {
  if (e) {
    if (typeof e == "string") return Ux(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Ux(e, t);
  }
}
function Ux(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function gge(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function fge(e) {
  if (Array.isArray(e)) return e;
}
function Kx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function qx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kx(Object(r), !0).forEach(function(n) {
      pge(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Kx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function pge(e, t, r) {
  return t = mge(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function mge(e) {
  var t = vge(e, "string");
  return Oc(t) == "symbol" ? t : t + "";
}
function vge(e, t) {
  if (Oc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Oc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Yx = function(t, r, n, i, o) {
  var s = Math.min(Math.abs(n) / 2, Math.abs(i) / 2), a = i >= 0 ? 1 : -1, l = n >= 0 ? 1 : -1, u = i >= 0 && n >= 0 || i < 0 && n < 0 ? 1 : 0, d;
  if (s > 0 && o instanceof Array) {
    for (var h = [0, 0, 0, 0], f = 0, p = 4; f < p; f++)
      h[f] = o[f] > s ? s : o[f];
    d = "M".concat(t, ",").concat(r + a * h[0]), h[0] > 0 && (d += "A ".concat(h[0], ",").concat(h[0], ",0,0,").concat(u, ",").concat(t + l * h[0], ",").concat(r)), d += "L ".concat(t + n - l * h[1], ",").concat(r), h[1] > 0 && (d += "A ".concat(h[1], ",").concat(h[1], ",0,0,").concat(u, `,
        `).concat(t + n, ",").concat(r + a * h[1])), d += "L ".concat(t + n, ",").concat(r + i - a * h[2]), h[2] > 0 && (d += "A ".concat(h[2], ",").concat(h[2], ",0,0,").concat(u, `,
        `).concat(t + n - l * h[2], ",").concat(r + i)), d += "L ".concat(t + l * h[3], ",").concat(r + i), h[3] > 0 && (d += "A ".concat(h[3], ",").concat(h[3], ",0,0,").concat(u, `,
        `).concat(t, ",").concat(r + i - a * h[3])), d += "Z";
  } else if (s > 0 && o === +o && o > 0) {
    var y = Math.min(s, o);
    d = "M ".concat(t, ",").concat(r + a * y, `
            A `).concat(y, ",").concat(y, ",0,0,").concat(u, ",").concat(t + l * y, ",").concat(r, `
            L `).concat(t + n - l * y, ",").concat(r, `
            A `).concat(y, ",").concat(y, ",0,0,").concat(u, ",").concat(t + n, ",").concat(r + a * y, `
            L `).concat(t + n, ",").concat(r + i - a * y, `
            A `).concat(y, ",").concat(y, ",0,0,").concat(u, ",").concat(t + n - l * y, ",").concat(r + i, `
            L `).concat(t + l * y, ",").concat(r + i, `
            A `).concat(y, ",").concat(y, ",0,0,").concat(u, ",").concat(t, ",").concat(r + i - a * y, " Z");
  } else
    d = "M ".concat(t, ",").concat(r, " h ").concat(n, " v ").concat(i, " h ").concat(-n, " Z");
  return d;
}, yge = function(t, r) {
  if (!t || !r)
    return !1;
  var n = t.x, i = t.y, o = r.x, s = r.y, a = r.width, l = r.height;
  if (Math.abs(a) > 0 && Math.abs(l) > 0) {
    var u = Math.min(o, o + a), d = Math.max(o, o + a), h = Math.min(s, s + l), f = Math.max(s, s + l);
    return n >= u && n <= d && i >= h && i <= f;
  }
  return !1;
}, Cge = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, cC = function(t) {
  var r = qx(qx({}, Cge), t), n = ge(), i = pe(-1), o = uge(i, 2), s = o[0], a = o[1];
  pr(function() {
    if (n.current && n.current.getTotalLength)
      try {
        var P = n.current.getTotalLength();
        P && a(P);
      } catch {
      }
  }, []);
  var l = r.x, u = r.y, d = r.width, h = r.height, f = r.radius, p = r.className, y = r.animationEasing, C = r.animationDuration, v = r.animationBegin, w = r.isAnimationActive, R = r.isUpdateAnimationActive;
  if (l !== +l || u !== +u || d !== +d || h !== +h || d === 0 || h === 0)
    return null;
  var b = Ze("recharts-rectangle", p);
  return R ? /* @__PURE__ */ O.createElement($n, {
    canBegin: s > 0,
    from: {
      width: d,
      height: h,
      x: l,
      y: u
    },
    to: {
      width: d,
      height: h,
      x: l,
      y: u
    },
    duration: C,
    animationEasing: y,
    isActive: R
  }, function(P) {
    var S = P.width, E = P.height, A = P.x, M = P.y;
    return /* @__PURE__ */ O.createElement($n, {
      canBegin: s > 0,
      from: "0px ".concat(s === -1 ? 1 : s, "px"),
      to: "".concat(s, "px 0px"),
      attributeName: "strokeDasharray",
      begin: v,
      duration: C,
      isActive: w,
      easing: y
    }, /* @__PURE__ */ O.createElement("path", bh({}, Ne(r, !0), {
      className: b,
      d: Yx(A, M, S, E, f),
      ref: n
    })));
  }) : /* @__PURE__ */ O.createElement("path", bh({}, Ne(r, !0), {
    className: b,
    d: Yx(l, u, d, h, f)
  }));
};
function Bv() {
  return Bv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Bv.apply(this, arguments);
}
var xg = function(t) {
  var r = t.cx, n = t.cy, i = t.r, o = t.className, s = Ze("recharts-dot", o);
  return r === +r && n === +n && i === +i ? /* @__PURE__ */ O.createElement("circle", Bv({}, Ne(t, !1), Gd(t), {
    className: s,
    cx: r,
    cy: n,
    r: i
  })) : null;
};
function Ic(e) {
  "@babel/helpers - typeof";
  return Ic = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ic(e);
}
var wge = ["x", "y", "top", "left", "width", "height", "className"];
function Gv() {
  return Gv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Gv.apply(this, arguments);
}
function Jx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function bge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jx(Object(r), !0).forEach(function(n) {
      Sge(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Jx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Sge(e, t, r) {
  return t = xge(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function xge(e) {
  var t = Rge(e, "string");
  return Ic(t) == "symbol" ? t : t + "";
}
function Rge(e, t) {
  if (Ic(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ic(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ege(e, t) {
  if (e == null) return {};
  var r = Pge(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Pge(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
var Age = function(t, r, n, i, o, s) {
  return "M".concat(t, ",").concat(o, "v").concat(i, "M").concat(s, ",").concat(r, "h").concat(n);
}, Fge = function(t) {
  var r = t.x, n = r === void 0 ? 0 : r, i = t.y, o = i === void 0 ? 0 : i, s = t.top, a = s === void 0 ? 0 : s, l = t.left, u = l === void 0 ? 0 : l, d = t.width, h = d === void 0 ? 0 : d, f = t.height, p = f === void 0 ? 0 : f, y = t.className, C = Ege(t, wge), v = bge({
    x: n,
    y: o,
    top: a,
    left: u,
    width: h,
    height: p
  }, C);
  return !Ce(n) || !Ce(o) || !Ce(h) || !Ce(p) || !Ce(a) || !Ce(u) ? null : /* @__PURE__ */ O.createElement("path", Gv({}, Ne(v, !0), {
    className: Ze("recharts-cross", y),
    d: Age(n, o, h, p, a, u)
  }));
}, Mge = yF, Tge = Mge(Object.getPrototypeOf, Object), Dge = Tge, Oge = Bi, Ige = Dge, kge = Gi, Lge = "[object Object]", _ge = Function.prototype, zge = Object.prototype, eT = _ge.toString, Nge = zge.hasOwnProperty, Bge = eT.call(Object);
function Gge(e) {
  if (!kge(e) || Oge(e) != Lge)
    return !1;
  var t = Ige(e);
  if (t === null)
    return !0;
  var r = Nge.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r instanceof r && eT.call(r) == Bge;
}
var Hge = Gge;
const Wge = /* @__PURE__ */ bt(Hge);
var Vge = Bi, $ge = Gi, jge = "[object Boolean]";
function Uge(e) {
  return e === !0 || e === !1 || $ge(e) && Vge(e) == jge;
}
var Kge = Uge;
const qge = /* @__PURE__ */ bt(Kge);
function kc(e) {
  "@babel/helpers - typeof";
  return kc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, kc(e);
}
function Sh() {
  return Sh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Sh.apply(this, arguments);
}
function Yge(e, t) {
  return Zge(e) || Qge(e, t) || Xge(e, t) || Jge();
}
function Jge() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Xge(e, t) {
  if (e) {
    if (typeof e == "string") return Xx(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Xx(e, t);
  }
}
function Xx(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Qge(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function Zge(e) {
  if (Array.isArray(e)) return e;
}
function Qx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Zx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qx(Object(r), !0).forEach(function(n) {
      efe(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Qx(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function efe(e, t, r) {
  return t = tfe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function tfe(e) {
  var t = rfe(e, "string");
  return kc(t) == "symbol" ? t : t + "";
}
function rfe(e, t) {
  if (kc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (kc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var eR = function(t, r, n, i, o) {
  var s = n - i, a;
  return a = "M ".concat(t, ",").concat(r), a += "L ".concat(t + n, ",").concat(r), a += "L ".concat(t + n - s / 2, ",").concat(r + o), a += "L ".concat(t + n - s / 2 - i, ",").concat(r + o), a += "L ".concat(t, ",").concat(r, " Z"), a;
}, nfe = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, ife = function(t) {
  var r = Zx(Zx({}, nfe), t), n = ge(), i = pe(-1), o = Yge(i, 2), s = o[0], a = o[1];
  pr(function() {
    if (n.current && n.current.getTotalLength)
      try {
        var b = n.current.getTotalLength();
        b && a(b);
      } catch {
      }
  }, []);
  var l = r.x, u = r.y, d = r.upperWidth, h = r.lowerWidth, f = r.height, p = r.className, y = r.animationEasing, C = r.animationDuration, v = r.animationBegin, w = r.isUpdateAnimationActive;
  if (l !== +l || u !== +u || d !== +d || h !== +h || f !== +f || d === 0 && h === 0 || f === 0)
    return null;
  var R = Ze("recharts-trapezoid", p);
  return w ? /* @__PURE__ */ O.createElement($n, {
    canBegin: s > 0,
    from: {
      upperWidth: 0,
      lowerWidth: 0,
      height: f,
      x: l,
      y: u
    },
    to: {
      upperWidth: d,
      lowerWidth: h,
      height: f,
      x: l,
      y: u
    },
    duration: C,
    animationEasing: y,
    isActive: w
  }, function(b) {
    var P = b.upperWidth, S = b.lowerWidth, E = b.height, A = b.x, M = b.y;
    return /* @__PURE__ */ O.createElement($n, {
      canBegin: s > 0,
      from: "0px ".concat(s === -1 ? 1 : s, "px"),
      to: "".concat(s, "px 0px"),
      attributeName: "strokeDasharray",
      begin: v,
      duration: C,
      easing: y
    }, /* @__PURE__ */ O.createElement("path", Sh({}, Ne(r, !0), {
      className: R,
      d: eR(A, M, P, S, E),
      ref: n
    })));
  }) : /* @__PURE__ */ O.createElement("g", null, /* @__PURE__ */ O.createElement("path", Sh({}, Ne(r, !0), {
    className: R,
    d: eR(l, u, d, h, f)
  })));
}, ofe = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function Lc(e) {
  "@babel/helpers - typeof";
  return Lc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lc(e);
}
function sfe(e, t) {
  if (e == null) return {};
  var r = afe(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function afe(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function tR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function xh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tR(Object(r), !0).forEach(function(n) {
      lfe(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : tR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function lfe(e, t, r) {
  return t = cfe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function cfe(e) {
  var t = ufe(e, "string");
  return Lc(t) == "symbol" ? t : t + "";
}
function ufe(e, t) {
  if (Lc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Lc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dfe(e, t) {
  return xh(xh({}, t), e);
}
function hfe(e, t) {
  return e === "symbols";
}
function rR(e) {
  var t = e.shapeType, r = e.elementProps;
  switch (t) {
    case "rectangle":
      return /* @__PURE__ */ O.createElement(cC, r);
    case "trapezoid":
      return /* @__PURE__ */ O.createElement(ife, r);
    case "sector":
      return /* @__PURE__ */ O.createElement($M, r);
    case "symbols":
      if (hfe(t))
        return /* @__PURE__ */ O.createElement(ug, r);
      break;
    default:
      return null;
  }
}
function gfe(e) {
  return /* @__PURE__ */ ri(e) ? e.props : e;
}
function Hv(e) {
  var t = e.option, r = e.shapeType, n = e.propTransformer, i = n === void 0 ? dfe : n, o = e.activeClassName, s = o === void 0 ? "recharts-active-shape" : o, a = e.isActive, l = sfe(e, ofe), u;
  if (/* @__PURE__ */ ri(t))
    u = /* @__PURE__ */ er(t, xh(xh({}, l), gfe(t)));
  else if (We(t))
    u = t(l);
  else if (Wge(t) && !qge(t)) {
    var d = i(t, l);
    u = /* @__PURE__ */ O.createElement(rR, {
      shapeType: r,
      elementProps: d
    });
  } else {
    var h = l;
    u = /* @__PURE__ */ O.createElement(rR, {
      shapeType: r,
      elementProps: h
    });
  }
  return a ? /* @__PURE__ */ O.createElement(st, {
    className: s
  }, u) : u;
}
function Rg(e, t) {
  return t != null && "trapezoids" in e.props;
}
function Eg(e, t) {
  return t != null && "sectors" in e.props;
}
function _c(e, t) {
  return t != null && "points" in e.props;
}
function ffe(e, t) {
  var r, n, i = e.x === (t == null || (r = t.labelViewBox) === null || r === void 0 ? void 0 : r.x) || e.x === t.x, o = e.y === (t == null || (n = t.labelViewBox) === null || n === void 0 ? void 0 : n.y) || e.y === t.y;
  return i && o;
}
function pfe(e, t) {
  var r = e.endAngle === t.endAngle, n = e.startAngle === t.startAngle;
  return r && n;
}
function mfe(e, t) {
  var r = e.x === t.x, n = e.y === t.y, i = e.z === t.z;
  return r && n && i;
}
function vfe(e, t) {
  var r;
  return Rg(e, t) ? r = ffe : Eg(e, t) ? r = pfe : _c(e, t) && (r = mfe), r;
}
function yfe(e, t) {
  var r;
  return Rg(e, t) ? r = "trapezoids" : Eg(e, t) ? r = "sectors" : _c(e, t) && (r = "points"), r;
}
function Cfe(e, t) {
  if (Rg(e, t)) {
    var r;
    return (r = t.tooltipPayload) === null || r === void 0 || (r = r[0]) === null || r === void 0 || (r = r.payload) === null || r === void 0 ? void 0 : r.payload;
  }
  if (Eg(e, t)) {
    var n;
    return (n = t.tooltipPayload) === null || n === void 0 || (n = n[0]) === null || n === void 0 || (n = n.payload) === null || n === void 0 ? void 0 : n.payload;
  }
  return _c(e, t) ? t.payload : {};
}
function wfe(e) {
  var t = e.activeTooltipItem, r = e.graphicalItem, n = e.itemData, i = yfe(r, t), o = Cfe(r, t), s = n.filter(function(l, u) {
    var d = hs(o, l), h = r.props[i].filter(function(y) {
      var C = vfe(r, t);
      return C(y, t);
    }), f = r.props[i].indexOf(h[h.length - 1]), p = u === f;
    return d && p;
  }), a = n.indexOf(s[s.length - 1]);
  return a;
}
var bfe = Math.ceil, Sfe = Math.max;
function xfe(e, t, r, n) {
  for (var i = -1, o = Sfe(bfe((t - e) / (r || 1)), 0), s = Array(o); o--; )
    s[n ? o : ++i] = e, e += r;
  return s;
}
var Rfe = xfe, Efe = _F, nR = 1 / 0, Pfe = 17976931348623157e292;
function Afe(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Efe(e), e === nR || e === -nR) {
    var t = e < 0 ? -1 : 1;
    return t * Pfe;
  }
  return e === e ? e : 0;
}
var Ffe = Afe, Mfe = Rfe, Tfe = gg, tm = Ffe;
function Dfe(e) {
  return function(t, r, n) {
    return n && typeof n != "number" && Tfe(t, r, n) && (r = n = void 0), t = tm(t), r === void 0 ? (r = t, t = 0) : r = tm(r), n = n === void 0 ? t < r ? 1 : -1 : tm(n), Mfe(t, r, n, e);
  };
}
var Ofe = Dfe, Ife = Ofe, kfe = Ife(), Lfe = kfe;
const Rh = /* @__PURE__ */ bt(Lfe);
function zc(e) {
  "@babel/helpers - typeof";
  return zc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zc(e);
}
function iR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function oR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iR(Object(r), !0).forEach(function(n) {
      tT(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : iR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function tT(e, t, r) {
  return t = _fe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function _fe(e) {
  var t = zfe(e, "string");
  return zc(t) == "symbol" ? t : t + "";
}
function zfe(e, t) {
  if (zc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (zc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Nfe = ["Webkit", "Moz", "O", "ms"], Bfe = function(t, r) {
  var n = t.replace(/(\w)/, function(o) {
    return o.toUpperCase();
  }), i = Nfe.reduce(function(o, s) {
    return oR(oR({}, o), {}, tT({}, s + n, r));
  }, {});
  return i[t] = r, i;
};
function ya(e) {
  "@babel/helpers - typeof";
  return ya = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ya(e);
}
function Eh() {
  return Eh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Eh.apply(this, arguments);
}
function sR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function rm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sR(Object(r), !0).forEach(function(n) {
      Qr(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : sR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Gfe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, nT(n.key), n);
  }
}
function Hfe(e, t, r) {
  return t && aR(e.prototype, t), r && aR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Wfe(e, t, r) {
  return t = Ph(t), Vfe(e, rT() ? Reflect.construct(t, r || [], Ph(e).constructor) : t.apply(e, r));
}
function Vfe(e, t) {
  if (t && (ya(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return $fe(e);
}
function $fe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function rT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (rT = function() {
    return !!e;
  })();
}
function Ph(e) {
  return Ph = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Ph(e);
}
function jfe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Wv(e, t);
}
function Wv(e, t) {
  return Wv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Wv(e, t);
}
function Qr(e, t, r) {
  return t = nT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function nT(e) {
  var t = Ufe(e, "string");
  return ya(t) == "symbol" ? t : t + "";
}
function Ufe(e, t) {
  if (ya(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (ya(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Kfe = function(t) {
  var r = t.data, n = t.startIndex, i = t.endIndex, o = t.x, s = t.width, a = t.travellerWidth;
  if (!r || !r.length)
    return {};
  var l = r.length, u = ql().domain(Rh(0, l)).range([o, o + s - a]), d = u.domain().map(function(h) {
    return u(h);
  });
  return {
    isTextActive: !1,
    isSlideMoving: !1,
    isTravellerMoving: !1,
    isTravellerFocused: !1,
    startX: u(n),
    endX: u(i),
    scale: u,
    scaleValues: d
  };
}, lR = function(t) {
  return t.changedTouches && !!t.changedTouches.length;
}, Ca = /* @__PURE__ */ function(e) {
  function t(r) {
    var n;
    return Gfe(this, t), n = Wfe(this, t, [r]), Qr(n, "handleDrag", function(i) {
      n.leaveTimer && (clearTimeout(n.leaveTimer), n.leaveTimer = null), n.state.isTravellerMoving ? n.handleTravellerMove(i) : n.state.isSlideMoving && n.handleSlideDrag(i);
    }), Qr(n, "handleTouchMove", function(i) {
      i.changedTouches != null && i.changedTouches.length > 0 && n.handleDrag(i.changedTouches[0]);
    }), Qr(n, "handleDragEnd", function() {
      n.setState({
        isTravellerMoving: !1,
        isSlideMoving: !1
      }, function() {
        var i = n.props, o = i.endIndex, s = i.onDragEnd, a = i.startIndex;
        s == null || s({
          endIndex: o,
          startIndex: a
        });
      }), n.detachDragEndListener();
    }), Qr(n, "handleLeaveWrapper", function() {
      (n.state.isTravellerMoving || n.state.isSlideMoving) && (n.leaveTimer = window.setTimeout(n.handleDragEnd, n.props.leaveTimeOut));
    }), Qr(n, "handleEnterSlideOrTraveller", function() {
      n.setState({
        isTextActive: !0
      });
    }), Qr(n, "handleLeaveSlideOrTraveller", function() {
      n.setState({
        isTextActive: !1
      });
    }), Qr(n, "handleSlideDragStart", function(i) {
      var o = lR(i) ? i.changedTouches[0] : i;
      n.setState({
        isTravellerMoving: !1,
        isSlideMoving: !0,
        slideMoveStartX: o.pageX
      }), n.attachDragEndListener();
    }), n.travellerDragStartHandlers = {
      startX: n.handleTravellerDragStart.bind(n, "startX"),
      endX: n.handleTravellerDragStart.bind(n, "endX")
    }, n.state = {}, n;
  }
  return jfe(t, e), Hfe(t, [{
    key: "componentWillUnmount",
    value: function() {
      this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function(n) {
      var i = n.startX, o = n.endX, s = this.state.scaleValues, a = this.props, l = a.gap, u = a.data, d = u.length - 1, h = Math.min(i, o), f = Math.max(i, o), p = t.getIndexInRange(s, h), y = t.getIndexInRange(s, f);
      return {
        startIndex: p - p % l,
        endIndex: y === d ? d : y - y % l
      };
    }
  }, {
    key: "getTextOfTick",
    value: function(n) {
      var i = this.props, o = i.data, s = i.tickFormatter, a = i.dataKey, l = Xt(o[n], a, n);
      return We(s) ? s(l, n) : l;
    }
  }, {
    key: "attachDragEndListener",
    value: function() {
      window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "detachDragEndListener",
    value: function() {
      window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "handleSlideDrag",
    value: function(n) {
      var i = this.state, o = i.slideMoveStartX, s = i.startX, a = i.endX, l = this.props, u = l.x, d = l.width, h = l.travellerWidth, f = l.startIndex, p = l.endIndex, y = l.onChange, C = n.pageX - o;
      C > 0 ? C = Math.min(C, u + d - h - a, u + d - h - s) : C < 0 && (C = Math.max(C, u - s, u - a));
      var v = this.getIndex({
        startX: s + C,
        endX: a + C
      });
      (v.startIndex !== f || v.endIndex !== p) && y && y(v), this.setState({
        startX: s + C,
        endX: a + C,
        slideMoveStartX: n.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function(n, i) {
      var o = lR(i) ? i.changedTouches[0] : i;
      this.setState({
        isSlideMoving: !1,
        isTravellerMoving: !0,
        movingTravellerId: n,
        brushMoveStartX: o.pageX
      }), this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function(n) {
      var i = this.state, o = i.brushMoveStartX, s = i.movingTravellerId, a = i.endX, l = i.startX, u = this.state[s], d = this.props, h = d.x, f = d.width, p = d.travellerWidth, y = d.onChange, C = d.gap, v = d.data, w = {
        startX: this.state.startX,
        endX: this.state.endX
      }, R = n.pageX - o;
      R > 0 ? R = Math.min(R, h + f - p - u) : R < 0 && (R = Math.max(R, h - u)), w[s] = u + R;
      var b = this.getIndex(w), P = b.startIndex, S = b.endIndex, E = function() {
        var M = v.length - 1;
        return s === "startX" && (a > l ? P % C === 0 : S % C === 0) || a < l && S === M || s === "endX" && (a > l ? S % C === 0 : P % C === 0) || a > l && S === M;
      };
      this.setState(Qr(Qr({}, s, u + R), "brushMoveStartX", n.pageX), function() {
        y && E() && y(b);
      });
    }
  }, {
    key: "handleTravellerMoveKeyboard",
    value: function(n, i) {
      var o = this, s = this.state, a = s.scaleValues, l = s.startX, u = s.endX, d = this.state[i], h = a.indexOf(d);
      if (h !== -1) {
        var f = h + n;
        if (!(f === -1 || f >= a.length)) {
          var p = a[f];
          i === "startX" && p >= u || i === "endX" && p <= l || this.setState(Qr({}, i, p), function() {
            o.props.onChange(o.getIndex({
              startX: o.state.startX,
              endX: o.state.endX
            }));
          });
        }
      }
    }
  }, {
    key: "renderBackground",
    value: function() {
      var n = this.props, i = n.x, o = n.y, s = n.width, a = n.height, l = n.fill, u = n.stroke;
      return /* @__PURE__ */ O.createElement("rect", {
        stroke: u,
        fill: l,
        x: i,
        y: o,
        width: s,
        height: a
      });
    }
  }, {
    key: "renderPanorama",
    value: function() {
      var n = this.props, i = n.x, o = n.y, s = n.width, a = n.height, l = n.data, u = n.children, d = n.padding, h = Xo.only(u);
      return h ? /* @__PURE__ */ O.cloneElement(h, {
        x: i,
        y: o,
        width: s,
        height: a,
        margin: d,
        compact: !0,
        data: l
      }) : null;
    }
  }, {
    key: "renderTravellerLayer",
    value: function(n, i) {
      var o, s, a = this, l = this.props, u = l.y, d = l.travellerWidth, h = l.height, f = l.traveller, p = l.ariaLabel, y = l.data, C = l.startIndex, v = l.endIndex, w = Math.max(n, this.props.x), R = rm(rm({}, Ne(this.props, !1)), {}, {
        x: w,
        y: u,
        width: d,
        height: h
      }), b = p || "Min value: ".concat((o = y[C]) === null || o === void 0 ? void 0 : o.name, ", Max value: ").concat((s = y[v]) === null || s === void 0 ? void 0 : s.name);
      return /* @__PURE__ */ O.createElement(st, {
        tabIndex: 0,
        role: "slider",
        "aria-label": b,
        "aria-valuenow": n,
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[i],
        onTouchStart: this.travellerDragStartHandlers[i],
        onKeyDown: function(S) {
          ["ArrowLeft", "ArrowRight"].includes(S.key) && (S.preventDefault(), S.stopPropagation(), a.handleTravellerMoveKeyboard(S.key === "ArrowRight" ? 1 : -1, i));
        },
        onFocus: function() {
          a.setState({
            isTravellerFocused: !0
          });
        },
        onBlur: function() {
          a.setState({
            isTravellerFocused: !1
          });
        },
        style: {
          cursor: "col-resize"
        }
      }, t.renderTraveller(f, R));
    }
  }, {
    key: "renderSlide",
    value: function(n, i) {
      var o = this.props, s = o.y, a = o.height, l = o.stroke, u = o.travellerWidth, d = Math.min(n, i) + u, h = Math.max(Math.abs(i - n) - u, 0);
      return /* @__PURE__ */ O.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: l,
        fillOpacity: 0.2,
        x: d,
        y: s,
        width: h,
        height: a
      });
    }
  }, {
    key: "renderText",
    value: function() {
      var n = this.props, i = n.startIndex, o = n.endIndex, s = n.y, a = n.height, l = n.travellerWidth, u = n.stroke, d = this.state, h = d.startX, f = d.endX, p = 5, y = {
        pointerEvents: "none",
        fill: u
      };
      return /* @__PURE__ */ O.createElement(st, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ O.createElement(eh, Eh({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(h, f) - p,
        y: s + a / 2
      }, y), this.getTextOfTick(i)), /* @__PURE__ */ O.createElement(eh, Eh({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(h, f) + l + p,
        y: s + a / 2
      }, y), this.getTextOfTick(o)));
    }
  }, {
    key: "render",
    value: function() {
      var n = this.props, i = n.data, o = n.className, s = n.children, a = n.x, l = n.y, u = n.width, d = n.height, h = n.alwaysShowText, f = this.state, p = f.startX, y = f.endX, C = f.isTextActive, v = f.isSlideMoving, w = f.isTravellerMoving, R = f.isTravellerFocused;
      if (!i || !i.length || !Ce(a) || !Ce(l) || !Ce(u) || !Ce(d) || u <= 0 || d <= 0)
        return null;
      var b = Ze("recharts-brush", o), P = O.Children.count(s) === 1, S = Bfe("userSelect", "none");
      return /* @__PURE__ */ O.createElement(st, {
        className: b,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style: S
      }, this.renderBackground(), P && this.renderPanorama(), this.renderSlide(p, y), this.renderTravellerLayer(p, "startX"), this.renderTravellerLayer(y, "endX"), (C || v || w || R || h) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function(n) {
      var i = n.x, o = n.y, s = n.width, a = n.height, l = n.stroke, u = Math.floor(o + a / 2) - 1;
      return /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement("rect", {
        x: i,
        y: o,
        width: s,
        height: a,
        fill: l,
        stroke: "none"
      }), /* @__PURE__ */ O.createElement("line", {
        x1: i + 1,
        y1: u,
        x2: i + s - 1,
        y2: u,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ O.createElement("line", {
        x1: i + 1,
        y1: u + 2,
        x2: i + s - 1,
        y2: u + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function(n, i) {
      var o;
      return /* @__PURE__ */ O.isValidElement(n) ? o = /* @__PURE__ */ O.cloneElement(n, i) : We(n) ? o = n(i) : o = t.renderDefaultTraveller(i), o;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function(n, i) {
      var o = n.data, s = n.width, a = n.x, l = n.travellerWidth, u = n.updateId, d = n.startIndex, h = n.endIndex;
      if (o !== i.prevData || u !== i.prevUpdateId)
        return rm({
          prevData: o,
          prevTravellerWidth: l,
          prevUpdateId: u,
          prevX: a,
          prevWidth: s
        }, o && o.length ? Kfe({
          data: o,
          width: s,
          x: a,
          travellerWidth: l,
          startIndex: d,
          endIndex: h
        }) : {
          scale: null,
          scaleValues: null
        });
      if (i.scale && (s !== i.prevWidth || a !== i.prevX || l !== i.prevTravellerWidth)) {
        i.scale.range([a, a + s - l]);
        var f = i.scale.domain().map(function(p) {
          return i.scale(p);
        });
        return {
          prevData: o,
          prevTravellerWidth: l,
          prevUpdateId: u,
          prevX: a,
          prevWidth: s,
          startX: i.scale(n.startIndex),
          endX: i.scale(n.endIndex),
          scaleValues: f
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function(n, i) {
      for (var o = n.length, s = 0, a = o - 1; a - s > 1; ) {
        var l = Math.floor((s + a) / 2);
        n[l] > i ? a = l : s = l;
      }
      return i >= n[a] ? a : s;
    }
  }]);
}(ui);
Qr(Ca, "displayName", "Brush");
Qr(Ca, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: !1
});
var qfe = Iy;
function Yfe(e, t) {
  var r;
  return qfe(e, function(n, i, o) {
    return r = t(n, i, o), !r;
  }), !!r;
}
var Jfe = Yfe, Xfe = uF, Qfe = el, Zfe = Jfe, epe = Vr, tpe = gg;
function rpe(e, t, r) {
  var n = epe(e) ? Xfe : Zfe;
  return r && tpe(e, t, r) && (t = void 0), n(e, Qfe(t));
}
var npe = rpe;
const ipe = /* @__PURE__ */ bt(npe);
var si = function(t, r) {
  var n = t.alwaysShow, i = t.ifOverflow;
  return n && (i = "extendDomain"), i === r;
}, cR = DF;
function ope(e, t, r) {
  t == "__proto__" && cR ? cR(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
var spe = ope, ape = spe, lpe = MF, cpe = el;
function upe(e, t) {
  var r = {};
  return t = cpe(t), lpe(e, function(n, i, o) {
    ape(r, i, t(n, i, o));
  }), r;
}
var dpe = upe;
const hpe = /* @__PURE__ */ bt(dpe);
function gpe(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
    if (!t(e[r], r, e))
      return !1;
  return !0;
}
var fpe = gpe, ppe = Iy;
function mpe(e, t) {
  var r = !0;
  return ppe(e, function(n, i, o) {
    return r = !!t(n, i, o), r;
  }), r;
}
var vpe = mpe, ype = fpe, Cpe = vpe, wpe = el, bpe = Vr, Spe = gg;
function xpe(e, t, r) {
  var n = bpe(e) ? ype : Cpe;
  return r && Spe(e, t, r) && (t = void 0), n(e, wpe(t));
}
var Rpe = xpe;
const Epe = /* @__PURE__ */ bt(Rpe);
var Ppe = ["x", "y"];
function wa(e) {
  "@babel/helpers - typeof";
  return wa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wa(e);
}
function Vv() {
  return Vv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Vv.apply(this, arguments);
}
function uR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Ll(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uR(Object(r), !0).forEach(function(n) {
      Ape(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : uR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Ape(e, t, r) {
  return t = Fpe(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Fpe(e) {
  var t = Mpe(e, "string");
  return wa(t) == "symbol" ? t : t + "";
}
function Mpe(e, t) {
  if (wa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (wa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Tpe(e, t) {
  if (e == null) return {};
  var r = Dpe(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Dpe(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Ope(e, t) {
  var r = e.x, n = e.y, i = Tpe(e, Ppe), o = "".concat(r), s = parseInt(o, 10), a = "".concat(n), l = parseInt(a, 10), u = "".concat(t.height || i.height), d = parseInt(u, 10), h = "".concat(t.width || i.width), f = parseInt(h, 10);
  return Ll(Ll(Ll(Ll(Ll({}, t), i), s ? {
    x: s
  } : {}), l ? {
    y: l
  } : {}), {}, {
    height: d,
    width: f,
    name: t.name,
    radius: t.radius
  });
}
function dR(e) {
  return /* @__PURE__ */ O.createElement(Hv, Vv({
    shapeType: "rectangle",
    propTransformer: Ope,
    activeClassName: "recharts-active-bar"
  }, e));
}
var Ipe = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return function(n, i) {
    if (typeof t == "number") return t;
    var o = typeof n == "number";
    return o ? t(n, i) : (o || (process.env.NODE_ENV !== "production" ? Hr(!1, "minPointSize callback function received a value with type of ".concat(wa(n), ". Currently only numbers are supported.")) : Hr()), r);
  };
}, kpe = ["value", "background"], iT;
function ba(e) {
  "@babel/helpers - typeof";
  return ba = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ba(e);
}
function Lpe(e, t) {
  if (e == null) return {};
  var r = _pe(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function _pe(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Ah() {
  return Ah = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Ah.apply(this, arguments);
}
function hR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Vt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hR(Object(r), !0).forEach(function(n) {
      oo(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : hR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function zpe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, sT(n.key), n);
  }
}
function Npe(e, t, r) {
  return t && gR(e.prototype, t), r && gR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Bpe(e, t, r) {
  return t = Fh(t), Gpe(e, oT() ? Reflect.construct(t, r || [], Fh(e).constructor) : t.apply(e, r));
}
function Gpe(e, t) {
  if (t && (ba(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Hpe(e);
}
function Hpe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function oT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (oT = function() {
    return !!e;
  })();
}
function Fh(e) {
  return Fh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Fh(e);
}
function Wpe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && $v(e, t);
}
function $v(e, t) {
  return $v = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, $v(e, t);
}
function oo(e, t, r) {
  return t = sT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function sT(e) {
  var t = Vpe(e, "string");
  return ba(t) == "symbol" ? t : t + "";
}
function Vpe(e, t) {
  if (ba(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (ba(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var kt = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    zpe(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = Bpe(this, t, [].concat(i)), oo(r, "state", {
      isAnimationFinished: !1
    }), oo(r, "id", Cs("recharts-bar-")), oo(r, "handleAnimationEnd", function() {
      var s = r.props.onAnimationEnd;
      r.setState({
        isAnimationFinished: !0
      }), s && s();
    }), oo(r, "handleAnimationStart", function() {
      var s = r.props.onAnimationStart;
      r.setState({
        isAnimationFinished: !1
      }), s && s();
    }), r;
  }
  return Wpe(t, e), Npe(t, [{
    key: "renderRectanglesStatically",
    value: function(n) {
      var i = this, o = this.props, s = o.shape, a = o.dataKey, l = o.activeIndex, u = o.activeBar, d = Ne(this.props, !1);
      return n && n.map(function(h, f) {
        var p = f === l, y = p ? u : s, C = Vt(Vt(Vt({}, d), h), {}, {
          isActive: p,
          option: y,
          index: f,
          dataKey: a,
          onAnimationStart: i.handleAnimationStart,
          onAnimationEnd: i.handleAnimationEnd
        });
        return /* @__PURE__ */ O.createElement(st, Ah({
          className: "recharts-bar-rectangle"
        }, lc(i.props, h, f), {
          // https://github.com/recharts/recharts/issues/5415
          // eslint-disable-next-line react/no-array-index-key
          key: "rectangle-".concat(h == null ? void 0 : h.x, "-").concat(h == null ? void 0 : h.y, "-").concat(h == null ? void 0 : h.value, "-").concat(f)
        }), /* @__PURE__ */ O.createElement(dR, C));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function() {
      var n = this, i = this.props, o = i.data, s = i.layout, a = i.isAnimationActive, l = i.animationBegin, u = i.animationDuration, d = i.animationEasing, h = i.animationId, f = this.state.prevData;
      return /* @__PURE__ */ O.createElement($n, {
        begin: l,
        duration: u,
        isActive: a,
        easing: d,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(h),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(p) {
        var y = p.t, C = o.map(function(v, w) {
          var R = f && f[w];
          if (R) {
            var b = Ht(R.x, v.x), P = Ht(R.y, v.y), S = Ht(R.width, v.width), E = Ht(R.height, v.height);
            return Vt(Vt({}, v), {}, {
              x: b(y),
              y: P(y),
              width: S(y),
              height: E(y)
            });
          }
          if (s === "horizontal") {
            var A = Ht(0, v.height), M = A(y);
            return Vt(Vt({}, v), {}, {
              y: v.y + v.height - M,
              height: M
            });
          }
          var I = Ht(0, v.width), z = I(y);
          return Vt(Vt({}, v), {}, {
            width: z
          });
        });
        return /* @__PURE__ */ O.createElement(st, null, n.renderRectanglesStatically(C));
      });
    }
  }, {
    key: "renderRectangles",
    value: function() {
      var n = this.props, i = n.data, o = n.isAnimationActive, s = this.state.prevData;
      return o && i && i.length && (!s || !hs(s, i)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(i);
    }
  }, {
    key: "renderBackground",
    value: function() {
      var n = this, i = this.props, o = i.data, s = i.dataKey, a = i.activeIndex, l = Ne(this.props.background, !1);
      return o.map(function(u, d) {
        u.value;
        var h = u.background, f = Lpe(u, kpe);
        if (!h)
          return null;
        var p = Vt(Vt(Vt(Vt(Vt({}, f), {}, {
          fill: "#eee"
        }, h), l), lc(n.props, u, d)), {}, {
          onAnimationStart: n.handleAnimationStart,
          onAnimationEnd: n.handleAnimationEnd,
          dataKey: s,
          index: d,
          className: "recharts-bar-background-rectangle"
        });
        return /* @__PURE__ */ O.createElement(dR, Ah({
          key: "background-bar-".concat(d),
          option: n.props.background,
          isActive: d === a
        }, p));
      });
    }
  }, {
    key: "renderErrorBar",
    value: function(n, i) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished)
        return null;
      var o = this.props, s = o.data, a = o.xAxis, l = o.yAxis, u = o.layout, d = o.children, h = Wr(d, il);
      if (!h)
        return null;
      var f = u === "vertical" ? s[0].height / 2 : s[0].width / 2, p = function(v, w) {
        var R = Array.isArray(v.value) ? v.value[1] : v.value;
        return {
          x: v.x,
          y: v.y,
          value: R,
          errorVal: Xt(v, w)
        };
      }, y = {
        clipPath: n ? "url(#clipPath-".concat(i, ")") : null
      };
      return /* @__PURE__ */ O.createElement(st, y, h.map(function(C) {
        return /* @__PURE__ */ O.cloneElement(C, {
          key: "error-bar-".concat(i, "-").concat(C.props.dataKey),
          data: s,
          xAxis: a,
          yAxis: l,
          layout: u,
          offset: f,
          dataPointFormatter: p
        });
      }));
    }
  }, {
    key: "render",
    value: function() {
      var n = this.props, i = n.hide, o = n.data, s = n.className, a = n.xAxis, l = n.yAxis, u = n.left, d = n.top, h = n.width, f = n.height, p = n.isAnimationActive, y = n.background, C = n.id;
      if (i || !o || !o.length)
        return null;
      var v = this.state.isAnimationFinished, w = Ze("recharts-bar", s), R = a && a.allowDataOverflow, b = l && l.allowDataOverflow, P = R || b, S = _e(C) ? this.id : C;
      return /* @__PURE__ */ O.createElement(st, {
        className: w
      }, R || b ? /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-".concat(S)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: R ? u : u - h / 2,
        y: b ? d : d - f / 2,
        width: R ? h : h * 2,
        height: b ? f : f * 2
      }))) : null, /* @__PURE__ */ O.createElement(st, {
        className: "recharts-bar-rectangles",
        clipPath: P ? "url(#clipPath-".concat(S, ")") : null
      }, y ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(P, S), (!p || v) && oi.renderCallByParent(this.props, o));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(n, i) {
      return n.animationId !== i.prevAnimationId ? {
        prevAnimationId: n.animationId,
        curData: n.data,
        prevData: i.curData
      } : n.data !== i.curData ? {
        curData: n.data
      } : null;
    }
  }]);
}(ui);
iT = kt;
oo(kt, "displayName", "Bar");
oo(kt, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: !1,
  data: [],
  layout: "vertical",
  activeBar: !1,
  isAnimationActive: !So.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
oo(kt, "getComposedData", function(e) {
  var t = e.props, r = e.item, n = e.barPosition, i = e.bandSize, o = e.xAxis, s = e.yAxis, a = e.xAxisTicks, l = e.yAxisTicks, u = e.stackedData, d = e.dataStartIndex, h = e.displayedData, f = e.offset, p = gue(n, r);
  if (!p)
    return null;
  var y = t.layout, C = r.type.defaultProps, v = C !== void 0 ? Vt(Vt({}, C), r.props) : r.props, w = v.dataKey, R = v.children, b = v.minPointSize, P = y === "horizontal" ? s : o, S = u ? P.scale.domain() : null, E = bue({
    numericAxis: P
  }), A = Wr(R, _y), M = h.map(function(I, z) {
    var k, _, q, j, Q, K;
    u ? k = fue(u[d + z], S) : (k = Xt(I, w), Array.isArray(k) || (k = [E, k]));
    var Z = Ipe(b, iT.defaultProps.minPointSize)(k[1], z);
    if (y === "horizontal") {
      var te, se = [s.scale(k[0]), s.scale(k[1])], W = se[0], U = se[1];
      _ = nx({
        axis: o,
        ticks: a,
        bandSize: i,
        offset: p.offset,
        entry: I,
        index: z
      }), q = (te = U ?? W) !== null && te !== void 0 ? te : void 0, j = p.size;
      var X = W - U;
      if (Q = Number.isNaN(X) ? 0 : X, K = {
        x: _,
        y: s.y,
        width: j,
        height: s.height
      }, Math.abs(Z) > 0 && Math.abs(Q) < Math.abs(Z)) {
        var he = Gn(Q || Z) * (Math.abs(Z) - Math.abs(Q));
        q -= he, Q += he;
      }
    } else {
      var ce = [o.scale(k[0]), o.scale(k[1])], me = ce[0], ve = ce[1];
      if (_ = me, q = nx({
        axis: s,
        ticks: l,
        bandSize: i,
        offset: p.offset,
        entry: I,
        index: z
      }), j = ve - me, Q = p.size, K = {
        x: o.x,
        y: q,
        width: o.width,
        height: Q
      }, Math.abs(Z) > 0 && Math.abs(j) < Math.abs(Z)) {
        var Pe = Gn(j || Z) * (Math.abs(Z) - Math.abs(j));
        j += Pe;
      }
    }
    return Vt(Vt(Vt({}, I), {}, {
      x: _,
      y: q,
      width: j,
      height: Q,
      value: u ? k : k[1],
      payload: I,
      background: K
    }, A && A[z] && A[z].props), {}, {
      tooltipPayload: [HM(r, I)],
      tooltipPosition: {
        x: _ + j / 2,
        y: q + Q / 2
      }
    });
  });
  return Vt({
    data: M,
    layout: y
  }, f);
});
function Nc(e) {
  "@babel/helpers - typeof";
  return Nc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nc(e);
}
function $pe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, aT(n.key), n);
  }
}
function jpe(e, t, r) {
  return t && fR(e.prototype, t), r && fR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function pR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Ln(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pR(Object(r), !0).forEach(function(n) {
      Pg(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : pR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Pg(e, t, r) {
  return t = aT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function aT(e) {
  var t = Upe(e, "string");
  return Nc(t) == "symbol" ? t : t + "";
}
function Upe(e, t) {
  if (Nc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Nc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var lT = function(t, r, n, i, o) {
  var s = t.width, a = t.height, l = t.layout, u = t.children, d = Object.keys(r), h = {
    left: n.left,
    leftMirror: n.left,
    right: s - n.right,
    rightMirror: s - n.right,
    top: n.top,
    topMirror: n.top,
    bottom: a - n.bottom,
    bottomMirror: a - n.bottom
  }, f = !!Zr(u, kt);
  return d.reduce(function(p, y) {
    var C = r[y], v = C.orientation, w = C.domain, R = C.padding, b = R === void 0 ? {} : R, P = C.mirror, S = C.reversed, E = "".concat(v).concat(P ? "Mirror" : ""), A, M, I, z, k;
    if (C.type === "number" && (C.padding === "gap" || C.padding === "no-gap")) {
      var _ = w[1] - w[0], q = 1 / 0, j = C.categoricalDomain.sort(Zq);
      if (j.forEach(function(ce, me) {
        me > 0 && (q = Math.min((ce || 0) - (j[me - 1] || 0), q));
      }), Number.isFinite(q)) {
        var Q = q / _, K = C.layout === "vertical" ? n.height : n.width;
        if (C.padding === "gap" && (A = Q * K / 2), C.padding === "no-gap") {
          var Z = ds(t.barCategoryGap, Q * K), te = Q * K / 2;
          A = te - Z - (te - Z) / K * Z;
        }
      }
    }
    i === "xAxis" ? M = [n.left + (b.left || 0) + (A || 0), n.left + n.width - (b.right || 0) - (A || 0)] : i === "yAxis" ? M = l === "horizontal" ? [n.top + n.height - (b.bottom || 0), n.top + (b.top || 0)] : [n.top + (b.top || 0) + (A || 0), n.top + n.height - (b.bottom || 0) - (A || 0)] : M = C.range, S && (M = [M[1], M[0]]);
    var se = due(C, o, f), W = se.scale, U = se.realScaleType;
    W.domain(w).range(M), hue(W);
    var X = wue(W, Ln(Ln({}, C), {}, {
      realScaleType: U
    }));
    i === "xAxis" ? (k = v === "top" && !P || v === "bottom" && P, I = n.left, z = h[E] - k * C.height) : i === "yAxis" && (k = v === "left" && !P || v === "right" && P, I = h[E] - k * C.width, z = n.top);
    var he = Ln(Ln(Ln({}, C), X), {}, {
      realScaleType: U,
      x: I,
      y: z,
      scale: W,
      width: i === "xAxis" ? n.width : C.width,
      height: i === "yAxis" ? n.height : C.height
    });
    return he.bandSize = fh(he, X), !C.hide && i === "xAxis" ? h[E] += (k ? -1 : 1) * he.height : C.hide || (h[E] += (k ? -1 : 1) * he.width), Ln(Ln({}, p), {}, Pg({}, y, he));
  }, {});
}, cT = function(t, r) {
  var n = t.x, i = t.y, o = r.x, s = r.y;
  return {
    x: Math.min(n, o),
    y: Math.min(i, s),
    width: Math.abs(o - n),
    height: Math.abs(s - i)
  };
}, Kpe = function(t) {
  var r = t.x1, n = t.y1, i = t.x2, o = t.y2;
  return cT({
    x: r,
    y: n
  }, {
    x: i,
    y: o
  });
}, uT = /* @__PURE__ */ function() {
  function e(t) {
    $pe(this, e), this.scale = t;
  }
  return jpe(e, [{
    key: "domain",
    get: function() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.bandAware, o = n.position;
      if (r !== void 0) {
        if (o)
          switch (o) {
            case "start":
              return this.scale(r);
            case "middle": {
              var s = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(r) + s;
            }
            case "end": {
              var a = this.bandwidth ? this.bandwidth() : 0;
              return this.scale(r) + a;
            }
            default:
              return this.scale(r);
          }
        if (i) {
          var l = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(r) + l;
        }
        return this.scale(r);
      }
    }
  }, {
    key: "isInRange",
    value: function(r) {
      var n = this.range(), i = n[0], o = n[n.length - 1];
      return i <= o ? r >= i && r <= o : r >= o && r <= i;
    }
  }], [{
    key: "create",
    value: function(r) {
      return new e(r);
    }
  }]);
}();
Pg(uT, "EPS", 1e-4);
var uC = function(t) {
  var r = Object.keys(t).reduce(function(n, i) {
    return Ln(Ln({}, n), {}, Pg({}, i, uT.create(t[i])));
  }, {});
  return Ln(Ln({}, r), {}, {
    apply: function(i) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = o.bandAware, a = o.position;
      return hpe(i, function(l, u) {
        return r[u].apply(l, {
          bandAware: s,
          position: a
        });
      });
    },
    isInRange: function(i) {
      return Epe(i, function(o, s) {
        return r[s].isInRange(o);
      });
    }
  });
};
function qpe(e) {
  return (e % 180 + 180) % 180;
}
var Ype = function(t) {
  var r = t.width, n = t.height, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = qpe(i), s = o * Math.PI / 180, a = Math.atan(n / r), l = s > a && s < Math.PI - a ? n / Math.sin(s) : r / Math.cos(s);
  return Math.abs(l);
}, Jpe = rq(function(e) {
  return {
    x: e.left,
    y: e.top,
    width: e.width,
    height: e.height
  };
}, function(e) {
  return ["l", e.left, "t", e.top, "w", e.width, "h", e.height].join("");
});
function Mh(e) {
  "@babel/helpers - typeof";
  return Mh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mh(e);
}
var dT = /* @__PURE__ */ mo(void 0), hT = /* @__PURE__ */ mo(void 0), gT = /* @__PURE__ */ mo(void 0), Xpe = /* @__PURE__ */ mo({}), fT = /* @__PURE__ */ mo(void 0), pT = /* @__PURE__ */ mo(0), mT = /* @__PURE__ */ mo(0), mR = function(t) {
  var r = t.state, n = r.xAxisMap, i = r.yAxisMap, o = r.offset, s = t.clipPathId, a = t.children, l = t.width, u = t.height, d = Jpe(o);
  return /* @__PURE__ */ O.createElement(dT.Provider, {
    value: n
  }, /* @__PURE__ */ O.createElement(hT.Provider, {
    value: i
  }, /* @__PURE__ */ O.createElement(Xpe.Provider, {
    value: o
  }, /* @__PURE__ */ O.createElement(gT.Provider, {
    value: d
  }, /* @__PURE__ */ O.createElement(fT.Provider, {
    value: s
  }, /* @__PURE__ */ O.createElement(pT.Provider, {
    value: u
  }, /* @__PURE__ */ O.createElement(mT.Provider, {
    value: l
  }, a)))))));
}, Qpe = function() {
  return Wt(fT);
};
function vT(e) {
  var t = Object.keys(e);
  return t.length === 0 ? "There are no available ids." : "Available ids are: ".concat(t, ".");
}
var yT = function(t) {
  var r = Wt(dT);
  r == null && (process.env.NODE_ENV !== "production" ? Hr(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : Hr());
  var n = r[t];
  return n == null && (process.env.NODE_ENV !== "production" ? Hr(!1, 'Could not find xAxis by id "'.concat(t, '" [').concat(Mh(t), "]. ").concat(vT(r))) : Hr()), n;
}, CT = function(t) {
  var r = Wt(hT);
  r == null && (process.env.NODE_ENV !== "production" ? Hr(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : Hr());
  var n = r[t];
  return n == null && (process.env.NODE_ENV !== "production" ? Hr(!1, 'Could not find yAxis by id "'.concat(t, '" [').concat(Mh(t), "]. ").concat(vT(r))) : Hr()), n;
}, Zpe = function() {
  var t = Wt(gT);
  return t;
}, wT = function() {
  return Wt(mT);
}, bT = function() {
  return Wt(pT);
};
function Sa(e) {
  "@babel/helpers - typeof";
  return Sa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sa(e);
}
function eme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tme(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, xT(n.key), n);
  }
}
function rme(e, t, r) {
  return t && tme(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function nme(e, t, r) {
  return t = Th(t), ime(e, ST() ? Reflect.construct(t, r || [], Th(e).constructor) : t.apply(e, r));
}
function ime(e, t) {
  if (t && (Sa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return ome(e);
}
function ome(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ST() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (ST = function() {
    return !!e;
  })();
}
function Th(e) {
  return Th = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Th(e);
}
function sme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && jv(e, t);
}
function jv(e, t) {
  return jv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, jv(e, t);
}
function vR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function yR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vR(Object(r), !0).forEach(function(n) {
      dC(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : vR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function dC(e, t, r) {
  return t = xT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function xT(e) {
  var t = ame(e, "string");
  return Sa(t) == "symbol" ? t : t + "";
}
function ame(e, t) {
  if (Sa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Sa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function lme(e, t) {
  return hme(e) || dme(e, t) || ume(e, t) || cme();
}
function cme() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ume(e, t) {
  if (e) {
    if (typeof e == "string") return CR(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return CR(e, t);
  }
}
function CR(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function dme(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function hme(e) {
  if (Array.isArray(e)) return e;
}
function Uv() {
  return Uv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Uv.apply(this, arguments);
}
var gme = function(t, r) {
  var n;
  return /* @__PURE__ */ O.isValidElement(t) ? n = /* @__PURE__ */ O.cloneElement(t, r) : We(t) ? n = t(r) : n = /* @__PURE__ */ O.createElement("line", Uv({}, r, {
    className: "recharts-reference-line-line"
  })), n;
}, fme = function(t, r, n, i, o, s, a, l, u) {
  var d = o.x, h = o.y, f = o.width, p = o.height;
  if (n) {
    var y = u.y, C = t.y.apply(y, {
      position: s
    });
    if (si(u, "discard") && !t.y.isInRange(C))
      return null;
    var v = [{
      x: d + f,
      y: C
    }, {
      x: d,
      y: C
    }];
    return l === "left" ? v.reverse() : v;
  }
  if (r) {
    var w = u.x, R = t.x.apply(w, {
      position: s
    });
    if (si(u, "discard") && !t.x.isInRange(R))
      return null;
    var b = [{
      x: R,
      y: h + p
    }, {
      x: R,
      y: h
    }];
    return a === "top" ? b.reverse() : b;
  }
  if (i) {
    var P = u.segment, S = P.map(function(E) {
      return t.apply(E, {
        position: s
      });
    });
    return si(u, "discard") && ipe(S, function(E) {
      return !t.isInRange(E);
    }) ? null : S;
  }
  return null;
};
function pme(e) {
  var t = e.x, r = e.y, n = e.segment, i = e.xAxisId, o = e.yAxisId, s = e.shape, a = e.className, l = e.alwaysShow, u = Qpe(), d = yT(i), h = CT(o), f = Zpe();
  if (!u || !f)
    return null;
  og(l === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var p = uC({
    x: d.scale,
    y: h.scale
  }), y = Jt(t), C = Jt(r), v = n && n.length === 2, w = fme(p, y, C, v, f, e.position, d.orientation, h.orientation, e);
  if (!w)
    return null;
  var R = lme(w, 2), b = R[0], P = b.x, S = b.y, E = R[1], A = E.x, M = E.y, I = si(e, "hidden") ? "url(#".concat(u, ")") : void 0, z = yR(yR({
    clipPath: I
  }, Ne(e, !0)), {}, {
    x1: P,
    y1: S,
    x2: A,
    y2: M
  });
  return /* @__PURE__ */ O.createElement(st, {
    className: Ze("recharts-reference-line", a)
  }, gme(s, z), fr.renderCallByParent(e, Kpe({
    x1: P,
    y1: S,
    x2: A,
    y2: M
  })));
}
var hC = /* @__PURE__ */ function(e) {
  function t() {
    return eme(this, t), nme(this, t, arguments);
  }
  return sme(t, e), rme(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ O.createElement(pme, this.props);
    }
  }]);
}(O.Component);
dC(hC, "displayName", "ReferenceLine");
dC(hC, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
});
function Kv() {
  return Kv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Kv.apply(this, arguments);
}
function xa(e) {
  "@babel/helpers - typeof";
  return xa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xa(e);
}
function wR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function bR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wR(Object(r), !0).forEach(function(n) {
      Ag(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : wR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function mme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vme(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, ET(n.key), n);
  }
}
function yme(e, t, r) {
  return t && vme(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Cme(e, t, r) {
  return t = Dh(t), wme(e, RT() ? Reflect.construct(t, r || [], Dh(e).constructor) : t.apply(e, r));
}
function wme(e, t) {
  if (t && (xa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return bme(e);
}
function bme(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function RT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (RT = function() {
    return !!e;
  })();
}
function Dh(e) {
  return Dh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Dh(e);
}
function Sme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && qv(e, t);
}
function qv(e, t) {
  return qv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, qv(e, t);
}
function Ag(e, t, r) {
  return t = ET(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function ET(e) {
  var t = xme(e, "string");
  return xa(t) == "symbol" ? t : t + "";
}
function xme(e, t) {
  if (xa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (xa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Rme = function(t) {
  var r = t.x, n = t.y, i = t.xAxis, o = t.yAxis, s = uC({
    x: i.scale,
    y: o.scale
  }), a = s.apply({
    x: r,
    y: n
  }, {
    bandAware: !0
  });
  return si(t, "discard") && !s.isInRange(a) ? null : a;
}, Fg = /* @__PURE__ */ function(e) {
  function t() {
    return mme(this, t), Cme(this, t, arguments);
  }
  return Sme(t, e), yme(t, [{
    key: "render",
    value: function() {
      var n = this.props, i = n.x, o = n.y, s = n.r, a = n.alwaysShow, l = n.clipPathId, u = Jt(i), d = Jt(o);
      if (og(a === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !u || !d)
        return null;
      var h = Rme(this.props);
      if (!h)
        return null;
      var f = h.x, p = h.y, y = this.props, C = y.shape, v = y.className, w = si(this.props, "hidden") ? "url(#".concat(l, ")") : void 0, R = bR(bR({
        clipPath: w
      }, Ne(this.props, !0)), {}, {
        cx: f,
        cy: p
      });
      return /* @__PURE__ */ O.createElement(st, {
        className: Ze("recharts-reference-dot", v)
      }, t.renderDot(C, R), fr.renderCallByParent(this.props, {
        x: f - s,
        y: p - s,
        width: 2 * s,
        height: 2 * s
      }));
    }
  }]);
}(O.Component);
Ag(Fg, "displayName", "ReferenceDot");
Ag(Fg, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
});
Ag(Fg, "renderDot", function(e, t) {
  var r;
  return /* @__PURE__ */ O.isValidElement(e) ? r = /* @__PURE__ */ O.cloneElement(e, t) : We(e) ? r = e(t) : r = /* @__PURE__ */ O.createElement(xg, Kv({}, t, {
    cx: t.cx,
    cy: t.cy,
    className: "recharts-reference-dot-dot"
  })), r;
});
function Yv() {
  return Yv = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Yv.apply(this, arguments);
}
function Ra(e) {
  "@babel/helpers - typeof";
  return Ra = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ra(e);
}
function SR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function xR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SR(Object(r), !0).forEach(function(n) {
      Mg(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : SR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Eme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Pme(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, AT(n.key), n);
  }
}
function Ame(e, t, r) {
  return t && Pme(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Fme(e, t, r) {
  return t = Oh(t), Mme(e, PT() ? Reflect.construct(t, r || [], Oh(e).constructor) : t.apply(e, r));
}
function Mme(e, t) {
  if (t && (Ra(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Tme(e);
}
function Tme(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function PT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (PT = function() {
    return !!e;
  })();
}
function Oh(e) {
  return Oh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Oh(e);
}
function Dme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Jv(e, t);
}
function Jv(e, t) {
  return Jv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Jv(e, t);
}
function Mg(e, t, r) {
  return t = AT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function AT(e) {
  var t = Ome(e, "string");
  return Ra(t) == "symbol" ? t : t + "";
}
function Ome(e, t) {
  if (Ra(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ra(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Ime = function(t, r, n, i, o) {
  var s = o.x1, a = o.x2, l = o.y1, u = o.y2, d = o.xAxis, h = o.yAxis;
  if (!d || !h) return null;
  var f = uC({
    x: d.scale,
    y: h.scale
  }), p = {
    x: t ? f.x.apply(s, {
      position: "start"
    }) : f.x.rangeMin,
    y: n ? f.y.apply(l, {
      position: "start"
    }) : f.y.rangeMin
  }, y = {
    x: r ? f.x.apply(a, {
      position: "end"
    }) : f.x.rangeMax,
    y: i ? f.y.apply(u, {
      position: "end"
    }) : f.y.rangeMax
  };
  return si(o, "discard") && (!f.isInRange(p) || !f.isInRange(y)) ? null : cT(p, y);
}, Tg = /* @__PURE__ */ function(e) {
  function t() {
    return Eme(this, t), Fme(this, t, arguments);
  }
  return Dme(t, e), Ame(t, [{
    key: "render",
    value: function() {
      var n = this.props, i = n.x1, o = n.x2, s = n.y1, a = n.y2, l = n.className, u = n.alwaysShow, d = n.clipPathId;
      og(u === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      var h = Jt(i), f = Jt(o), p = Jt(s), y = Jt(a), C = this.props.shape;
      if (!h && !f && !p && !y && !C)
        return null;
      var v = Ime(h, f, p, y, this.props);
      if (!v && !C)
        return null;
      var w = si(this.props, "hidden") ? "url(#".concat(d, ")") : void 0;
      return /* @__PURE__ */ O.createElement(st, {
        className: Ze("recharts-reference-area", l)
      }, t.renderRect(C, xR(xR({
        clipPath: w
      }, Ne(this.props, !0)), v)), fr.renderCallByParent(this.props, v));
    }
  }]);
}(O.Component);
Mg(Tg, "displayName", "ReferenceArea");
Mg(Tg, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
});
Mg(Tg, "renderRect", function(e, t) {
  var r;
  return /* @__PURE__ */ O.isValidElement(e) ? r = /* @__PURE__ */ O.cloneElement(e, t) : We(e) ? r = e(t) : r = /* @__PURE__ */ O.createElement(cC, Yv({}, t, {
    className: "recharts-reference-area-rect"
  })), r;
});
function FT(e, t, r) {
  if (t < 1)
    return [];
  if (t === 1 && r === void 0)
    return e;
  for (var n = [], i = 0; i < e.length; i += t)
    n.push(e[i]);
  return n;
}
function kme(e, t, r) {
  var n = {
    width: e.width + t.width,
    height: e.height + t.height
  };
  return Ype(n, r);
}
function Lme(e, t, r) {
  var n = r === "width", i = e.x, o = e.y, s = e.width, a = e.height;
  return t === 1 ? {
    start: n ? i : o,
    end: n ? i + s : o + a
  } : {
    start: n ? i + s : o + a,
    end: n ? i : o
  };
}
function Ih(e, t, r, n, i) {
  if (e * t < e * n || e * t > e * i)
    return !1;
  var o = r();
  return e * (t - e * o / 2 - n) >= 0 && e * (t + e * o / 2 - i) <= 0;
}
function _me(e, t) {
  return FT(e, t + 1);
}
function zme(e, t, r, n, i) {
  for (var o = (n || []).slice(), s = t.start, a = t.end, l = 0, u = 1, d = s, h = function() {
    var y = n == null ? void 0 : n[l];
    if (y === void 0)
      return {
        v: FT(n, u)
      };
    var C = l, v, w = function() {
      return v === void 0 && (v = r(y, C)), v;
    }, R = y.coordinate, b = l === 0 || Ih(e, R, w, d, a);
    b || (l = 0, d = s, u += 1), b && (d = R + e * (w() / 2 + i), l += u);
  }, f; u <= o.length; )
    if (f = h(), f) return f.v;
  return [];
}
function Bc(e) {
  "@babel/helpers - typeof";
  return Bc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bc(e);
}
function RR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function dr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RR(Object(r), !0).forEach(function(n) {
      Nme(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : RR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Nme(e, t, r) {
  return t = Bme(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Bme(e) {
  var t = Gme(e, "string");
  return Bc(t) == "symbol" ? t : t + "";
}
function Gme(e, t) {
  if (Bc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Bc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Hme(e, t, r, n, i) {
  for (var o = (n || []).slice(), s = o.length, a = t.start, l = t.end, u = function(f) {
    var p = o[f], y, C = function() {
      return y === void 0 && (y = r(p, f)), y;
    };
    if (f === s - 1) {
      var v = e * (p.coordinate + e * C() / 2 - l);
      o[f] = p = dr(dr({}, p), {}, {
        tickCoord: v > 0 ? p.coordinate - v * e : p.coordinate
      });
    } else
      o[f] = p = dr(dr({}, p), {}, {
        tickCoord: p.coordinate
      });
    var w = Ih(e, p.tickCoord, C, a, l);
    w && (l = p.tickCoord - e * (C() / 2 + i), o[f] = dr(dr({}, p), {}, {
      isShow: !0
    }));
  }, d = s - 1; d >= 0; d--)
    u(d);
  return o;
}
function Wme(e, t, r, n, i, o) {
  var s = (n || []).slice(), a = s.length, l = t.start, u = t.end;
  if (o) {
    var d = n[a - 1], h = r(d, a - 1), f = e * (d.coordinate + e * h / 2 - u);
    s[a - 1] = d = dr(dr({}, d), {}, {
      tickCoord: f > 0 ? d.coordinate - f * e : d.coordinate
    });
    var p = Ih(e, d.tickCoord, function() {
      return h;
    }, l, u);
    p && (u = d.tickCoord - e * (h / 2 + i), s[a - 1] = dr(dr({}, d), {}, {
      isShow: !0
    }));
  }
  for (var y = o ? a - 1 : a, C = function(R) {
    var b = s[R], P, S = function() {
      return P === void 0 && (P = r(b, R)), P;
    };
    if (R === 0) {
      var E = e * (b.coordinate - e * S() / 2 - l);
      s[R] = b = dr(dr({}, b), {}, {
        tickCoord: E < 0 ? b.coordinate - E * e : b.coordinate
      });
    } else
      s[R] = b = dr(dr({}, b), {}, {
        tickCoord: b.coordinate
      });
    var A = Ih(e, b.tickCoord, S, l, u);
    A && (l = b.tickCoord + e * (S() / 2 + i), s[R] = dr(dr({}, b), {}, {
      isShow: !0
    }));
  }, v = 0; v < y; v++)
    C(v);
  return s;
}
function Vme(e, t, r) {
  var n = e.tick, i = e.ticks, o = e.viewBox, s = e.minTickGap, a = e.orientation, l = e.interval, u = e.tickFormatter, d = e.unit, h = e.angle;
  if (!i || !i.length || !n)
    return [];
  if (Ce(l) || So.isSsr)
    return _me(i, typeof l == "number" && Ce(l) ? l : 0);
  var f = [], p = a === "top" || a === "bottom" ? "width" : "height", y = d && p === "width" ? Kl(d, {
    fontSize: t,
    letterSpacing: r
  }) : {
    width: 0,
    height: 0
  }, C = function(b, P) {
    var S = We(u) ? u(b.value, P) : b.value;
    return p === "width" ? kme(Kl(S, {
      fontSize: t,
      letterSpacing: r
    }), y, h) : Kl(S, {
      fontSize: t,
      letterSpacing: r
    })[p];
  }, v = i.length >= 2 ? Gn(i[1].coordinate - i[0].coordinate) : 1, w = Lme(o, v, p);
  return l === "equidistantPreserveStart" ? zme(v, w, C, i, s) : (l === "preserveStart" || l === "preserveStartEnd" ? f = Wme(v, w, C, i, s, l === "preserveStartEnd") : f = Hme(v, w, C, i, s), f.filter(function(R) {
    return R.isShow;
  }));
}
var $me = ["viewBox"], jme = ["viewBox"], Ume = ["ticks"];
function Ea(e) {
  "@babel/helpers - typeof";
  return Ea = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ea(e);
}
function Us() {
  return Us = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Us.apply(this, arguments);
}
function ER(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Rr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ER(Object(r), !0).forEach(function(n) {
      gC(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ER(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function nm(e, t) {
  if (e == null) return {};
  var r = Kme(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Kme(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function qme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, TT(n.key), n);
  }
}
function Yme(e, t, r) {
  return t && PR(e.prototype, t), r && PR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Jme(e, t, r) {
  return t = kh(t), Xme(e, MT() ? Reflect.construct(t, r || [], kh(e).constructor) : t.apply(e, r));
}
function Xme(e, t) {
  if (t && (Ea(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Qme(e);
}
function Qme(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function MT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (MT = function() {
    return !!e;
  })();
}
function kh(e) {
  return kh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, kh(e);
}
function Zme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Xv(e, t);
}
function Xv(e, t) {
  return Xv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Xv(e, t);
}
function gC(e, t, r) {
  return t = TT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function TT(e) {
  var t = eve(e, "string");
  return Ea(t) == "symbol" ? t : t + "";
}
function eve(e, t) {
  if (Ea(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ea(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Dg = /* @__PURE__ */ function(e) {
  function t(r) {
    var n;
    return qme(this, t), n = Jme(this, t, [r]), n.state = {
      fontSize: "",
      letterSpacing: ""
    }, n;
  }
  return Zme(t, e), Yme(t, [{
    key: "shouldComponentUpdate",
    value: function(n, i) {
      var o = n.viewBox, s = nm(n, $me), a = this.props, l = a.viewBox, u = nm(a, jme);
      return !Zs(o, l) || !Zs(s, u) || !Zs(i, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function() {
      var n = this.layerReference;
      if (n) {
        var i = n.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
        i && this.setState({
          fontSize: window.getComputedStyle(i).fontSize,
          letterSpacing: window.getComputedStyle(i).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function(n) {
      var i = this.props, o = i.x, s = i.y, a = i.width, l = i.height, u = i.orientation, d = i.tickSize, h = i.mirror, f = i.tickMargin, p, y, C, v, w, R, b = h ? -1 : 1, P = n.tickSize || d, S = Ce(n.tickCoord) ? n.tickCoord : n.coordinate;
      switch (u) {
        case "top":
          p = y = n.coordinate, v = s + +!h * l, C = v - b * P, R = C - b * f, w = S;
          break;
        case "left":
          C = v = n.coordinate, y = o + +!h * a, p = y - b * P, w = p - b * f, R = S;
          break;
        case "right":
          C = v = n.coordinate, y = o + +h * a, p = y + b * P, w = p + b * f, R = S;
          break;
        default:
          p = y = n.coordinate, v = s + +h * l, C = v + b * P, R = C + b * f, w = S;
          break;
      }
      return {
        line: {
          x1: p,
          y1: C,
          x2: y,
          y2: v
        },
        tick: {
          x: w,
          y: R
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function() {
      var n = this.props, i = n.orientation, o = n.mirror, s;
      switch (i) {
        case "left":
          s = o ? "start" : "end";
          break;
        case "right":
          s = o ? "end" : "start";
          break;
        default:
          s = "middle";
          break;
      }
      return s;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function() {
      var n = this.props, i = n.orientation, o = n.mirror, s = "end";
      switch (i) {
        case "left":
        case "right":
          s = "middle";
          break;
        case "top":
          s = o ? "start" : "end";
          break;
        default:
          s = o ? "end" : "start";
          break;
      }
      return s;
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var n = this.props, i = n.x, o = n.y, s = n.width, a = n.height, l = n.orientation, u = n.mirror, d = n.axisLine, h = Rr(Rr(Rr({}, Ne(this.props, !1)), Ne(d, !1)), {}, {
        fill: "none"
      });
      if (l === "top" || l === "bottom") {
        var f = +(l === "top" && !u || l === "bottom" && u);
        h = Rr(Rr({}, h), {}, {
          x1: i,
          y1: o + f * a,
          x2: i + s,
          y2: o + f * a
        });
      } else {
        var p = +(l === "left" && !u || l === "right" && u);
        h = Rr(Rr({}, h), {}, {
          x1: i + p * s,
          y1: o,
          x2: i + p * s,
          y2: o + a
        });
      }
      return /* @__PURE__ */ O.createElement("line", Us({}, h, {
        className: Ze("recharts-cartesian-axis-line", En(d, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function(n, i, o) {
        var s = this, a = this.props, l = a.tickLine, u = a.stroke, d = a.tick, h = a.tickFormatter, f = a.unit, p = Vme(Rr(Rr({}, this.props), {}, {
          ticks: n
        }), i, o), y = this.getTickTextAnchor(), C = this.getTickVerticalAnchor(), v = Ne(this.props, !1), w = Ne(d, !1), R = Rr(Rr({}, v), {}, {
          fill: "none"
        }, Ne(l, !1)), b = p.map(function(P, S) {
          var E = s.getTickLineCoord(P), A = E.line, M = E.tick, I = Rr(Rr(Rr(Rr({
            textAnchor: y,
            verticalAnchor: C
          }, v), {}, {
            stroke: "none",
            fill: u
          }, w), M), {}, {
            index: S,
            payload: P,
            visibleTicksCount: p.length,
            tickFormatter: h
          });
          return /* @__PURE__ */ O.createElement(st, Us({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(P.value, "-").concat(P.coordinate, "-").concat(P.tickCoord)
          }, lc(s.props, P, S)), l && /* @__PURE__ */ O.createElement("line", Us({}, R, A, {
            className: Ze("recharts-cartesian-axis-tick-line", En(l, "className"))
          })), d && t.renderTickItem(d, I, "".concat(We(h) ? h(P.value, S) : P.value).concat(f || "")));
        });
        return /* @__PURE__ */ O.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, b);
      }
    )
  }, {
    key: "render",
    value: function() {
      var n = this, i = this.props, o = i.axisLine, s = i.width, a = i.height, l = i.ticksGenerator, u = i.className, d = i.hide;
      if (d)
        return null;
      var h = this.props, f = h.ticks, p = nm(h, Ume), y = f;
      return We(l) && (y = f && f.length > 0 ? l(this.props) : l(p)), s <= 0 || a <= 0 || !y || !y.length ? null : /* @__PURE__ */ O.createElement(st, {
        className: Ze("recharts-cartesian-axis", u),
        ref: function(v) {
          n.layerReference = v;
        }
      }, o && this.renderAxisLine(), this.renderTicks(y, this.state.fontSize, this.state.letterSpacing), fr.renderCallByParent(this.props));
    }
  }], [{
    key: "renderTickItem",
    value: function(n, i, o) {
      var s;
      return /* @__PURE__ */ O.isValidElement(n) ? s = /* @__PURE__ */ O.cloneElement(n, i) : We(n) ? s = n(i) : s = /* @__PURE__ */ O.createElement(eh, Us({}, i, {
        className: "recharts-cartesian-axis-tick-value"
      }), o), s;
    }
  }]);
}(R0);
gC(Dg, "displayName", "CartesianAxis");
gC(Dg, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var tve = ["type", "layout", "connectNulls", "ref"], rve = ["key"];
function Pa(e) {
  "@babel/helpers - typeof";
  return Pa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pa(e);
}
function AR(e, t) {
  if (e == null) return {};
  var r = nve(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function nve(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Xl() {
  return Xl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Xl.apply(this, arguments);
}
function FR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Xr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FR(Object(r), !0).forEach(function(n) {
      _n(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : FR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Gs(e) {
  return ave(e) || sve(e) || ove(e) || ive();
}
function ive() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ove(e, t) {
  if (e) {
    if (typeof e == "string") return Qv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Qv(e, t);
  }
}
function sve(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function ave(e) {
  if (Array.isArray(e)) return Qv(e);
}
function Qv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function lve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function MR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, OT(n.key), n);
  }
}
function cve(e, t, r) {
  return t && MR(e.prototype, t), r && MR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function uve(e, t, r) {
  return t = Lh(t), dve(e, DT() ? Reflect.construct(t, r || [], Lh(e).constructor) : t.apply(e, r));
}
function dve(e, t) {
  if (t && (Pa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return hve(e);
}
function hve(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function DT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (DT = function() {
    return !!e;
  })();
}
function Lh(e) {
  return Lh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Lh(e);
}
function gve(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Zv(e, t);
}
function Zv(e, t) {
  return Zv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Zv(e, t);
}
function _n(e, t, r) {
  return t = OT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function OT(e) {
  var t = fve(e, "string");
  return Pa(t) == "symbol" ? t : t + "";
}
function fve(e, t) {
  if (Pa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Pa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Qn = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    lve(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = uve(this, t, [].concat(i)), _n(r, "state", {
      isAnimationFinished: !0,
      totalLength: 0
    }), _n(r, "generateSimpleStrokeDasharray", function(s, a) {
      return "".concat(a, "px ").concat(s - a, "px");
    }), _n(r, "getStrokeDasharray", function(s, a, l) {
      var u = l.reduce(function(w, R) {
        return w + R;
      });
      if (!u)
        return r.generateSimpleStrokeDasharray(a, s);
      for (var d = Math.floor(s / u), h = s % u, f = a - s, p = [], y = 0, C = 0; y < l.length; C += l[y], ++y)
        if (C + l[y] > h) {
          p = [].concat(Gs(l.slice(0, y)), [h - C]);
          break;
        }
      var v = p.length % 2 === 0 ? [0, f] : [f];
      return [].concat(Gs(t.repeat(l, d)), Gs(p), v).map(function(w) {
        return "".concat(w, "px");
      }).join(", ");
    }), _n(r, "id", Cs("recharts-line-")), _n(r, "pathRef", function(s) {
      r.mainCurve = s;
    }), _n(r, "handleAnimationEnd", function() {
      r.setState({
        isAnimationFinished: !0
      }), r.props.onAnimationEnd && r.props.onAnimationEnd();
    }), _n(r, "handleAnimationStart", function() {
      r.setState({
        isAnimationFinished: !1
      }), r.props.onAnimationStart && r.props.onAnimationStart();
    }), r;
  }
  return gve(t, e), cve(t, [{
    key: "componentDidMount",
    value: function() {
      if (this.props.isAnimationActive) {
        var n = this.getTotalLength();
        this.setState({
          totalLength: n
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      if (this.props.isAnimationActive) {
        var n = this.getTotalLength();
        n !== this.state.totalLength && this.setState({
          totalLength: n
        });
      }
    }
  }, {
    key: "getTotalLength",
    value: function() {
      var n = this.mainCurve;
      try {
        return n && n.getTotalLength && n.getTotalLength() || 0;
      } catch {
        return 0;
      }
    }
  }, {
    key: "renderErrorBar",
    value: function(n, i) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished)
        return null;
      var o = this.props, s = o.points, a = o.xAxis, l = o.yAxis, u = o.layout, d = o.children, h = Wr(d, il);
      if (!h)
        return null;
      var f = function(C, v) {
        return {
          x: C.x,
          y: C.y,
          value: C.value,
          errorVal: Xt(C.payload, v)
        };
      }, p = {
        clipPath: n ? "url(#clipPath-".concat(i, ")") : null
      };
      return /* @__PURE__ */ O.createElement(st, p, h.map(function(y) {
        return /* @__PURE__ */ O.cloneElement(y, {
          key: "bar-".concat(y.props.dataKey),
          data: s,
          xAxis: a,
          yAxis: l,
          layout: u,
          dataPointFormatter: f
        });
      }));
    }
  }, {
    key: "renderDots",
    value: function(n, i, o) {
      var s = this.props.isAnimationActive;
      if (s && !this.state.isAnimationFinished)
        return null;
      var a = this.props, l = a.dot, u = a.points, d = a.dataKey, h = Ne(this.props, !1), f = Ne(l, !0), p = u.map(function(C, v) {
        var w = Xr(Xr(Xr({
          key: "dot-".concat(v),
          r: 3
        }, h), f), {}, {
          index: v,
          cx: C.x,
          cy: C.y,
          value: C.value,
          dataKey: d,
          payload: C.payload,
          points: u
        });
        return t.renderDotItem(l, w);
      }), y = {
        clipPath: n ? "url(#clipPath-".concat(i ? "" : "dots-").concat(o, ")") : null
      };
      return /* @__PURE__ */ O.createElement(st, Xl({
        className: "recharts-line-dots",
        key: "dots"
      }, y), p);
    }
  }, {
    key: "renderCurveStatically",
    value: function(n, i, o, s) {
      var a = this.props, l = a.type, u = a.layout, d = a.connectNulls;
      a.ref;
      var h = AR(a, tve), f = Xr(Xr(Xr({}, Ne(h, !0)), {}, {
        fill: "none",
        className: "recharts-line-curve",
        clipPath: i ? "url(#clipPath-".concat(o, ")") : null,
        points: n
      }, s), {}, {
        type: l,
        layout: u,
        connectNulls: d
      });
      return /* @__PURE__ */ O.createElement(os, Xl({}, f, {
        pathRef: this.pathRef
      }));
    }
  }, {
    key: "renderCurveWithAnimation",
    value: function(n, i) {
      var o = this, s = this.props, a = s.points, l = s.strokeDasharray, u = s.isAnimationActive, d = s.animationBegin, h = s.animationDuration, f = s.animationEasing, p = s.animationId, y = s.animateNewValues, C = s.width, v = s.height, w = this.state, R = w.prevPoints, b = w.totalLength;
      return /* @__PURE__ */ O.createElement($n, {
        begin: d,
        duration: h,
        isActive: u,
        easing: f,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "line-".concat(p),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(P) {
        var S = P.t;
        if (R) {
          var E = R.length / a.length, A = a.map(function(_, q) {
            var j = Math.floor(q * E);
            if (R[j]) {
              var Q = R[j], K = Ht(Q.x, _.x), Z = Ht(Q.y, _.y);
              return Xr(Xr({}, _), {}, {
                x: K(S),
                y: Z(S)
              });
            }
            if (y) {
              var te = Ht(C * 2, _.x), se = Ht(v / 2, _.y);
              return Xr(Xr({}, _), {}, {
                x: te(S),
                y: se(S)
              });
            }
            return Xr(Xr({}, _), {}, {
              x: _.x,
              y: _.y
            });
          });
          return o.renderCurveStatically(A, n, i);
        }
        var M = Ht(0, b), I = M(S), z;
        if (l) {
          var k = "".concat(l).split(/[,\s]+/gim).map(function(_) {
            return parseFloat(_);
          });
          z = o.getStrokeDasharray(I, b, k);
        } else
          z = o.generateSimpleStrokeDasharray(b, I);
        return o.renderCurveStatically(a, n, i, {
          strokeDasharray: z
        });
      });
    }
  }, {
    key: "renderCurve",
    value: function(n, i) {
      var o = this.props, s = o.points, a = o.isAnimationActive, l = this.state, u = l.prevPoints, d = l.totalLength;
      return a && s && s.length && (!u && d > 0 || !hs(u, s)) ? this.renderCurveWithAnimation(n, i) : this.renderCurveStatically(s, n, i);
    }
  }, {
    key: "render",
    value: function() {
      var n, i = this.props, o = i.hide, s = i.dot, a = i.points, l = i.className, u = i.xAxis, d = i.yAxis, h = i.top, f = i.left, p = i.width, y = i.height, C = i.isAnimationActive, v = i.id;
      if (o || !a || !a.length)
        return null;
      var w = this.state.isAnimationFinished, R = a.length === 1, b = Ze("recharts-line", l), P = u && u.allowDataOverflow, S = d && d.allowDataOverflow, E = P || S, A = _e(v) ? this.id : v, M = (n = Ne(s, !1)) !== null && n !== void 0 ? n : {
        r: 3,
        strokeWidth: 2
      }, I = M.r, z = I === void 0 ? 3 : I, k = M.strokeWidth, _ = k === void 0 ? 2 : k, q = LA(s) ? s : {}, j = q.clipDot, Q = j === void 0 ? !0 : j, K = z * 2 + _;
      return /* @__PURE__ */ O.createElement(st, {
        className: b
      }, P || S ? /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-".concat(A)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: P ? f : f - p / 2,
        y: S ? h : h - y / 2,
        width: P ? p : p * 2,
        height: S ? y : y * 2
      })), !Q && /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-dots-".concat(A)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: f - K / 2,
        y: h - K / 2,
        width: p + K,
        height: y + K
      }))) : null, !R && this.renderCurve(E, A), this.renderErrorBar(E, A), (R || s) && this.renderDots(E, Q, A), (!C || w) && oi.renderCallByParent(this.props, a));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(n, i) {
      return n.animationId !== i.prevAnimationId ? {
        prevAnimationId: n.animationId,
        curPoints: n.points,
        prevPoints: i.curPoints
      } : n.points !== i.curPoints ? {
        curPoints: n.points
      } : null;
    }
  }, {
    key: "repeat",
    value: function(n, i) {
      for (var o = n.length % 2 !== 0 ? [].concat(Gs(n), [0]) : n, s = [], a = 0; a < i; ++a)
        s = [].concat(Gs(s), Gs(o));
      return s;
    }
  }, {
    key: "renderDotItem",
    value: function(n, i) {
      var o;
      if (/* @__PURE__ */ O.isValidElement(n))
        o = /* @__PURE__ */ O.cloneElement(n, i);
      else if (We(n))
        o = n(i);
      else {
        var s = i.key, a = AR(i, rve), l = Ze("recharts-line-dot", typeof n != "boolean" ? n.className : "");
        o = /* @__PURE__ */ O.createElement(xg, Xl({
          key: s
        }, a, {
          className: l
        }));
      }
      return o;
    }
  }]);
}(ui);
_n(Qn, "displayName", "Line");
_n(Qn, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  connectNulls: !1,
  activeDot: !0,
  dot: !0,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  fill: "#fff",
  points: [],
  isAnimationActive: !So.isSsr,
  animateNewValues: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  hide: !1,
  label: !1
});
_n(Qn, "getComposedData", function(e) {
  var t = e.props, r = e.xAxis, n = e.yAxis, i = e.xAxisTicks, o = e.yAxisTicks, s = e.dataKey, a = e.bandSize, l = e.displayedData, u = e.offset, d = t.layout, h = l.map(function(f, p) {
    var y = Xt(f, s);
    return d === "horizontal" ? {
      x: ma({
        axis: r,
        ticks: i,
        bandSize: a,
        entry: f,
        index: p
      }),
      y: _e(y) ? null : n.scale(y),
      value: y,
      payload: f
    } : {
      x: _e(y) ? null : r.scale(y),
      y: ma({
        axis: n,
        ticks: o,
        bandSize: a,
        entry: f,
        index: p
      }),
      value: y,
      payload: f
    };
  });
  return Xr({
    points: h,
    layout: d
  }, u);
});
var pve = ["layout", "type", "stroke", "connectNulls", "isRange", "ref"], mve = ["key"], IT;
function Aa(e) {
  "@babel/helpers - typeof";
  return Aa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Aa(e);
}
function kT(e, t) {
  if (e == null) return {};
  var r = vve(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function vve(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function Jo() {
  return Jo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Jo.apply(this, arguments);
}
function TR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function to(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TR(Object(r), !0).forEach(function(n) {
      ti(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : TR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function yve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, _T(n.key), n);
  }
}
function Cve(e, t, r) {
  return t && DR(e.prototype, t), r && DR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function wve(e, t, r) {
  return t = _h(t), bve(e, LT() ? Reflect.construct(t, r || [], _h(e).constructor) : t.apply(e, r));
}
function bve(e, t) {
  if (t && (Aa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Sve(e);
}
function Sve(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function LT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (LT = function() {
    return !!e;
  })();
}
function _h(e) {
  return _h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, _h(e);
}
function xve(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && e0(e, t);
}
function e0(e, t) {
  return e0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, e0(e, t);
}
function ti(e, t, r) {
  return t = _T(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function _T(e) {
  var t = Rve(e, "string");
  return Aa(t) == "symbol" ? t : t + "";
}
function Rve(e, t) {
  if (Aa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Aa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Nr = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    yve(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = wve(this, t, [].concat(i)), ti(r, "state", {
      isAnimationFinished: !0
    }), ti(r, "id", Cs("recharts-area-")), ti(r, "handleAnimationEnd", function() {
      var s = r.props.onAnimationEnd;
      r.setState({
        isAnimationFinished: !0
      }), We(s) && s();
    }), ti(r, "handleAnimationStart", function() {
      var s = r.props.onAnimationStart;
      r.setState({
        isAnimationFinished: !1
      }), We(s) && s();
    }), r;
  }
  return xve(t, e), Cve(t, [{
    key: "renderDots",
    value: function(n, i, o) {
      var s = this.props.isAnimationActive, a = this.state.isAnimationFinished;
      if (s && !a)
        return null;
      var l = this.props, u = l.dot, d = l.points, h = l.dataKey, f = Ne(this.props, !1), p = Ne(u, !0), y = d.map(function(v, w) {
        var R = to(to(to({
          key: "dot-".concat(w),
          r: 3
        }, f), p), {}, {
          index: w,
          cx: v.x,
          cy: v.y,
          dataKey: h,
          value: v.value,
          payload: v.payload,
          points: d
        });
        return t.renderDotItem(u, R);
      }), C = {
        clipPath: n ? "url(#clipPath-".concat(i ? "" : "dots-").concat(o, ")") : null
      };
      return /* @__PURE__ */ O.createElement(st, Jo({
        className: "recharts-area-dots"
      }, C), y);
    }
  }, {
    key: "renderHorizontalRect",
    value: function(n) {
      var i = this.props, o = i.baseLine, s = i.points, a = i.strokeWidth, l = s[0].x, u = s[s.length - 1].x, d = n * Math.abs(l - u), h = io(s.map(function(f) {
        return f.y || 0;
      }));
      return Ce(o) && typeof o == "number" ? h = Math.max(o, h) : o && Array.isArray(o) && o.length && (h = Math.max(io(o.map(function(f) {
        return f.y || 0;
      })), h)), Ce(h) ? /* @__PURE__ */ O.createElement("rect", {
        x: l < u ? l : l - d,
        y: 0,
        width: d,
        height: Math.floor(h + (a ? parseInt("".concat(a), 10) : 1))
      }) : null;
    }
  }, {
    key: "renderVerticalRect",
    value: function(n) {
      var i = this.props, o = i.baseLine, s = i.points, a = i.strokeWidth, l = s[0].y, u = s[s.length - 1].y, d = n * Math.abs(l - u), h = io(s.map(function(f) {
        return f.x || 0;
      }));
      return Ce(o) && typeof o == "number" ? h = Math.max(o, h) : o && Array.isArray(o) && o.length && (h = Math.max(io(o.map(function(f) {
        return f.x || 0;
      })), h)), Ce(h) ? /* @__PURE__ */ O.createElement("rect", {
        x: 0,
        y: l < u ? l : l - d,
        width: h + (a ? parseInt("".concat(a), 10) : 1),
        height: Math.floor(d)
      }) : null;
    }
  }, {
    key: "renderClipRect",
    value: function(n) {
      var i = this.props.layout;
      return i === "vertical" ? this.renderVerticalRect(n) : this.renderHorizontalRect(n);
    }
  }, {
    key: "renderAreaStatically",
    value: function(n, i, o, s) {
      var a = this.props, l = a.layout, u = a.type, d = a.stroke, h = a.connectNulls, f = a.isRange;
      a.ref;
      var p = kT(a, pve);
      return /* @__PURE__ */ O.createElement(st, {
        clipPath: o ? "url(#clipPath-".concat(s, ")") : null
      }, /* @__PURE__ */ O.createElement(os, Jo({}, Ne(p, !0), {
        points: n,
        connectNulls: h,
        type: u,
        baseLine: i,
        layout: l,
        stroke: "none",
        className: "recharts-area-area"
      })), d !== "none" && /* @__PURE__ */ O.createElement(os, Jo({}, Ne(this.props, !1), {
        className: "recharts-area-curve",
        layout: l,
        type: u,
        connectNulls: h,
        fill: "none",
        points: n
      })), d !== "none" && f && /* @__PURE__ */ O.createElement(os, Jo({}, Ne(this.props, !1), {
        className: "recharts-area-curve",
        layout: l,
        type: u,
        connectNulls: h,
        fill: "none",
        points: i
      })));
    }
  }, {
    key: "renderAreaWithAnimation",
    value: function(n, i) {
      var o = this, s = this.props, a = s.points, l = s.baseLine, u = s.isAnimationActive, d = s.animationBegin, h = s.animationDuration, f = s.animationEasing, p = s.animationId, y = this.state, C = y.prevPoints, v = y.prevBaseLine;
      return /* @__PURE__ */ O.createElement($n, {
        begin: d,
        duration: h,
        isActive: u,
        easing: f,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "area-".concat(p),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(w) {
        var R = w.t;
        if (C) {
          var b = C.length / a.length, P = a.map(function(M, I) {
            var z = Math.floor(I * b);
            if (C[z]) {
              var k = C[z], _ = Ht(k.x, M.x), q = Ht(k.y, M.y);
              return to(to({}, M), {}, {
                x: _(R),
                y: q(R)
              });
            }
            return M;
          }), S;
          if (Ce(l) && typeof l == "number") {
            var E = Ht(v, l);
            S = E(R);
          } else if (_e(l) || Ja(l)) {
            var A = Ht(v, 0);
            S = A(R);
          } else
            S = l.map(function(M, I) {
              var z = Math.floor(I * b);
              if (v[z]) {
                var k = v[z], _ = Ht(k.x, M.x), q = Ht(k.y, M.y);
                return to(to({}, M), {}, {
                  x: _(R),
                  y: q(R)
                });
              }
              return M;
            });
          return o.renderAreaStatically(P, S, n, i);
        }
        return /* @__PURE__ */ O.createElement(st, null, /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
          id: "animationClipPath-".concat(i)
        }, o.renderClipRect(R))), /* @__PURE__ */ O.createElement(st, {
          clipPath: "url(#animationClipPath-".concat(i, ")")
        }, o.renderAreaStatically(a, l, n, i)));
      });
    }
  }, {
    key: "renderArea",
    value: function(n, i) {
      var o = this.props, s = o.points, a = o.baseLine, l = o.isAnimationActive, u = this.state, d = u.prevPoints, h = u.prevBaseLine, f = u.totalLength;
      return l && s && s.length && (!d && f > 0 || !hs(d, s) || !hs(h, a)) ? this.renderAreaWithAnimation(n, i) : this.renderAreaStatically(s, a, n, i);
    }
  }, {
    key: "render",
    value: function() {
      var n, i = this.props, o = i.hide, s = i.dot, a = i.points, l = i.className, u = i.top, d = i.left, h = i.xAxis, f = i.yAxis, p = i.width, y = i.height, C = i.isAnimationActive, v = i.id;
      if (o || !a || !a.length)
        return null;
      var w = this.state.isAnimationFinished, R = a.length === 1, b = Ze("recharts-area", l), P = h && h.allowDataOverflow, S = f && f.allowDataOverflow, E = P || S, A = _e(v) ? this.id : v, M = (n = Ne(s, !1)) !== null && n !== void 0 ? n : {
        r: 3,
        strokeWidth: 2
      }, I = M.r, z = I === void 0 ? 3 : I, k = M.strokeWidth, _ = k === void 0 ? 2 : k, q = LA(s) ? s : {}, j = q.clipDot, Q = j === void 0 ? !0 : j, K = z * 2 + _;
      return /* @__PURE__ */ O.createElement(st, {
        className: b
      }, P || S ? /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-".concat(A)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: P ? d : d - p / 2,
        y: S ? u : u - y / 2,
        width: P ? p : p * 2,
        height: S ? y : y * 2
      })), !Q && /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-dots-".concat(A)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: d - K / 2,
        y: u - K / 2,
        width: p + K,
        height: y + K
      }))) : null, R ? null : this.renderArea(E, A), (s || R) && this.renderDots(E, Q, A), (!C || w) && oi.renderCallByParent(this.props, a));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(n, i) {
      return n.animationId !== i.prevAnimationId ? {
        prevAnimationId: n.animationId,
        curPoints: n.points,
        curBaseLine: n.baseLine,
        prevPoints: i.curPoints,
        prevBaseLine: i.curBaseLine
      } : n.points !== i.curPoints || n.baseLine !== i.curBaseLine ? {
        curPoints: n.points,
        curBaseLine: n.baseLine
      } : null;
    }
  }]);
}(ui);
IT = Nr;
ti(Nr, "displayName", "Area");
ti(Nr, "defaultProps", {
  stroke: "#3182bd",
  fill: "#3182bd",
  fillOpacity: 0.6,
  xAxisId: 0,
  yAxisId: 0,
  legendType: "line",
  connectNulls: !1,
  // points of area
  points: [],
  dot: !1,
  activeDot: !0,
  hide: !1,
  isAnimationActive: !So.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
});
ti(Nr, "getBaseValue", function(e, t, r, n) {
  var i = e.layout, o = e.baseValue, s = t.props.baseValue, a = s ?? o;
  if (Ce(a) && typeof a == "number")
    return a;
  var l = i === "horizontal" ? n : r, u = l.scale.domain();
  if (l.type === "number") {
    var d = Math.max(u[0], u[1]), h = Math.min(u[0], u[1]);
    return a === "dataMin" ? h : a === "dataMax" || d < 0 ? d : Math.max(Math.min(u[0], u[1]), 0);
  }
  return a === "dataMin" ? u[0] : a === "dataMax" ? u[1] : u[0];
});
ti(Nr, "getComposedData", function(e) {
  var t = e.props, r = e.item, n = e.xAxis, i = e.yAxis, o = e.xAxisTicks, s = e.yAxisTicks, a = e.bandSize, l = e.dataKey, u = e.stackedData, d = e.dataStartIndex, h = e.displayedData, f = e.offset, p = t.layout, y = u && u.length, C = IT.getBaseValue(t, r, n, i), v = p === "horizontal", w = !1, R = h.map(function(P, S) {
    var E;
    y ? E = u[d + S] : (E = Xt(P, l), Array.isArray(E) ? w = !0 : E = [C, E]);
    var A = E[1] == null || y && Xt(P, l) == null;
    return v ? {
      x: ma({
        axis: n,
        ticks: o,
        bandSize: a,
        entry: P,
        index: S
      }),
      y: A ? null : i.scale(E[1]),
      value: E,
      payload: P
    } : {
      x: A ? null : n.scale(E[1]),
      y: ma({
        axis: i,
        ticks: s,
        bandSize: a,
        entry: P,
        index: S
      }),
      value: E,
      payload: P
    };
  }), b;
  return y || w ? b = R.map(function(P) {
    var S = Array.isArray(P.value) ? P.value[0] : null;
    return v ? {
      x: P.x,
      y: S != null && P.y != null ? i.scale(S) : null
    } : {
      x: S != null ? n.scale(S) : null,
      y: P.y
    };
  }) : b = v ? i.scale(C) : n.scale(C), to({
    points: R,
    baseLine: b,
    layout: p,
    isRange: w
  }, f);
});
ti(Nr, "renderDotItem", function(e, t) {
  var r;
  if (/* @__PURE__ */ O.isValidElement(e))
    r = /* @__PURE__ */ O.cloneElement(e, t);
  else if (We(e))
    r = e(t);
  else {
    var n = Ze("recharts-area-dot", typeof e != "boolean" ? e.className : ""), i = t.key, o = kT(t, mve);
    r = /* @__PURE__ */ O.createElement(xg, Jo({}, o, {
      key: i,
      className: n
    }));
  }
  return r;
});
function Fa(e) {
  "@babel/helpers - typeof";
  return Fa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fa(e);
}
function Eve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Pve(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, BT(n.key), n);
  }
}
function Ave(e, t, r) {
  return t && Pve(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Fve(e, t, r) {
  return t = zh(t), Mve(e, zT() ? Reflect.construct(t, r || [], zh(e).constructor) : t.apply(e, r));
}
function Mve(e, t) {
  if (t && (Fa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Tve(e);
}
function Tve(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function zT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (zT = function() {
    return !!e;
  })();
}
function zh(e) {
  return zh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, zh(e);
}
function Dve(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && t0(e, t);
}
function t0(e, t) {
  return t0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, t0(e, t);
}
function NT(e, t, r) {
  return t = BT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function BT(e) {
  var t = Ove(e, "string");
  return Fa(t) == "symbol" ? t : t + "";
}
function Ove(e, t) {
  if (Fa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Fa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Og = /* @__PURE__ */ function(e) {
  function t() {
    return Eve(this, t), Fve(this, t, arguments);
  }
  return Dve(t, e), Ave(t, [{
    key: "render",
    value: function() {
      return null;
    }
  }]);
}(O.Component);
NT(Og, "displayName", "ZAxis");
NT(Og, "defaultProps", {
  zAxisId: 0,
  range: [64, 64],
  scale: "auto",
  type: "number"
});
var Ive = ["option", "isActive"];
function Ql() {
  return Ql = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Ql.apply(this, arguments);
}
function kve(e, t) {
  if (e == null) return {};
  var r = Lve(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function Lve(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function _ve(e) {
  var t = e.option, r = e.isActive, n = kve(e, Ive);
  return typeof t == "string" ? /* @__PURE__ */ O.createElement(Hv, Ql({
    option: /* @__PURE__ */ O.createElement(ug, Ql({
      type: t
    }, n)),
    isActive: r,
    shapeType: "symbols"
  }, n)) : /* @__PURE__ */ O.createElement(Hv, Ql({
    option: t,
    isActive: r,
    shapeType: "symbols"
  }, n));
}
function Ma(e) {
  "@babel/helpers - typeof";
  return Ma = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ma(e);
}
function Zl() {
  return Zl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Zl.apply(this, arguments);
}
function OR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function yn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OR(Object(r), !0).forEach(function(n) {
      so(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : OR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function zve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IR(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, HT(n.key), n);
  }
}
function Nve(e, t, r) {
  return t && IR(e.prototype, t), r && IR(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Bve(e, t, r) {
  return t = Nh(t), Gve(e, GT() ? Reflect.construct(t, r || [], Nh(e).constructor) : t.apply(e, r));
}
function Gve(e, t) {
  if (t && (Ma(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Hve(e);
}
function Hve(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function GT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (GT = function() {
    return !!e;
  })();
}
function Nh(e) {
  return Nh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Nh(e);
}
function Wve(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && r0(e, t);
}
function r0(e, t) {
  return r0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, r0(e, t);
}
function so(e, t, r) {
  return t = HT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function HT(e) {
  var t = Vve(e, "string");
  return Ma(t) == "symbol" ? t : t + "";
}
function Vve(e, t) {
  if (Ma(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ma(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Ig = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    zve(this, t);
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    return r = Bve(this, t, [].concat(i)), so(r, "state", {
      isAnimationFinished: !1
    }), so(r, "handleAnimationEnd", function() {
      r.setState({
        isAnimationFinished: !0
      });
    }), so(r, "handleAnimationStart", function() {
      r.setState({
        isAnimationFinished: !1
      });
    }), so(r, "id", Cs("recharts-scatter-")), r;
  }
  return Wve(t, e), Nve(t, [{
    key: "renderSymbolsStatically",
    value: function(n) {
      var i = this, o = this.props, s = o.shape, a = o.activeShape, l = o.activeIndex, u = Ne(this.props, !1);
      return n.map(function(d, h) {
        var f = l === h, p = f ? a : s, y = yn(yn({}, u), d);
        return /* @__PURE__ */ O.createElement(st, Zl({
          className: "recharts-scatter-symbol",
          key: "symbol-".concat(d == null ? void 0 : d.cx, "-").concat(d == null ? void 0 : d.cy, "-").concat(d == null ? void 0 : d.size, "-").concat(h)
        }, lc(i.props, d, h), {
          role: "img"
        }), /* @__PURE__ */ O.createElement(_ve, Zl({
          option: p,
          isActive: f,
          key: "symbol-".concat(h)
        }, y)));
      });
    }
  }, {
    key: "renderSymbolsWithAnimation",
    value: function() {
      var n = this, i = this.props, o = i.points, s = i.isAnimationActive, a = i.animationBegin, l = i.animationDuration, u = i.animationEasing, d = i.animationId, h = this.state.prevPoints;
      return /* @__PURE__ */ O.createElement($n, {
        begin: a,
        duration: l,
        isActive: s,
        easing: u,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "pie-".concat(d),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(f) {
        var p = f.t, y = o.map(function(C, v) {
          var w = h && h[v];
          if (w) {
            var R = Ht(w.cx, C.cx), b = Ht(w.cy, C.cy), P = Ht(w.size, C.size);
            return yn(yn({}, C), {}, {
              cx: R(p),
              cy: b(p),
              size: P(p)
            });
          }
          var S = Ht(0, C.size);
          return yn(yn({}, C), {}, {
            size: S(p)
          });
        });
        return /* @__PURE__ */ O.createElement(st, null, n.renderSymbolsStatically(y));
      });
    }
  }, {
    key: "renderSymbols",
    value: function() {
      var n = this.props, i = n.points, o = n.isAnimationActive, s = this.state.prevPoints;
      return o && i && i.length && (!s || !hs(s, i)) ? this.renderSymbolsWithAnimation() : this.renderSymbolsStatically(i);
    }
  }, {
    key: "renderErrorBar",
    value: function() {
      var n = this.props.isAnimationActive;
      if (n && !this.state.isAnimationFinished)
        return null;
      var i = this.props, o = i.points, s = i.xAxis, a = i.yAxis, l = i.children, u = Wr(l, il);
      return u ? u.map(function(d, h) {
        var f = d.props, p = f.direction, y = f.dataKey;
        return /* @__PURE__ */ O.cloneElement(d, {
          key: "".concat(p, "-").concat(y, "-").concat(o[h]),
          data: o,
          xAxis: s,
          yAxis: a,
          layout: p === "x" ? "vertical" : "horizontal",
          dataPointFormatter: function(v, w) {
            return {
              x: v.cx,
              y: v.cy,
              value: p === "x" ? +v.node.x : +v.node.y,
              errorVal: Xt(v, w)
            };
          }
        });
      }) : null;
    }
  }, {
    key: "renderLine",
    value: function() {
      var n = this.props, i = n.points, o = n.line, s = n.lineType, a = n.lineJointType, l = Ne(this.props, !1), u = Ne(o, !1), d, h;
      if (s === "joint")
        d = i.map(function(b) {
          return {
            x: b.cx,
            y: b.cy
          };
        });
      else if (s === "fitting") {
        var f = Qq(i), p = f.xmin, y = f.xmax, C = f.a, v = f.b, w = function(P) {
          return C * P + v;
        };
        d = [{
          x: p,
          y: w(p)
        }, {
          x: y,
          y: w(y)
        }];
      }
      var R = yn(yn(yn({}, l), {}, {
        fill: "none",
        stroke: l && l.fill
      }, u), {}, {
        points: d
      });
      return /* @__PURE__ */ O.isValidElement(o) ? h = /* @__PURE__ */ O.cloneElement(o, R) : We(o) ? h = o(R) : h = /* @__PURE__ */ O.createElement(os, Zl({}, R, {
        type: a
      })), /* @__PURE__ */ O.createElement(st, {
        className: "recharts-scatter-line",
        key: "recharts-scatter-line"
      }, h);
    }
  }, {
    key: "render",
    value: function() {
      var n = this.props, i = n.hide, o = n.points, s = n.line, a = n.className, l = n.xAxis, u = n.yAxis, d = n.left, h = n.top, f = n.width, p = n.height, y = n.id, C = n.isAnimationActive;
      if (i || !o || !o.length)
        return null;
      var v = this.state.isAnimationFinished, w = Ze("recharts-scatter", a), R = l && l.allowDataOverflow, b = u && u.allowDataOverflow, P = R || b, S = _e(y) ? this.id : y;
      return /* @__PURE__ */ O.createElement(st, {
        className: w,
        clipPath: P ? "url(#clipPath-".concat(S, ")") : null
      }, R || b ? /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
        id: "clipPath-".concat(S)
      }, /* @__PURE__ */ O.createElement("rect", {
        x: R ? d : d - f / 2,
        y: b ? h : h - p / 2,
        width: R ? f : f * 2,
        height: b ? p : p * 2
      }))) : null, s && this.renderLine(), this.renderErrorBar(), /* @__PURE__ */ O.createElement(st, {
        key: "recharts-scatter-symbols"
      }, this.renderSymbols()), (!C || v) && oi.renderCallByParent(this.props, o));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(n, i) {
      return n.animationId !== i.prevAnimationId ? {
        prevAnimationId: n.animationId,
        curPoints: n.points,
        prevPoints: i.curPoints
      } : n.points !== i.curPoints ? {
        curPoints: n.points
      } : null;
    }
  }]);
}(ui);
so(Ig, "displayName", "Scatter");
so(Ig, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  zAxisId: 0,
  legendType: "circle",
  lineType: "joint",
  lineJointType: "linear",
  data: [],
  shape: "circle",
  hide: !1,
  isAnimationActive: !So.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "linear"
});
so(Ig, "getComposedData", function(e) {
  var t = e.xAxis, r = e.yAxis, n = e.zAxis, i = e.item, o = e.displayedData, s = e.xAxisTicks, a = e.yAxisTicks, l = e.offset, u = i.props.tooltipType, d = Wr(i.props.children, _y), h = _e(t.dataKey) ? i.props.dataKey : t.dataKey, f = _e(r.dataKey) ? i.props.dataKey : r.dataKey, p = n && n.dataKey, y = n ? n.range : Og.defaultProps.range, C = y && y[0], v = t.scale.bandwidth ? t.scale.bandwidth() : 0, w = r.scale.bandwidth ? r.scale.bandwidth() : 0, R = o.map(function(b, P) {
    var S = Xt(b, h), E = Xt(b, f), A = !_e(p) && Xt(b, p) || "-", M = [{
      name: _e(t.dataKey) ? i.props.name : t.name || t.dataKey,
      unit: t.unit || "",
      value: S,
      payload: b,
      dataKey: h,
      type: u
    }, {
      name: _e(r.dataKey) ? i.props.name : r.name || r.dataKey,
      unit: r.unit || "",
      value: E,
      payload: b,
      dataKey: f,
      type: u
    }];
    A !== "-" && M.push({
      name: n.name || n.dataKey,
      unit: n.unit || "",
      value: A,
      payload: b,
      dataKey: p,
      type: u
    });
    var I = ma({
      axis: t,
      ticks: s,
      bandSize: v,
      entry: b,
      index: P,
      dataKey: h
    }), z = ma({
      axis: r,
      ticks: a,
      bandSize: w,
      entry: b,
      index: P,
      dataKey: f
    }), k = A !== "-" ? n.scale(A) : C, _ = Math.sqrt(Math.max(k, 0) / Math.PI);
    return yn(yn({}, b), {}, {
      cx: I,
      cy: z,
      x: I - _,
      y: z - _,
      xAxis: t,
      yAxis: r,
      zAxis: n,
      width: 2 * _,
      height: 2 * _,
      size: k,
      node: {
        x: S,
        y: E,
        z: A
      },
      tooltipPayload: M,
      tooltipPosition: {
        x: I,
        y: z
      },
      payload: b
    }, d && d[P] && d[P].props);
  });
  return yn({
    points: R
  }, l);
});
function Ta(e) {
  "@babel/helpers - typeof";
  return Ta = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ta(e);
}
function $ve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jve(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, $T(n.key), n);
  }
}
function Uve(e, t, r) {
  return t && jve(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Kve(e, t, r) {
  return t = Bh(t), qve(e, WT() ? Reflect.construct(t, r || [], Bh(e).constructor) : t.apply(e, r));
}
function qve(e, t) {
  if (t && (Ta(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Yve(e);
}
function Yve(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function WT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (WT = function() {
    return !!e;
  })();
}
function Bh(e) {
  return Bh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Bh(e);
}
function Jve(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && n0(e, t);
}
function n0(e, t) {
  return n0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, n0(e, t);
}
function VT(e, t, r) {
  return t = $T(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function $T(e) {
  var t = Xve(e, "string");
  return Ta(t) == "symbol" ? t : t + "";
}
function Xve(e, t) {
  if (Ta(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Ta(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function i0() {
  return i0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, i0.apply(this, arguments);
}
function Qve(e) {
  var t = e.xAxisId, r = wT(), n = bT(), i = yT(t);
  return i == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ O.createElement(Dg, i0({}, i, {
      className: Ze("recharts-".concat(i.axisType, " ").concat(i.axisType), i.className),
      viewBox: {
        x: 0,
        y: 0,
        width: r,
        height: n
      },
      ticksGenerator: function(s) {
        return Yo(s, !0);
      }
    }))
  );
}
var kg = /* @__PURE__ */ function(e) {
  function t() {
    return $ve(this, t), Kve(this, t, arguments);
  }
  return Jve(t, e), Uve(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ O.createElement(Qve, this.props);
    }
  }]);
}(O.Component);
VT(kg, "displayName", "XAxis");
VT(kg, "defaultProps", {
  allowDecimals: !0,
  hide: !1,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: !1,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1,
  allowDuplicatedCategory: !0
});
function Da(e) {
  "@babel/helpers - typeof";
  return Da = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Da(e);
}
function Zve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function e0e(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, KT(n.key), n);
  }
}
function t0e(e, t, r) {
  return t && e0e(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function r0e(e, t, r) {
  return t = Gh(t), n0e(e, jT() ? Reflect.construct(t, r || [], Gh(e).constructor) : t.apply(e, r));
}
function n0e(e, t) {
  if (t && (Da(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return i0e(e);
}
function i0e(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function jT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (jT = function() {
    return !!e;
  })();
}
function Gh(e) {
  return Gh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Gh(e);
}
function o0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && o0(e, t);
}
function o0(e, t) {
  return o0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, o0(e, t);
}
function UT(e, t, r) {
  return t = KT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function KT(e) {
  var t = s0e(e, "string");
  return Da(t) == "symbol" ? t : t + "";
}
function s0e(e, t) {
  if (Da(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Da(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function s0() {
  return s0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, s0.apply(this, arguments);
}
var a0e = function(t) {
  var r = t.yAxisId, n = wT(), i = bT(), o = CT(r);
  return o == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ O.createElement(Dg, s0({}, o, {
      className: Ze("recharts-".concat(o.axisType, " ").concat(o.axisType), o.className),
      viewBox: {
        x: 0,
        y: 0,
        width: n,
        height: i
      },
      ticksGenerator: function(a) {
        return Yo(a, !0);
      }
    }))
  );
}, Lg = /* @__PURE__ */ function(e) {
  function t() {
    return Zve(this, t), r0e(this, t, arguments);
  }
  return o0e(t, e), t0e(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ O.createElement(a0e, this.props);
    }
  }]);
}(O.Component);
UT(Lg, "displayName", "YAxis");
UT(Lg, "defaultProps", {
  allowDuplicatedCategory: !0,
  allowDecimals: !0,
  hide: !1,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: !1,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1
});
function kR(e) {
  return d0e(e) || u0e(e) || c0e(e) || l0e();
}
function l0e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function c0e(e, t) {
  if (e) {
    if (typeof e == "string") return a0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return a0(e, t);
  }
}
function u0e(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function d0e(e) {
  if (Array.isArray(e)) return a0(e);
}
function a0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
var l0 = function(t, r, n, i, o) {
  var s = Wr(t, hC), a = Wr(t, Fg), l = [].concat(kR(s), kR(a)), u = Wr(t, Tg), d = "".concat(i, "Id"), h = i[0], f = r;
  if (l.length && (f = l.reduce(function(C, v) {
    if (v.props[d] === n && si(v.props, "extendDomain") && Ce(v.props[h])) {
      var w = v.props[h];
      return [Math.min(C[0], w), Math.max(C[1], w)];
    }
    return C;
  }, f)), u.length) {
    var p = "".concat(h, "1"), y = "".concat(h, "2");
    f = u.reduce(function(C, v) {
      if (v.props[d] === n && si(v.props, "extendDomain") && Ce(v.props[p]) && Ce(v.props[y])) {
        var w = v.props[p], R = v.props[y];
        return [Math.min(C[0], w, R), Math.max(C[1], w, R)];
      }
      return C;
    }, f);
  }
  return o && o.length && (f = o.reduce(function(C, v) {
    return Ce(v) ? [Math.min(C[0], v), Math.max(C[1], v)] : C;
  }, f)), f;
}, qT = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(l, u, d) {
    this.fn = l, this.context = u, this.once = d || !1;
  }
  function o(l, u, d, h, f) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var p = new i(d, h || l, f), y = r ? r + u : u;
    return l._events[y] ? l._events[y].fn ? l._events[y] = [l._events[y], p] : l._events[y].push(p) : (l._events[y] = p, l._eventsCount++), l;
  }
  function s(l, u) {
    --l._eventsCount === 0 ? l._events = new n() : delete l._events[u];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var u = [], d, h;
    if (this._eventsCount === 0) return u;
    for (h in d = this._events)
      t.call(d, h) && u.push(r ? h.slice(1) : h);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(d)) : u;
  }, a.prototype.listeners = function(u) {
    var d = r ? r + u : u, h = this._events[d];
    if (!h) return [];
    if (h.fn) return [h.fn];
    for (var f = 0, p = h.length, y = new Array(p); f < p; f++)
      y[f] = h[f].fn;
    return y;
  }, a.prototype.listenerCount = function(u) {
    var d = r ? r + u : u, h = this._events[d];
    return h ? h.fn ? 1 : h.length : 0;
  }, a.prototype.emit = function(u, d, h, f, p, y) {
    var C = r ? r + u : u;
    if (!this._events[C]) return !1;
    var v = this._events[C], w = arguments.length, R, b;
    if (v.fn) {
      switch (v.once && this.removeListener(u, v.fn, void 0, !0), w) {
        case 1:
          return v.fn.call(v.context), !0;
        case 2:
          return v.fn.call(v.context, d), !0;
        case 3:
          return v.fn.call(v.context, d, h), !0;
        case 4:
          return v.fn.call(v.context, d, h, f), !0;
        case 5:
          return v.fn.call(v.context, d, h, f, p), !0;
        case 6:
          return v.fn.call(v.context, d, h, f, p, y), !0;
      }
      for (b = 1, R = new Array(w - 1); b < w; b++)
        R[b - 1] = arguments[b];
      v.fn.apply(v.context, R);
    } else {
      var P = v.length, S;
      for (b = 0; b < P; b++)
        switch (v[b].once && this.removeListener(u, v[b].fn, void 0, !0), w) {
          case 1:
            v[b].fn.call(v[b].context);
            break;
          case 2:
            v[b].fn.call(v[b].context, d);
            break;
          case 3:
            v[b].fn.call(v[b].context, d, h);
            break;
          case 4:
            v[b].fn.call(v[b].context, d, h, f);
            break;
          default:
            if (!R) for (S = 1, R = new Array(w - 1); S < w; S++)
              R[S - 1] = arguments[S];
            v[b].fn.apply(v[b].context, R);
        }
    }
    return !0;
  }, a.prototype.on = function(u, d, h) {
    return o(this, u, d, h, !1);
  }, a.prototype.once = function(u, d, h) {
    return o(this, u, d, h, !0);
  }, a.prototype.removeListener = function(u, d, h, f) {
    var p = r ? r + u : u;
    if (!this._events[p]) return this;
    if (!d)
      return s(this, p), this;
    var y = this._events[p];
    if (y.fn)
      y.fn === d && (!f || y.once) && (!h || y.context === h) && s(this, p);
    else {
      for (var C = 0, v = [], w = y.length; C < w; C++)
        (y[C].fn !== d || f && !y[C].once || h && y[C].context !== h) && v.push(y[C]);
      v.length ? this._events[p] = v.length === 1 ? v[0] : v : s(this, p);
    }
    return this;
  }, a.prototype.removeAllListeners = function(u) {
    var d;
    return u ? (d = r ? r + u : u, this._events[d] && s(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a;
})(qT);
var h0e = qT.exports;
const g0e = /* @__PURE__ */ bt(h0e);
var im = new g0e(), om = "recharts.syncMouseEvents";
function Gc(e) {
  "@babel/helpers - typeof";
  return Gc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gc(e);
}
function f0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p0e(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, YT(n.key), n);
  }
}
function m0e(e, t, r) {
  return t && p0e(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function sm(e, t, r) {
  return t = YT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function YT(e) {
  var t = v0e(e, "string");
  return Gc(t) == "symbol" ? t : t + "";
}
function v0e(e, t) {
  if (Gc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Gc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var y0e = /* @__PURE__ */ function() {
  function e() {
    f0e(this, e), sm(this, "activeIndex", 0), sm(this, "coordinateList", []), sm(this, "layout", "horizontal");
  }
  return m0e(e, [{
    key: "setDetails",
    value: function(r) {
      var n, i = r.coordinateList, o = i === void 0 ? null : i, s = r.container, a = s === void 0 ? null : s, l = r.layout, u = l === void 0 ? null : l, d = r.offset, h = d === void 0 ? null : d, f = r.mouseHandlerCallback, p = f === void 0 ? null : f;
      this.coordinateList = (n = o ?? this.coordinateList) !== null && n !== void 0 ? n : [], this.container = a ?? this.container, this.layout = u ?? this.layout, this.offset = h ?? this.offset, this.mouseHandlerCallback = p ?? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
    }
  }, {
    key: "focus",
    value: function() {
      this.spoofMouse();
    }
  }, {
    key: "keyboardEvent",
    value: function(r) {
      if (this.coordinateList.length !== 0)
        switch (r.key) {
          case "ArrowRight": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1), this.spoofMouse();
            break;
          }
          case "ArrowLeft": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.max(this.activeIndex - 1, 0), this.spoofMouse();
            break;
          }
        }
    }
  }, {
    key: "setIndex",
    value: function(r) {
      this.activeIndex = r;
    }
  }, {
    key: "spoofMouse",
    value: function() {
      var r, n;
      if (this.layout === "horizontal" && this.coordinateList.length !== 0) {
        var i = this.container.getBoundingClientRect(), o = i.x, s = i.y, a = i.height, l = this.coordinateList[this.activeIndex].coordinate, u = ((r = window) === null || r === void 0 ? void 0 : r.scrollX) || 0, d = ((n = window) === null || n === void 0 ? void 0 : n.scrollY) || 0, h = o + l + u, f = s + this.offset.top + a / 2 + d;
        this.mouseHandlerCallback({
          pageX: h,
          pageY: f
        });
      }
    }
  }]);
}();
function C0e(e, t, r) {
  if (r === "number" && t === !0 && Array.isArray(e)) {
    var n = e == null ? void 0 : e[0], i = e == null ? void 0 : e[1];
    if (n && i && Ce(n) && Ce(i))
      return !0;
  }
  return !1;
}
function w0e(e, t, r, n) {
  var i = n / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: e === "horizontal" ? t.x - i : r.left + 0.5,
    y: e === "horizontal" ? r.top + 0.5 : t.y - i,
    width: e === "horizontal" ? n : r.width - 1,
    height: e === "horizontal" ? r.height - 1 : n
  };
}
function JT(e) {
  var t = e.cx, r = e.cy, n = e.radius, i = e.startAngle, o = e.endAngle, s = sr(t, r, n, i), a = sr(t, r, n, o);
  return {
    points: [s, a],
    cx: t,
    cy: r,
    radius: n,
    startAngle: i,
    endAngle: o
  };
}
function b0e(e, t, r) {
  var n, i, o, s;
  if (e === "horizontal")
    n = t.x, o = n, i = r.top, s = r.top + r.height;
  else if (e === "vertical")
    i = t.y, s = i, n = r.left, o = r.left + r.width;
  else if (t.cx != null && t.cy != null)
    if (e === "centric") {
      var a = t.cx, l = t.cy, u = t.innerRadius, d = t.outerRadius, h = t.angle, f = sr(a, l, u, h), p = sr(a, l, d, h);
      n = f.x, i = f.y, o = p.x, s = p.y;
    } else
      return JT(t);
  return [{
    x: n,
    y: i
  }, {
    x: o,
    y: s
  }];
}
function Hc(e) {
  "@babel/helpers - typeof";
  return Hc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hc(e);
}
function LR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ld(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LR(Object(r), !0).forEach(function(n) {
      S0e(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : LR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function S0e(e, t, r) {
  return t = x0e(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function x0e(e) {
  var t = R0e(e, "string");
  return Hc(t) == "symbol" ? t : t + "";
}
function R0e(e, t) {
  if (Hc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Hc(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function E0e(e) {
  var t, r, n = e.element, i = e.tooltipEventType, o = e.isActive, s = e.activeCoordinate, a = e.activePayload, l = e.offset, u = e.activeTooltipIndex, d = e.tooltipAxisBandSize, h = e.layout, f = e.chartName, p = (t = n.props.cursor) !== null && t !== void 0 ? t : (r = n.type.defaultProps) === null || r === void 0 ? void 0 : r.cursor;
  if (!n || !p || !o || !s || f !== "ScatterChart" && i !== "axis")
    return null;
  var y, C = os;
  if (f === "ScatterChart")
    y = s, C = Fge;
  else if (f === "BarChart")
    y = w0e(h, s, l, d), C = cC;
  else if (h === "radial") {
    var v = JT(s), w = v.cx, R = v.cy, b = v.radius, P = v.startAngle, S = v.endAngle;
    y = {
      cx: w,
      cy: R,
      startAngle: P,
      endAngle: S,
      innerRadius: b,
      outerRadius: b
    }, C = $M;
  } else
    y = {
      points: b0e(h, s, l)
    }, C = os;
  var E = ld(ld(ld(ld({
    stroke: "#ccc",
    pointerEvents: "none"
  }, l), y), Ne(p, !1)), {}, {
    payload: a,
    payloadIndex: u,
    className: Ze("recharts-tooltip-cursor", p.className)
  });
  return /* @__PURE__ */ ri(p) ? /* @__PURE__ */ er(p, E) : /* @__PURE__ */ x0(C, E);
}
var P0e = ["item"], A0e = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function Oa(e) {
  "@babel/helpers - typeof";
  return Oa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Oa(e);
}
function Ks() {
  return Ks = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Ks.apply(this, arguments);
}
function _R(e, t) {
  return T0e(e) || M0e(e, t) || QT(e, t) || F0e();
}
function F0e() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function M0e(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (n = o.call(r)).done) && (a.push(n.value), a.length !== t); l = !0) ;
    } catch (d) {
      u = !0, i = d;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return a;
  }
}
function T0e(e) {
  if (Array.isArray(e)) return e;
}
function zR(e, t) {
  if (e == null) return {};
  var r = D0e(e, t), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      n = o[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n]);
  }
  return r;
}
function D0e(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) >= 0) continue;
      r[n] = e[n];
    }
  return r;
}
function O0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function I0e(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, ZT(n.key), n);
  }
}
function k0e(e, t, r) {
  return t && I0e(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function L0e(e, t, r) {
  return t = Hh(t), _0e(e, XT() ? Reflect.construct(t, r || [], Hh(e).constructor) : t.apply(e, r));
}
function _0e(e, t) {
  if (t && (Oa(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return z0e(e);
}
function z0e(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function XT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (XT = function() {
    return !!e;
  })();
}
function Hh(e) {
  return Hh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Hh(e);
}
function N0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && c0(e, t);
}
function c0(e, t) {
  return c0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, c0(e, t);
}
function Ia(e) {
  return H0e(e) || G0e(e) || QT(e) || B0e();
}
function B0e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QT(e, t) {
  if (e) {
    if (typeof e == "string") return u0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return u0(e, t);
  }
}
function G0e(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function H0e(e) {
  if (Array.isArray(e)) return u0(e);
}
function u0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function NR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function re(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NR(Object(r), !0).forEach(function(n) {
      ke(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : NR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function ke(e, t, r) {
  return t = ZT(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function ZT(e) {
  var t = W0e(e, "string");
  return Oa(t) == "symbol" ? t : t + "";
}
function W0e(e, t) {
  if (Oa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (Oa(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var V0e = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
}, $0e = {
  width: "100%",
  height: "100%"
}, eD = {
  x: 0,
  y: 0
};
function cd(e) {
  return e;
}
var j0e = function(t, r) {
  return r === "horizontal" ? t.x : r === "vertical" ? t.y : r === "centric" ? t.angle : t.radius;
}, U0e = function(t, r, n, i) {
  var o = r.find(function(d) {
    return d && d.index === n;
  });
  if (o) {
    if (t === "horizontal")
      return {
        x: o.coordinate,
        y: i.y
      };
    if (t === "vertical")
      return {
        x: i.x,
        y: o.coordinate
      };
    if (t === "centric") {
      var s = o.coordinate, a = i.radius;
      return re(re(re({}, i), sr(i.cx, i.cy, a, s)), {}, {
        angle: s,
        radius: a
      });
    }
    var l = o.coordinate, u = i.angle;
    return re(re(re({}, i), sr(i.cx, i.cy, l, u)), {}, {
      angle: u,
      radius: l
    });
  }
  return eD;
}, _g = function(t, r) {
  var n = r.graphicalItems, i = r.dataStartIndex, o = r.dataEndIndex, s = (n ?? []).reduce(function(a, l) {
    var u = l.props.data;
    return u && u.length ? [].concat(Ia(a), Ia(u)) : a;
  }, []);
  return s.length > 0 ? s : t && t.length && Ce(i) && Ce(o) ? t.slice(i, o + 1) : [];
};
function tD(e) {
  return e === "number" ? [0, "auto"] : void 0;
}
var d0 = function(t, r, n, i) {
  var o = t.graphicalItems, s = t.tooltipAxis, a = _g(r, t);
  return n < 0 || !o || !o.length || n >= a.length ? null : o.reduce(function(l, u) {
    var d, h = (d = u.props.data) !== null && d !== void 0 ? d : r;
    h && t.dataStartIndex + t.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717
    // The data is sliced only when the active index is within the start/end index range.
    t.dataEndIndex - t.dataStartIndex >= n && (h = h.slice(t.dataStartIndex, t.dataEndIndex + 1));
    var f;
    if (s.dataKey && !s.allowDuplicatedCategory) {
      var p = h === void 0 ? a : h;
      f = Bd(p, s.dataKey, i);
    } else
      f = h && h[n] || a[n];
    return f ? [].concat(Ia(l), [HM(u, f)]) : l;
  }, []);
}, BR = function(t, r, n, i) {
  var o = i || {
    x: t.chartX,
    y: t.chartY
  }, s = j0e(o, n), a = t.orderedTooltipTicks, l = t.tooltipAxis, u = t.tooltipTicks, d = oue(s, a, u, l);
  if (d >= 0 && u) {
    var h = u[d] && u[d].value, f = d0(t, r, d, h), p = U0e(n, a, d, o);
    return {
      activeTooltipIndex: d,
      activeLabel: h,
      activePayload: f,
      activeCoordinate: p
    };
  }
  return null;
}, K0e = function(t, r) {
  var n = r.axes, i = r.graphicalItems, o = r.axisType, s = r.axisIdKey, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, d = t.layout, h = t.children, f = t.stackOffset, p = BM(d, o);
  return n.reduce(function(y, C) {
    var v, w = C.type.defaultProps !== void 0 ? re(re({}, C.type.defaultProps), C.props) : C.props, R = w.type, b = w.dataKey, P = w.allowDataOverflow, S = w.allowDuplicatedCategory, E = w.scale, A = w.ticks, M = w.includeHidden, I = w[s];
    if (y[I])
      return y;
    var z = _g(t.data, {
      graphicalItems: i.filter(function(X) {
        var he, ce = s in X.props ? X.props[s] : (he = X.type.defaultProps) === null || he === void 0 ? void 0 : he[s];
        return ce === I;
      }),
      dataStartIndex: l,
      dataEndIndex: u
    }), k = z.length, _, q, j;
    C0e(w.domain, P, R) && (_ = Rv(w.domain, null, P), p && (R === "number" || E !== "auto") && (j = Yl(z, b, "category")));
    var Q = tD(R);
    if (!_ || _.length === 0) {
      var K, Z = (K = w.domain) !== null && K !== void 0 ? K : Q;
      if (b) {
        if (_ = Yl(z, b, R), R === "category" && p) {
          var te = Xq(_);
          S && te ? (q = _, _ = Rh(0, k)) : S || (_ = sx(Z, _, C).reduce(function(X, he) {
            return X.indexOf(he) >= 0 ? X : [].concat(Ia(X), [he]);
          }, []));
        } else if (R === "category")
          S ? _ = _.filter(function(X) {
            return X !== "" && !_e(X);
          }) : _ = sx(Z, _, C).reduce(function(X, he) {
            return X.indexOf(he) >= 0 || he === "" || _e(he) ? X : [].concat(Ia(X), [he]);
          }, []);
        else if (R === "number") {
          var se = uue(z, i.filter(function(X) {
            var he, ce, me = s in X.props ? X.props[s] : (he = X.type.defaultProps) === null || he === void 0 ? void 0 : he[s], ve = "hide" in X.props ? X.props.hide : (ce = X.type.defaultProps) === null || ce === void 0 ? void 0 : ce.hide;
            return me === I && (M || !ve);
          }), b, o, d);
          se && (_ = se);
        }
        p && (R === "number" || E !== "auto") && (j = Yl(z, b, "category"));
      } else p ? _ = Rh(0, k) : a && a[I] && a[I].hasStack && R === "number" ? _ = f === "expand" ? [0, 1] : GM(a[I].stackGroups, l, u) : _ = NM(z, i.filter(function(X) {
        var he = s in X.props ? X.props[s] : X.type.defaultProps[s], ce = "hide" in X.props ? X.props.hide : X.type.defaultProps.hide;
        return he === I && (M || !ce);
      }), R, d, !0);
      if (R === "number")
        _ = l0(h, _, I, o, A), Z && (_ = Rv(Z, _, P));
      else if (R === "category" && Z) {
        var W = Z, U = _.every(function(X) {
          return W.indexOf(X) >= 0;
        });
        U && (_ = W);
      }
    }
    return re(re({}, y), {}, ke({}, I, re(re({}, w), {}, {
      axisType: o,
      domain: _,
      categoricalDomain: j,
      duplicateDomain: q,
      originalDomain: (v = w.domain) !== null && v !== void 0 ? v : Q,
      isCategorical: p,
      layout: d
    })));
  }, {});
}, q0e = function(t, r) {
  var n = r.graphicalItems, i = r.Axis, o = r.axisType, s = r.axisIdKey, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, d = t.layout, h = t.children, f = _g(t.data, {
    graphicalItems: n,
    dataStartIndex: l,
    dataEndIndex: u
  }), p = f.length, y = BM(d, o), C = -1;
  return n.reduce(function(v, w) {
    var R = w.type.defaultProps !== void 0 ? re(re({}, w.type.defaultProps), w.props) : w.props, b = R[s], P = tD("number");
    if (!v[b]) {
      C++;
      var S;
      return y ? S = Rh(0, p) : a && a[b] && a[b].hasStack ? (S = GM(a[b].stackGroups, l, u), S = l0(h, S, b, o)) : (S = Rv(P, NM(f, n.filter(function(E) {
        var A, M, I = s in E.props ? E.props[s] : (A = E.type.defaultProps) === null || A === void 0 ? void 0 : A[s], z = "hide" in E.props ? E.props.hide : (M = E.type.defaultProps) === null || M === void 0 ? void 0 : M.hide;
        return I === b && !z;
      }), "number", d), i.defaultProps.allowDataOverflow), S = l0(h, S, b, o)), re(re({}, v), {}, ke({}, b, re(re({
        axisType: o
      }, i.defaultProps), {}, {
        hide: !0,
        orientation: En(V0e, "".concat(o, ".").concat(C % 2), null),
        domain: S,
        originalDomain: P,
        isCategorical: y,
        layout: d
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return v;
  }, {});
}, Y0e = function(t, r) {
  var n = r.axisType, i = n === void 0 ? "xAxis" : n, o = r.AxisComp, s = r.graphicalItems, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, d = t.children, h = "".concat(i, "Id"), f = Wr(d, o), p = {};
  return f && f.length ? p = K0e(t, {
    axes: f,
    graphicalItems: s,
    axisType: i,
    axisIdKey: h,
    stackGroups: a,
    dataStartIndex: l,
    dataEndIndex: u
  }) : s && s.length && (p = q0e(t, {
    Axis: o,
    graphicalItems: s,
    axisType: i,
    axisIdKey: h,
    stackGroups: a,
    dataStartIndex: l,
    dataEndIndex: u
  })), p;
}, J0e = function(t) {
  var r = Ws(t), n = Yo(r, !1, !0);
  return {
    tooltipTicks: n,
    orderedTooltipTicks: ky(n, function(i) {
      return i.coordinate;
    }),
    tooltipAxis: r,
    tooltipAxisBandSize: fh(r, n)
  };
}, GR = function(t) {
  var r = t.children, n = t.defaultShowTooltip, i = Zr(r, Ca), o = 0, s = 0;
  return t.data && t.data.length !== 0 && (s = t.data.length - 1), i && i.props && (i.props.startIndex >= 0 && (o = i.props.startIndex), i.props.endIndex >= 0 && (s = i.props.endIndex)), {
    chartX: 0,
    chartY: 0,
    dataStartIndex: o,
    dataEndIndex: s,
    activeTooltipIndex: -1,
    isTooltipActive: !!n
  };
}, X0e = function(t) {
  return !t || !t.length ? !1 : t.some(function(r) {
    var n = co(r && r.type);
    return n && n.indexOf("Bar") >= 0;
  });
}, HR = function(t) {
  return t === "horizontal" ? {
    numericAxisName: "yAxis",
    cateAxisName: "xAxis"
  } : t === "vertical" ? {
    numericAxisName: "xAxis",
    cateAxisName: "yAxis"
  } : t === "centric" ? {
    numericAxisName: "radiusAxis",
    cateAxisName: "angleAxis"
  } : {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
}, Q0e = function(t, r) {
  var n = t.props, i = t.graphicalItems, o = t.xAxisMap, s = o === void 0 ? {} : o, a = t.yAxisMap, l = a === void 0 ? {} : a, u = n.width, d = n.height, h = n.children, f = n.margin || {}, p = Zr(h, Ca), y = Zr(h, ea), C = Object.keys(l).reduce(function(S, E) {
    var A = l[E], M = A.orientation;
    return !A.mirror && !A.hide ? re(re({}, S), {}, ke({}, M, S[M] + A.width)) : S;
  }, {
    left: f.left || 0,
    right: f.right || 0
  }), v = Object.keys(s).reduce(function(S, E) {
    var A = s[E], M = A.orientation;
    return !A.mirror && !A.hide ? re(re({}, S), {}, ke({}, M, En(S, "".concat(M)) + A.height)) : S;
  }, {
    top: f.top || 0,
    bottom: f.bottom || 0
  }), w = re(re({}, v), C), R = w.bottom;
  p && (w.bottom += p.props.height || Ca.defaultProps.height), y && r && (w = lue(w, i, n, r));
  var b = u - w.left - w.right, P = d - w.top - w.bottom;
  return re(re({
    brushBottom: R
  }, w), {}, {
    // never return negative values for height and width
    width: Math.max(b, 0),
    height: Math.max(P, 0)
  });
}, Z0e = function(t, r) {
  if (r === "xAxis")
    return t[r].width;
  if (r === "yAxis")
    return t[r].height;
}, rD = function(t) {
  var r = t.chartName, n = t.GraphicalChild, i = t.defaultTooltipEventType, o = i === void 0 ? "axis" : i, s = t.validateTooltipEventTypes, a = s === void 0 ? ["axis"] : s, l = t.axisComponents, u = t.legendContent, d = t.formatAxisMap, h = t.defaultProps, f = function(w, R) {
    var b = R.graphicalItems, P = R.stackGroups, S = R.offset, E = R.updateId, A = R.dataStartIndex, M = R.dataEndIndex, I = w.barSize, z = w.layout, k = w.barGap, _ = w.barCategoryGap, q = w.maxBarSize, j = HR(z), Q = j.numericAxisName, K = j.cateAxisName, Z = X0e(b), te = [];
    return b.forEach(function(se, W) {
      var U = _g(w.data, {
        graphicalItems: [se],
        dataStartIndex: A,
        dataEndIndex: M
      }), X = se.type.defaultProps !== void 0 ? re(re({}, se.type.defaultProps), se.props) : se.props, he = X.dataKey, ce = X.maxBarSize, me = X["".concat(Q, "Id")], ve = X["".concat(K, "Id")], Pe = {}, Re = l.reduce(function(Et, Ut) {
        var Or, Po, on = R["".concat(Ut.axisType, "Map")], yt = X["".concat(Ut.axisType, "Id")];
        on && on[yt] || Ut.axisType === "zAxis" || (process.env.NODE_ENV !== "production" ? Hr(!1, "Specifying a(n) ".concat(Ut.axisType, "Id requires a corresponding ").concat(
          Ut.axisType,
          "Id on the targeted graphical component "
        ).concat((Or = se == null || (Po = se.type) === null || Po === void 0 ? void 0 : Po.displayName) !== null && Or !== void 0 ? Or : "")) : Hr());
        var Ot = on[yt];
        return re(re({}, Et), {}, ke(ke({}, Ut.axisType, Ot), "".concat(Ut.axisType, "Ticks"), Yo(Ot)));
      }, Pe), ee = Re[K], fe = Re["".concat(K, "Ticks")], ye = P && P[me] && P[me].hasStack && Sue(se, P[me].stackGroups), B = co(se.type).indexOf("Bar") >= 0, Ae = fh(ee, fe), oe = [], Me = Z && sue({
        barSize: I,
        stackGroups: P,
        totalSize: Z0e(Re, K)
      });
      if (B) {
        var Je, nt, $r = _e(ce) ? q : ce, Dr = (Je = (nt = fh(ee, fe, !0)) !== null && nt !== void 0 ? nt : $r) !== null && Je !== void 0 ? Je : 0;
        oe = aue({
          barGap: k,
          barCategoryGap: _,
          bandSize: Dr !== Ae ? Dr : Ae,
          sizeList: Me[ve],
          maxBarSize: $r
        }), Dr !== Ae && (oe = oe.map(function(Et) {
          return re(re({}, Et), {}, {
            position: re(re({}, Et.position), {}, {
              offset: Et.position.offset - Dr / 2
            })
          });
        }));
      }
      var Nt = se && se.type && se.type.getComposedData;
      Nt && te.push({
        props: re(re({}, Nt(re(re({}, Re), {}, {
          displayedData: U,
          props: w,
          dataKey: he,
          item: se,
          bandSize: Ae,
          barPosition: oe,
          offset: S,
          stackedData: ye,
          layout: z,
          dataStartIndex: A,
          dataEndIndex: M
        }))), {}, ke(ke(ke({
          key: se.key || "item-".concat(W)
        }, Q, Re[Q]), K, Re[K]), "animationId", E)),
        childIndex: uY(se, w.children),
        item: se
      });
    }), te;
  }, p = function(w, R) {
    var b = w.props, P = w.dataStartIndex, S = w.dataEndIndex, E = w.updateId;
    if (!r1({
      props: b
    }))
      return null;
    var A = b.children, M = b.layout, I = b.stackOffset, z = b.data, k = b.reverseStackOrder, _ = HR(M), q = _.numericAxisName, j = _.cateAxisName, Q = Wr(A, n), K = Cue(z, Q, "".concat(q, "Id"), "".concat(j, "Id"), I, k), Z = l.reduce(function(X, he) {
      var ce = "".concat(he.axisType, "Map");
      return re(re({}, X), {}, ke({}, ce, Y0e(b, re(re({}, he), {}, {
        graphicalItems: Q,
        stackGroups: he.axisType === q && K,
        dataStartIndex: P,
        dataEndIndex: S
      }))));
    }, {}), te = Q0e(re(re({}, Z), {}, {
      props: b,
      graphicalItems: Q
    }), R == null ? void 0 : R.legendBBox);
    Object.keys(Z).forEach(function(X) {
      Z[X] = d(b, Z[X], te, X.replace("Map", ""), r);
    });
    var se = Z["".concat(j, "Map")], W = J0e(se), U = f(b, re(re({}, Z), {}, {
      dataStartIndex: P,
      dataEndIndex: S,
      updateId: E,
      graphicalItems: Q,
      stackGroups: K,
      offset: te
    }));
    return re(re({
      formattedGraphicalItems: U,
      graphicalItems: Q,
      offset: te,
      stackGroups: K
    }, W), Z);
  }, y = /* @__PURE__ */ function(v) {
    function w(R) {
      var b, P, S;
      return O0e(this, w), S = L0e(this, w, [R]), ke(S, "eventEmitterSymbol", Symbol("rechartsEventEmitter")), ke(S, "accessibilityManager", new y0e()), ke(S, "handleLegendBBoxUpdate", function(E) {
        if (E) {
          var A = S.state, M = A.dataStartIndex, I = A.dataEndIndex, z = A.updateId;
          S.setState(re({
            legendBBox: E
          }, p({
            props: S.props,
            dataStartIndex: M,
            dataEndIndex: I,
            updateId: z
          }, re(re({}, S.state), {}, {
            legendBBox: E
          }))));
        }
      }), ke(S, "handleReceiveSyncEvent", function(E, A, M) {
        if (S.props.syncId === E) {
          if (M === S.eventEmitterSymbol && typeof S.props.syncMethod != "function")
            return;
          S.applySyncEvent(A);
        }
      }), ke(S, "handleBrushChange", function(E) {
        var A = E.startIndex, M = E.endIndex;
        if (A !== S.state.dataStartIndex || M !== S.state.dataEndIndex) {
          var I = S.state.updateId;
          S.setState(function() {
            return re({
              dataStartIndex: A,
              dataEndIndex: M
            }, p({
              props: S.props,
              dataStartIndex: A,
              dataEndIndex: M,
              updateId: I
            }, S.state));
          }), S.triggerSyncEvent({
            dataStartIndex: A,
            dataEndIndex: M
          });
        }
      }), ke(S, "handleMouseEnter", function(E) {
        var A = S.getMouseInfo(E);
        if (A) {
          var M = re(re({}, A), {}, {
            isTooltipActive: !0
          });
          S.setState(M), S.triggerSyncEvent(M);
          var I = S.props.onMouseEnter;
          We(I) && I(M, E);
        }
      }), ke(S, "triggeredAfterMouseMove", function(E) {
        var A = S.getMouseInfo(E), M = A ? re(re({}, A), {}, {
          isTooltipActive: !0
        }) : {
          isTooltipActive: !1
        };
        S.setState(M), S.triggerSyncEvent(M);
        var I = S.props.onMouseMove;
        We(I) && I(M, E);
      }), ke(S, "handleItemMouseEnter", function(E) {
        S.setState(function() {
          return {
            isTooltipActive: !0,
            activeItem: E,
            activePayload: E.tooltipPayload,
            activeCoordinate: E.tooltipPosition || {
              x: E.cx,
              y: E.cy
            }
          };
        });
      }), ke(S, "handleItemMouseLeave", function() {
        S.setState(function() {
          return {
            isTooltipActive: !1
          };
        });
      }), ke(S, "handleMouseMove", function(E) {
        E.persist(), S.throttleTriggeredAfterMouseMove(E);
      }), ke(S, "handleMouseLeave", function(E) {
        S.throttleTriggeredAfterMouseMove.cancel();
        var A = {
          isTooltipActive: !1
        };
        S.setState(A), S.triggerSyncEvent(A);
        var M = S.props.onMouseLeave;
        We(M) && M(A, E);
      }), ke(S, "handleOuterEvent", function(E) {
        var A = cY(E), M = En(S.props, "".concat(A));
        if (A && We(M)) {
          var I, z;
          /.*touch.*/i.test(A) ? z = S.getMouseInfo(E.changedTouches[0]) : z = S.getMouseInfo(E), M((I = z) !== null && I !== void 0 ? I : {}, E);
        }
      }), ke(S, "handleClick", function(E) {
        var A = S.getMouseInfo(E);
        if (A) {
          var M = re(re({}, A), {}, {
            isTooltipActive: !0
          });
          S.setState(M), S.triggerSyncEvent(M);
          var I = S.props.onClick;
          We(I) && I(M, E);
        }
      }), ke(S, "handleMouseDown", function(E) {
        var A = S.props.onMouseDown;
        if (We(A)) {
          var M = S.getMouseInfo(E);
          A(M, E);
        }
      }), ke(S, "handleMouseUp", function(E) {
        var A = S.props.onMouseUp;
        if (We(A)) {
          var M = S.getMouseInfo(E);
          A(M, E);
        }
      }), ke(S, "handleTouchMove", function(E) {
        E.changedTouches != null && E.changedTouches.length > 0 && S.throttleTriggeredAfterMouseMove(E.changedTouches[0]);
      }), ke(S, "handleTouchStart", function(E) {
        E.changedTouches != null && E.changedTouches.length > 0 && S.handleMouseDown(E.changedTouches[0]);
      }), ke(S, "handleTouchEnd", function(E) {
        E.changedTouches != null && E.changedTouches.length > 0 && S.handleMouseUp(E.changedTouches[0]);
      }), ke(S, "handleDoubleClick", function(E) {
        var A = S.props.onDoubleClick;
        if (We(A)) {
          var M = S.getMouseInfo(E);
          A(M, E);
        }
      }), ke(S, "handleContextMenu", function(E) {
        var A = S.props.onContextMenu;
        if (We(A)) {
          var M = S.getMouseInfo(E);
          A(M, E);
        }
      }), ke(S, "triggerSyncEvent", function(E) {
        S.props.syncId !== void 0 && im.emit(om, S.props.syncId, E, S.eventEmitterSymbol);
      }), ke(S, "applySyncEvent", function(E) {
        var A = S.props, M = A.layout, I = A.syncMethod, z = S.state.updateId, k = E.dataStartIndex, _ = E.dataEndIndex;
        if (E.dataStartIndex !== void 0 || E.dataEndIndex !== void 0)
          S.setState(re({
            dataStartIndex: k,
            dataEndIndex: _
          }, p({
            props: S.props,
            dataStartIndex: k,
            dataEndIndex: _,
            updateId: z
          }, S.state)));
        else if (E.activeTooltipIndex !== void 0) {
          var q = E.chartX, j = E.chartY, Q = E.activeTooltipIndex, K = S.state, Z = K.offset, te = K.tooltipTicks;
          if (!Z)
            return;
          if (typeof I == "function")
            Q = I(te, E);
          else if (I === "value") {
            Q = -1;
            for (var se = 0; se < te.length; se++)
              if (te[se].value === E.activeLabel) {
                Q = se;
                break;
              }
          }
          var W = re(re({}, Z), {}, {
            x: Z.left,
            y: Z.top
          }), U = Math.min(q, W.x + W.width), X = Math.min(j, W.y + W.height), he = te[Q] && te[Q].value, ce = d0(S.state, S.props.data, Q), me = te[Q] ? {
            x: M === "horizontal" ? te[Q].coordinate : U,
            y: M === "horizontal" ? X : te[Q].coordinate
          } : eD;
          S.setState(re(re({}, E), {}, {
            activeLabel: he,
            activeCoordinate: me,
            activePayload: ce,
            activeTooltipIndex: Q
          }));
        } else
          S.setState(E);
      }), ke(S, "renderCursor", function(E) {
        var A, M = S.state, I = M.isTooltipActive, z = M.activeCoordinate, k = M.activePayload, _ = M.offset, q = M.activeTooltipIndex, j = M.tooltipAxisBandSize, Q = S.getTooltipEventType(), K = (A = E.props.active) !== null && A !== void 0 ? A : I, Z = S.props.layout, te = E.key || "_recharts-cursor";
        return /* @__PURE__ */ O.createElement(E0e, {
          key: te,
          activeCoordinate: z,
          activePayload: k,
          activeTooltipIndex: q,
          chartName: r,
          element: E,
          isActive: K,
          layout: Z,
          offset: _,
          tooltipAxisBandSize: j,
          tooltipEventType: Q
        });
      }), ke(S, "renderPolarAxis", function(E, A, M) {
        var I = En(E, "type.axisType"), z = En(S.state, "".concat(I, "Map")), k = E.type.defaultProps, _ = k !== void 0 ? re(re({}, k), E.props) : E.props, q = z && z[_["".concat(I, "Id")]];
        return /* @__PURE__ */ er(E, re(re({}, q), {}, {
          className: Ze(I, q.className),
          key: E.key || "".concat(A, "-").concat(M),
          ticks: Yo(q, !0)
        }));
      }), ke(S, "renderPolarGrid", function(E) {
        var A = E.props, M = A.radialLines, I = A.polarAngles, z = A.polarRadius, k = S.state, _ = k.radiusAxisMap, q = k.angleAxisMap, j = Ws(_), Q = Ws(q), K = Q.cx, Z = Q.cy, te = Q.innerRadius, se = Q.outerRadius;
        return /* @__PURE__ */ er(E, {
          polarAngles: Array.isArray(I) ? I : Yo(Q, !0).map(function(W) {
            return W.coordinate;
          }),
          polarRadius: Array.isArray(z) ? z : Yo(j, !0).map(function(W) {
            return W.coordinate;
          }),
          cx: K,
          cy: Z,
          innerRadius: te,
          outerRadius: se,
          key: E.key || "polar-grid",
          radialLines: M
        });
      }), ke(S, "renderLegend", function() {
        var E = S.state.formattedGraphicalItems, A = S.props, M = A.children, I = A.width, z = A.height, k = S.props.margin || {}, _ = I - (k.left || 0) - (k.right || 0), q = _M({
          children: M,
          formattedGraphicalItems: E,
          legendWidth: _,
          legendContent: u
        });
        if (!q)
          return null;
        var j = q.item, Q = zR(q, P0e);
        return /* @__PURE__ */ er(j, re(re({}, Q), {}, {
          chartWidth: I,
          chartHeight: z,
          margin: k,
          onBBoxUpdate: S.handleLegendBBoxUpdate
        }));
      }), ke(S, "renderTooltip", function() {
        var E, A = S.props, M = A.children, I = A.accessibilityLayer, z = Zr(M, kn);
        if (!z)
          return null;
        var k = S.state, _ = k.isTooltipActive, q = k.activeCoordinate, j = k.activePayload, Q = k.activeLabel, K = k.offset, Z = (E = z.props.active) !== null && E !== void 0 ? E : _;
        return /* @__PURE__ */ er(z, {
          viewBox: re(re({}, K), {}, {
            x: K.left,
            y: K.top
          }),
          active: Z,
          label: Q,
          payload: Z ? j : [],
          coordinate: q,
          accessibilityLayer: I
        });
      }), ke(S, "renderBrush", function(E) {
        var A = S.props, M = A.margin, I = A.data, z = S.state, k = z.offset, _ = z.dataStartIndex, q = z.dataEndIndex, j = z.updateId;
        return /* @__PURE__ */ er(E, {
          key: E.key || "_recharts-brush",
          onChange: nd(S.handleBrushChange, E.props.onChange),
          data: I,
          x: Ce(E.props.x) ? E.props.x : k.left,
          y: Ce(E.props.y) ? E.props.y : k.top + k.height + k.brushBottom - (M.bottom || 0),
          width: Ce(E.props.width) ? E.props.width : k.width,
          startIndex: _,
          endIndex: q,
          updateId: "brush-".concat(j)
        });
      }), ke(S, "renderReferenceElement", function(E, A, M) {
        if (!E)
          return null;
        var I = S, z = I.clipPathId, k = S.state, _ = k.xAxisMap, q = k.yAxisMap, j = k.offset, Q = E.type.defaultProps || {}, K = E.props, Z = K.xAxisId, te = Z === void 0 ? Q.xAxisId : Z, se = K.yAxisId, W = se === void 0 ? Q.yAxisId : se;
        return /* @__PURE__ */ er(E, {
          key: E.key || "".concat(A, "-").concat(M),
          xAxis: _[te],
          yAxis: q[W],
          viewBox: {
            x: j.left,
            y: j.top,
            width: j.width,
            height: j.height
          },
          clipPathId: z
        });
      }), ke(S, "renderActivePoints", function(E) {
        var A = E.item, M = E.activePoint, I = E.basePoint, z = E.childIndex, k = E.isRange, _ = [], q = A.props.key, j = A.item.type.defaultProps !== void 0 ? re(re({}, A.item.type.defaultProps), A.item.props) : A.item.props, Q = j.activeDot, K = j.dataKey, Z = re(re({
          index: z,
          dataKey: K,
          cx: M.x,
          cy: M.y,
          r: 4,
          fill: aC(A.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: M.payload,
          value: M.value
        }, Ne(Q, !1)), Gd(Q));
        return _.push(w.renderActiveDot(Q, Z, "".concat(q, "-activePoint-").concat(z))), I ? _.push(w.renderActiveDot(Q, re(re({}, Z), {}, {
          cx: I.x,
          cy: I.y
        }), "".concat(q, "-basePoint-").concat(z))) : k && _.push(null), _;
      }), ke(S, "renderGraphicChild", function(E, A, M) {
        var I = S.filterFormatItem(E, A, M);
        if (!I)
          return null;
        var z = S.getTooltipEventType(), k = S.state, _ = k.isTooltipActive, q = k.tooltipAxis, j = k.activeTooltipIndex, Q = k.activeLabel, K = S.props.children, Z = Zr(K, kn), te = I.props, se = te.points, W = te.isRange, U = te.baseLine, X = I.item.type.defaultProps !== void 0 ? re(re({}, I.item.type.defaultProps), I.item.props) : I.item.props, he = X.activeDot, ce = X.hide, me = X.activeBar, ve = X.activeShape, Pe = !!(!ce && _ && Z && (he || me || ve)), Re = {};
        z !== "axis" && Z && Z.props.trigger === "click" ? Re = {
          onClick: nd(S.handleItemMouseEnter, E.props.onClick)
        } : z !== "axis" && (Re = {
          onMouseLeave: nd(S.handleItemMouseLeave, E.props.onMouseLeave),
          onMouseEnter: nd(S.handleItemMouseEnter, E.props.onMouseEnter)
        });
        var ee = /* @__PURE__ */ er(E, re(re({}, I.props), Re));
        function fe(Ut) {
          return typeof q.dataKey == "function" ? q.dataKey(Ut.payload) : null;
        }
        if (Pe)
          if (j >= 0) {
            var ye, B;
            if (q.dataKey && !q.allowDuplicatedCategory) {
              var Ae = typeof q.dataKey == "function" ? fe : "payload.".concat(q.dataKey.toString());
              ye = Bd(se, Ae, Q), B = W && U && Bd(U, Ae, Q);
            } else
              ye = se == null ? void 0 : se[j], B = W && U && U[j];
            if (ve || me) {
              var oe = E.props.activeIndex !== void 0 ? E.props.activeIndex : j;
              return [/* @__PURE__ */ er(E, re(re(re({}, I.props), Re), {}, {
                activeIndex: oe
              })), null, null];
            }
            if (!_e(ye))
              return [ee].concat(Ia(S.renderActivePoints({
                item: I,
                activePoint: ye,
                basePoint: B,
                childIndex: j,
                isRange: W
              })));
          } else {
            var Me, Je = (Me = S.getItemByXY(S.state.activeCoordinate)) !== null && Me !== void 0 ? Me : {
              graphicalItem: ee
            }, nt = Je.graphicalItem, $r = nt.item, Dr = $r === void 0 ? E : $r, Nt = nt.childIndex, Et = re(re(re({}, I.props), Re), {}, {
              activeIndex: Nt
            });
            return [/* @__PURE__ */ er(Dr, Et), null, null];
          }
        return W ? [ee, null, null] : [ee, null];
      }), ke(S, "renderCustomized", function(E, A, M) {
        return /* @__PURE__ */ er(E, re(re({
          key: "recharts-customized-".concat(M)
        }, S.props), S.state));
      }), ke(S, "renderMap", {
        CartesianGrid: {
          handler: cd,
          once: !0
        },
        ReferenceArea: {
          handler: S.renderReferenceElement
        },
        ReferenceLine: {
          handler: cd
        },
        ReferenceDot: {
          handler: S.renderReferenceElement
        },
        XAxis: {
          handler: cd
        },
        YAxis: {
          handler: cd
        },
        Brush: {
          handler: S.renderBrush,
          once: !0
        },
        Bar: {
          handler: S.renderGraphicChild
        },
        Line: {
          handler: S.renderGraphicChild
        },
        Area: {
          handler: S.renderGraphicChild
        },
        Radar: {
          handler: S.renderGraphicChild
        },
        RadialBar: {
          handler: S.renderGraphicChild
        },
        Scatter: {
          handler: S.renderGraphicChild
        },
        Pie: {
          handler: S.renderGraphicChild
        },
        Funnel: {
          handler: S.renderGraphicChild
        },
        Tooltip: {
          handler: S.renderCursor,
          once: !0
        },
        PolarGrid: {
          handler: S.renderPolarGrid,
          once: !0
        },
        PolarAngleAxis: {
          handler: S.renderPolarAxis
        },
        PolarRadiusAxis: {
          handler: S.renderPolarAxis
        },
        Customized: {
          handler: S.renderCustomized
        }
      }), S.clipPathId = "".concat((b = R.id) !== null && b !== void 0 ? b : Cs("recharts"), "-clip"), S.throttleTriggeredAfterMouseMove = Roe(S.triggeredAfterMouseMove, (P = R.throttleDelay) !== null && P !== void 0 ? P : 1e3 / 60), S.state = {}, S;
    }
    return N0e(w, v), k0e(w, [{
      key: "componentDidMount",
      value: function() {
        var b, P;
        this.addListener(), this.accessibilityManager.setDetails({
          container: this.container,
          offset: {
            left: (b = this.props.margin.left) !== null && b !== void 0 ? b : 0,
            top: (P = this.props.margin.top) !== null && P !== void 0 ? P : 0
          },
          coordinateList: this.state.tooltipTicks,
          mouseHandlerCallback: this.triggeredAfterMouseMove,
          layout: this.props.layout
        }), this.displayDefaultTooltip();
      }
    }, {
      key: "displayDefaultTooltip",
      value: function() {
        var b = this.props, P = b.children, S = b.data, E = b.height, A = b.layout, M = Zr(P, kn);
        if (M) {
          var I = M.props.defaultIndex;
          if (!(typeof I != "number" || I < 0 || I > this.state.tooltipTicks.length - 1)) {
            var z = this.state.tooltipTicks[I] && this.state.tooltipTicks[I].value, k = d0(this.state, S, I, z), _ = this.state.tooltipTicks[I].coordinate, q = (this.state.offset.top + E) / 2, j = A === "horizontal", Q = j ? {
              x: _,
              y: q
            } : {
              y: _,
              x: q
            }, K = this.state.formattedGraphicalItems.find(function(te) {
              var se = te.item;
              return se.type.name === "Scatter";
            });
            K && (Q = re(re({}, Q), K.props.points[I].tooltipPosition), k = K.props.points[I].tooltipPayload);
            var Z = {
              activeTooltipIndex: I,
              isTooltipActive: !0,
              activeLabel: z,
              activePayload: k,
              activeCoordinate: Q
            };
            this.setState(Z), this.renderCursor(M), this.accessibilityManager.setIndex(I);
          }
        }
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function(b, P) {
        if (!this.props.accessibilityLayer)
          return null;
        if (this.state.tooltipTicks !== P.tooltipTicks && this.accessibilityManager.setDetails({
          coordinateList: this.state.tooltipTicks
        }), this.props.layout !== b.layout && this.accessibilityManager.setDetails({
          layout: this.props.layout
        }), this.props.margin !== b.margin) {
          var S, E;
          this.accessibilityManager.setDetails({
            offset: {
              left: (S = this.props.margin.left) !== null && S !== void 0 ? S : 0,
              top: (E = this.props.margin.top) !== null && E !== void 0 ? E : 0
            }
          });
        }
        return null;
      }
    }, {
      key: "componentDidUpdate",
      value: function(b) {
        Bm([Zr(b.children, kn)], [Zr(this.props.children, kn)]) || this.displayDefaultTooltip();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel();
      }
    }, {
      key: "getTooltipEventType",
      value: function() {
        var b = Zr(this.props.children, kn);
        if (b && typeof b.props.shared == "boolean") {
          var P = b.props.shared ? "axis" : "item";
          return a.indexOf(P) >= 0 ? P : o;
        }
        return o;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {MousePointer} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function(b) {
        if (!this.container)
          return null;
        var P = this.container, S = P.getBoundingClientRect(), E = Doe(S), A = {
          chartX: Math.round(b.pageX - E.left),
          chartY: Math.round(b.pageY - E.top)
        }, M = S.width / P.offsetWidth || 1, I = this.inRange(A.chartX, A.chartY, M);
        if (!I)
          return null;
        var z = this.state, k = z.xAxisMap, _ = z.yAxisMap, q = this.getTooltipEventType(), j = BR(this.state, this.props.data, this.props.layout, I);
        if (q !== "axis" && k && _) {
          var Q = Ws(k).scale, K = Ws(_).scale, Z = Q && Q.invert ? Q.invert(A.chartX) : null, te = K && K.invert ? K.invert(A.chartY) : null;
          return re(re({}, A), {}, {
            xValue: Z,
            yValue: te
          }, j);
        }
        return j ? re(re({}, A), j) : null;
      }
    }, {
      key: "inRange",
      value: function(b, P) {
        var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, E = this.props.layout, A = b / S, M = P / S;
        if (E === "horizontal" || E === "vertical") {
          var I = this.state.offset, z = A >= I.left && A <= I.left + I.width && M >= I.top && M <= I.top + I.height;
          return z ? {
            x: A,
            y: M
          } : null;
        }
        var k = this.state, _ = k.angleAxisMap, q = k.radiusAxisMap;
        if (_ && q) {
          var j = Ws(_);
          return cx({
            x: A,
            y: M
          }, j);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function() {
        var b = this.props.children, P = this.getTooltipEventType(), S = Zr(b, kn), E = {};
        S && P === "axis" && (S.props.trigger === "click" ? E = {
          onClick: this.handleClick
        } : E = {
          onMouseEnter: this.handleMouseEnter,
          onDoubleClick: this.handleDoubleClick,
          onMouseMove: this.handleMouseMove,
          onMouseLeave: this.handleMouseLeave,
          onTouchMove: this.handleTouchMove,
          onTouchStart: this.handleTouchStart,
          onTouchEnd: this.handleTouchEnd,
          onContextMenu: this.handleContextMenu
        });
        var A = Gd(this.props, this.handleOuterEvent);
        return re(re({}, A), E);
      }
    }, {
      key: "addListener",
      value: function() {
        im.on(om, this.handleReceiveSyncEvent);
      }
    }, {
      key: "removeListener",
      value: function() {
        im.removeListener(om, this.handleReceiveSyncEvent);
      }
    }, {
      key: "filterFormatItem",
      value: function(b, P, S) {
        for (var E = this.state.formattedGraphicalItems, A = 0, M = E.length; A < M; A++) {
          var I = E[A];
          if (I.item === b || I.props.key === b.key || P === co(I.item.type) && S === I.childIndex)
            return I;
        }
        return null;
      }
    }, {
      key: "renderClipPath",
      value: function() {
        var b = this.clipPathId, P = this.state.offset, S = P.left, E = P.top, A = P.height, M = P.width;
        return /* @__PURE__ */ O.createElement("defs", null, /* @__PURE__ */ O.createElement("clipPath", {
          id: b
        }, /* @__PURE__ */ O.createElement("rect", {
          x: S,
          y: E,
          height: A,
          width: M
        })));
      }
    }, {
      key: "getXScales",
      value: function() {
        var b = this.state.xAxisMap;
        return b ? Object.entries(b).reduce(function(P, S) {
          var E = _R(S, 2), A = E[0], M = E[1];
          return re(re({}, P), {}, ke({}, A, M.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function() {
        var b = this.state.yAxisMap;
        return b ? Object.entries(b).reduce(function(P, S) {
          var E = _R(S, 2), A = E[0], M = E[1];
          return re(re({}, P), {}, ke({}, A, M.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function(b) {
        var P;
        return (P = this.state.xAxisMap) === null || P === void 0 || (P = P[b]) === null || P === void 0 ? void 0 : P.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function(b) {
        var P;
        return (P = this.state.yAxisMap) === null || P === void 0 || (P = P[b]) === null || P === void 0 ? void 0 : P.scale;
      }
    }, {
      key: "getItemByXY",
      value: function(b) {
        var P = this.state, S = P.formattedGraphicalItems, E = P.activeItem;
        if (S && S.length)
          for (var A = 0, M = S.length; A < M; A++) {
            var I = S[A], z = I.props, k = I.item, _ = k.type.defaultProps !== void 0 ? re(re({}, k.type.defaultProps), k.props) : k.props, q = co(k.type);
            if (q === "Bar") {
              var j = (z.data || []).find(function(te) {
                return yge(b, te);
              });
              if (j)
                return {
                  graphicalItem: I,
                  payload: j
                };
            } else if (q === "RadialBar") {
              var Q = (z.data || []).find(function(te) {
                return cx(b, te);
              });
              if (Q)
                return {
                  graphicalItem: I,
                  payload: Q
                };
            } else if (Rg(I, E) || Eg(I, E) || _c(I, E)) {
              var K = wfe({
                graphicalItem: I,
                activeTooltipItem: E,
                itemData: _.data
              }), Z = _.activeIndex === void 0 ? K : _.activeIndex;
              return {
                graphicalItem: re(re({}, I), {}, {
                  childIndex: Z
                }),
                payload: _c(I, E) ? _.data[K] : I.props.data[K]
              };
            }
          }
        return null;
      }
    }, {
      key: "render",
      value: function() {
        var b = this;
        if (!r1(this))
          return null;
        var P = this.props, S = P.children, E = P.className, A = P.width, M = P.height, I = P.style, z = P.compact, k = P.title, _ = P.desc, q = zR(P, A0e), j = Ne(q, !1);
        if (z)
          return /* @__PURE__ */ O.createElement(mR, {
            state: this.state,
            width: this.props.width,
            height: this.props.height,
            clipPathId: this.clipPathId
          }, /* @__PURE__ */ O.createElement(Hm, Ks({}, j, {
            width: A,
            height: M,
            title: k,
            desc: _
          }), this.renderClipPath(), i1(S, this.renderMap)));
        if (this.props.accessibilityLayer) {
          var Q, K;
          j.tabIndex = (Q = this.props.tabIndex) !== null && Q !== void 0 ? Q : 0, j.role = (K = this.props.role) !== null && K !== void 0 ? K : "application", j.onKeyDown = function(te) {
            b.accessibilityManager.keyboardEvent(te);
          }, j.onFocus = function() {
            b.accessibilityManager.focus();
          };
        }
        var Z = this.parseEventsOfWrapper();
        return /* @__PURE__ */ O.createElement(mR, {
          state: this.state,
          width: this.props.width,
          height: this.props.height,
          clipPathId: this.clipPathId
        }, /* @__PURE__ */ O.createElement("div", Ks({
          className: Ze("recharts-wrapper", E),
          style: re({
            position: "relative",
            cursor: "default",
            width: A,
            height: M
          }, I)
        }, Z, {
          ref: function(se) {
            b.container = se;
          }
        }), /* @__PURE__ */ O.createElement(Hm, Ks({}, j, {
          width: A,
          height: M,
          title: k,
          desc: _,
          style: $0e
        }), this.renderClipPath(), i1(S, this.renderMap)), this.renderLegend(), this.renderTooltip()));
      }
    }]);
  }(R0);
  ke(y, "displayName", r), ke(y, "defaultProps", re({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: !1,
    syncMethod: "index"
  }, h)), ke(y, "getDerivedStateFromProps", function(v, w) {
    var R = v.dataKey, b = v.data, P = v.children, S = v.width, E = v.height, A = v.layout, M = v.stackOffset, I = v.margin, z = w.dataStartIndex, k = w.dataEndIndex;
    if (w.updateId === void 0) {
      var _ = GR(v);
      return re(re(re({}, _), {}, {
        updateId: 0
      }, p(re(re({
        props: v
      }, _), {}, {
        updateId: 0
      }), w)), {}, {
        prevDataKey: R,
        prevData: b,
        prevWidth: S,
        prevHeight: E,
        prevLayout: A,
        prevStackOffset: M,
        prevMargin: I,
        prevChildren: P
      });
    }
    if (R !== w.prevDataKey || b !== w.prevData || S !== w.prevWidth || E !== w.prevHeight || A !== w.prevLayout || M !== w.prevStackOffset || !Zs(I, w.prevMargin)) {
      var q = GR(v), j = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: w.chartX,
        chartY: w.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: w.isTooltipActive
      }, Q = re(re({}, BR(w, b, A)), {}, {
        updateId: w.updateId + 1
      }), K = re(re(re({}, q), j), Q);
      return re(re(re({}, K), p(re({
        props: v
      }, K), w)), {}, {
        prevDataKey: R,
        prevData: b,
        prevWidth: S,
        prevHeight: E,
        prevLayout: A,
        prevStackOffset: M,
        prevMargin: I,
        prevChildren: P
      });
    }
    if (!Bm(P, w.prevChildren)) {
      var Z, te, se, W, U = Zr(P, Ca), X = U && (Z = (te = U.props) === null || te === void 0 ? void 0 : te.startIndex) !== null && Z !== void 0 ? Z : z, he = U && (se = (W = U.props) === null || W === void 0 ? void 0 : W.endIndex) !== null && se !== void 0 ? se : k, ce = X !== z || he !== k, me = !_e(b), ve = me && !ce ? w.updateId : w.updateId + 1;
      return re(re({
        updateId: ve
      }, p(re(re({
        props: v
      }, w), {}, {
        updateId: ve,
        dataStartIndex: X,
        dataEndIndex: he
      }), w)), {}, {
        prevChildren: P,
        dataStartIndex: X,
        dataEndIndex: he
      });
    }
    return null;
  }), ke(y, "renderActiveDot", function(v, w, R) {
    var b;
    return /* @__PURE__ */ ri(v) ? b = /* @__PURE__ */ er(v, w) : We(v) ? b = v(w) : b = /* @__PURE__ */ O.createElement(xg, w), /* @__PURE__ */ O.createElement(st, {
      className: "recharts-active-dot",
      key: R
    }, b);
  });
  var C = /* @__PURE__ */ Vh(function(w, R) {
    return /* @__PURE__ */ O.createElement(y, Ks({}, w, {
      ref: R
    }));
  });
  return C.displayName = y.displayName, C;
}, eye = rD({
  chartName: "BarChart",
  GraphicalChild: kt,
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: ["axis", "item"],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: kg
  }, {
    axisType: "yAxis",
    AxisComp: Lg
  }],
  formatAxisMap: lT
}), tye = rD({
  chartName: "ComposedChart",
  GraphicalChild: [Qn, Nr, kt, Ig],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: kg
  }, {
    axisType: "yAxis",
    AxisComp: Lg
  }, {
    axisType: "zAxis",
    AxisComp: Og
  }],
  formatAxisMap: lT
});
const rye = (e, t, r) => r.payload.name === "longtail" ? [e, t] : [e, r.payload.name], nye = ({ active: e, payload: t, screenCoords: r }) => {
  if (e && t && t.length && r) {
    const n = t[0].payload.name;
    return $h(
      /* @__PURE__ */ $(
        "div",
        {
          style: {
            backgroundColor: "#eee",
            padding: "5px 10px 5px 10px",
            color: "#111",
            position: "absolute",
            top: r.y + 10,
            left: r.x + 10
          },
          children: /* @__PURE__ */ $("p", { className: "label", children: `${n} : ${t[0].value}` })
        }
      ),
      document.body
    );
  }
  return null;
}, qs = {
  unique: "#0f0",
  longtail: "teal",
  NA: "red",
  cat_pop: "pink"
}, iye = (e) => {
  const t = {
    custom1_color: "teal",
    custom2_color: "orange",
    custom3_color: "purple"
  }, r = e.colors ? e.colors : {}, n = { ...t, ...r }, { custom1_color: i, custom2_color: o, custom3_color: s } = n, a = (u) => {
    if (u === void 0)
      return /* @__PURE__ */ $("span", {});
    const d = u.value;
    return d === void 0 || !ot.isArray(d) ? /* @__PURE__ */ $("span", {}) : l({ histogramArr: d });
  }, l = ({ histogramArr: u }) => {
    const d = (p, y) => {
      console.log("dumbClickHandler", p);
    }, [h, f] = O.useState(null);
    return /* @__PURE__ */ $("div", { className: "histogram-component", children: /* @__PURE__ */ He(
      tye,
      {
        width: 100,
        height: 24,
        data: u,
        onClick: d,
        onMouseMove: (p, y) => {
          f({ x: y.clientX, y: y.clientY });
        },
        children: [
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barRed",
              stroke: "red",
              fill: "red",
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barBlue",
              stroke: "blue",
              fill: "blue",
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barGrayed",
              stroke: "gray",
              fill: "Gray",
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barCustom1",
              stroke: i,
              fill: i,
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barCustom2",
              stroke: o,
              fill: o,
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            kt,
            {
              dataKey: "barCustom3",
              stroke: s,
              fill: s,
              isAnimationActive: !1,
              stackId: "stack"
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineRed",
              stroke: "red",
              fill: "red",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineBlue",
              stroke: "blue",
              fill: "blue",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineGray",
              stroke: "gray",
              fill: "gray",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineCustom1",
              stroke: i,
              fill: i,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineCustom2",
              stroke: o,
              fill: o,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Qn,
            {
              type: "monotone",
              dataKey: "lineCustom3",
              stroke: s,
              fill: s,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaBlue",
              stroke: "blue",
              fill: "blue",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaRed",
              stroke: "red",
              fill: "red",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaGray",
              stroke: "gray",
              fill: "gray",
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaUnique",
              stroke: qs.unique,
              fill: qs.unique,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaCustom1",
              stroke: i,
              fill: i,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaCustom2",
              stroke: o,
              fill: o,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            Nr,
            {
              type: "monotone",
              dataKey: "areaCustom3",
              stroke: s,
              fill: s,
              isAnimationActive: !1
            }
          ),
          /* @__PURE__ */ $(
            kn,
            {
              formatter: rye,
              allowEscapeViewBox: { x: !0, y: !0 },
              wrapperStyle: { zIndex: 99999999, color: "#111" },
              content: (p) => /* @__PURE__ */ $(nye, { ...p, screenCoords: h })
            }
          )
        ]
      }
    ) });
  };
  return a;
}, oye = (e, t, r) => r.payload.name === "longtail" ? [e, t] : [e, r.payload.name], sye = ({ active: e, payload: t, screenCoords: r }) => {
  if (e && t && t.length && r) {
    const n = t[0].payload.name;
    return $h(
      /* @__PURE__ */ $(
        "div",
        {
          style: {
            backgroundColor: "#eee",
            padding: "5px 10px 5px 10px",
            color: "#111",
            position: "absolute",
            top: r.y + 10,
            left: r.x + 10
          },
          children: /* @__PURE__ */ $("p", { className: "label", children: `${n} : ${t[0].value}` })
        }
      ),
      document.body
    );
  }
  return null;
}, nD = (e) => {
  if (e === void 0)
    return /* @__PURE__ */ $("span", {});
  const t = e.value;
  return t === void 0 || !ot.isArray(t) ? /* @__PURE__ */ $("span", {}) : aye({ histogramArr: t, context: e.context, className: e.colDef.cellClass || "" });
}, aye = ({ histogramArr: e, context: t, className: r }) => {
  const n = (R, b) => {
    console.log("dumbClickHandler", R, t);
  }, i = (R) => {
    const b = `${R}-${crypto.randomUUID()}`;
    return [b, `url(#${b})`];
  }, [o, s] = i("star"), [a, l] = i("stripe"), [u, d] = i("circle"), [h, f] = i("checkers"), [p, y] = i("leafs"), [C, v] = O.useState(null), w = `histogram-component ${r}`;
  return /* @__PURE__ */ $("div", { className: w, children: /* @__PURE__ */ He(
    eye,
    {
      width: 100,
      height: 24,
      barGap: 1,
      data: e,
      onClick: n,
      onMouseMove: (R, b) => {
        v({ x: b.clientX, y: b.clientY });
      },
      children: [
        /* @__PURE__ */ He("defs", { children: [
          /* @__PURE__ */ $("pattern", { id: o, width: "10", height: "10", patternUnits: "userSpaceOnUse", children: /* @__PURE__ */ $("polygon", { stroke: "pink", points: "0,0 2,5 0,10 5,8 10,10 8,5 10,0 5,2" }) }),
          /* @__PURE__ */ $(
            "pattern",
            {
              id: a,
              width: "4",
              height: "4",
              patternUnits: "userSpaceOnUse",
              patternTransform: "rotate(45)",
              children: /* @__PURE__ */ $("rect", { width: "2", height: "4", fill: qs.NA })
            }
          ),
          /* @__PURE__ */ $("pattern", { id: u, width: "4", height: "4", patternUnits: "userSpaceOnUse", children: /* @__PURE__ */ $("circle", { "data-color": "outline", stroke: "pink", cx: ".5", cy: ".5", r: "1.5" }) }),
          /* @__PURE__ */ He(
            "pattern",
            {
              id: h,
              x: "0",
              y: "0",
              width: "4",
              height: "4",
              patternUnits: "userSpaceOnUse",
              children: [
                /* @__PURE__ */ $("rect", { stroke: "#0f0", x: "0", width: "2", height: "2", y: "0" }),
                /* @__PURE__ */ $("rect", { x: "2", width: "2", height: "2", y: "2" })
              ]
            }
          ),
          /* @__PURE__ */ $(
            "pattern",
            {
              id: p,
              x: "0",
              y: "0",
              width: "6",
              height: "6",
              patternUnits: "userSpaceOnUse",
              patternTransform: "translate(1, 1) rotate(0) skewX(0)",
              children: /* @__PURE__ */ $("svg", { width: "5", height: "5", viewBox: "0 0 100 100", children: /* @__PURE__ */ $("g", { fill: "teal", opacity: "1", children: /* @__PURE__ */ $("path", { d: "M99.9557 99.9557C45.4895 98.3748 1.6248 54.5101 0.0439453 0.0439453C54.5101 1.6248 98.3748 45.4895 99.9557 99.9557Z" }) }) })
            }
          )
        ] }),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "population",
            stroke: "#000",
            fill: "gray",
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "tail",
            stroke: "#000",
            fill: "gray",
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "true",
            stroke: "#00f",
            fill: "#00f",
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "false",
            stroke: "#000",
            fill: "#fff",
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "cat_pop",
            stroke: qs.cat_pop,
            fill: d,
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "unique",
            stroke: qs.unique,
            fill: f,
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "longtail",
            stroke: qs.longtail,
            fill: y,
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "user1",
            stroke: "teal",
            fill: s,
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kt,
          {
            dataKey: "NA",
            fill: l,
            stackId: "stack",
            isAnimationActive: !1
          }
        ),
        /* @__PURE__ */ $(
          kn,
          {
            formatter: oye,
            allowEscapeViewBox: { x: !0, y: !0 },
            wrapperStyle: { zIndex: 99999999, color: "#111" },
            content: (R) => /* @__PURE__ */ $(sye, { ...R, screenCoords: C })
          }
        )
      ]
    }
  ) });
}, am = new Intl.NumberFormat("en-US", {
  minimumFractionDigits: 0,
  maximumFractionDigits: 3
}), WR = (e) => (r) => {
  const n = r.value;
  if (n && e.max_length && typeof n == "string")
    try {
      return n.slice(0, e.max_length);
    } catch (i) {
      return console.log("e", i, "val", n), "";
    }
  return n;
}, lye = (e) => `{ ${je.map(e, (r, n) => `'${n}': ${fC(r)}`).join(",")} }`, iD = (e) => !!(je.isDate(e) && isFinite(e.getTime())), cye = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  hour12: !1
}, uye = (e) => {
  const t = e.toLocaleDateString("en-CA", cye), [r, n] = t.split(",");
  return `${r} ${n}`;
}, fC = (e) => e == null ? "None" : je.isArray(e) ? `[ ${e.map(fC).join(", ")}]` : je.isBoolean(e) ? sD(e) : je.isObject(e) ? lye(e) : e.toString(), oD = (e) => (r) => {
  const n = r.value, i = fC(n);
  return e.max_length ? i.slice(0, e.max_length) : i;
}, dye = oD({}), sD = (e) => e === !0 ? "True" : e === !1 ? "False" : "", hye = (e) => {
  const t = e.value;
  return sD(t);
}, gye = (e) => {
  const r = Math.floor(e.max_digits / 3) + e.max_digits, n = new Intl.NumberFormat("en-US");
  return (o) => {
    const s = o.value;
    return s === null || s === void 0 ? "" : n.format(o.value).padStart(r, " ");
  };
}, fye = (e) => {
  const t = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: e.min_fraction_digits,
    maximumFractionDigits: e.max_fraction_digits
  });
  return (r) => {
    if (r.value === null || r.value === void 0)
      return "";
    const n = t.format(r.value);
    if (je.includes(n, ".")) {
      const i = n.split(".")[1], o = e.max_fraction_digits - i.length + n.length;
      return n.padEnd(o);
    } else {
      const i = n.length + e.max_fraction_digits + 1;
      return n.padEnd(i);
    }
  };
}, pye = (e) => (t) => {
  const r = t.value;
  if (r == null)
    return "";
  const n = new Date(r);
  return iD(n) ? n.toLocaleDateString(e.locale, e.args) : "";
}, mye = (e) => {
  const t = e.value;
  if (t == null)
    return "";
  const r = new Date(t);
  return iD(r) ? uye(r) : "";
};
function aD(e) {
  switch (e.displayer) {
    case "integer":
      return gye(e);
    case "string":
      return WR(e);
    case "datetimeDefault":
      return mye;
    case "datetimeLocaleString":
      return pye(e);
    case "float":
      return fye(e);
    case "boolean":
      return hye;
    case "obj":
      return oD(e);
    default:
      return WR({ displayer: "string" });
  }
}
function lD(e) {
  switch (e.displayer) {
    case "histogram":
      return nD;
    case "chart":
      return iye(e);
    case "linkify":
      return LN;
    case "Base64PNGImageDisplayer":
      return _N;
    case "boolean_checkbox":
      return "agCheckboxCellRenderer";
    case "SVGDisplayer":
      return zN;
  }
}
function vye(e) {
  return je.includes(cE, e.displayer) ? void 0 : aD(e);
}
function yye(e) {
  const t = vye(e);
  return t !== void 0 ? { valueFormatter: t } : je.includes(cE, e.displayer) ? {
    cellRenderer: lD(e)
  } : {};
}
function Cye(e, t) {
  return je.map(je.map(t, "primary_key_val"), (r) => je.find(e, { index: r }));
}
const cD = (e) => je.has(e, "col_path") ? e.field : e.col_name;
function uD(e) {
  const t = e.color_map_config ? jN(e.color_map_config) : {};
  return {
    field: cD(e),
    cellDataType: !1,
    cellStyle: void 0,
    // necessary for colormapped columns to have a default
    ...yye(e.displayer_args),
    ...t,
    ...CU(e.tooltip_config),
    ...e.ag_grid_specs
  };
}
function wye(e) {
  return {
    headerName: e.header_name,
    ...uD(e)
  };
}
const h0 = (e, t) => {
  const r = (n) => je.has(n, "col_path") ? n.col_path[t] : n.col_name + "!&single" + je.indexOf(e, n).toString();
  return e.reduce((n, i) => {
    const o = r(i), s = n[n.length - 1];
    return !s || r(s[0]) !== o ? n.push([i]) : s.push(i), n;
  }, []);
};
function VR(e, t) {
  return console.log("f", e, e.ag_grid_specs), {
    headerName: e.col_path[t],
    ...uD(e)
  };
}
function dD(e, t = 0) {
  if (e.length == 0)
    throw new Error("f shouldn't be empty");
  const r = e[0].col_path, n = r[t], i = r.length;
  if (t == i)
    throw new Error("something went wrong, level is too deep");
  const o = t + 1;
  if (i == 1) {
    const s = {
      //headerName: rootHeader,
      children: je.map(e, (a) => VR(a, 0)),
      ...e[0].ag_grid_specs
    };
    return console.log(" colDef from multiIndexColToColDef", s), s;
  }
  if (o == i - 1) {
    const s = {
      headerName: n,
      children: je.map(e, (a) => VR(a, o)),
      ...e[0].ag_grid_specs
    };
    return console.log(" colDef from multiIndexColToColDef", s), s;
  } else {
    const s = h0(e, o), a = {
      headerName: n,
      children: je.map(s, (l) => dD(l, o)),
      ...e[0].ag_grid_specs
    };
    return console.log(" colDef from multiIndexColToColDef", a), a;
  }
}
const $R = (e) => {
  if (e.length == 0)
    throw new Error("x shouldn't be empty");
  if (je.has(e[0], "col_path"))
    return dD(e);
  if (e.length > 1)
    throw new Error(`for NormalColumnConfig, length should be 1, improperly grouped ${e}`);
  return wye(e[0]);
};
function ud(e, t, r) {
  const n = je.cloneDeep(e);
  return n[t] === void 0 ? n[t] = r : (console.log("c", n, t), je.isArray(n[t]) ? n[t].push(r) : n[t] = [n[t], r]), n;
}
function bye(e) {
  const i = h0(e.left_col_configs, 0).map($R).map((h) => ud(h, "headerClass", "left_col_configs_header")).map((h) => ud(h, "cellClass", "left_col_configs_cell"));
  if (i.length > 0) {
    const h = i.length - 1;
    i[h] = ud(i[h], "headerClass", "left_col_configs_header_last"), i[h] = ud(i[h], "cellClass", "left_col_configs_cell_last");
  }
  const o = (h) => ({
    ...h,
    pinned: "left"
  }), s = i.map(o);
  console.log("lcc3", s);
  const a = e.column_config, u = h0(a, 0).map($R);
  return [
    ...i,
    ...u
  ];
}
function Sye(e) {
  const t = {
    component: Qb(dye)
    //params: {colDef: {cellClass:"pinned_row_cell_class"}}
  };
  return (r) => {
    var n;
    if (r.node.rowPinned) {
      const i = je.get(r.node.data, "index");
      if (i === void 0)
        return t;
      const o = je.find(e, {
        primary_key_val: i
      });
      if (o === void 0)
        return t;
      const s = o, a = (n = r.column) == null ? void 0 : n.getColId();
      if (s.default_renderer_columns === void 0 && a === "index" || je.includes(s.default_renderer_columns, a))
        return t;
      const l = lD(s.displayer_args);
      return l === void 0 ? {
        component: Qb(
          aD(s.displayer_args)
        )
        //		  params: {colDef: {cellClass:"pinned_row_cell_class"}}
      } : {
        component: l
        //params: {colDef: {cellClass:"pinned_row_cell_class"}}
      };
    } else
      return;
  };
}
function xye(e) {
  const t = je.find(e, { index: "histogram_bins" }) || {}, r = je.find(e, { index: "histogram_log_bins" }) || {}, n = je.without(
    je.union(je.keys(t), je.keys(r)),
    "index"
  ), i = je.map(n, (o) => ({
    histogram_bins: je.get(t, o, []),
    histogram_log_bins: je.get(r, o, [])
  }));
  return je.zipObject(n, i);
}
const hD = (e) => {
  const t = /* @__PURE__ */ new Date();
  return {
    createTime: t,
    rowCount: void 0,
    getRows: (n) => {
      var u;
      console.log("gridUtils 198 calling getRows createTime", t, /* @__PURE__ */ new Date() - t);
      const i = n.sortModel, o = JSON.stringify((u = n.context) == null ? void 0 : u.outside_df_params), s = {
        sourceName: o,
        start: n.startRow,
        end: n.startRow + 1e3,
        origEnd: n.endRow,
        sort: i.length === 1 ? i[0].colId : void 0,
        sort_direction: i.length === 1 ? i[0].sort : void 0
      };
      console.log("[getRows] dsPayloadArgs", s, "context.outside_df_params", o);
      const a = (d, h) => {
        console.log("successWrapper called 217", t, /* @__PURE__ */ new Date() - t), n.successCallback(d, h);
      }, l = () => {
        console.log("request failed for ", s), n.failCallback();
      };
      e.getRequestRows(s, a, l);
    }
  };
}, Rye = (e, t, r, n) => Pye({
  numRows: t,
  pinnedRowLen: e,
  location: window.location,
  compC: r,
  rowHeight: n
}), Eye = () => window.vscIPyWidgets !== void 0, Pye = (e) => {
  const { numRows: t, pinnedRowLen: r, location: n, rowHeight: i, compC: o } = e, s = n.host.indexOf("colab.googleusercontent.com") !== -1, a = window.parent !== window, l = window.innerHeight / ((o == null ? void 0 : o.height_fraction) || 2), u = (o == null ? void 0 : o.dfvHeight) || l;
  console.log("314, ", l, window.innerHeight, (o == null ? void 0 : o.height_fraction) || 2, o == null ? void 0 : o.dfvHeight, l, u);
  const d = { height: u, overflow: "hidden" }, h = { minHeight: 50, maxHeight: u, overflow: "hidden" }, p = Math.floor(u / (i || 21) - 3), y = t + r < p;
  console.log("belowMinRows", y, t, r, p);
  const C = (o == null ? void 0 : o.shortMode) || y && i === void 0;
  console.log("shortMode", C, o == null ? void 0 : o.shortMode, y, i);
  const v = a ? "inIframe" : "";
  if (s || Eye())
    return {
      classMode: "regular-mode",
      domLayout: "normal",
      applicableStyle: { height: 500 },
      inIframe: v,
      maxRowsWithoutScrolling: p
    };
  const w = (o == null ? void 0 : o.layoutType) || (C ? "autoHeight" : "normal"), R = C ? h : d;
  return console.log("351 gridUtils", C, h, d), {
    classMode: C ? "short-mode" : "regular-mode",
    domLayout: w,
    applicableStyle: R,
    inIframe: v,
    maxRowsWithoutScrolling: p
  };
}, Aye = (e) => e < 1 ? {
  type: "fitProvidedWidth",
  width: window.innerWidth - 100
} : {
  type: "fitCellContents"
}, Fye = SA.withPart(bA).withParams({
  spacing: 5,
  browserColorScheme: "dark",
  cellHorizontalPaddingScale: 0.3,
  columnBorder: !0,
  rowBorder: !1,
  rowVerticalPaddingScale: 0.5,
  wrapperBorder: !1,
  fontSize: 12,
  dataFontSize: "12px",
  headerFontSize: 14,
  iconSize: 10,
  backgroundColor: "#181D1F",
  oddRowBackgroundColor: "#222628",
  headerVerticalPaddingScale: 0.6
  //    cellHorizontalPadding: 3,
});
function pC({
  df_viewer_config: e,
  activeColumn: t,
  operations: r,
  setOperations: n,
  operation_result: i,
  command_config: o
}) {
  const s = e.column_config.map(cD);
  return /* @__PURE__ */ $("div", { className: "columns-editor", style: { width: "100%" }, children: /* @__PURE__ */ He("div", { children: [
    /* @__PURE__ */ $(
      lE,
      {
        operations: r,
        setOperations: n,
        activeColumn: t[1],
        allColumns: s,
        command_config: o
      }
    ),
    /* @__PURE__ */ $(
      uE,
      {
        filledOperations: r,
        operation_result: i
      }
    )
  ] }) });
}
const jR = [
  "BOOLEAN",
  "INT32",
  "INT64",
  "INT96",
  // deprecated
  "FLOAT",
  "DOUBLE",
  "BYTE_ARRAY",
  "FIXED_LEN_BYTE_ARRAY"
], jo = [
  "PLAIN",
  "GROUP_VAR_INT",
  // deprecated
  "PLAIN_DICTIONARY",
  "RLE",
  "BIT_PACKED",
  // deprecated
  "DELTA_BINARY_PACKED",
  "DELTA_LENGTH_BYTE_ARRAY",
  "DELTA_BYTE_ARRAY",
  "RLE_DICTIONARY",
  "BYTE_STREAM_SPLIT"
], Mye = [
  "REQUIRED",
  "OPTIONAL",
  "REPEATED"
], Tye = [
  "UTF8",
  "MAP",
  "MAP_KEY_VALUE",
  "LIST",
  "ENUM",
  "DECIMAL",
  "DATE",
  "TIME_MILLIS",
  "TIME_MICROS",
  "TIMESTAMP_MILLIS",
  "TIMESTAMP_MICROS",
  "UINT_8",
  "UINT_16",
  "UINT_32",
  "UINT_64",
  "INT_8",
  "INT_16",
  "INT_32",
  "INT_64",
  "JSON",
  "BSON",
  "INTERVAL"
], Dye = [
  "UNCOMPRESSED",
  "SNAPPY",
  "GZIP",
  "LZO",
  "BROTLI",
  "LZ4",
  "ZSTD",
  "LZ4_RAW"
], gD = [
  "DATA_PAGE",
  "INDEX_PAGE",
  "DICTIONARY_PAGE",
  "DATA_PAGE_V2"
], Oye = [
  "SPHERICAL",
  "VINCENTY",
  "THOMAS",
  "ANDOYER",
  "KARNEY"
];
function g0(e) {
  const t = dd(e);
  if (t.type === 1)
    return { type: "Point", coordinates: f0(e, t) };
  if (t.type === 2)
    return { type: "LineString", coordinates: p0(e, t) };
  if (t.type === 3)
    return { type: "Polygon", coordinates: UR(e, t) };
  if (t.type === 4) {
    const r = [];
    for (let n = 0; n < t.count; n++)
      r.push(f0(e, dd(e)));
    return { type: "MultiPoint", coordinates: r };
  } else if (t.type === 5) {
    const r = [];
    for (let n = 0; n < t.count; n++)
      r.push(p0(e, dd(e)));
    return { type: "MultiLineString", coordinates: r };
  } else if (t.type === 6) {
    const r = [];
    for (let n = 0; n < t.count; n++)
      r.push(UR(e, dd(e)));
    return { type: "MultiPolygon", coordinates: r };
  } else if (t.type === 7) {
    const r = [];
    for (let n = 0; n < t.count; n++)
      r.push(g0(e));
    return { type: "GeometryCollection", geometries: r };
  } else
    throw new Error(`Unsupported geometry type: ${t.type}`);
}
function dd(e) {
  const { view: t } = e, r = t.getUint8(e.offset++) === 1, n = t.getUint32(e.offset, r);
  e.offset += 4;
  const i = n % 1e3, o = Math.floor(n / 1e3);
  let s = 0;
  i > 1 && i <= 7 && (s = t.getUint32(e.offset, r), e.offset += 4);
  let a = 2;
  return o && a++, o === 3 && a++, { littleEndian: r, type: i, dim: a, count: s };
}
function f0(e, t) {
  const r = [];
  for (let n = 0; n < t.dim; n++) {
    const i = e.view.getFloat64(e.offset, t.littleEndian);
    e.offset += 8, r.push(i);
  }
  return r;
}
function p0(e, t) {
  const r = [];
  for (let n = 0; n < t.count; n++)
    r.push(f0(e, t));
  return r;
}
function UR(e, t) {
  const { view: r } = e, n = [];
  for (let i = 0; i < t.count; i++) {
    const o = r.getUint32(e.offset, t.littleEndian);
    e.offset += 4, n.push(p0(e, { ...t, count: o }));
  }
  return n;
}
const fD = new TextDecoder(), pD = {
  timestampFromMilliseconds(e) {
    return new Date(Number(e));
  },
  timestampFromMicroseconds(e) {
    return new Date(Number(e / 1000n));
  },
  timestampFromNanoseconds(e) {
    return new Date(Number(e / 1000000n));
  },
  dateFromDays(e) {
    return new Date(e * 864e5);
  },
  stringFromBytes(e) {
    return e && fD.decode(e);
  },
  geometryFromBytes(e) {
    return e && g0({ view: new DataView(e.buffer, e.byteOffset, e.byteLength), offset: 0 });
  },
  geographyFromBytes(e) {
    return e && g0({ view: new DataView(e.buffer, e.byteOffset, e.byteLength), offset: 0 });
  }
};
function KR(e, t, r, n) {
  if (t && r.endsWith("_DICTIONARY")) {
    let i = e;
    e instanceof Uint8Array && !(t instanceof Uint8Array) && (i = new t.constructor(e.length));
    for (let o = 0; o < e.length; o++)
      i[o] = t[e[o]];
    return i;
  } else
    return mD(e, n);
}
function mD(e, t) {
  const { element: r, parsers: n, utf8: i = !0 } = t, { type: o, converted_type: s, logical_type: a } = r;
  if (s === "DECIMAL") {
    const u = 10 ** -(r.scale || 0), d = new Array(e.length);
    for (let h = 0; h < d.length; h++)
      e[h] instanceof Uint8Array ? d[h] = vD(e[h]) * u : d[h] = Number(e[h]) * u;
    return d;
  }
  if (!s && o === "INT96")
    return Array.from(e).map((l) => n.timestampFromNanoseconds(Iye(l)));
  if (s === "DATE")
    return Array.from(e).map((l) => n.dateFromDays(l));
  if (s === "TIMESTAMP_MILLIS")
    return Array.from(e).map((l) => n.timestampFromMilliseconds(l));
  if (s === "TIMESTAMP_MICROS")
    return Array.from(e).map((l) => n.timestampFromMicroseconds(l));
  if (s === "JSON")
    return e.map((l) => JSON.parse(fD.decode(l)));
  if (s === "BSON")
    throw new Error("parquet bson not supported");
  if (s === "INTERVAL")
    throw new Error("parquet interval not supported");
  if ((a == null ? void 0 : a.type) === "GEOMETRY")
    return e.map((l) => n.geometryFromBytes(l));
  if ((a == null ? void 0 : a.type) === "GEOGRAPHY")
    return e.map((l) => n.geographyFromBytes(l));
  if (s === "UTF8" || (a == null ? void 0 : a.type) === "STRING" || i && o === "BYTE_ARRAY")
    return e.map((l) => n.stringFromBytes(l));
  if (s === "UINT_64" || (a == null ? void 0 : a.type) === "INTEGER" && a.bitWidth === 64 && !a.isSigned) {
    if (e instanceof BigInt64Array)
      return new BigUint64Array(e.buffer, e.byteOffset, e.length);
    const l = new BigUint64Array(e.length);
    for (let u = 0; u < l.length; u++) l[u] = BigInt(e[u]);
    return l;
  }
  if (s === "UINT_32" || (a == null ? void 0 : a.type) === "INTEGER" && a.bitWidth === 32 && !a.isSigned) {
    if (e instanceof Int32Array)
      return new Uint32Array(e.buffer, e.byteOffset, e.length);
    const l = new Uint32Array(e.length);
    for (let u = 0; u < l.length; u++) l[u] = e[u];
    return l;
  }
  if ((a == null ? void 0 : a.type) === "FLOAT16")
    return Array.from(e).map(yD);
  if ((a == null ? void 0 : a.type) === "TIMESTAMP") {
    const { unit: l } = a;
    let u = n.timestampFromMilliseconds;
    l === "MICROS" && (u = n.timestampFromMicroseconds), l === "NANOS" && (u = n.timestampFromNanoseconds);
    const d = new Array(e.length);
    for (let h = 0; h < d.length; h++)
      d[h] = u(e[h]);
    return d;
  }
  return e;
}
function vD(e) {
  if (!e.length) return 0;
  let t = 0n;
  for (const n of e)
    t = t * 256n + BigInt(n);
  const r = e.length * 8;
  return t >= 2n ** BigInt(r - 1) && (t -= 2n ** BigInt(r)), Number(t);
}
function Iye(e) {
  const t = (e >> 64n) - 2440588n, r = e & 0xffffffffffffffffn;
  return t * 86400000000000n + r;
}
function yD(e) {
  if (!e) return;
  const t = e[1] << 8 | e[0], r = t >> 15 ? -1 : 1, n = t >> 10 & 31, i = t & 1023;
  return n === 0 ? r * 2 ** -14 * (i / 1024) : n === 31 ? i ? NaN : r * (1 / 0) : r * 2 ** (n - 15) * (1 + i / 1024);
}
function CD(e, t, r) {
  const n = e[t], i = [];
  let o = 1;
  if (n.num_children)
    for (; i.length < n.num_children; ) {
      const s = e[t + o], a = CD(e, t + o, [...r, s.name]);
      o += a.count, i.push(a);
    }
  return { count: o, element: n, children: i, path: r };
}
function wD(e, t) {
  let r = CD(e, 0, []);
  const n = [r];
  for (const i of t) {
    const o = r.children.find((s) => s.element.name === i);
    if (!o) throw new Error(`parquet schema element not found: ${t}`);
    n.push(o), r = o;
  }
  return n;
}
function kye(e) {
  const t = [];
  function r(n) {
    if (n.children.length)
      for (const i of n.children)
        r(i);
    else
      t.push(n.path.join("."));
  }
  return r(e), t;
}
function bD(e) {
  let t = 0;
  for (const { element: r } of e)
    r.repetition_type === "REPEATED" && t++;
  return t;
}
function mC(e) {
  let t = 0;
  for (const { element: r } of e.slice(1))
    r.repetition_type !== "REQUIRED" && t++;
  return t;
}
function Lye(e) {
  if (!e || e.element.converted_type !== "LIST" || e.children.length > 1) return !1;
  const t = e.children[0];
  return !(t.children.length > 1 || t.element.repetition_type !== "REPEATED");
}
function _ye(e) {
  if (!e || e.element.converted_type !== "MAP" || e.children.length > 1) return !1;
  const t = e.children[0];
  if (t.children.length !== 2 || t.element.repetition_type !== "REPEATED") return !1;
  const r = t.children.find((i) => i.element.name === "key");
  if ((r == null ? void 0 : r.element.repetition_type) === "REPEATED") return !1;
  const n = t.children.find((i) => i.element.name === "value");
  return (n == null ? void 0 : n.element.repetition_type) !== "REPEATED";
}
function SD(e) {
  if (e.length !== 2) return !1;
  const [, t] = e;
  return !(t.element.repetition_type === "REPEATED" || t.children.length);
}
const ur = {
  STOP: 0,
  TRUE: 1,
  FALSE: 2,
  BYTE: 3,
  I16: 4,
  I32: 5,
  I64: 6,
  DOUBLE: 7,
  BINARY: 8,
  LIST: 9,
  STRUCT: 12
};
function vC(e) {
  let t = 0;
  const r = {};
  for (; e.offset < e.view.byteLength; ) {
    const [n, i, o] = RD(e, t);
    if (t = o, n === ur.STOP)
      break;
    r[`field_${i}`] = wd(e, n);
  }
  return r;
}
function wd(e, t) {
  switch (t) {
    case ur.TRUE:
      return !0;
    case ur.FALSE:
      return !1;
    case ur.BYTE:
      return e.view.getInt8(e.offset++);
    case ur.I16:
    case ur.I32:
      return xD(e);
    case ur.I64:
      return m0(e);
    case ur.DOUBLE: {
      const r = e.view.getFloat64(e.offset, !0);
      return e.offset += 8, r;
    }
    case ur.BINARY: {
      const r = ss(e), n = new Uint8Array(e.view.buffer, e.view.byteOffset + e.offset, r);
      return e.offset += r, n;
    }
    case ur.LIST: {
      const r = e.view.getUint8(e.offset++), n = r & 15;
      let i = r >> 4;
      i === 15 && (i = ss(e));
      const o = n === ur.TRUE || n === ur.FALSE, s = new Array(i);
      for (let a = 0; a < i; a++)
        s[a] = o ? wd(e, ur.BYTE) === 1 : wd(e, n);
      return s;
    }
    case ur.STRUCT: {
      const r = {};
      let n = 0;
      for (; ; ) {
        const [i, o, s] = RD(e, n);
        if (n = s, i === ur.STOP)
          break;
        r[`field_${o}`] = wd(e, i);
      }
      return r;
    }
    default:
      throw new Error(`thrift unhandled type: ${t}`);
  }
}
function ss(e) {
  let t = 0, r = 0;
  for (; ; ) {
    const n = e.view.getUint8(e.offset++);
    if (t |= (n & 127) << r, !(n & 128))
      return t;
    r += 7;
  }
}
function zye(e) {
  let t = 0n, r = 0n;
  for (; ; ) {
    const n = e.view.getUint8(e.offset++);
    if (t |= BigInt(n & 127) << r, !(n & 128))
      return t;
    r += 7n;
  }
}
function xD(e) {
  const t = ss(e);
  return t >>> 1 ^ -(t & 1);
}
function m0(e) {
  const t = zye(e);
  return t >> 1n ^ -(t & 1n);
}
function RD(e, t) {
  const r = e.view.getUint8(e.offset++), n = r & 15;
  if (n === ur.STOP)
    return [0, 0, t];
  const i = r >> 4, o = i ? t + i : xD(e);
  return [n, o, o];
}
function Nye(e, t) {
  var o, s, a, l, u;
  const r = /* @__PURE__ */ new Map(), n = (o = t == null ? void 0 : t.find(({ key: d }) => d === "geo")) == null ? void 0 : o.value, i = (n && ((s = JSON.parse(n)) == null ? void 0 : s.columns)) ?? {};
  for (const [d, h] of Object.entries(i)) {
    if (h.encoding !== "WKB")
      continue;
    const f = h.edges === "spherical" ? "GEOGRAPHY" : "GEOMETRY", p = ((a = h.crs) == null ? void 0 : a.id) ?? ((u = (l = h.crs) == null ? void 0 : l.ids) == null ? void 0 : u[0]), y = p ? `${p.authority}:${p.code.toString()}` : void 0;
    r.set(d, { type: f, crs: y });
  }
  for (let d = 1; d < e.length; d++) {
    const h = e[d], { logical_type: f, name: p, num_children: y, repetition_type: C, type: v } = h;
    if (y) {
      d += y;
      continue;
    }
    v === "BYTE_ARRAY" && f === void 0 && C !== "REPEATED" && (h.logical_type = r.get(p));
  }
}
const Bye = 1 << 19, Gye = new TextDecoder();
function Xn(e) {
  return e && Gye.decode(e);
}
async function Hye(e, { parsers: t, initialFetchSize: r = Bye, geoparquet: n = !0 } = {}) {
  if (!e || !(e.byteLength >= 0)) throw new Error("parquet expected AsyncBuffer");
  const i = Math.max(0, e.byteLength - r), o = await e.slice(i, e.byteLength), s = new DataView(o);
  if (s.getUint32(o.byteLength - 4, !0) !== 827474256)
    throw new Error("parquet file invalid (footer != PAR1)");
  const a = s.getUint32(o.byteLength - 8, !0);
  if (a > e.byteLength - 8)
    throw new Error(`parquet metadata length ${a} exceeds available buffer ${e.byteLength - 8}`);
  if (a + 8 > r) {
    const l = e.byteLength - a - 8, u = await e.slice(l, i), d = new ArrayBuffer(a + 8), h = new Uint8Array(d);
    return h.set(new Uint8Array(u)), h.set(new Uint8Array(o), i - l), ka(d, { parsers: t, geoparquet: n });
  } else
    return ka(o, { parsers: t, geoparquet: n });
}
function ka(e, { parsers: t, geoparquet: r = !0 } = {}) {
  var v;
  if (!(e instanceof ArrayBuffer)) throw new Error("parquet expected ArrayBuffer");
  const n = new DataView(e);
  if (t = { ...pD, ...t }, n.byteLength < 8)
    throw new Error("parquet file is too short");
  if (n.getUint32(n.byteLength - 4, !0) !== 827474256)
    throw new Error("parquet file invalid (footer != PAR1)");
  const i = n.byteLength - 8, o = n.getUint32(i, !0);
  if (o > n.byteLength - 8)
    throw new Error(`parquet metadata length ${o} exceeds available buffer ${n.byteLength - 8}`);
  const s = i - o, l = vC({ view: n, offset: s }), u = l.field_1, d = l.field_2.map((w) => ({
    type: jR[w.field_1],
    type_length: w.field_2,
    repetition_type: Mye[w.field_3],
    name: Xn(w.field_4),
    num_children: w.field_5,
    converted_type: Tye[w.field_6],
    scale: w.field_7,
    precision: w.field_8,
    field_id: w.field_9,
    logical_type: Wye(w.field_10)
  })), h = d.filter((w) => w.type), f = l.field_3, p = l.field_4.map((w) => {
    var R;
    return {
      columns: w.field_1.map((b, P) => {
        var S, E, A;
        return {
          file_path: Xn(b.field_1),
          file_offset: b.field_2,
          meta_data: b.field_3 && {
            type: jR[b.field_3.field_1],
            encodings: (S = b.field_3.field_2) == null ? void 0 : S.map((M) => jo[M]),
            path_in_schema: b.field_3.field_3.map(Xn),
            codec: Dye[b.field_3.field_4],
            num_values: b.field_3.field_5,
            total_uncompressed_size: b.field_3.field_6,
            total_compressed_size: b.field_3.field_7,
            key_value_metadata: (E = b.field_3.field_8) == null ? void 0 : E.map((M) => ({
              key: Xn(M.field_1),
              value: Xn(M.field_2)
            })),
            data_page_offset: b.field_3.field_9,
            index_page_offset: b.field_3.field_10,
            dictionary_page_offset: b.field_3.field_11,
            statistics: Vye(b.field_3.field_12, h[P], t),
            encoding_stats: (A = b.field_3.field_13) == null ? void 0 : A.map((M) => ({
              page_type: gD[M.field_1],
              encoding: jo[M.field_2],
              count: M.field_3
            })),
            bloom_filter_offset: b.field_3.field_14,
            bloom_filter_length: b.field_3.field_15,
            size_statistics: b.field_3.field_16 && {
              unencoded_byte_array_data_bytes: b.field_3.field_16.field_1,
              repetition_level_histogram: b.field_3.field_16.field_2,
              definition_level_histogram: b.field_3.field_16.field_3
            },
            geospatial_statistics: b.field_3.field_17 && {
              bbox: b.field_3.field_17.field_1 && {
                xmin: b.field_3.field_17.field_1.field_1,
                xmax: b.field_3.field_17.field_1.field_2,
                ymin: b.field_3.field_17.field_1.field_3,
                ymax: b.field_3.field_17.field_1.field_4,
                zmin: b.field_3.field_17.field_1.field_5,
                zmax: b.field_3.field_17.field_1.field_6,
                mmin: b.field_3.field_17.field_1.field_7,
                mmax: b.field_3.field_17.field_1.field_8
              },
              geospatial_types: b.field_3.field_17.field_2
            }
          },
          offset_index_offset: b.field_4,
          offset_index_length: b.field_5,
          column_index_offset: b.field_6,
          column_index_length: b.field_7,
          crypto_metadata: b.field_8,
          encrypted_column_metadata: b.field_9
        };
      }),
      total_byte_size: w.field_2,
      num_rows: w.field_3,
      sorting_columns: (R = w.field_4) == null ? void 0 : R.map((b) => ({
        column_idx: b.field_1,
        descending: b.field_2,
        nulls_first: b.field_3
      })),
      file_offset: w.field_5,
      total_compressed_size: w.field_6,
      ordinal: w.field_7
    };
  }), y = (v = l.field_5) == null ? void 0 : v.map((w) => ({
    key: Xn(w.field_1),
    value: Xn(w.field_2)
  })), C = Xn(l.field_6);
  return r && Nye(d, y), {
    version: u,
    schema: d,
    num_rows: f,
    row_groups: p,
    key_value_metadata: y,
    created_by: C,
    metadata_length: o
  };
}
function v0({ schema: e }) {
  return wD(e, [])[0];
}
function Wye(e) {
  return e != null && e.field_1 ? { type: "STRING" } : e != null && e.field_2 ? { type: "MAP" } : e != null && e.field_3 ? { type: "LIST" } : e != null && e.field_4 ? { type: "ENUM" } : e != null && e.field_5 ? {
    type: "DECIMAL",
    scale: e.field_5.field_1,
    precision: e.field_5.field_2
  } : e != null && e.field_6 ? { type: "DATE" } : e != null && e.field_7 ? {
    type: "TIME",
    isAdjustedToUTC: e.field_7.field_1,
    unit: qR(e.field_7.field_2)
  } : e != null && e.field_8 ? {
    type: "TIMESTAMP",
    isAdjustedToUTC: e.field_8.field_1,
    unit: qR(e.field_8.field_2)
  } : e != null && e.field_10 ? {
    type: "INTEGER",
    bitWidth: e.field_10.field_1,
    isSigned: e.field_10.field_2
  } : e != null && e.field_11 ? { type: "NULL" } : e != null && e.field_12 ? { type: "JSON" } : e != null && e.field_13 ? { type: "BSON" } : e != null && e.field_14 ? { type: "UUID" } : e != null && e.field_15 ? { type: "FLOAT16" } : e != null && e.field_16 ? {
    type: "VARIANT",
    specification_version: e.field_16.field_1
  } : e != null && e.field_17 ? {
    type: "GEOMETRY",
    crs: Xn(e.field_17.field_1)
  } : e != null && e.field_18 ? {
    type: "GEOGRAPHY",
    crs: Xn(e.field_18.field_1),
    algorithm: Oye[e.field_18.field_2]
  } : e;
}
function qR(e) {
  if (e.field_1) return "MILLIS";
  if (e.field_2) return "MICROS";
  if (e.field_3) return "NANOS";
  throw new Error("parquet time unit required");
}
function Vye(e, t, r) {
  return e && {
    max: hd(e.field_1, t, r),
    min: hd(e.field_2, t, r),
    null_count: e.field_3,
    distinct_count: e.field_4,
    max_value: hd(e.field_5, t, r),
    min_value: hd(e.field_6, t, r),
    is_max_value_exact: e.field_7,
    is_min_value_exact: e.field_8
  };
}
function hd(e, t, r) {
  const { type: n, converted_type: i, logical_type: o } = t;
  if (e === void 0) return e;
  if (n === "BOOLEAN") return e[0] === 1;
  if (n === "BYTE_ARRAY") return r.stringFromBytes(e);
  const s = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n === "FLOAT" && s.byteLength === 4 ? s.getFloat32(0, !0) : n === "DOUBLE" && s.byteLength === 8 ? s.getFloat64(0, !0) : n === "INT32" && i === "DATE" ? r.dateFromDays(s.getInt32(0, !0)) : n === "INT64" && i === "TIMESTAMP_MILLIS" ? r.timestampFromMilliseconds(s.getBigInt64(0, !0)) : n === "INT64" && i === "TIMESTAMP_MICROS" ? r.timestampFromMicroseconds(s.getBigInt64(0, !0)) : n === "INT64" && (o == null ? void 0 : o.type) === "TIMESTAMP" && (o == null ? void 0 : o.unit) === "NANOS" ? r.timestampFromNanoseconds(s.getBigInt64(0, !0)) : n === "INT64" && (o == null ? void 0 : o.type) === "TIMESTAMP" && (o == null ? void 0 : o.unit) === "MICROS" ? r.timestampFromMicroseconds(s.getBigInt64(0, !0)) : n === "INT64" && (o == null ? void 0 : o.type) === "TIMESTAMP" ? r.timestampFromMilliseconds(s.getBigInt64(0, !0)) : n === "INT32" && s.byteLength === 4 ? s.getInt32(0, !0) : n === "INT64" && s.byteLength === 8 ? s.getBigInt64(0, !0) : i === "DECIMAL" ? vD(e) * 10 ** -(t.scale || 0) : (o == null ? void 0 : o.type) === "FLOAT16" ? yD(e) : e;
}
function $ye(e) {
  const t = vC(e);
  return {
    page_locations: t.field_1.map(jye),
    unencoded_byte_array_data_bytes: t.field_2
  };
}
function jye(e) {
  return {
    offset: e.field_1,
    compressed_page_size: e.field_2,
    first_row_index: e.field_3
  };
}
function ED(e, t) {
  for (let n = 0; n < t.length; n += 1e4)
    e.push(...t.slice(n, n + 1e4));
}
function Oi(e, t, r = !0) {
  if (r ? e === t : e == t) return !0;
  if (e instanceof Uint8Array && t instanceof Uint8Array) return Oi(Array.from(e), Array.from(t), r);
  if (!e || !t || typeof e != typeof t) return !1;
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length) return !1;
    for (let i = 0; i < e.length; i++)
      if (!Oi(e[i], t[i], r)) return !1;
    return !0;
  }
  if (typeof e != "object") return !1;
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length) return !1;
  for (const i of n)
    if (!Oi(e[i], t[i], r)) return !1;
  return !0;
}
function PD(e) {
  if (!e) return [];
  if (e.length === 1) return e[0];
  const t = [];
  for (const r of e)
    ED(t, r);
  return t;
}
function bd(e) {
  if (!e) return [];
  const t = [];
  return "$and" in e && Array.isArray(e.$and) ? t.push(...e.$and.flatMap(bd)) : "$or" in e && Array.isArray(e.$or) ? t.push(...e.$or.flatMap(bd)) : "$nor" in e && Array.isArray(e.$nor) ? t.push(...e.$nor.flatMap(bd)) : t.push(...Object.keys(e)), t;
}
function Gl(e, t, r = !0) {
  return "$and" in t && Array.isArray(t.$and) ? t.$and.every((n) => Gl(e, n, r)) : "$or" in t && Array.isArray(t.$or) ? t.$or.some((n) => Gl(e, n, r)) : "$nor" in t && Array.isArray(t.$nor) ? !t.$nor.some((n) => Gl(e, n, r)) : Object.entries(t).every(([n, i]) => {
    const o = e[n];
    return typeof i != "object" || i === null || Array.isArray(i) ? Oi(o, i, r) : Object.entries(i || {}).every(([s, a]) => s === "$gt" ? o > a : s === "$gte" ? o >= a : s === "$lt" ? o < a : s === "$lte" ? o <= a : s === "$eq" ? Oi(o, a, r) : s === "$ne" ? !Oi(o, a, r) : s === "$in" ? Array.isArray(a) && a.includes(o) : s === "$nin" ? Array.isArray(a) && !a.includes(o) : s === "$not" ? !Gl({ [n]: o }, { [n]: a }, r) : !0);
  });
}
function y0({ rowGroup: e, physicalColumns: t, filter: r, strict: n = !0 }) {
  var i;
  if (!r) return !1;
  if ("$and" in r && Array.isArray(r.$and))
    return r.$and.some((o) => y0({ rowGroup: e, physicalColumns: t, filter: o, strict: n }));
  if ("$or" in r && Array.isArray(r.$or))
    return r.$or.every((o) => y0({ rowGroup: e, physicalColumns: t, filter: o, strict: n }));
  if ("$nor" in r && Array.isArray(r.$nor))
    return !1;
  for (const [o, s] of Object.entries(r)) {
    const a = t.indexOf(o);
    if (a === -1) continue;
    const l = (i = e.columns[a].meta_data) == null ? void 0 : i.statistics;
    if (!l) continue;
    const { min: u, max: d, min_value: h, max_value: f } = l, p = h !== void 0 ? h : u, y = f !== void 0 ? f : d;
    if (!(p === void 0 || y === void 0)) {
      for (const [C, v] of Object.entries(s || {}))
        if (C === "$gt" && y <= v || C === "$gte" && y < v || C === "$lt" && p >= v || C === "$lte" && p > v || C === "$eq" && (v < p || v > y) || C === "$ne" && Oi(p, y, n) && Oi(p, v, n) || C === "$in" && Array.isArray(v) && v.every((w) => w < p || w > y) || C === "$nin" && Array.isArray(v) && Oi(p, y, n) && v.includes(p)) return !0;
    }
  }
  return !1;
}
const Uye = 1 << 21;
function Kye({ metadata: e, rowStart: t = 0, rowEnd: r = 1 / 0, columns: n, filter: i, filterStrict: o = !0, useOffsetIndex: s = !1 }) {
  if (!e) throw new Error("parquetPlan requires metadata");
  const a = [], l = [], u = [], d = kye(v0(e));
  let h = 0;
  for (const f of e.row_groups) {
    const p = Number(f.num_rows), y = h + p;
    if (p > 0 && y > t && h < r && !y0({ rowGroup: f, physicalColumns: d, filter: i, strict: o })) {
      const C = [];
      for (const b of f.columns) {
        const P = b.meta_data;
        if (b.file_path) throw new Error("parquet file_path not supported");
        if (!P) throw new Error("parquet column metadata is undefined");
        if (!n || n.includes(P.path_in_schema[0])) {
          const S = P.dictionary_page_offset || P.data_page_offset, E = Number(S), A = Number(S + P.total_compressed_size);
          if (s && b.offset_index_offset && b.offset_index_length) {
            const M = Number(b.offset_index_offset);
            C.push({
              columnMetadata: P,
              offsetIndex: {
                startByte: M,
                endByte: M + b.offset_index_length
              },
              bounds: { startByte: E, endByte: A }
            });
          } else
            C.push({
              columnMetadata: P,
              range: { startByte: E, endByte: A }
            });
        }
      }
      const v = Math.max(t - h, 0), w = Math.min(r - h, p);
      a.push({ chunks: C, rowGroup: f, groupStart: h, groupRows: p, selectStart: v, selectEnd: w });
      let R;
      for (const b of C)
        if ("offsetIndex" in b)
          u.push(b.offsetIndex);
        else {
          const { range: P } = b;
          n ? l.push(P) : R && P.endByte - R.startByte <= Uye ? R.endByte = P.endByte : (R && l.push(R), R = { ...P });
        }
      R && l.push(R);
    }
    h = y;
  }
  return isFinite(r) || (r = h), l.push(...u), { metadata: e, rowStart: t, rowEnd: r, columns: n, fetches: l, groups: a };
}
function qye(e, { fetches: t }) {
  const r = t.map(({ startByte: n, endByte: i }) => e.slice(n, i));
  return {
    byteLength: e.byteLength,
    slice(n, i = e.byteLength) {
      const o = t.findIndex(({ startByte: s, endByte: a }) => s <= n && i <= a);
      if (o < 0)
        return e.slice(n, i);
      if (t[o].startByte !== n || t[o].endByte !== i) {
        const s = n - t[o].startByte, a = i - t[o].startByte;
        return r[o] instanceof Promise ? r[o].then((l) => l.slice(s, a)) : r[o].slice(s, a);
      } else
        return r[o];
    }
  };
}
function YR(e, t, r, n, i) {
  const o = (t == null ? void 0 : t.length) || r.length;
  if (!o) return n;
  const s = mC(i), a = i.map(({ element: y }) => y.repetition_type);
  let l = 0;
  const u = [e];
  let d = e, h = 0, f = 0, p = 0;
  if (r[0])
    for (; h < a.length - 2 && p < r[0]; )
      h++, a[h] !== "REQUIRED" && (d = d.at(-1), u.push(d), f++), a[h] === "REPEATED" && p++;
  for (let y = 0; y < o; y++) {
    const C = t != null && t.length ? t[y] : s, v = r[y];
    for (; h && (v < p || a[h] !== "REPEATED"); )
      a[h] !== "REQUIRED" && (u.pop(), f--), a[h] === "REPEATED" && p--, h--;
    for (d = u.at(-1); (h < a.length - 2 || a[h + 1] === "REPEATED") && (f < C || a[h + 1] === "REQUIRED"); ) {
      if (h++, a[h] !== "REQUIRED") {
        const w = [];
        d.push(w), d = w, u.push(w), f++;
      }
      a[h] === "REPEATED" && p++;
    }
    C === s ? d.push(n[l++]) : h === a.length - 2 ? d.push(null) : d.push([]);
  }
  if (!e.length)
    for (let y = 0; y < s; y++) {
      const C = [];
      d.push(C), d = C;
    }
  return e;
}
function Hl(e, t, r = 0) {
  const n = t.path.join("."), i = t.element.repetition_type === "OPTIONAL", o = i ? r + 1 : r;
  if (Lye(t)) {
    let s = t.children[0], a = o;
    s.children.length === 1 && (s = s.children[0], a++), Hl(e, s, a);
    const l = s.path.join("."), u = e.get(l);
    if (!u) throw new Error("parquet list column missing values");
    i && Sd(u, r), e.set(n, u), e.delete(l);
    return;
  }
  if (_ye(t)) {
    const s = t.children[0].element.name;
    Hl(e, t.children[0].children[0], o + 1), Hl(e, t.children[0].children[1], o + 1);
    const a = e.get(`${n}.${s}.key`), l = e.get(`${n}.${s}.value`);
    if (!a) throw new Error("parquet map column missing keys");
    if (!l) throw new Error("parquet map column missing values");
    if (a.length !== l.length)
      throw new Error("parquet map column key/value length mismatch");
    const u = AD(a, l, o);
    i && Sd(u, r), e.delete(`${n}.${s}.key`), e.delete(`${n}.${s}.value`), e.set(n, u);
    return;
  }
  if (t.children.length) {
    const s = t.element.repetition_type === "REQUIRED" ? r : r + 1, a = {};
    for (const u of t.children) {
      Hl(e, u, s);
      const d = e.get(u.path.join("."));
      if (!d) throw new Error("parquet struct missing child data");
      a[u.element.name] = d;
    }
    for (const u of t.children)
      e.delete(u.path.join("."));
    const l = FD(a, s);
    i && Sd(l, r), e.set(n, l);
  }
}
function Sd(e, t) {
  for (let r = 0; r < e.length; r++)
    t ? Sd(e[r], t - 1) : e[r] = e[r][0];
}
function AD(e, t, r) {
  const n = [];
  for (let i = 0; i < e.length; i++)
    if (r)
      n.push(AD(e[i], t[i], r - 1));
    else if (e[i]) {
      const o = {};
      for (let s = 0; s < e[i].length; s++) {
        const a = t[i][s];
        o[e[i][s]] = a === void 0 ? null : a;
      }
      n.push(o);
    } else
      n.push(void 0);
  return n;
}
function FD(e, t) {
  var o;
  const r = Object.keys(e), n = (o = e[r[0]]) == null ? void 0 : o.length, i = [];
  for (let s = 0; s < n; s++) {
    const a = {};
    for (const l of r) {
      if (e[l].length !== n) throw new Error("parquet struct parsing error");
      a[l] = e[l][s];
    }
    t ? i.push(FD(a, t - 1)) : i.push(a);
  }
  return i;
}
function Wc(e, t, r) {
  const n = r instanceof Int32Array, i = ss(e), o = ss(e);
  ss(e);
  let s = m0(e), a = 0;
  r[a++] = n ? Number(s) : s;
  const l = i / o;
  for (; a < t; ) {
    const u = m0(e), d = new Uint8Array(o);
    for (let h = 0; h < o; h++)
      d[h] = e.view.getUint8(e.offset++);
    for (let h = 0; h < o && a < t; h++) {
      const f = BigInt(d[h]);
      if (f) {
        let p = 0n, y = l;
        const C = (1n << f) - 1n;
        for (; y && a < t; ) {
          let v = BigInt(e.view.getUint8(e.offset)) >> p & C;
          for (p += f; p >= 8; )
            p -= 8n, e.offset++, p && (v |= BigInt(e.view.getUint8(e.offset)) << f - p & C);
          const w = u + v;
          s += w, r[a++] = n ? Number(s) : s, y--;
        }
        y && (e.offset += Math.ceil((y * Number(f) + Number(p)) / 8));
      } else
        for (let p = 0; p < l && a < t; p++)
          s += u, r[a++] = n ? Number(s) : s;
    }
  }
}
function MD(e, t, r) {
  const n = new Int32Array(t);
  Wc(e, t, n);
  for (let i = 0; i < t; i++)
    r[i] = new Uint8Array(e.view.buffer, e.view.byteOffset + e.offset, n[i]), e.offset += n[i];
}
function Yye(e, t, r) {
  const n = new Int32Array(t);
  Wc(e, t, n);
  const i = new Int32Array(t);
  Wc(e, t, i);
  for (let o = 0; o < t; o++) {
    const s = new Uint8Array(e.view.buffer, e.view.byteOffset + e.offset, i[o]);
    n[o] ? (r[o] = new Uint8Array(n[o] + i[o]), r[o].set(r[o - 1].subarray(0, n[o])), r[o].set(s, n[o])) : r[o] = s, e.offset += i[o];
  }
}
function zg(e) {
  return 32 - Math.clz32(e);
}
function po(e, t, r, n) {
  n === void 0 && (n = e.view.getUint32(e.offset, !0), e.offset += 4);
  const i = e.offset;
  let o = 0;
  for (; o < r.length; ) {
    const s = ss(e);
    if (s & 1)
      o = Xye(e, s, t, r, o);
    else {
      const a = s >>> 1;
      Jye(e, a, t, r, o), o += a;
    }
  }
  e.offset = i + n;
}
function Jye(e, t, r, n, i) {
  const o = r + 7 >> 3;
  let s = 0;
  for (let a = 0; a < o; a++)
    s |= e.view.getUint8(e.offset++) << (a << 3);
  for (let a = 0; a < t; a++)
    n[i + a] = s;
}
function Xye(e, t, r, n, i) {
  let o = t >> 1 << 3;
  const s = (1 << r) - 1;
  let a = 0;
  if (e.offset < e.view.byteLength)
    a = e.view.getUint8(e.offset++);
  else if (s)
    throw new Error(`parquet bitpack offset ${e.offset} out of range`);
  let l = 8, u = 0;
  for (; o; )
    u > 8 ? (u -= 8, l -= 8, a >>>= 8) : l - u < r ? (a |= e.view.getUint8(e.offset) << l, e.offset++, l += 8) : (i < n.length && (n[i++] = a >> u & s), o--, u += r);
  return i;
}
function TD(e, t, r, n) {
  const i = Qye(r, n), o = new Uint8Array(t * i);
  for (let s = 0; s < i; s++)
    for (let a = 0; a < t; a++)
      o[a * i + s] = e.view.getUint8(e.offset++);
  if (r === "FLOAT") return new Float32Array(o.buffer);
  if (r === "DOUBLE") return new Float64Array(o.buffer);
  if (r === "INT32") return new Int32Array(o.buffer);
  if (r === "INT64") return new BigInt64Array(o.buffer);
  if (r === "FIXED_LEN_BYTE_ARRAY") {
    const s = new Array(t);
    for (let a = 0; a < t; a++)
      s[a] = o.subarray(a * i, (a + 1) * i);
    return s;
  }
  throw new Error(`parquet byte_stream_split unsupported type: ${r}`);
}
function Qye(e, t) {
  switch (e) {
    case "INT32":
    case "FLOAT":
      return 4;
    case "INT64":
    case "DOUBLE":
      return 8;
    case "FIXED_LEN_BYTE_ARRAY":
      if (!t) throw new Error("parquet byteWidth missing type_length");
      return t;
    default:
      throw new Error(`parquet unsupported type: ${e}`);
  }
}
function yC(e, t, r, n) {
  if (r === 0) return [];
  if (t === "BOOLEAN")
    return Zye(e, r);
  if (t === "INT32")
    return eCe(e, r);
  if (t === "INT64")
    return tCe(e, r);
  if (t === "INT96")
    return rCe(e, r);
  if (t === "FLOAT")
    return nCe(e, r);
  if (t === "DOUBLE")
    return iCe(e, r);
  if (t === "BYTE_ARRAY")
    return oCe(e, r);
  if (t === "FIXED_LEN_BYTE_ARRAY") {
    if (!n) throw new Error("parquet missing fixed length");
    return sCe(e, r, n);
  } else
    throw new Error(`parquet unhandled type: ${t}`);
}
function Zye(e, t) {
  const r = new Array(t);
  for (let n = 0; n < t; n++) {
    const i = e.offset + (n / 8 | 0), o = n % 8, s = e.view.getUint8(i);
    r[n] = (s & 1 << o) !== 0;
  }
  return e.offset += Math.ceil(t / 8), r;
}
function eCe(e, t) {
  const r = (e.view.byteOffset + e.offset) % 4 ? new Int32Array(Ng(e.view.buffer, e.view.byteOffset + e.offset, t * 4)) : new Int32Array(e.view.buffer, e.view.byteOffset + e.offset, t);
  return e.offset += t * 4, r;
}
function tCe(e, t) {
  const r = (e.view.byteOffset + e.offset) % 8 ? new BigInt64Array(Ng(e.view.buffer, e.view.byteOffset + e.offset, t * 8)) : new BigInt64Array(e.view.buffer, e.view.byteOffset + e.offset, t);
  return e.offset += t * 8, r;
}
function rCe(e, t) {
  const r = new Array(t);
  for (let n = 0; n < t; n++) {
    const i = e.view.getBigInt64(e.offset + n * 12, !0), o = e.view.getInt32(e.offset + n * 12 + 8, !0);
    r[n] = BigInt(o) << 64n | i;
  }
  return e.offset += t * 12, r;
}
function nCe(e, t) {
  const r = (e.view.byteOffset + e.offset) % 4 ? new Float32Array(Ng(e.view.buffer, e.view.byteOffset + e.offset, t * 4)) : new Float32Array(e.view.buffer, e.view.byteOffset + e.offset, t);
  return e.offset += t * 4, r;
}
function iCe(e, t) {
  const r = (e.view.byteOffset + e.offset) % 8 ? new Float64Array(Ng(e.view.buffer, e.view.byteOffset + e.offset, t * 8)) : new Float64Array(e.view.buffer, e.view.byteOffset + e.offset, t);
  return e.offset += t * 8, r;
}
function oCe(e, t) {
  const r = new Array(t);
  for (let n = 0; n < t; n++) {
    const i = e.view.getUint32(e.offset, !0);
    e.offset += 4, r[n] = new Uint8Array(e.view.buffer, e.view.byteOffset + e.offset, i), e.offset += i;
  }
  return r;
}
function sCe(e, t, r) {
  const n = new Array(t);
  for (let i = 0; i < t; i++)
    n[i] = new Uint8Array(e.view.buffer, e.view.byteOffset + e.offset, r), e.offset += r;
  return n;
}
function Ng(e, t, r) {
  const n = new ArrayBuffer(r);
  return new Uint8Array(n).set(new Uint8Array(e, t, r)), n;
}
const aCe = [0, 255, 65535, 16777215, 4294967295];
function JR(e, t, r, n, i) {
  for (let o = 0; o < i; o++)
    r[n + o] = e[t + o];
}
function lCe(e, t) {
  const r = e.byteLength, n = t.byteLength;
  let i = 0, o = 0;
  for (; i < r; ) {
    const s = e[i];
    if (i++, s < 128)
      break;
  }
  if (n && i >= r)
    throw new Error("invalid snappy length header");
  for (; i < r; ) {
    const s = e[i];
    let a = 0;
    if (i++, i >= r)
      throw new Error("missing eof marker");
    if (s & 3) {
      let l = 0;
      switch (s & 3) {
        case 1:
          a = (s >>> 2 & 7) + 4, l = e[i] + (s >>> 5 << 8), i++;
          break;
        case 2:
          if (r <= i + 1)
            throw new Error("snappy error end of input");
          a = (s >>> 2) + 1, l = e[i] + (e[i + 1] << 8), i += 2;
          break;
        case 3:
          if (r <= i + 3)
            throw new Error("snappy error end of input");
          a = (s >>> 2) + 1, l = e[i] + (e[i + 1] << 8) + (e[i + 2] << 16) + (e[i + 3] << 24), i += 4;
          break;
      }
      if (l === 0 || isNaN(l))
        throw new Error(`invalid offset ${l} pos ${i} inputLength ${r}`);
      if (l > o)
        throw new Error("cannot copy from before start of buffer");
      JR(t, o - l, t, o, a), o += a;
    } else {
      let l = (s >>> 2) + 1;
      if (l > 60) {
        if (i + 3 >= r)
          throw new Error("snappy error literal pos + 3 >= inputLength");
        const u = l - 60;
        l = e[i] + (e[i + 1] << 8) + (e[i + 2] << 16) + (e[i + 3] << 24), l = (l & aCe[u]) + 1, i += u;
      }
      if (i + l > r)
        throw new Error("snappy error literal exceeds input length");
      JR(e, i, t, o, l), i += l, o += l;
    }
  }
  if (o !== n) throw new Error("premature end of input");
}
function cCe(e, t, { type: r, element: n, schemaPath: i }) {
  const o = new DataView(e.buffer, e.byteOffset, e.byteLength), s = { view: o, offset: 0 };
  let a;
  const l = uCe(s, t, i), { definitionLevels: u, numNulls: d } = dCe(s, t, i), h = t.num_values - d;
  if (t.encoding === "PLAIN")
    a = yC(s, r, h, n.type_length);
  else if (t.encoding === "PLAIN_DICTIONARY" || t.encoding === "RLE_DICTIONARY" || t.encoding === "RLE") {
    const f = r === "BOOLEAN" ? 1 : o.getUint8(s.offset++);
    f ? (a = new Array(h), r === "BOOLEAN" ? (po(s, f, a), a = a.map((p) => !!p)) : po(s, f, a, o.byteLength - s.offset)) : a = new Uint8Array(h);
  } else if (t.encoding === "BYTE_STREAM_SPLIT")
    a = TD(s, h, r, n.type_length);
  else if (t.encoding === "DELTA_BINARY_PACKED")
    a = r === "INT32" ? new Int32Array(h) : new BigInt64Array(h), Wc(s, h, a);
  else if (t.encoding === "DELTA_LENGTH_BYTE_ARRAY")
    a = new Array(h), MD(s, h, a);
  else
    throw new Error(`parquet unsupported encoding: ${t.encoding}`);
  return { definitionLevels: u, repetitionLevels: l, dataPage: a };
}
function uCe(e, t, r) {
  if (r.length > 1) {
    const n = bD(r);
    if (n) {
      const i = new Array(t.num_values);
      return po(e, zg(n), i), i;
    }
  }
  return [];
}
function dCe(e, t, r) {
  const n = mC(r);
  if (!n) return { definitionLevels: [], numNulls: 0 };
  const i = new Array(t.num_values);
  po(e, zg(n), i);
  let o = t.num_values;
  for (const s of i)
    s === n && o--;
  return o === 0 && (i.length = 0), { definitionLevels: i, numNulls: o };
}
function C0(e, t, r, n) {
  let i;
  const o = n == null ? void 0 : n[r];
  if (r === "UNCOMPRESSED")
    i = e;
  else if (o)
    i = o(e, t);
  else if (r === "SNAPPY")
    i = new Uint8Array(t), lCe(e, i);
  else
    throw new Error(`parquet unsupported compression codec: ${r}`);
  if ((i == null ? void 0 : i.length) !== t)
    throw new Error(`parquet decompressed page length ${i == null ? void 0 : i.length} does not match header ${t}`);
  return i;
}
function hCe(e, t, r) {
  const i = { view: new DataView(e.buffer, e.byteOffset, e.byteLength), offset: 0 }, { type: o, element: s, schemaPath: a, codec: l, compressors: u } = r, d = t.data_page_header_v2;
  if (!d) throw new Error("parquet data page header v2 is undefined");
  const h = gCe(i, d, a);
  i.offset = d.repetition_levels_byte_length;
  const f = fCe(i, d, a), p = t.uncompressed_page_size - d.definition_levels_byte_length - d.repetition_levels_byte_length;
  let y = e.subarray(i.offset);
  d.is_compressed !== !1 && (y = C0(y, p, l, u));
  const C = new DataView(y.buffer, y.byteOffset, y.byteLength), v = { view: C, offset: 0 };
  let w;
  const R = d.num_values - d.num_nulls;
  if (d.encoding === "PLAIN")
    w = yC(v, o, R, s.type_length);
  else if (d.encoding === "RLE")
    w = new Array(R), po(v, 1, w), w = w.map((b) => !!b);
  else if (d.encoding === "PLAIN_DICTIONARY" || d.encoding === "RLE_DICTIONARY") {
    const b = C.getUint8(v.offset++);
    w = new Array(R), po(v, b, w, p - 1);
  } else if (d.encoding === "DELTA_BINARY_PACKED")
    w = o === "INT32" ? new Int32Array(R) : new BigInt64Array(R), Wc(v, R, w);
  else if (d.encoding === "DELTA_LENGTH_BYTE_ARRAY")
    w = new Array(R), MD(v, R, w);
  else if (d.encoding === "DELTA_BYTE_ARRAY")
    w = new Array(R), Yye(v, R, w);
  else if (d.encoding === "BYTE_STREAM_SPLIT")
    w = TD(v, R, o, s.type_length);
  else
    throw new Error(`parquet unsupported encoding: ${d.encoding}`);
  return { definitionLevels: f, repetitionLevels: h, dataPage: w };
}
function gCe(e, t, r) {
  const n = bD(r);
  if (!n) return [];
  const i = new Array(t.num_values);
  return po(e, zg(n), i, t.repetition_levels_byte_length), i;
}
function fCe(e, t, r) {
  const n = mC(r);
  if (n) {
    const i = new Array(t.num_values);
    return po(e, zg(n), i, t.definition_levels_byte_length), i;
  }
}
function XR(e, { groupStart: t, selectStart: r, selectEnd: n }, i, o) {
  const { pathInSchema: s, schemaPath: a } = i, l = SD(a), u = [];
  let d, h, f = 0;
  const p = o && (() => {
    h && o({
      pathInSchema: s,
      columnData: h,
      rowStart: t + f - h.length,
      rowEnd: t + f
    });
  });
  for (; (l ? f < n : e.offset < e.view.byteLength - 1) && !(e.offset >= e.view.byteLength - 1); ) {
    const y = pCe(e);
    if (y.type === "DICTIONARY_PAGE")
      d = QR(e, y, i, d, void 0, 0), d = mD(d, i);
    else {
      const C = (h == null ? void 0 : h.length) || 0, v = QR(e, y, i, d, h, r - f);
      h === v ? f += v.length - C : (p == null || p(), u.push(v), f += v.length, h = v);
    }
  }
  return p == null || p(), u;
}
function QR(e, t, r, n, i, o) {
  const { type: s, element: a, schemaPath: l, codec: u, compressors: d } = r, h = new Uint8Array(
    e.view.buffer,
    e.view.byteOffset + e.offset,
    t.compressed_page_size
  );
  if (e.offset += t.compressed_page_size, t.type === "DATA_PAGE") {
    const f = t.data_page_header;
    if (!f) throw new Error("parquet data page header is undefined");
    if (o > f.num_values && SD(l))
      return new Array(f.num_values);
    const p = C0(h, Number(t.uncompressed_page_size), u, d), { definitionLevels: y, repetitionLevels: C, dataPage: v } = cCe(p, f, r);
    let w = KR(v, n, f.encoding, r);
    if (C.length || y != null && y.length) {
      const R = Array.isArray(i) ? i : [];
      return YR(R, y, C, w, l);
    } else {
      for (let R = 2; R < l.length; R++)
        l[R].element.repetition_type !== "REQUIRED" && (w = Array.from(w, (b) => [b]));
      return w;
    }
  } else if (t.type === "DATA_PAGE_V2") {
    const f = t.data_page_header_v2;
    if (!f) throw new Error("parquet data page header v2 is undefined");
    if (o > f.num_rows)
      return new Array(f.num_values);
    const { definitionLevels: p, repetitionLevels: y, dataPage: C } = hCe(h, t, r), v = KR(C, n, f.encoding, r), w = Array.isArray(i) ? i : [];
    return YR(w, p, y, v, l);
  } else if (t.type === "DICTIONARY_PAGE") {
    const f = t.dictionary_page_header;
    if (!f) throw new Error("parquet dictionary page header is undefined");
    const p = C0(
      h,
      Number(t.uncompressed_page_size),
      u,
      d
    ), y = { view: new DataView(p.buffer, p.byteOffset, p.byteLength), offset: 0 };
    return yC(y, s, f.num_values, a.type_length);
  } else
    throw new Error(`parquet unsupported page type: ${t.type}`);
}
function pCe(e) {
  const t = vC(e), r = gD[t.field_1], n = t.field_2, i = t.field_3, o = t.field_4, s = t.field_5 && {
    num_values: t.field_5.field_1,
    encoding: jo[t.field_5.field_2],
    definition_level_encoding: jo[t.field_5.field_3],
    repetition_level_encoding: jo[t.field_5.field_4],
    statistics: t.field_5.field_5 && {
      max: t.field_5.field_5.field_1,
      min: t.field_5.field_5.field_2,
      null_count: t.field_5.field_5.field_3,
      distinct_count: t.field_5.field_5.field_4,
      max_value: t.field_5.field_5.field_5,
      min_value: t.field_5.field_5.field_6
    }
  }, a = t.field_6, l = t.field_7 && {
    num_values: t.field_7.field_1,
    encoding: jo[t.field_7.field_2],
    is_sorted: t.field_7.field_3
  }, u = t.field_8 && {
    num_values: t.field_8.field_1,
    num_nulls: t.field_8.field_2,
    num_rows: t.field_8.field_3,
    encoding: jo[t.field_8.field_4],
    definition_levels_byte_length: t.field_8.field_5,
    repetition_levels_byte_length: t.field_8.field_6,
    is_compressed: t.field_8.field_7 === void 0 ? !0 : t.field_8.field_7,
    // default true
    statistics: t.field_8.field_8
  };
  return {
    type: r,
    uncompressed_page_size: n,
    compressed_page_size: i,
    crc: o,
    data_page_header: s,
    index_page_header: a,
    dictionary_page_header: l,
    data_page_header_v2: u
  };
}
function mCe(e, { metadata: t }, r) {
  const { file: n, compressors: i, utf8: o } = e, s = [], a = { ...pD, ...e.parsers };
  for (const l of r.chunks) {
    const { columnMetadata: u } = l, d = wD(t.schema, u.path_in_schema), h = {
      pathInSchema: u.path_in_schema,
      type: u.type,
      element: d[d.length - 1].element,
      schemaPath: d,
      codec: u.codec,
      parsers: a,
      compressors: i,
      utf8: o
    };
    if (!("offsetIndex" in l)) {
      s.push({
        pathInSchema: u.path_in_schema,
        data: Promise.resolve(n.slice(l.range.startByte, l.range.endByte)).then((f) => {
          const p = { view: new DataView(f), offset: 0 };
          return {
            pageSkip: 0,
            data: XR(p, r, h, e.onPage)
          };
        })
      });
      continue;
    }
    s.push({
      pathInSchema: u.path_in_schema,
      // fetch offset index
      data: Promise.resolve(n.slice(l.offsetIndex.startByte, l.offsetIndex.endByte)).then(async (f) => {
        const p = $ye({ view: new DataView(f), offset: 0 }), { selectStart: y, selectEnd: C } = r, v = p.page_locations;
        let w = NaN, R = NaN, b = 0;
        for (let A = 0; A < v.length; A++) {
          const M = v[A], I = Number(M.first_row_index), z = A + 1 < v.length ? Number(v[A + 1].first_row_index) : r.groupRows;
          I < C && z > y && (Number.isNaN(w) && (w = Number(M.offset), b = I), R = Number(M.offset) + M.compressed_page_size);
        }
        const P = await n.slice(w, R), S = { view: new DataView(P), offset: 0 }, E = b ? {
          ...r,
          groupStart: r.groupStart + b,
          selectStart: r.selectStart - b,
          selectEnd: r.selectEnd - b
        } : r;
        return {
          data: XR(S, E, h, e.onPage),
          pageSkip: b
        };
      })
    });
  }
  return { groupStart: r.groupStart, groupRows: r.groupRows, asyncColumns: s };
}
async function ZR({ asyncColumns: e }, t, r, n, i) {
  const o = await Promise.all(e.map(async ({ data: h }) => {
    const f = await h;
    return {
      ...f,
      data: PD(f.data)
    };
  })), s = e.map((h) => h.pathInSchema[0]).filter((h) => !n || n.includes(h)), a = n ?? s, l = a.map((h) => e.findIndex((f) => f.pathInSchema[0] === h)), u = r - t;
  if (i === "object") {
    const h = Array(u);
    for (let f = 0; f < u; f++) {
      const p = t + f, y = {};
      for (let C = 0; C < e.length; C++) {
        const { data: v, pageSkip: w } = o[C];
        y[e[C].pathInSchema[0]] = v[p - w];
      }
      h[f] = y;
    }
    return h;
  }
  const d = Array(u);
  for (let h = 0; h < u; h++) {
    const f = t + h, p = Array(e.length);
    for (let y = 0; y < a.length; y++) {
      const C = l[y];
      if (C >= 0) {
        const { data: v, pageSkip: w } = o[C];
        p[y] = v[f - w];
      }
    }
    d[h] = p;
  }
  return d;
}
function vCe(e, t) {
  const { asyncColumns: r } = e, n = [];
  for (const i of t.children)
    if (i.children.length) {
      const o = r.filter((l) => l.pathInSchema[0] === i.element.name);
      if (!o.length) continue;
      const s = /* @__PURE__ */ new Map(), a = Promise.all(o.map((l) => l.data.then(({ data: u }) => {
        s.set(l.pathInSchema.join("."), PD(u));
      }))).then(() => {
        Hl(s, i);
        const l = s.get(i.path.join("."));
        if (!l) throw new Error("parquet column data not assembled");
        return { data: [l], pageSkip: 0 };
      });
      n.push({ pathInSchema: i.path, data: a });
    } else {
      const o = r.find((s) => s.pathInSchema[0] === i.element.name);
      o && n.push(o);
    }
  return { ...e, asyncColumns: n };
}
async function Bg(e) {
  e.metadata ?? (e.metadata = await Hye(e.file, e));
  const { rowStart: t = 0, rowEnd: r, columns: n, onChunk: i, onComplete: o, rowFormat: s, filter: a, filterStrict: l = !0 } = e;
  if (a && s !== "object")
    throw new Error('parquet filter requires rowFormat: "object"');
  const u = bd(a);
  if (u.length) {
    const v = v0(e.metadata).children.map((R) => R.element.name), w = u.filter((R) => !v.includes(R));
    if (w.length)
      throw new Error(`parquet filter columns not found: ${w.join(", ")}`);
  }
  let d = n, h = !1;
  if (n && a) {
    const v = u.filter((w) => !n.includes(w));
    v.length && (d = [...n, ...v], h = !0);
  }
  const f = d !== n ? { ...e, columns: d } : e, p = yCe(f);
  if (!o && !i) {
    for (const { asyncColumns: v } of p)
      for (const { data: w } of v) await w;
    return;
  }
  const y = v0(e.metadata), C = p.map((v) => vCe(v, y));
  if (i)
    for (const v of C)
      for (const w of v.asyncColumns)
        w.data.then(({ data: R, pageSkip: b }) => {
          let P = v.groupStart + b;
          for (const S of R)
            i({
              columnName: w.pathInSchema[0],
              columnData: S,
              rowStart: P,
              rowEnd: P + S.length
            }), P += S.length;
        });
  if (o) {
    const v = [];
    for (const w of C) {
      const R = Math.max(t - w.groupStart, 0), b = Math.min((r ?? 1 / 0) - w.groupStart, w.groupRows), P = s === "object" ? await ZR(w, R, b, d, "object") : await ZR(w, R, b, n, "array");
      if (a) {
        for (
          const S of
          /** @type {Record<string, any>[]} */
          P
        )
          if (Gl(S, a, l)) {
            if (h && n)
              for (const E of u)
                n.includes(E) || delete S[E];
            v.push(S);
          }
      } else
        ED(v, P);
    }
    o(v);
  } else
    for (const { asyncColumns: v } of C)
      for (const { data: w } of v) await w;
}
function yCe(e) {
  if (!e.metadata) throw new Error("parquet requires metadata");
  const t = Kye(e);
  return e.file = qye(e.file, t), t.groups.map((r) => mCe(e, t, r));
}
function CC(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e) && e.format === "parquet_b64" && typeof e.data == "string";
}
const Ys = /* @__PURE__ */ new Map(), CCe = 8;
function w0(e, t) {
  if (Ys.size >= CCe) {
    const r = Ys.keys().next().value;
    r !== void 0 && Ys.delete(r);
  }
  Ys.set(e, t);
}
function DD(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r.buffer;
}
function OD(e) {
  const t = {};
  for (const [r, n] of Object.entries(e))
    if (r === "index" || r === "level_0")
      t[r] = n;
    else if (typeof n == "string")
      try {
        t[r] = JSON.parse(n);
      } catch {
        t[r] = n;
      }
    else
      t[r] = n;
  return t;
}
function La(e) {
  if (e == null) return [];
  if (Array.isArray(e)) return e;
  if (CC(e)) {
    const t = Ys.get(e.data);
    if (t && t.length > 0) return t;
    try {
      const r = DD(e.data), n = ka(r);
      let i = [];
      return Bg({
        file: r,
        metadata: n,
        rowFormat: "object",
        onComplete: (o) => {
          i = o.map(OD), w0(e.data, i);
        }
      }), i.length > 0 && w0(e.data, i), i;
    } catch (r) {
      return console.error("resolveDFData: failed to decode parquet_b64", r), [];
    }
  }
  return console.warn("resolveDFData: unknown payload format", e), [];
}
async function wCe(e) {
  if (e == null) return [];
  if (Array.isArray(e)) return e;
  if (CC(e)) {
    const t = Ys.get(e.data);
    if (t && t.length > 0) return t;
    try {
      const r = DD(e.data), n = ka(r), o = (await new Promise((s, a) => {
        try {
          Bg({
            file: r,
            metadata: n,
            rowFormat: "object",
            onComplete: (l) => s(l)
          });
        } catch (l) {
          a(l);
        }
      })).map(OD);
      return w0(e.data, o), o;
    } catch (r) {
      return console.error("resolveDFDataAsync: failed to decode parquet_b64", r), [];
    }
  }
  return console.warn("resolveDFDataAsync: unknown payload format", e), [];
}
async function bCe(e) {
  if (!e) return {};
  const t = {}, r = [];
  for (const [n, i] of Object.entries(e))
    CC(i) ? r.push(
      wCe(i).then((o) => {
        t[n] = o;
      })
    ) : t[n] = i;
  return await Promise.all(r), t;
}
Cn.registerModules([cA]);
const SCe = function(e) {
  return /* @__PURE__ */ $(
    "a",
    {
      href: "https://buckaroo-data.readthedocs.io/en/latest/feature_reference.html",
      target: "_blank",
      rel: "noopener noreferrer",
      children: "?"
    }
  );
}, xCe = function(e) {
  const t = e.value, r = e.context.buckarooOptions.df_display;
  return /* @__PURE__ */ $(
    "select",
    {
      value: t,
      onChange: (i) => {
        const o = ot.clone(e.context.buckarooState);
        o.df_display = i.target.value, e.context.setBuckarooState(o);
      },
      style: { width: "100%", background: "transparent", border: "none", color: "inherit" },
      children: r.map((i) => /* @__PURE__ */ $("option", { value: i, children: i }, i))
    }
  );
}, RCe = function(e) {
  const t = e.value, r = e.context.buckarooOptions.cleaning_method;
  return /* @__PURE__ */ $(
    "select",
    {
      value: t,
      onChange: (i) => {
        const o = ot.clone(e.context.buckarooState);
        o.cleaning_method = i.target.value, e.context.setBuckarooState(o);
      },
      style: { width: "100%", background: "transparent", border: "none", color: "inherit" },
      children: r.map((i) => /* @__PURE__ */ $("option", { value: i, children: i }, i))
    }
  );
}, ECe = function(e) {
  const t = e.value, r = e.context.buckarooOptions.post_processing;
  return /* @__PURE__ */ $(
    "select",
    {
      value: t,
      onChange: (i) => {
        const o = ot.clone(e.context.buckarooState);
        o.post_processing = i.target.value, e.context.setBuckarooState(o);
      },
      style: { width: "100%", background: "transparent", border: "none", color: "inherit" },
      children: r.map((i) => /* @__PURE__ */ $("option", { value: i, children: i }, i))
    }
  );
}, PCe = function(e) {
  const t = e.value === "1";
  return /* @__PURE__ */ $(
    "input",
    {
      type: "checkbox",
      checked: t,
      onChange: (n) => {
        const i = ot.clone(e.context.buckarooState);
        i.show_commands = n.target.checked ? "1" : "0", e.context.setBuckarooState(i);
      },
      style: { margin: "0 auto", display: "block" }
    }
  );
}, ACe = function(e) {
  const t = e.value, [r, n] = pe(t || ""), i = () => {
    e.setValue(r === "" ? null : r);
  };
  return /* @__PURE__ */ He(
    "div",
    {
      className: "FakeSearchEditor",
      tabIndex: 1,
      style: { display: "flex", flexDirection: "row" },
      children: [
        /* @__PURE__ */ $(
          "input",
          {
            type: "text",
            style: { flex: "auto", width: 133 },
            value: r,
            onChange: ({ target: { value: s } }) => n(s),
            onSubmit: i,
            onKeyDown: (s) => {
              s.key === "Enter" && (s.preventDefault(), i());
            }
          }
        ),
        /* @__PURE__ */ $("button", { style: { flex: "none" }, onClick: i, children: "🔍" }),
        /* @__PURE__ */ $(
          "button",
          {
            style: { flex: "none" },
            onClick: (s) => {
              console.log("clickParams", s), e.setValue("");
            },
            children: "X"
          }
        )
      ]
    }
  );
}, FCe = Tr(({ value: e, onValueChange: t, stopEditing: r }) => {
  const [n, i] = pe(!1), o = ge(null);
  return pr(() => {
    var s;
    (s = o.current) == null || s.focus(), i(!0);
  }, []), /* @__PURE__ */ He(
    "div",
    {
      className: "SearchEditor",
      ref: o,
      tabIndex: 1,
      style: { display: "flex", flexDirection: "row" },
      children: [
        /* @__PURE__ */ $(
          "input",
          {
            type: "text",
            style: { flex: "auto", width: 150 },
            value: e || "",
            onChange: ({ target: { value: s } }) => t(s === "" ? null : s)
          }
        ),
        /* @__PURE__ */ $(
          "button",
          {
            style: { flex: "none" },
            onClick: () => {
              t(""), r();
            },
            children: "X"
          }
        )
      ]
    }
  );
});
function wC({
  dfMeta: e,
  buckarooState: t,
  setBuckarooState: r,
  buckarooOptions: n,
  heightOverride: i
}) {
  var S;
  const o = n, s = ot.fromPairs(
    ot.map(ot.keys(o), (E) => [
      E,
      ot.indexOf(o[E], t[E])
    ])
  ), a = (E, A) => E === A.length - 1 ? 0 : E + 1, l = (E) => {
    const A = o[E], M = s[E], I = a(M, A), z = A[I], k = ot.clone(t);
    return k[E] = z, k;
  }, u = ["quick_command_args", "search", "show_displayed_rows"], d = (E) => {
    console.log("event.column", E.column, E.column.getColId());
    const A = E.column.getColId();
    if (!ot.includes(u, A) && ot.includes(ot.keys(t), A)) {
      const M = l(A);
      r(M);
    }
  }, h = Qe((E) => {
    const { oldValue: A, newValue: M } = E;
    if (A !== M && M !== null) {
      const I = {
        ...t,
        quick_command_args: { search: [M] }
      };
      r(I);
    }
  }, []), f = [
    {
      field: "search",
      headerName: "search",
      width: 200,
      //editable: true,
      cellEditor: FCe,
      cellRenderer: ACe,
      onCellValueChanged: h
    },
    {
      field: "df_display",
      headerName: "Σ",
      //note the greek symbols instead of icons which require buildchain work
      headerTooltip: "Summary Stats",
      width: 120,
      cellRenderer: xCe
    },
    /*
    {
      field: 'auto_clean',
      //headerName: 'Σ', //note the greek symbols instead of icons which require buildchain work
      headerName: 'auto cleaning',
      headerTooltip: 'Auto Cleaning config',
      width: 120,
    },
    */
    {
      field: "post_processing",
      headerName: "post processing",
      headerTooltip: "post process method",
      width: 100,
      cellRenderer: ECe
    },
    {
      field: "show_commands",
      headerName: "λ",
      headerTooltip: "Show Commands",
      width: 30,
      cellRenderer: PCe
    },
    {
      field: "cleaning_method",
      headerName: "cleaning",
      headerTooltip: "Auto cleaning method",
      width: 80,
      cellRenderer: RCe
    },
    {
      field: "help",
      headerName: "?",
      headerTooltip: "Help",
      width: 30,
      cellRenderer: SCe
    },
    { field: "total_rows", width: 100 },
    { field: "filtered_rows", headerName: "filtered", width: 85 },
    {
      field: "rows_shown",
      headerName: "displayed",
      width: 85,
      hide: e.rows_shown === -1
    },
    { field: "columns", width: 75 }
  ], p = (S = t.quick_command_args) == null ? void 0 : S.search, y = p && p.length === 1 ? p[0] : "", C = [
    {
      total_rows: am.format(e.total_rows),
      columns: e.columns,
      rows_shown: am.format(e.rows_shown),
      //sampled: buckarooState.sampled || "0",
      cleaning_method: t.cleaning_method || "0",
      df_display: t.df_display,
      filtered_rows: am.format(e.filtered_rows),
      post_processing: t.post_processing,
      show_commands: t.show_commands || "0",
      search: y
    }
  ], v = {
    suppressRowClickSelection: !0
  }, w = ge(null), R = Qe((E) => {
    console.log("StatusBar252 onGridReady statusbar", E);
  }, []), b = {
    sortable: !1,
    cellStyle: { textAlign: "left" }
  }, P = Se(() => Fye.withParams({
    headerFontSize: 14,
    rowVerticalPaddingScale: 0.8
  }), []);
  return /* @__PURE__ */ $("div", { className: "status-bar", children: /* @__PURE__ */ $(
    "div",
    {
      className: "theme-hanger ag-theme-alpine-dark",
      children: /* @__PURE__ */ $(
        aA,
        {
          ref: w,
          theme: P,
          loadThemeGoogleFonts: !0,
          onCellEditingStopped: R,
          onColumnHeaderClicked: d,
          onGridReady: R,
          gridOptions: v,
          defaultColDef: b,
          rowData: C,
          domLayout: "autoHeight",
          columnDefs: f,
          context: {
            buckarooState: t,
            setBuckarooState: r,
            buckarooOptions: n
          }
        }
      )
    }
  ) });
}
function MCe({
  df_data_dict: e,
  df_display_args: t,
  df_meta: r,
  operations: n,
  on_operations: i,
  operation_results: o,
  command_config: s,
  buckaroo_state: a,
  on_buckaroo_state: l,
  buckaroo_options: u
}) {
  const [d, h] = pe(["a", "stoptime"]), f = t[a.df_display];
  f === void 0 && console.log("cDisp undefined", a.df_display, u.df_display);
  const p = La(e[f.data_key]), y = La(e[f.summary_stats_key]);
  return /* @__PURE__ */ He("div", { className: "dcf-root flex flex-col buckaroo-widget", style: { width: "100%", height: "100%" }, children: [
    /* @__PURE__ */ He(
      "div",
      {
        className: "orig-df",
        style: {
          // height: '450px',
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ $(
            wC,
            {
              dfMeta: r,
              buckarooState: a,
              setBuckarooState: l,
              buckarooOptions: u
            }
          ),
          /* @__PURE__ */ $(
            xA,
            {
              df_data: p,
              df_viewer_config: f.df_viewer_config,
              summary_stats_data: y,
              activeCol: d,
              setActiveCol: h
            }
          )
        ]
      }
    ),
    a.show_commands ? /* @__PURE__ */ $(
      pC,
      {
        df_viewer_config: f.df_viewer_config,
        activeColumn: d,
        operations: n,
        setOperations: i,
        operation_result: o,
        command_config: s
      }
    ) : /* @__PURE__ */ $("span", {})
  ] });
}
const gd = (e) => `${e.sourceName}-${e.start}-${e.end}-${e.sort}-${e.sort_direction}`, lm = (e) => `${e.sourceName}-${e.sort}-${e.sort_direction}`, ID = (e, t, r, n) => {
  if (e.length == 0)
    return [[r], [n]];
  const [i, o] = r, [s, a] = e[0];
  if (o < s)
    return [[r, ...e], [n, ...t]];
  const [l, u] = [[], []];
  for (var d = 0; d < e.length; d++) {
    const [p, y] = [e[d], t[d]];
    if (ol(p, r)) {
      const [C, v] = kD([p, y], [r, n]), w = l.concat(e.slice(d + 1)), R = u.concat(t.slice(d + 1));
      return ID(w, R, C, v);
    }
    l.push(p), u.push(y), d < e.length - 1 && LD(r, p, e[d + 1]) && (l.push(r), u.push(n));
  }
  const [h, f] = e[e.length - 1];
  return f < i && (l.push(r), u.push(n)), [l, u];
}, kD = (e, t) => {
  const [r, n] = e, [i, o] = t;
  if (Gg(i, r))
    return kD(t, e);
  const [s, a] = r, [l, u] = i;
  if (s < l && u < a)
    return e;
  if (a === l) {
    const f = n.concat(o);
    return [[s, u], f];
  }
  const d = l - a, h = n.slice(0, d).concat(o);
  return [[s, u], h];
}, LD = (e, t, r) => {
  if (Gg(r, t))
    return LD(e, r, t);
  const [n, i] = e, o = t[1], s = r[0];
  return o < n && i < s;
}, Gg = (e, t) => {
  const [r, n] = e, [i, o] = t;
  return r < i ? !0 : r == i && n < o;
}, Wh = (e, t) => {
  const [r, n] = e, [i, o] = t;
  return r <= i && o <= n;
}, ol = (e, t) => {
  if (Gg(t, e))
    return ol(t, e);
  const [r, n] = e, [i, o] = t;
  return r <= o && n >= i;
}, TCe = (e, t) => {
  const [r, n] = e, [i, o] = t;
  return [Math.max(r, i), Math.min(n, o)];
}, eE = (e, t) => {
  const [r, n] = e, [i, o] = t;
  if (ol(e, t)) {
    if (Wh(e, t))
      return !0;
    if (i === r)
      return { start: n, end: o };
    if (o === n)
      return { start: i, end: r };
    if (Wh(t, e))
      return { start: i, end: o };
    if (i < r)
      return { start: i, end: r };
    if (r < i)
      return { start: n, end: o };
  } else return { start: i, end: o };
  return { start: i, end: o };
}, b0 = (e, t, r) => {
  const [n, i] = e, [o, s] = r, a = o - n, l = s - n;
  return t.slice(a, l);
}, DCe = (e, t, r) => {
  for (var n = 0; n < e.length; n++) {
    const [i, o] = [e[n], t[n]];
    if (Wh(i, r))
      return b0(i, o, r);
  }
  throw new Error("RequestSeg {requestSeg} not in {segments}");
}, OCe = (e) => {
  for (var t = 0, r = 0; r < e.length; r++) {
    const [n, i] = e[r];
    t += i - n;
  }
  return t;
}, ICe = (e) => {
  const [t, r] = e;
  return r - t;
}, kCe = (e) => Math.floor(e[0] + ICe(e) / 2), LCe = (e, t) => {
  const r = kCe(e), [n, i] = t, [o, s] = [r - n, i - r];
  return o < s ? -o : s;
}, _Ce = (e, t) => {
  for (var r = 0, n = 0; n < e.length; n++)
    if (ol(e[n], t)) {
      const [i, o] = TCe(e[n], t);
      r += o - i;
    }
  return r;
}, _D = (e, t) => [Math.floor(e - t), Math.floor(e + t)], cm = (e, t, r) => _Ce(r, _D(e, t)), zCe = (e, t, r) => {
  const [n, i] = [[], []];
  for (var o = 0; o < e.length; o++) {
    const [s, a] = [e[o], t[o]];
    if (Wh(r, s))
      n.push(s), i.push(a);
    else if (ol(r, s))
      if (Gg(r, s)) {
        const l = [s[0], r[1]], u = b0(s, a, l);
        n.push(l), i.push(u);
      } else {
        const l = [r[0], s[1]], u = b0(s, a, l);
        n.push(l), i.push(u);
      }
  }
  return [n, i];
};
class NCe {
  constructor() {
    wr(this, "segments", []);
    wr(this, "dfs", []);
    wr(this, "sentLength", -1);
    // These tuning factors are sensitive.
    // there are other serverside and ag-grid tuning factors too.
    // those are "rowRequestSize" from ag-grid verify prop name
    // and the serverside followon payload size.
    // to be safe  maxSize should be 10* rowRequestSize
    // and followon payload size should be  1/3rd to 1/4 of maxSize
    // RRS = 40
    // maxSize = 400
    // followon = 100
    // given all of this we want some signal for "not at the end of cache, but fire off the next request anyways"
    // the idea is that the user shouldn't have to wait for a server side request.
    // also especially for sorting, that is expensive, fire off the
    // first cache filling with the min, but while that DF is still
    // sorted serverside, sned the followno request.
    wr(this, "maxSize", 4e3);
    wr(this, "trimFactor", 0.8);
    // trim down to trimFactor from maxSize
    wr(this, "lastRequest", [0, 0]);
  }
  usedSize() {
    return OCe(this.segments);
  }
  trimCache() {
    if (this.usedSize() < this.maxSize || this.lastRequest[0] === 0 && this.lastRequest[1] === 0)
      return;
    const t = this.lastRequest, n = (t[1] - t[0]) / 2 + t[0];
    var i = 0, o = Math.floor(this.maxSize * this.trimFactor / 2);
    for (i = cm(n, o, this.segments); i < this.maxSize; )
      i = cm(n, o, this.segments), o *= 2;
    const s = Math.floor(this.maxSize * this.trimFactor);
    for (; i > s; )
      o = Math.floor(0.9 * o), i = cm(n, o, this.segments);
    const a = _D(n, o), l = zCe(this.segments, this.dfs, a);
    this.segments = l[0], this.dfs = l[1];
  }
  getExtents() {
    if (this.segments.length === 0)
      throw new Error("No Segments");
    const t = this.segments[this.segments.length - 1];
    return [this.segments[0][0], t[1]];
  }
  safeGetExtents() {
    if (this.segments.length === 0)
      return [];
    const t = this.segments[this.segments.length - 1];
    return [this.segments[0][0], t[1]];
  }
  addRows(t, r) {
    const n = t[1] - t[0];
    if (r.length !== n) {
      if (t[0] + r.length === this.sentLength) {
        const s = [t[0], this.sentLength];
        return this.addRows(s, r);
      }
      return;
    }
    const [i, o] = ID(this.segments, this.dfs, t, r);
    this.segments = i, this.dfs = o, this.trimCache();
  }
  hasRows(t) {
    if (t[0] === 0 && t[1] === 0 && console.log("setting lastRequest to [0,0] in hasRows, this is unexpected"), this.sentLength > -1 && t[1] > this.sentLength) {
      const r = [t[0], this.sentLength];
      return this.hasRows(r);
    }
    this.lastRequest = t;
    try {
      console.log("[SmartRowCache.hasRows] need", t, "extents", this.safeGetExtents(), "lastRequest", this.lastRequest);
    } catch {
    }
    for (const r of this.segments)
      if (ol(r, t))
        return eE(r, t);
    return eE([0, 0], t);
  }
  getRows(t) {
    try {
      console.log("[SmartRowCache.getRows] range", t, "extents", this.safeGetExtents(), "segments", this.segments);
    } catch {
    }
    if (this.sentLength > 0 && t[1] > this.sentLength)
      return this.getRows([t[0], this.sentLength]);
    if (this.hasRows(t) === !0)
      return t[0] === 0 && t[1] === 0 && console.log("unexpected setting lastRequest to [0,0] in getRows"), this.lastRequest = t, DCe(this.segments, this.dfs, t);
    throw console.error("[SmartRowCache.getRows] Missing rows error. range", t, "extents", this.safeGetExtents(), "segments", this.segments, "sentLength", this.sentLength), new Error("Missing rows for {range}");
  }
}
function BCe(e) {
  debugger;
  return e.data.length !== 0;
}
class GCe {
  constructor(t) {
    wr(this, "srcAccesses");
    wr(this, "waitingCallbacks");
    wr(this, "reqFn");
    wr(this, "maxSize", 1e4);
    wr(this, "trimFactor", 0.8);
    // trim down to trimFactor from maxSize
    wr(this, "lastRequest", [0, 0]);
    wr(this, "reUpDist", 300);
    //threshhold for requesting next range
    wr(this, "padding", 200);
    this.reqFn = t, this.waitingCallbacks = {}, this.srcAccesses = /* @__PURE__ */ new Map();
  }
  usedSize() {
    return je.sum(Array.from(this.srcAccesses.values()).map((t) => t.usedSize()));
  }
  debugCacheState() {
    je.map(
      je.fromPairs(
        Array.from(this.srcAccesses.entries())
      ),
      (t, r) => {
        console.log(t, t.safeGetExtents());
      }
    );
  }
  hasRows(t) {
    const r = lm(t), n = [t.start, t.origEnd];
    if (!this.srcAccesses.has(r))
      return console.log("500 hasRows, returning False because couldn't find srcKey"), !1;
    const i = this.srcAccesses.get(r);
    if (i === void 0)
      throw new Error(`unexpected couldn't find SmartRowCache for ${r}`);
    return i.hasRows(n) === !0 ? !0 : (console.log("500 hasRows, returning False because src didn't have rows"), !1);
  }
  getRows(t) {
    const r = lm(t), n = [t.start, t.origEnd];
    if (!this.srcAccesses.has(r))
      throw new Error(`Missing source for ${t}`);
    let i = this.srcAccesses.get(r);
    if (i === void 0)
      throw new Error(`unexpected couldn't find SmartRowCache for ${r}`);
    if (this.srcAccesses.delete(r), this.srcAccesses.set(r, i), i.sentLength !== 0 && i.sentLength < t.end) {
      const o = Math.min(t.origEnd, i.sentLength), s = [t.start, o];
      return i.getRows(s);
    }
    return i.getRows(n);
  }
  maybeMakeLeadingRequest(t) {
    const r = [t.start, t.origEnd], n = this.ensureRowCacheForPa(t), i = n.safeGetExtents();
    if (i[1] == n.sentLength) {
      console.log("not making extra request because already have to the end of the available data", i, n.sentLength);
      return;
    }
    const o = LCe(r, i);
    if (console.log("maybeMakeLeadingRequest", o, r, i), o > 0 && o < this.reUpDist) {
      const s = /* @__PURE__ */ new Date() - 1, a = {
        sourceName: t.sourceName,
        sort: t.sort,
        sort_direction: t.sort_direction,
        start: i[1],
        end: i[1] + this.padding,
        origEnd: i[1] + this.padding,
        request_time: s
      };
      n.hasRows([i[1], i[1] + this.padding]), this.reqFn(a);
    }
  }
  getRequestRows(t, r, n) {
    const i = gd(t), o = this.ensureRowCacheForPa(t), s = /* @__PURE__ */ new Date() - 1;
    t.request_time = s;
    try {
      console.log("[KeyAware.getRequestRows] pa", t, "cbKey", i, "extents", o.safeGetExtents(), "sentLength", o.sentLength);
    } catch {
    }
    if (this.hasRows(t)) {
      console.log(`request for ${[t.start, t.origEnd, t.end]} in cache, extents ${o.getExtents()}`);
      const a = [t.start, t.origEnd];
      r(o.getRows(a), o.sentLength);
      const l = gd(t);
      delete this.waitingCallbacks[l], this.maybeMakeLeadingRequest(t);
      return;
    }
    this.waitingCallbacks[i] = [r, n], this.reqFn(t);
  }
  ensureRowCacheForPa(t) {
    const r = lm(t);
    console.log("592 ensureRowCacheForPa", r, this.srcAccesses.has(r)), this.srcAccesses.has(r) || this.srcAccesses.set(r, new NCe());
    const n = this.srcAccesses.get(r);
    if (n === void 0)
      throw new Error(`unexpected couldn't find SmartRowCache for ${r}`);
    return n;
  }
  addPayloadResponse(t) {
    const r = [t.key.start, t.key.end];
    t.key.request_time, this.trim();
    const n = this.ensureRowCacheForPa(t.key), i = gd(t.key);
    if (n.sentLength = t.length, t.data.length < r[1] - r[0]) {
      const o = [t.key.start, t.key.start + t.data.length];
      n.addRows(o, t.data);
    } else
      n.addRows(r, t.data);
    if (je.has(this.waitingCallbacks, i)) {
      const [o, s] = this.waitingCallbacks[i];
      BCe(t) ? o(this.getRows(t.key), n.sentLength) : s(), delete this.waitingCallbacks[i];
    }
  }
  addErrorResponse(t) {
    const r = gd(t.key);
    if (je.has(this.waitingCallbacks, r)) {
      const [n, i] = this.waitingCallbacks[r];
      i(), delete this.waitingCallbacks[r];
    }
  }
  trim() {
    if (this.usedSize() > this.maxSize) {
      const t = this.srcAccesses.keys().next().value;
      if (t !== void 0)
        this.srcAccesses.delete(t);
      else
        throw new Error("unexpected couldn't find any keys in srcAccesses ");
    }
  }
}
function HCe({
  messages: e
}) {
  const [t, r] = pe(0), n = ge(0), i = Se(() => {
    if (!e || e.length === 0)
      return n.current !== 0 && (n.current = 0, r((l) => l + 1)), [];
    const a = e.map((l, u) => !l || typeof l != "object" ? {
      index: u,
      time: "",
      type: "",
      message: String(l || "")
    } : {
      index: u,
      time: l.time || "",
      type: l.type || "",
      message: l.message || "",
      ...Object.fromEntries(
        Object.entries(l).filter(([d]) => !["time", "type", "message"].includes(d))
      )
    });
    return e.length !== n.current && (n.current = e.length, r((l) => l + 1)), a;
  }, [e]), o = Se(() => {
    if (!e || e.length === 0)
      return {
        pinned_rows: [],
        column_config: [],
        left_col_configs: [
          {
            col_name: "index",
            header_name: "index",
            displayer_args: { displayer: "obj" }
          }
        ]
      };
    const a = /* @__PURE__ */ new Set();
    e.forEach((u) => {
      u && typeof u == "object" && Object.keys(u).forEach((d) => a.add(d));
    }), a.add("index"), a.add("time"), a.add("type"), a.add("message");
    const l = Array.from(a).map((u) => ({
      col_name: u,
      header_name: u,
      displayer_args: { displayer: "obj" }
    }));
    return {
      pinned_rows: [],
      column_config: l,
      left_col_configs: [
        {
          col_name: "index",
          header_name: "index",
          displayer_args: { displayer: "obj" }
        }
      ]
    };
  }, [e]), s = () => {
  };
  return !e || e.length === 0 ? null : /* @__PURE__ */ $(
    "div",
    {
      style: {
        height: "300px",
        width: "100%",
        border: "1px solid red",
        marginTop: "10px",
        backgroundColor: "#1a1a1a"
      },
      children: /* @__PURE__ */ $(
        qc,
        {
          data_wrapper: {
            data_type: "Raw",
            data: i,
            length: i.length
          },
          df_viewer_config: o,
          summary_stats_data: [],
          activeCol: ["", ""],
          setActiveCol: s,
          error_info: ""
        },
        `df-viewer-${t}-${i.length}`
      )
    }
  );
}
const zD = (e, t, r, n) => {
  if (e === "main")
    return {
      data_type: "DataSource",
      datasource: r,
      length: n || 50
    };
  {
    const i = La(t[e]);
    return {
      data_type: "Raw",
      data: i,
      length: i.length
    };
  }
}, WCe = (e, t) => {
  const r = (i) => {
    e.send({ type: "infinite_request", payload_args: i });
  }, n = new GCe(r);
  return e.on("msg:custom", (i, o) => {
    if (console.log("got a message", i), (i == null ? void 0 : i.type) !== "infinite_resp") {
      console.log("bailing not infinite_resp");
      return;
    }
    if (i.data === void 0) {
      console.log("bailing no data", i);
      return;
    }
    const s = i;
    if (s.error_info !== void 0) {
      console.log("there was a problem with the request, not adding to the cache"), n.addErrorResponse(s), console.log(s.error_info), t(s.error_info);
      return;
    }
    if (s.key.request_time !== void 0) {
      const d = /* @__PURE__ */ new Date() - 1 - s.key.request_time;
      console.log(`response before ${[s.key.start, s.key.origEnd, s.key.end]} parse took ${d}`);
    }
    console.log("about to read buffers[0]", o[0]);
    const a = o[0], l = ka(a.buffer);
    console.log("metadata", l), Bg({
      file: a.buffer,
      metadata: l,
      rowFormat: "object",
      onComplete: (u) => {
        const d = u;
        s.data = d, n.addPayloadResponse(s);
      }
    });
  }), n;
};
function VCe({
  df_data_dict: e,
  df_display_args: t,
  df_meta: r,
  operations: n,
  on_operations: i,
  operation_results: o,
  command_config: s,
  buckaroo_state: a,
  on_buckaroo_state: l,
  buckaroo_options: u,
  src: d
}) {
  console.log("132 BuckarooInfiniteWidget");
  const h = /* @__PURE__ */ new Date(), f = Se(() => (console.log("recreating data source because operations changed", h, /* @__PURE__ */ new Date() - h), d.debugCacheState(), hD(d)), [n, a.post_processing, a.cleaning_method, JSON.stringify(a.quick_command_args)]), [p, y] = pe(["a", "stoptime"]), C = t[a.df_display], [v, w] = Se(
    () => [
      zD(C.data_key, e, f, r.total_rows),
      La(e[C.summary_stats_key])
    ],
    [C, n, a]
  ), R = [n, a.post_processing, a.quick_command_args, a.df_display];
  return /* @__PURE__ */ He(
    "div",
    {
      className: "dcf-root flex flex-col buckaroo-widget buckaroo-infinite-widget",
      style: { width: "100%", height: "100%" },
      children: [
        /* @__PURE__ */ He(
          "div",
          {
            className: "orig-df flex flex-row",
            style: {
              // height: '450px',
              overflow: "hidden"
            },
            children: [
              /* @__PURE__ */ $(
                wC,
                {
                  dfMeta: r,
                  buckarooState: a,
                  setBuckarooState: l,
                  buckarooOptions: u
                }
              ),
              /* @__PURE__ */ $(
                qc,
                {
                  data_wrapper: v,
                  df_viewer_config: C.df_viewer_config,
                  summary_stats_data: w,
                  outside_df_params: R,
                  activeCol: p,
                  setActiveCol: y,
                  error_info: ""
                }
              )
            ]
          }
        ),
        a.show_commands ? /* @__PURE__ */ $(
          pC,
          {
            df_viewer_config: C.df_viewer_config,
            activeColumn: p,
            operations: n,
            setOperations: i,
            operation_result: o,
            command_config: s
          }
        ) : /* @__PURE__ */ $("span", {})
      ]
    }
  );
}
function $Ce({
  df_meta: e,
  df_data_dict: t,
  df_display_args: r,
  src: n,
  df_id: i,
  message_log: o,
  show_message_box: s
}) {
  const a = Se(() => (console.log("recreating data source because operations changed", /* @__PURE__ */ new Date()), n.debugCacheState(), hD(n)), []), [l, u] = pe(["a", "stoptime"]), d = r.main, [h, f] = Se(
    () => [
      zD(d.data_key, t, a, e.total_rows),
      La(t[d.summary_stats_key])
    ],
    [d, t, a, e.total_rows]
  ), p = [i], y = (s == null ? void 0 : s.enabled) ?? !1, C = O.useMemo(() => {
    const v = o == null ? void 0 : o.messages;
    return v ? Array.isArray(v) ? v : (console.warn("[DFViewerInfiniteDS] message_log.messages is not an array:", typeof v, v), []) : [];
  }, [o == null ? void 0 : o.messages]);
  return O.useEffect(() => {
    console.log("[DFViewerInfiniteDS] Message box state changed:", {
      messagesEnabled: y,
      messageCount: C.length,
      message_log_type: typeof o,
      message_log_keys: o ? Object.keys(o) : null,
      message_log_messages_type: o != null && o.messages ? typeof o.messages : null,
      message_log_messages_isArray: Array.isArray(o == null ? void 0 : o.messages),
      firstFewMessages: C.slice(0, 3)
    });
  }, [C, y, o]), /* @__PURE__ */ $(
    "div",
    {
      className: "dcf-root flex flex-col buckaroo-widget buckaroo-infinite-widget",
      style: { width: "100%", height: "100%" },
      children: /* @__PURE__ */ He(
        "div",
        {
          className: "orig-df flex flex-row",
          style: {
            // height: '450px',
            overflow: "hidden"
          },
          children: [
            y && /* @__PURE__ */ $(HCe, { messages: C }),
            /* @__PURE__ */ $(
              qc,
              {
                data_wrapper: h,
                df_viewer_config: d.df_viewer_config,
                summary_stats_data: f,
                outside_df_params: p,
                activeCol: l,
                setActiveCol: u,
                error_info: ""
              }
            )
          ]
        }
      )
    }
  );
}
const jCe = [
  {
    athlete: "Michael Phelps",
    age: 23,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 8,
    silver: 0,
    bronze: 0,
    total: 8
  },
  {
    athlete: "Michael Phelps",
    age: 19,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 6,
    silver: 0,
    bronze: 2,
    total: 8
  },
  {
    athlete: "Michael Phelps",
    age: 27,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 4,
    silver: 2,
    bronze: 0,
    total: 6
  },
  {
    athlete: "Natalie Coughlin",
    age: 25,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 3,
    total: 6
  },
  {
    athlete: "Aleksey Nemov",
    age: 24,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 2,
    silver: 1,
    bronze: 3,
    total: 6
  },
  {
    athlete: "Alicia Coutts",
    age: 24,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 3,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Missy Franklin",
    age: 17,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 4,
    silver: 0,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Ryan Lochte",
    age: 27,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 2,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Allison Schmitt",
    age: 22,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 3,
    silver: 1,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Natalie Coughlin",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 2,
    silver: 2,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Ian Thorpe",
    age: 17,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 3,
    silver: 2,
    bronze: 0,
    total: 5
  },
  {
    athlete: "Dara Torres",
    age: 33,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 3,
    total: 5
  },
  {
    athlete: "Cindy Klassen",
    age: 26,
    country: "Canada",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 2,
    bronze: 2,
    total: 5
  },
  {
    athlete: "Nastia Liukin",
    age: 18,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 1,
    silver: 3,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Marit Bjørgen",
    age: 29,
    country: "Norway",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 3,
    silver: 1,
    bronze: 1,
    total: 5
  },
  {
    athlete: "Sun Yang",
    age: 20,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Kirsty Coventry",
    age: 24,
    country: "Zimbabwe",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 3,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Libby Lenton-Trickett",
    age: 23,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Ryan Lochte",
    age: 24,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 2,
    total: 4
  },
  {
    athlete: "Inge de Bruijn",
    age: 30,
    country: "Netherlands",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 2,
    total: 4
  },
  {
    athlete: "Petria Thomas",
    age: 28,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 3,
    silver: 1,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Ian Thorpe",
    age: 21,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Inge de Bruijn",
    age: 27,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 3,
    silver: 1,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Gary Hall Jr.",
    age: 25,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Michael Klim",
    age: 23,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 2,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Susie O'Neill",
    age: 27,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 3,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Jenny Thompson",
    age: 27,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Pieter van den Hoogenband",
    age: 22,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 2,
    total: 4
  },
  {
    athlete: "An Hyeon-Su",
    age: 20,
    country: "South Korea",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 3,
    silver: 0,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Aliya Mustafina",
    age: 17,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 2,
    total: 4
  },
  {
    athlete: "Shawn Johnson",
    age: 16,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 1,
    silver: 3,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Dmitry Sautin",
    age: 26,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 2,
    total: 4
  },
  {
    athlete: "Leontien Zijlaard-van Moorsel",
    age: 30,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 3,
    silver: 1,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Petter Northug Jr.",
    age: 24,
    country: "Norway",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 1,
    bronze: 1,
    total: 4
  },
  {
    athlete: "Ole Einar Bjørndalen",
    age: 28,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 4,
    silver: 0,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Janica Kostelic",
    age: 20,
    country: "Croatia",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 3,
    silver: 1,
    bronze: 0,
    total: 4
  },
  {
    athlete: "Nathan Adrian",
    age: 23,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Yannick Agnel",
    age: 20,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Brittany Elmslie",
    age: 18,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Matt Grevers",
    age: 27,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Ryosuke Irie",
    age: 22,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Cullen Jones",
    age: 28,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Ranomi Kromowidjojo",
    age: 21,
    country: "Netherlands",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Camille Muffat",
    age: 22,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Mel Schlanger",
    age: 25,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Emily Seebohm",
    age: 20,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Rebecca Soni",
    age: 25,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Satomi Suzuki",
    age: 21,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Dana Vollmer",
    age: 24,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Alain Bernard",
    age: 25,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "László Cseh Jr.",
    age: 22,
    country: "Hungary",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 3,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Matt Grevers",
    age: 23,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Margaret Hoelzer",
    age: 25,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Katie Hoff",
    age: 19,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Leisel Jones",
    age: 22,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Kosuke Kitajima",
    age: 25,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Andrew Lauterstein",
    age: 21,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Jason Lezak",
    age: 32,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Pang Jiaying",
    age: 23,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Aaron Peirsol",
    age: 25,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Steph Rice",
    age: 20,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Jess Schipper",
    age: 21,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Rebecca Soni",
    age: 21,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Eamon Sullivan",
    age: 22,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Dara Torres",
    age: 41,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 3,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Amanda Beard",
    age: 22,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Antje Buschschulte",
    age: 25,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 3,
    total: 3
  },
  {
    athlete: "Kirsty Coventry",
    age: 20,
    country: "Zimbabwe",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Ian Crocker",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Grant Hackett",
    age: 24,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Brendan Hansen",
    age: 22,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Jodie Henry",
    age: 20,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Otylia Jedrzejczak",
    age: 20,
    country: "Poland",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Leisel Jones",
    age: 18,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Kosuke Kitajima",
    age: 21,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Laure Manaudou",
    age: 17,
    country: "France",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Aaron Peirsol",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Kaitlin Sandeno",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Roland Schoeman",
    age: 24,
    country: "South Africa",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Pieter van den Hoogenband",
    age: 26,
    country: "Netherlands",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Therese Alshammar",
    age: 23,
    country: "Sweden",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Yana Klochkova",
    age: 18,
    country: "Ukraine",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Lenny Krayzelburg",
    age: 24,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Massimiliano Rosolino",
    age: 22,
    country: "Italy",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Petria Thomas",
    age: 25,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Matt Welsh",
    age: 23,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Lee Jeong-Su",
    age: 20,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Apolo Anton Ohno",
    age: 27,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Wang Meng",
    age: 24,
    country: "China",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Jin Seon-Yu",
    age: 17,
    country: "South Korea",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Lee Ho-Seok",
    age: 19,
    country: "South Korea",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Apolo Anton Ohno",
    age: 23,
    country: "United States",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Wang Meng",
    age: 20,
    country: "China",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Marc Gagnon",
    age: 26,
    country: "Canada",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Yang Yang (A)",
    age: 25,
    country: "China",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Stephanie Beckert",
    age: 21,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Martina Sáblíková",
    age: 22,
    country: "Czech Republic",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Enrico Fabris",
    age: 24,
    country: "Italy",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Chad Hedrick",
    age: 28,
    country: "United States",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Jochem Uytdehaage",
    age: 25,
    country: "Netherlands",
    year: 2002,
    date: "24/02/2002",
    sport: "Speed Skating",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Sabine Völker",
    age: 28,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Gregor Schlierenzauer",
    age: 20,
    country: "Austria",
    year: 2010,
    date: "28/02/2010",
    sport: "Ski Jumping",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Lars Bystøl",
    age: 27,
    country: "Norway",
    year: 2006,
    date: "26/02/2006",
    sport: "Ski Jumping",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Johnny Spillane",
    age: 29,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Nordic Combined",
    gold: 0,
    silver: 3,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Felix Gottwald",
    age: 30,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Nordic Combined",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Georg Hettich",
    age: 27,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Nordic Combined",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Felix Gottwald",
    age: 26,
    country: "Austria",
    year: 2002,
    date: "24/02/2002",
    sport: "Nordic Combined",
    gold: 0,
    silver: 0,
    bronze: 3,
    total: 3
  },
  {
    athlete: "Samppa Lajunen",
    age: 22,
    country: "Finland",
    year: 2002,
    date: "24/02/2002",
    sport: "Nordic Combined",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Aly Raisman",
    age: 18,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Kohei Uchimura",
    age: 23,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Zou Kai",
    age: 24,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Cheng Fei",
    age: 20,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Yang Wei",
    age: 28,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Yang Yilin",
    age: 15,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Zou Kai",
    age: 20,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Marian Dragulescu",
    age: 23,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Paul Hamm",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Carly Patterson",
    age: 16,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Catalina Ponor",
    age: 16,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Simona Amânar",
    age: 20,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Svetlana Khorkina",
    age: 21,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Yekaterina Lobaznyuk",
    age: 17,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Yelena Zamolodchikova",
    age: 17,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Guo Shuang",
    age: 26,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Chris Hoy",
    age: 32,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Bradley Wiggins",
    age: 24,
    country: "Great Britain",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Florian Rousseau",
    age: 26,
    country: "France",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Justyna Kowalczyk",
    age: 27,
    country: "Poland",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Johan Olsson",
    age: 29,
    country: "Sweden",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Stefania Belmondo",
    age: 33,
    country: "Italy",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Yuliya Chepalova",
    age: 25,
    country: "Russia",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Frode Estil",
    age: 29,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Bente Skari-Martinsen",
    age: 29,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Magdalena Neuner",
    age: 23,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Emil Hegle Svendsen",
    age: 24,
    country: "Norway",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Albina Akhatova",
    age: 29,
    country: "Russia",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Ole Einar Bjørndalen",
    age: 32,
    country: "Norway",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 0,
    silver: 2,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Sven Fischer",
    age: 34,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Martina Glagow-Beck",
    age: 26,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 0,
    silver: 3,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Michael Greis",
    age: 29,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Kati Wilhelm",
    age: 29,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Kati Wilhelm",
    age: 25,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 2,
    silver: 1,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Yohan Blake",
    age: 22,
    country: "Jamaica",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Usain Bolt",
    age: 25,
    country: "Jamaica",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Allyson Felix",
    age: 26,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Shelly-Ann Fraser-Pryce",
    age: 25,
    country: "Jamaica",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 2,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Carmelita Jeter",
    age: 32,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Usain Bolt",
    age: 21,
    country: "Jamaica",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 3,
    silver: 0,
    bronze: 0,
    total: 3
  },
  {
    athlete: "Veronica Campbell-Brown",
    age: 22,
    country: "Jamaica",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Justin Gatlin",
    age: 22,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Bode Miller",
    age: 32,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Aksel Lund Svindal",
    age: 27,
    country: "Norway",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Anja Pärson",
    age: 24,
    country: "Sweden",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 0,
    bronze: 2,
    total: 3
  },
  {
    athlete: "Stephan Eberharter",
    age: 32,
    country: "Austria",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 1,
    bronze: 1,
    total: 3
  },
  {
    athlete: "Ding Ning",
    age: 22,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Feng Tian Wei",
    age: 25,
    country: "Singapore",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Li Xiaoxia",
    age: 24,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Dmitrij Ovtcharov",
    age: 23,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Wang Hao",
    age: 28,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Zhang Jike",
    age: 24,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Guo Yue",
    age: 20,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ma Lin",
    age: 28,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Wang Hao",
    age: 24,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Wang Liqin",
    age: 30,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wang Nan",
    age: 29,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Zhang Yining",
    age: 26,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Zhang Yining",
    age: 22,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kong Linghui",
    age: 24,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Li Ju",
    age: 24,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Table Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Liu Guoliang",
    age: 24,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Table Tennis",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wang Nan",
    age: 21,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Table Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Viktoriya Azarenko",
    age: 22,
    country: "Belarus",
    year: 2012,
    date: "12/08/2012",
    sport: "Tennis",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mike Bryan",
    age: 34,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Tennis",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andy Murray",
    age: 25,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Tennis",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Serena Williams",
    age: 30,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Fernando González",
    age: 24,
    country: "Chile",
    year: 2004,
    date: "29/08/2004",
    sport: "Tennis",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Nicolás Massú",
    age: 26,
    country: "Chile",
    year: 2004,
    date: "29/08/2004",
    sport: "Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Venus Williams",
    age: 20,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Tennis",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ona Carbonell",
    age: 22,
    country: "Spain",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andrea Fuentes",
    age: 29,
    country: "Spain",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Huang Xuechen",
    age: 22,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Nataliya Ishchenko",
    age: 26,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Liu Ou",
    age: 25,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Svetlana Romashina",
    age: 22,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anastasiya Davydova",
    age: 25,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Andrea Fuentes",
    age: 25,
    country: "Spain",
    year: 2008,
    date: "24/08/2008",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gemma Mengual",
    age: 31,
    country: "Spain",
    year: 2008,
    date: "24/08/2008",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anastasiya Yermakova",
    age: 25,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Alison Bartosik",
    age: 21,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Anastasiya Davydova",
    age: 21,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anna Kozlova",
    age: 31,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Miya Tachibana",
    age: 29,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Miho Takeda",
    age: 27,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anastasiya Yermakova",
    age: 21,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Olga Brusnikina",
    age: 21,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mariya Kiselyova",
    age: 25,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Synchronized Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Miya Tachibana",
    age: 25,
    country: "Japan",
    year: 2e3,
    date: "01/10/2000",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Miho Takeda",
    age: 24,
    country: "Japan",
    year: 2e3,
    date: "01/10/2000",
    sport: "Synchronized Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Becky Adlington",
    age: 23,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Bronte Barratt",
    age: 23,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Elizabeth Beisel",
    age: 19,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mireia Belmonte",
    age: 21,
    country: "Spain",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ricky Berens",
    age: 24,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Aleksandra Gerasimenya",
    age: 26,
    country: "Belarus",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Brendan Hansen",
    age: 30,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jessica Hardy",
    age: 25,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Chad le Clos",
    age: 20,
    country: "South Africa",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Clément Lefert",
    age: 24,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Amaury Leveaux",
    age: 26,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "James Magnussen",
    age: 21,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Takeshi Matsuda",
    age: 28,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Oussama Mellouli",
    age: 28,
    country: "Tunisia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Park Tae-Hwan",
    age: 22,
    country: "South Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Christian Sprenger",
    age: 26,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jeremy Stravius",
    age: 24,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Aya Terakawa",
    age: 27,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Nick Thoman",
    age: 26,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marleen Veldhuis",
    age: 33,
    country: "Netherlands",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ye Shiwen",
    age: 16,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Becky Adlington",
    age: 19,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Leith Brodie",
    age: 22,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Cate Campbell",
    age: 16,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "César Cielo Filho",
    age: 21,
    country: "Brazil",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Hugues Duboscq",
    age: 26,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Felicity Galvez",
    age: 23,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Grant Hackett",
    age: 28,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Kara Lynn Joyce",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Amaury Leveaux",
    age: 22,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Christine Magnuson",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Patrick Murphy",
    age: 24,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Park Tae-Hwan",
    age: 18,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Shayne Reese",
    age: 25,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Brenton Rickard",
    age: 24,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mel Schlanger",
    age: 21,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Julia Smit",
    age: 20,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Britta Steffen",
    age: 24,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hayden Stoeckel",
    age: 24,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Matt Targett",
    age: 22,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Peter Vanderkaay",
    age: 24,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Arkady Vyachanin",
    age: 24,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Garrett Weber-Gale",
    age: 23,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lindsay Benko",
    age: 27,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gary Hall Jr.",
    age: 29,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Brooke Hanson",
    age: 26,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kara Lynn Joyce",
    age: 18,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Klete Keller",
    age: 22,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Yana Klochkova",
    age: 22,
    country: "Ukraine",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Rachel Komisarz",
    age: 27,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Libby Lenton-Trickett",
    age: 19,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jason Lezak",
    age: 28,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ryan Lochte",
    age: 20,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Alice Mills",
    age: 18,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tomomi Morita",
    age: 19,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Markus Rogan",
    age: 22,
    country: "Austria",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jenny Thompson",
    age: 31,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Franziska van Almsick",
    age: 26,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Neil Walker",
    age: 28,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Amanda Weir",
    age: 18,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Takashi Yamamoto",
    age: 26,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Brooke Bennett",
    age: 20,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Beatrice Coada-Caslaru",
    age: 25,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Josh Davis",
    age: 28,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tom Dolan",
    age: 25,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anthony Ervin",
    age: 19,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Domenico Fioravanti",
    age: 23,
    country: "Italy",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Grant Hackett",
    age: 20,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Geoff Huegill",
    age: 21,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Leisel Jones",
    age: 15,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Klete Keller",
    age: 18,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jason Lezak",
    age: 24,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Diana Mocanu",
    age: 16,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Martina Moravcová",
    age: 24,
    country: "Slovakia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ed Moses",
    age: 20,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Diana Munz",
    age: 18,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mai Nakamura",
    age: 21,
    country: "Japan",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Todd Pearson",
    age: 22,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Adam Pine",
    age: 24,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Claudia Poll",
    age: 27,
    country: "Costa Rica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Megan Quann-Jendrick",
    age: 16,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Giaan Rooney",
    age: 17,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Courtney Shealy",
    age: 22,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ashley Tappin",
    age: 25,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Stev Theloke",
    age: 22,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Amy Van Dyken",
    age: 27,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Neil Walker",
    age: 24,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Swimming",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "J. R. Celski",
    age: 19,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Charles Hamelin",
    age: 25,
    country: "Canada",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lee Ho-Seok",
    age: 23,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Park Seung-Hui",
    age: 17,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Katherine Reutter",
    age: 21,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Seong Si-Baek",
    age: 22,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marianne St-Gelais",
    age: 19,
    country: "Canada",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "François-Louis Tremblay",
    age: 29,
    country: "Canada",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Zhou Yang",
    age: 18,
    country: "China",
    year: 2010,
    date: "28/02/2010",
    sport: "Short-Track Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Choi Eun-Gyeong",
    age: 21,
    country: "South Korea",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anouk Leblanc-Boucher",
    age: 21,
    country: "Canada",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "François-Louis Tremblay",
    age: 25,
    country: "Canada",
    year: 2006,
    date: "26/02/2006",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Choi Eun-Gyeong",
    age: 17,
    country: "South Korea",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Go Gi-Hyeon",
    age: 15,
    country: "South Korea",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jonathan Guilmette",
    age: 23,
    country: "Canada",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Li Jiajun",
    age: 26,
    country: "China",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Apolo Anton Ohno",
    age: 19,
    country: "United States",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Evgeniya Radanova",
    age: 24,
    country: "Bulgaria",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mathieu Turcotte",
    age: 25,
    country: "Canada",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wang Chunlu",
    age: 23,
    country: "China",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Yang Yang (S)",
    age: 24,
    country: "China",
    year: 2002,
    date: "24/02/2002",
    sport: "Short-Track Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Shani Davis",
    age: 27,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kristina Groves",
    age: 33,
    country: "Canada",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Chad Hedrick",
    age: 32,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Sven Kramer",
    age: 23,
    country: "Netherlands",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lee Seung-Hun",
    age: 21,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mo Tae-Beom",
    age: 21,
    country: "South Korea",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ivan Skobrev",
    age: 27,
    country: "Russia",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mark Tuitert",
    age: 29,
    country: "Netherlands",
    year: 2010,
    date: "28/02/2010",
    sport: "Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Joey Cheek",
    age: 26,
    country: "United States",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Shani Davis",
    age: 23,
    country: "United States",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anni Friesinger-Postma",
    age: 29,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Kristina Groves",
    age: 29,
    country: "Canada",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Clara Hughes",
    age: 33,
    country: "Canada",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sven Kramer",
    age: 19,
    country: "Netherlands",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Claudia Pechstein",
    age: 33,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Carl Verheijen",
    age: 30,
    country: "Netherlands",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Erben Wennemars",
    age: 30,
    country: "Netherlands",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Ireen Wüst",
    age: 19,
    country: "Netherlands",
    year: 2006,
    date: "26/02/2006",
    sport: "Speed Skating",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Derek Parra",
    age: 31,
    country: "United States",
    year: 2002,
    date: "24/02/2002",
    sport: "Speed Skating",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Claudia Pechstein",
    age: 29,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Speed Skating",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jennifer Rodriguez",
    age: 25,
    country: "United States",
    year: 2002,
    date: "24/02/2002",
    sport: "Speed Skating",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Simon Ammann",
    age: 28,
    country: "Switzerland",
    year: 2010,
    date: "28/02/2010",
    sport: "Ski Jumping",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Adam Malysz",
    age: 32,
    country: "Poland",
    year: 2010,
    date: "28/02/2010",
    sport: "Ski Jumping",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Matti Hautamäki",
    age: 24,
    country: "Finland",
    year: 2006,
    date: "26/02/2006",
    sport: "Ski Jumping",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Andreas Kofler",
    age: 21,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Ski Jumping",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Roar Ljøkelsøy",
    age: 29,
    country: "Norway",
    year: 2006,
    date: "26/02/2006",
    sport: "Ski Jumping",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Thomas Morgenstern",
    age: 19,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Ski Jumping",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Simon Ammann",
    age: 20,
    country: "Switzerland",
    year: 2002,
    date: "24/02/2002",
    sport: "Ski Jumping",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sven Hannawald",
    age: 27,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Ski Jumping",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Matti Hautamäki",
    age: 20,
    country: "Finland",
    year: 2002,
    date: "24/02/2002",
    sport: "Ski Jumping",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Adam Malysz",
    age: 24,
    country: "Poland",
    year: 2002,
    date: "24/02/2002",
    sport: "Ski Jumping",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Niccolò Campriani",
    age: 24,
    country: "Italy",
    year: 2012,
    date: "12/08/2012",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jin Jong-O",
    age: 32,
    country: "South Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Shooting",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Olena Kostevych",
    age: 27,
    country: "Ukraine",
    year: 2012,
    date: "12/08/2012",
    sport: "Shooting",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Jin Jong-O",
    age: 28,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Katerina Kurková-Emmons",
    age: 24,
    country: "Czech Republic",
    year: 2008,
    date: "24/08/2008",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lyubov Galkina",
    age: 31,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mariya Grozdeva",
    age: 32,
    country: "Bulgaria",
    year: 2004,
    date: "29/08/2004",
    sport: "Shooting",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lee Bo-Na",
    age: 23,
    country: "South Korea",
    year: 2004,
    date: "29/08/2004",
    sport: "Shooting",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mikhail Nestruyev",
    age: 35,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Igor Basinsky",
    age: 37,
    country: "Belarus",
    year: 2e3,
    date: "01/10/2000",
    sport: "Shooting",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tao Luna",
    age: 26,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Shooting",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kim Crow",
    age: 26,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Rowing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Georgeta Damian-Andrunache",
    age: 32,
    country: "Romania",
    year: 2008,
    date: "24/08/2008",
    sport: "Rowing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Viorica Susanu",
    age: 32,
    country: "Romania",
    year: 2008,
    date: "24/08/2008",
    sport: "Rowing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Georgeta Damian-Andrunache",
    age: 28,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Rowing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Viorica Susanu",
    age: 28,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Rowing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Georgeta Damian-Andrunache",
    age: 24,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Rowing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Doina Ignat",
    age: 31,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Rowing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Pieta van Dishoeck",
    age: 28,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Rowing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Eeke van Nes",
    age: 31,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Rowing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Bill Demong",
    age: 29,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Nordic Combined",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Bernhard Gruber",
    age: 27,
    country: "Austria",
    year: 2010,
    date: "28/02/2010",
    sport: "Nordic Combined",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Magnus Moan",
    age: 22,
    country: "Norway",
    year: 2006,
    date: "26/02/2006",
    sport: "Nordic Combined",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ronny Ackermann",
    age: 24,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Nordic Combined",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jaakko Tallus",
    age: 20,
    country: "Finland",
    year: 2002,
    date: "24/02/2002",
    sport: "Nordic Combined",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Denis Ablyazin",
    age: 19,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Chen Yibing",
    age: 27,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gabby Douglas",
    age: 16,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Feng Zhe",
    age: 24,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sandra Izbasa",
    age: 22,
    country: "Romania",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Viktoriya Komova",
    age: 17,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "McKayla Maroney",
    age: 16,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marcel Nguyen",
    age: 24,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mariya Paseka",
    age: 17,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Catalina Ponor",
    age: 24,
    country: "Romania",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Louis Smith",
    age: 23,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Max Whitlock",
    age: 19,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Gymnastics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Chen Yibing",
    age: 23,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anton Golotsutskov",
    age: 23,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "He Kexin",
    age: 16,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jonathan Horton",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Sandra Izbasa",
    age: 18,
    country: "Romania",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Li Xiaopeng",
    age: 27,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kohei Uchimura",
    age: 19,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Xiao Qin",
    age: 23,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Alexandra Eremia",
    age: 17,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Annia Hatch",
    age: 26,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Terin Humphrey",
    age: 18,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Takehiro Kashima",
    age: 24,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Svetlana Khorkina",
    age: 25,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Courtney Kupets",
    age: 18,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Anna Pavlova",
    age: 16,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Monica Rosu",
    age: 17,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Dana Sofronie",
    age: 16,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hiroyuki Tomita",
    age: 23,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marius Urzica",
    age: 28,
    country: "Romania",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Isao Yoneda",
    age: 26,
    country: "Japan",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Yordan Yovchev",
    age: 31,
    country: "Bulgaria",
    year: 2004,
    date: "29/08/2004",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Oleksandr Beresh",
    age: 22,
    country: "Ukraine",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Aleksey Bondarenko",
    age: 22,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lee Ju-Hyeong",
    age: 27,
    country: "South Korea",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Li Xiaopeng",
    age: 19,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Liu Xuan",
    age: 21,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Maria Olaru",
    age: 18,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yelena Produnova",
    age: 20,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andreea Raducan",
    age: 16,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yang Wei",
    age: 20,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yordan Yovchev",
    age: 27,
    country: "Bulgaria",
    year: 2e3,
    date: "01/10/2000",
    sport: "Gymnastics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Elisa Di Francisca",
    age: 29,
    country: "Italy",
    year: 2012,
    date: "12/08/2012",
    sport: "Fencing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Arianna Errigo",
    age: 24,
    country: "Italy",
    year: 2012,
    date: "12/08/2012",
    sport: "Fencing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Diego Occhiuzzi",
    age: 31,
    country: "Italy",
    year: 2012,
    date: "12/08/2012",
    sport: "Fencing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Sun Yujie",
    age: 19,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Valentina Vezzali",
    age: 38,
    country: "Italy",
    year: 2012,
    date: "12/08/2012",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Stefano Carozzo",
    age: 29,
    country: "Italy",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Margherita Granbassi",
    age: 28,
    country: "Italy",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Sada Jacobson",
    age: 25,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Fabrice Jeannet",
    age: 27,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Nicolas Lopez",
    age: 27,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Matteo Tagliariol",
    age: 25,
    country: "Italy",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Valentina Vezzali",
    age: 34,
    country: "Italy",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Becca Ward",
    age: 18,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Mariel Zagunis",
    age: 23,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andrea Cassarà",
    age: 20,
    country: "Italy",
    year: 2004,
    date: "29/08/2004",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Laura Flessel-Colovic",
    age: 32,
    country: "France",
    year: 2004,
    date: "29/08/2004",
    sport: "Fencing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Aldo Montano",
    age: 25,
    country: "Italy",
    year: 2004,
    date: "29/08/2004",
    sport: "Fencing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Maureen Nisima",
    age: 23,
    country: "France",
    year: 2004,
    date: "29/08/2004",
    sport: "Fencing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Salvatore Sanzo",
    age: 28,
    country: "Italy",
    year: 2004,
    date: "29/08/2004",
    sport: "Fencing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mathieu Gourdain",
    age: 26,
    country: "France",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gianna Hablützel-Bürki",
    age: 30,
    country: "Switzerland",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Rita König",
    age: 23,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wiradech Kothny",
    age: 21,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Hugues Obry",
    age: 27,
    country: "France",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Giovanna Trillini",
    age: 30,
    country: "Italy",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Valentina Vezzali",
    age: 26,
    country: "Italy",
    year: 2e3,
    date: "01/10/2000",
    sport: "Fencing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sandra Auffarth",
    age: 25,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Laura Bechtolsheimer",
    age: 27,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Adelinde Cornelissen",
    age: 33,
    country: "Netherlands",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Charlotte Dujardin",
    age: 27,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Michael Jung",
    age: 29,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gerco Schröder",
    age: 34,
    country: "Netherlands",
    year: 2012,
    date: "12/08/2012",
    sport: "Equestrian",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tina Cook",
    age: 37,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Heike Kemmer",
    age: 46,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Eric Lamaze",
    age: 40,
    country: "Canada",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Beezie Madden",
    age: 44,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Hinrich Romeike",
    age: 45,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anky van Grunsven",
    age: 40,
    country: "Netherlands",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Isabell Werth",
    age: 39,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Beatriz Ferrer-Salat",
    age: 38,
    country: "Spain",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Pippa Funnell",
    age: 35,
    country: "Great Britain",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Chris Kappler",
    age: 37,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marco Kutscher",
    age: 29,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Leslie Law",
    age: 39,
    country: "Great Britain",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ulla Salzgeber",
    age: 46,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kim Severson",
    age: 30,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Equestrian",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andrew Hoy",
    age: 41,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "David O'Connor",
    age: 38,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ulla Salzgeber",
    age: 42,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Equestrian",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Anky van Grunsven",
    age: 32,
    country: "Netherlands",
    year: 2e3,
    date: "01/10/2000",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Isabell Werth",
    age: 31,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Equestrian",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "David Boudia",
    age: 23,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Chen Ruolin",
    age: 19,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "He Zi",
    age: 21,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Qin Kai",
    age: 26,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Wu Minxia",
    age: 26,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ilya Zakharov",
    age: 21,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Chen Ruolin",
    age: 15,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gleb Galperin",
    age: 25,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Guo Jingjing",
    age: 26,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yuliya Pakhalina",
    age: 30,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Qin Kai",
    age: 22,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wang Xin",
    age: 16,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wu Minxia",
    age: 22,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Guo Jingjing",
    age: 22,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Mathew Helm",
    age: 23,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lao Lishi",
    age: 16,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Chantelle Michell-Newbery",
    age: 27,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Robert Newbery",
    age: 25,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Yuliya Pakhalina",
    age: 26,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tian Liang",
    age: 24,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Wu Minxia",
    age: 18,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Fu Mingxia",
    age: 22,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Guo Jingjing",
    age: 18,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hu Jia",
    age: 17,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Li Na",
    age: 16,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anne Montminy",
    age: 25,
    country: "Canada",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tian Liang",
    age: 21,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Xiong Ni",
    age: 26,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Diving",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Grégory Baugé",
    age: 27,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ed Clancy",
    age: 27,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Sarah Hammer",
    age: 28,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Chris Hoy",
    age: 36,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jason Kenny",
    age: 24,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Maximilian Levy",
    age: 25,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Anna Meares",
    age: 28,
    country: "Australia",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Vicki Pendleton",
    age: 31,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Laura Trott",
    age: 20,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Olga Zabelinskaya",
    age: 32,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Cycling",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Mickaël Bourgain",
    age: 28,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Fabian Cancellara",
    age: 27,
    country: "Switzerland",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jason Kenny",
    age: 20,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Joan Llaneras",
    age: 39,
    country: "Spain",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hayden Roulston",
    age: 27,
    country: "New Zealand",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Bradley Wiggins",
    age: 28,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ryan Bayley",
    age: 22,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Graeme Brown",
    age: 25,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sergi Escobar",
    age: 29,
    country: "Spain",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Rob Hayles",
    age: 31,
    country: "Great Britain",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Brad McGee",
    age: 28,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anna Meares",
    age: 20,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Stefan Nimke",
    age: 26,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Olga Slyusareva",
    age: 35,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Arnaud Tournant",
    age: 26,
    country: "France",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "René Wolff",
    age: 26,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Leontien Zijlaard-van Moorsel",
    age: 34,
    country: "Netherlands",
    year: 2004,
    date: "29/08/2004",
    sport: "Cycling",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Félicia Ballanger",
    age: 29,
    country: "France",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Robert Bartko",
    age: 24,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jens Fiedler",
    age: 30,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Jens Lehmann",
    age: 32,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gary Neiwand",
    age: 34,
    country: "Australia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jason Queally",
    age: 30,
    country: "Great Britain",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jan Ullrich",
    age: 26,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Cycling",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lukáš Bauer",
    age: 32,
    country: "Czech Republic",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Anna Haag",
    age: 23,
    country: "Sweden",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marcus Hellner",
    age: 24,
    country: "Sweden",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Charlotte Kalla",
    age: 22,
    country: "Sweden",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Claudia Künzel-Nystad",
    age: 32,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Aino-Kaisa Saarinen",
    age: 31,
    country: "Finland",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Evi Sachenbacher-Stehle",
    age: 29,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Axel Teichmann",
    age: 30,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tobias Angerer",
    age: 28,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Yuliya Chepalova",
    age: 29,
    country: "Russia",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yevgeny Dementyev",
    age: 23,
    country: "Russia",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Giorgio Di Centa",
    age: 33,
    country: "Italy",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Thobias Fredriksson",
    age: 30,
    country: "Sweden",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Claudia Künzel-Nystad",
    age: 28,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Björn Lind",
    age: 27,
    country: "Sweden",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yevgeniya Medvedeva",
    age: 29,
    country: "Russia",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katerina Neumannová",
    age: 32,
    country: "Czech Republic",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Pietro Piller Cottrer",
    age: 31,
    country: "Italy",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Kristina Šmigun-Vähi",
    age: 28,
    country: "Estonia",
    year: 2006,
    date: "26/02/2006",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Thomas Alsgaard",
    age: 30,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Viola Bauer",
    age: 25,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Anita Moen-Guidon",
    age: 34,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katerina Neumannová",
    age: 28,
    country: "Czech Republic",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Evi Sachenbacher-Stehle",
    age: 21,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kristen Skjeldal",
    age: 34,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andrus Veerpalu",
    age: 31,
    country: "Estonia",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Cristian Zorzi",
    age: 29,
    country: "Italy",
    year: 2002,
    date: "24/02/2002",
    sport: "Cross Country Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tina Dietze",
    age: 24,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Natasa Douchev-Janics",
    age: 30,
    country: "Hungary",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katalin Kovács",
    age: 36,
    country: "Hungary",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Danuta Kozák",
    age: 25,
    country: "Hungary",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Inna Osypenko-Radomska",
    age: 29,
    country: "Ukraine",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Franziska Weber",
    age: 23,
    country: "Germany",
    year: 2012,
    date: "12/08/2012",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tim Brabants",
    age: 31,
    country: "Great Britain",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "David Cal",
    age: 25,
    country: "Spain",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Natasa Douchev-Janics",
    age: 26,
    country: "Hungary",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Christian Gille",
    age: 32,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katalin Kovács",
    age: 32,
    country: "Hungary",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Vadim Makhnyov",
    age: 28,
    country: "Belarus",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Roman Petrushenko",
    age: 27,
    country: "Belarus",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katrin Wagner-Augustin",
    age: 30,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ken Wallace",
    age: 25,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tomasz Wylenzek",
    age: 25,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Canoeing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Nathan Baggaley",
    age: 28,
    country: "Australia",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "David Cal",
    age: 21,
    country: "Spain",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Andreas Dittmer",
    age: 32,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Natasa Douchev-Janics",
    age: 22,
    country: "Hungary",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Birgit Fischer-Schmidt",
    age: 42,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Aleksandr Kostoglod",
    age: 30,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Katalin Kovács",
    age: 28,
    country: "Hungary",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Aleksandr Kovalyov",
    age: 29,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Eirik Verås Larsen",
    age: 28,
    country: "Norway",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Carolin Leonhardt",
    age: 19,
    country: "Germany",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Adam Van Koeverden",
    age: 22,
    country: "Canada",
    year: 2004,
    date: "29/08/2004",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andreas Dittmer",
    age: 28,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Birgit Fischer-Schmidt",
    age: 38,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Knut Holmann",
    age: 32,
    country: "Norway",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Zoltán Kammerer",
    age: 22,
    country: "Hungary",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Katalin Kovács",
    age: 24,
    country: "Hungary",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Petar Merkov",
    age: 23,
    country: "Bulgaria",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Florin Popescu",
    age: 26,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mitica Pricop",
    age: 22,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Botond Storcz",
    age: 25,
    country: "Hungary",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Szilvia Szabó",
    age: 21,
    country: "Hungary",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Katrin Wagner-Augustin",
    age: 22,
    country: "Germany",
    year: 2e3,
    date: "01/10/2000",
    sport: "Canoeing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kevin Kuske",
    age: 31,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Bobsleigh",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "André Lange",
    age: 36,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Bobsleigh",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Martin Annen",
    age: 32,
    country: "Switzerland",
    year: 2006,
    date: "26/02/2006",
    sport: "Bobsleigh",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Beat Hefti",
    age: 28,
    country: "Switzerland",
    year: 2006,
    date: "26/02/2006",
    sport: "Bobsleigh",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Kevin Kuske",
    age: 27,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Bobsleigh",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "André Lange",
    age: 32,
    country: "Germany",
    year: 2006,
    date: "26/02/2006",
    sport: "Bobsleigh",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ole Einar Bjørndalen",
    age: 36,
    country: "Norway",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marie Laure Brunet",
    age: 21,
    country: "France",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Marie Dorin",
    age: 23,
    country: "France",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Simone Hauswald",
    age: 30,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Vincent Jay",
    age: 24,
    country: "France",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Anastasia Kuzmina",
    age: 25,
    country: "Slovakia",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Christoph Sumann",
    age: 34,
    country: "Austria",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yevgeny Ustyugov",
    age: 24,
    country: "Russia",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Olga Zaytseva",
    age: 31,
    country: "Russia",
    year: 2010,
    date: "28/02/2010",
    sport: "Biathlon",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Florence Baverel-Robert",
    age: 31,
    country: "France",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Vincent Defrasne",
    age: 28,
    country: "France",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Halvard Hanevold",
    age: 36,
    country: "Norway",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Svetlana Ishmuratova",
    age: 33,
    country: "Russia",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anna-Carin Olofsson-Zidek",
    age: 32,
    country: "Sweden",
    year: 2006,
    date: "26/02/2006",
    sport: "Biathlon",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Uschi Disl",
    age: 31,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Sven Fischer",
    age: 30,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ricco Groß",
    age: 31,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Andrea Henkel",
    age: 24,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Frank Luck",
    age: 34,
    country: "Germany",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Raphaël Poirée",
    age: 27,
    country: "France",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Olga Pylyova-Medvedtseva",
    age: 26,
    country: "Russia",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Liv Grete Skjelbreid-Poirée",
    age: 27,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Magdalena Wallin-Forsberg",
    age: 34,
    country: "Sweden",
    year: 2002,
    date: "24/02/2002",
    sport: "Biathlon",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Zhao Yunlei",
    age: 25,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Badminton",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lee Hyo-Jeong",
    age: 27,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Badminton",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yu Yang",
    age: 22,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Badminton",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Gao Ling",
    age: 25,
    country: "China",
    year: 2004,
    date: "29/08/2004",
    sport: "Badminton",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Gao Ling",
    age: 21,
    country: "China",
    year: 2e3,
    date: "01/10/2000",
    sport: "Badminton",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Nataliya Antyukh",
    age: 31,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Veronica Campbell-Brown",
    age: 30,
    country: "Jamaica",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Vivian Cheruiyot",
    age: 28,
    country: "Kenya",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Will Claye",
    age: 21,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Tirunesh Dibaba",
    age: 27,
    country: "Ethiopia",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Mo Farah",
    age: 29,
    country: "Great Britain",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Justin Gatlin",
    age: 30,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lalonde Gordon",
    age: 23,
    country: "Trinidad and Tobago",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Sanya Richards-Ross",
    age: 27,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "DeeDee Trotter",
    age: 29,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Elvan Abeylegesse",
    age: 25,
    country: "Turkey",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kenenisa Bekele",
    age: 26,
    country: "Ethiopia",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kerron Clement",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tirunesh Dibaba",
    age: 23,
    country: "Ethiopia",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Walter Dix",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Allyson Felix",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yuliya Gushchina",
    age: 25,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tatyana Lebedeva",
    age: 32,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "LaShawn Merritt",
    age: 22,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "David Neville",
    age: 24,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Sanya Richards-Ross",
    age: 23,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Kerron Stewart",
    age: 24,
    country: "Jamaica",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jared Tallent",
    age: 23,
    country: "Australia",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Angelo Taylor",
    age: 29,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Richard Thompson",
    age: 23,
    country: "Trinidad and Tobago",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Jeremy Wariner",
    age: 24,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Shericka Williams",
    age: 22,
    country: "Jamaica",
    year: 2008,
    date: "24/08/2008",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Nataliya Antyukh",
    age: 23,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Kenenisa Bekele",
    age: 22,
    country: "Ethiopia",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Derrick Brew",
    age: 26,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Shawn Crawford",
    age: 26,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hicham El Guerrouj",
    age: 29,
    country: "Morocco",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Maurice Greene",
    age: 30,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Otis Harris",
    age: 22,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kelly Holmes",
    age: 34,
    country: "Great Britain",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tatyana Lebedeva",
    age: 28,
    country: "Russia",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Jeremy Wariner",
    age: 20,
    country: "United States",
    year: 2004,
    date: "29/08/2004",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Ato Boldon",
    age: 26,
    country: "Trinidad and Tobago",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Pauline Davis-Thompson",
    age: 34,
    country: "Bahamas",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lorraine Graham",
    age: 27,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Maurice Greene",
    age: 26,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Greg Haughton",
    age: 26,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Deon Hemmings",
    age: 31,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Robert Korzeniowski",
    age: 32,
    country: "Poland",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tayna Lawrence",
    age: 25,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Beverly McDonald",
    age: 30,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Merlene Ottey-Page",
    age: 40,
    country: "Jamaica",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Irina Privalova",
    age: 31,
    country: "Russia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Gabriela Szabo",
    age: 24,
    country: "Romania",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Gete Wami",
    age: 25,
    country: "Ethiopia",
    year: 2e3,
    date: "01/10/2000",
    sport: "Athletics",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Elisabeth Görgl",
    age: 28,
    country: "Austria",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Lindsey Kildow-Vonn",
    age: 25,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Ivica Kostelic",
    age: 30,
    country: "Croatia",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Julia Mancuso",
    age: 25,
    country: "United States",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Tina Maze",
    age: 26,
    country: "Slovenia",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Maria Riesch",
    age: 25,
    country: "Germany",
    year: 2010,
    date: "28/02/2010",
    sport: "Alpine Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Michaela Dorfmeister",
    age: 32,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Janica Kostelic",
    age: 24,
    country: "Croatia",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Hermann Maier",
    age: 33,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Benjamin Raich",
    age: 27,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Marlies Schild",
    age: 24,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Rainer Schönfelder",
    age: 28,
    country: "Austria",
    year: 2006,
    date: "26/02/2006",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Kjetil André Aamodt",
    age: 30,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Renate Götschl",
    age: 26,
    country: "Austria",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Lasse Kjus",
    age: 31,
    country: "Norway",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Bode Miller",
    age: 24,
    country: "United States",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 2,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Anja Pärson",
    age: 20,
    country: "Sweden",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Benjamin Raich",
    age: 23,
    country: "Austria",
    year: 2002,
    date: "24/02/2002",
    sport: "Alpine Skiing",
    gold: 0,
    silver: 0,
    bronze: 2,
    total: 2
  },
  {
    athlete: "Ki Bo-Bae",
    age: 24,
    country: "South Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Archery",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Oh Jin-Hyek",
    age: 30,
    country: "South Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Archery",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Park Gyeong-Mo",
    age: 32,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Archery",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Park Seong-Hyeon",
    age: 25,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Archery",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Yun Ok-Hui",
    age: 23,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Archery",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Zhang Juanjuan",
    age: 27,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Archery",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Lee Seong-Jin",
    age: 19,
    country: "South Korea",
    year: 2004,
    date: "29/08/2004",
    sport: "Archery",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Park Seong-Hyeon",
    age: 21,
    country: "South Korea",
    year: 2004,
    date: "29/08/2004",
    sport: "Archery",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kim Nam-Sun",
    age: 20,
    country: "South Korea",
    year: 2e3,
    date: "01/10/2000",
    sport: "Archery",
    gold: 1,
    silver: 1,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Kim Su-Nyeong",
    age: 29,
    country: "South Korea",
    year: 2e3,
    date: "01/10/2000",
    sport: "Archery",
    gold: 1,
    silver: 0,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Vic Wunderle",
    age: 24,
    country: "United States",
    year: 2e3,
    date: "01/10/2000",
    sport: "Archery",
    gold: 0,
    silver: 1,
    bronze: 1,
    total: 2
  },
  {
    athlete: "Yun Mi-Jin",
    age: 17,
    country: "South Korea",
    year: 2e3,
    date: "01/10/2000",
    sport: "Archery",
    gold: 2,
    silver: 0,
    bronze: 0,
    total: 2
  },
  {
    athlete: "Artur Aleksanyan",
    age: 20,
    country: "Armenia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Valeriy Andriitsev",
    age: 25,
    country: "Ukraine",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Rövs?n Bayramov",
    age: 25,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Jordan Burroughs",
    age: 24,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Clarissa Chun",
    age: 30,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Yogeshwar Dutt",
    age: 29,
    country: "India",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Jaime Espinal",
    age: 27,
    country: "Puerto Rico",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Johan Eurén",
    age: 27,
    country: "Sweden",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Karam Gaber",
    age: 32,
    country: "Egypt",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Daniyal Gadzhiyev",
    age: 26,
    country: "Kazakhstan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Komeil Ghasemi",
    age: 24,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Giorgi Gogshelidze",
    age: 32,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Sadegh Goudarzi",
    age: 24,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Steeve Guénot",
    age: 26,
    country: "France",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Carol Huynh",
    age: 31,
    country: "Canada",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Kaori Icho",
    age: 28,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Damian Janikowski",
    age: 23,
    country: "Poland",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Jing Ruixue",
    age: 24,
    country: "China",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Arsen Julfalakyan",
    age: 25,
    country: "Armenia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Riza Kayaalp",
    age: 22,
    country: "Turkey",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Aleksandras Kazakevicius",
    age: 26,
    country: "Lithuania",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Vladimer Khinchegashvili",
    age: 21,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Alan Khugayev",
    age: 23,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Kim Hyeon-Wu",
    age: 23,
    country: "South Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Besik Kudukhov",
    age: 25,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Sushil Kumar",
    age: 29,
    country: "India",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Zaur Kuramagomedov",
    age: 24,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Ehsan Naser Lashgari",
    age: 26,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Revaz Lashkhi",
    age: 24,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Jimmy Lidberg",
    age: 30,
    country: "Sweden",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Liván López",
    age: 30,
    country: "Cuba",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Mijaín López",
    age: 29,
    country: "Cuba",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Tamás Lorincz",
    age: 25,
    country: "Hungary",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Bilyal Makhov",
    age: 24,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Gyuzel Manyurova",
    age: 34,
    country: "Kazakhstan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Dato Marsagishvili",
    age: 21,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Ryutaro Matsumoto",
    age: 26,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Péter Módos",
    age: 24,
    country: "Hungary",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Davit Modzmanashvili",
    age: 25,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Heiki Nabi",
    age: 27,
    country: "Estonia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Omid Noroozi",
    age: 26,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Hitomi Obara",
    age: 31,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Dzhamal Otarsultanov",
    age: 25,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Xetaq Qazyumov",
    age: 29,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Yuliya Ratkeviç",
    age: 27,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Jackeline Rentería",
    age: 26,
    country: "Colombia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Ghasem Rezaei",
    age: 26,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Coleman Scott",
    age: 26,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Mingiyan Semyonov",
    age: 22,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Soronzonboldyn Battsetseg",
    age: 22,
    country: "Mongolia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Hamid Soryan",
    age: 26,
    country: "Iran",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Mariya Stadnik",
    age: 24,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "S?rif S?rifov",
    age: 23,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Akzhurek Tanatarov",
    age: 25,
    country: "Kazakhstan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Artur Taymazov",
    age: 33,
    country: "Uzbekistan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Soslan Tigiyev",
    age: 28,
    country: "Uzbekistan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Rustam Totrov",
    age: 28,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Denis Tsargush",
    age: 24,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Manuchar Tskhadaia",
    age: 27,
    country: "Georgia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Maider Unda",
    age: 35,
    country: "Spain",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Jake Varner",
    age: 26,
    country: "United States",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Tonya Verbeek",
    age: 34,
    country: "Canada",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Roman Vlasov",
    age: 21,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Lyubov Volosova",
    age: 29,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Nataliya Vorobyova",
    age: 21,
    country: "Russia",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Yang Kyong-Il",
    age: 23,
    country: "North Korea",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Tatsuhiro Yonemitsu",
    age: 26,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Saori Yoshida",
    age: 29,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Shinichi Yumoto",
    age: 27,
    country: "Japan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Stanka Zlateva",
    age: 29,
    country: "Bulgaria",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Emin ?hm?dov",
    age: 25,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Togrul ?sg?rov",
    age: 19,
    country: "Azerbaijan",
    year: 2012,
    date: "12/08/2012",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Yusuf Abdusalomov",
    age: 30,
    country: "Tajikistan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Bakhtiyar Akhmedov",
    age: 21,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Islam-Beka Albiyev",
    age: 19,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Roman Amoyan",
    age: 24,
    country: "Armenia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Nazmi Avluca",
    age: 31,
    country: "Turkey",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Khasan Baroyev",
    age: 25,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Mavlet Batyrov",
    age: 24,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Rövs?n Bayramov",
    age: 21,
    country: "Azerbaijan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Kanat Begaliyev",
    age: 24,
    country: "Kyrgyzstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Henry Cejudo",
    age: 21,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Chang Yongxiang",
    age: 24,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Taras Danko",
    age: 28,
    country: "Ukraine",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Mirko Englich",
    age: 29,
    country: "Germany",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Vasyl Fedoryshyn",
    age: 27,
    country: "Ukraine",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Zoltán Fodor",
    age: 23,
    country: "Hungary",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Murad Gaydarov",
    age: 28,
    country: "Belarus",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Giorgi Gogshelidze",
    age: 28,
    country: "Georgia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Christophe Guénot",
    age: 29,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Steeve Guénot",
    age: 22,
    country: "France",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Kyoko Hamaguchi",
    age: 30,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Carol Huynh",
    age: 27,
    country: "Canada",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Chiharu Icho",
    age: 26,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Kaori Icho",
    age: 24,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Manuchar K'virk'elia",
    age: 29,
    country: "Georgia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Alyona Kartashova",
    age: 26,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Georgy Ketoyev",
    age: 22,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Aslanbek Khushtov",
    age: 28,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Besik Kudukhov",
    age: 22,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Sushil Kumar",
    age: 25,
    country: "India",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Mijaín López",
    age: 25,
    country: "Cuba",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Aset Mambetov",
    age: 26,
    country: "Kazakhstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Nazyr Mankiyev",
    age: 23,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Tomohiro Matsunaga",
    age: 28,
    country: "Japan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Iryna Merleni-Mykulchyn",
    age: 26,
    country: "Ukraine",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Randi Miller",
    age: 24,
    country: "United States",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Revaz Mindorashvili",
    age: 32,
    country: "Georgia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Andrea Minguzzi",
    age: 26,
    country: "Italy",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Mindaugas Mizgaitis",
    age: 28,
    country: "Lithuania",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Seyed Mohammadi",
    age: 28,
    country: "Iran",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Sharvani Muradov",
    age: 23,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "David Musulbes",
    age: 36,
    country: "Slovakia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Marid Mutalimov",
    age: 28,
    country: "Kazakhstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Park Eun-Chul",
    age: 27,
    country: "South Korea",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Yury Patrikeyev",
    age: 28,
    country: "Armenia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Xetaq Qazyumov",
    age: 25,
    country: "Azerbaijan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Jackeline Rentería",
    age: 22,
    country: "Colombia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Vitaliy R?himov",
    age: 23,
    country: "Azerbaijan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Ramazan Sahin",
    age: 25,
    country: "Turkey",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Buvaisa Saytiyev",
    age: 33,
    country: "Russia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Mikhail Semyonov",
    age: 24,
    country: "Belarus",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Yelena Shalygina",
    age: 21,
    country: "Kazakhstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Andriy Stadnik",
    age: 26,
    country: "Ukraine",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Mariya Stadnik",
    age: 20,
    country: "Azerbaijan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Artur Taymazov",
    age: 29,
    country: "Uzbekistan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Nurbakyt Tengizbayev",
    age: 25,
    country: "Kazakhstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Kiril Terziev",
    age: 24,
    country: "Bulgaria",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Soslan Tigiyev",
    age: 24,
    country: "Uzbekistan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Taymuraz Tigiyev",
    age: 26,
    country: "Kazakhstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 1,
    bronze: 0,
    total: 1
  },
  {
    athlete: "Otar Tushishvili",
    age: 30,
    country: "Georgia",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Ruslan Tyumenbayev",
    age: 22,
    country: "Kyrgyzstan",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Armen Vardanian",
    age: 25,
    country: "Ukraine",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Radoslav Velikov",
    age: 24,
    country: "Bulgaria",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Tonya Verbeek",
    age: 31,
    country: "Canada",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 0,
    silver: 0,
    bronze: 1,
    total: 1
  },
  {
    athlete: "Wang Jiao",
    age: 20,
    country: "China",
    year: 2008,
    date: "24/08/2008",
    sport: "Wrestling",
    gold: 1,
    silver: 0,
    bronze: 0,
    total: 1
  }
], UCe = [
  ["Swimming", [[{ symbol: "foo" }, { symbol: "df" }, "green"]]],
  ["Gymnastics", [[{ symbol: "bar" }, { symbol: "df" }, "green", "purple"]]],
  ["Tennis", []],
  ["Speed Skating", []]
], KCe = ({
  selectedCategory: e,
  setSelectedCategory: t,
  setOperations: r
}) => /* @__PURE__ */ $("div", { children: /* @__PURE__ */ He("label", { children: [
  "Category:",
  /* @__PURE__ */ $("select", { value: e, onChange: (i) => {
    t(i.target.value), r([[{ symbol: "sport" }, { symbol: "df" }, i.target.value]]);
  }, children: UCe.map(([i]) => /* @__PURE__ */ $("option", { value: i, children: i }, i)) })
] }) });
function qCe(e) {
  return ot.map(e, (t, r) => ({
    ...t,
    idx: r + 1
    // Adding 1 to start the index from 1
  }));
}
function YCe(e) {
  return ot.map(e, (t, r) => ({
    ...t,
    agIdx: `${t.idx}-${t.sport}`
  }));
}
function JCe(e, t) {
  return ot.filter(e, { sport: t });
}
const XCe = (e) => {
  const t = YCe(qCe(JCe(jCe, e)));
  return console.log("dataset retval", t), t;
}, QCe = ({
  //@ts-ignore
  payloadArgs: e,
  //@ts-ignore
  on_payloadArgs: t,
  payloadResponse: r,
  operations: n
}) => (console.log("here", e, t, r, n), /* @__PURE__ */ $("h1", { children: "broken" })), ZCe = () => {
  const [e, t] = pe("Tennis"), r = { sourceName: "paddy", start: 0, end: 100 }, [n, i] = pe(r), o = (u) => {
    const d = XCe(e), h = d.slice(u.start, u.end);
    return console.log("infinite ex", e, d, u.start, u.end), {
      data: h,
      key: u,
      length: d.length
    };
  }, [s, a] = pe([
    [{ symbol: "sport" }, { symbol: "df" }, e]
  ]), l = o(n);
  return /* @__PURE__ */ He("div", { children: [
    /* @__PURE__ */ $(
      KCe,
      {
        selectedCategory: e,
        setSelectedCategory: t,
        setOperations: a
      }
    ),
    /* @__PURE__ */ $(
      QCe,
      {
        payloadArgs: n,
        on_payloadArgs: i,
        payloadResponse: l,
        operations: s
      }
    )
  ] });
}, tE = "buckaroo-style-block", ewe = (e) => {
  if (document.getElementById(tE) !== null)
    return;
  let t = Object.assign(document.createElement("style"), {
    id: tE,
    type: "text/css"
  });
  t.appendChild(document.createTextNode(e)), document.head.appendChild(t);
}, twe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  injectBuckarooCSS: ewe
}, Symbol.toStringTag, { value: "Module" })), rwe = ({ label: e, onClick: t }) => /* @__PURE__ */ $("button", { onClick: t, children: e }), nwe = () => /* @__PURE__ */ $("h1", { children: " Header NoArgs " }), rE = ({ value: e, setValue: t }) => /* @__PURE__ */ $("button", { onClick: () => {
  t(e + 1);
}, children: e }), iwe = () => {
  const [e, t] = pe(1);
  return /* @__PURE__ */ He("div", { children: [
    /* @__PURE__ */ $(rE, { value: e, setValue: t }),
    /* @__PURE__ */ $(rE, { value: e, setValue: t })
  ] });
}, pwe = {
  ColumnsEditor: pC,
  DependentTabs: uE,
  OperationViewer: lE,
  WidgetDCFCell: MCe,
  DFViewer: xA,
  DFViewerInfinite: qc,
  DFViewerInfiniteDS: $Ce,
  StatusBar: wC,
  HistogramCell: nD,
  CommandUtils: TN,
  utils: RN,
  BuckarooInfiniteWidget: VCe,
  getKeySmartRowCache: WCe,
  InfiniteEx: ZCe,
  widgetUtils: twe,
  SampleButton: rwe,
  HeaderNoArgs: nwe,
  Counter: iwe,
  // Parquet parsing for transcript replay
  parquetRead: Bg,
  parquetMetadata: ka,
  resolveDFData: La,
  preResolveDFDataDict: bCe
};
export {
  pwe as default
};
//# sourceMappingURL=index.esm.js.map
