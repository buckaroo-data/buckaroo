var _=Object.defineProperty;var $=(e,t,s)=>t in e?_(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var h=(e,t,s)=>$(e,typeof t!="symbol"?t+"":t,s);import{l as f}from"./lodash-CGIzQN7T.js";const w=e=>`${e.sourceName}-${e.start}-${e.end}-${e.sort}-${e.sort_direction}`,S=e=>`${e.sourceName}-${e.sort}-${e.sort_direction}`,C=(e,t,s,r)=>{if(e.length==0)return[[s],[r]];const[n,o]=s,[i,a]=e[0];if(o<i)return[[s,...e],[r,...t]];const[c,u]=[[],[]];for(var l=0;l<e.length;l++){const[d,q]=[e[l],t[l]];if(g(d,s)){const[F,M]=k([d,q],[s,r]),A=c.concat(e.slice(l+1)),K=u.concat(t.slice(l+1));return C(A,K,F,M)}c.push(d),u.push(q),l<e.length-1&&v(s,d,e[l+1])&&(c.push(s),u.push(r))}const[b,E]=e[e.length-1];return E<n&&(c.push(s),u.push(r)),[c,u]},k=(e,t)=>{const[s,r]=e,[n,o]=t;if(R(n,s))return k(t,e);const[i,a]=s,[c,u]=n;if(i<c&&u<a)return e;if(a===c){const E=r.concat(o);return[[i,u],E]}const l=c-a,b=r.slice(0,l).concat(o);return[[i,u],b]},v=(e,t,s)=>{if(R(s,t))return v(e,s,t);const[r,n]=e,o=t[1],i=s[0];return o<r&&n<i},R=(e,t)=>{const[s,r]=e,[n,o]=t;return s<n?!0:s==n&&r<o},m=(e,t)=>{const[s,r]=e,[n,o]=t;return s<=n&&o<=r},g=(e,t)=>{if(R(t,e))return g(t,e);const[s,r]=e,[n,o]=t;return s<=o&&r>=n},D=(e,t)=>{const[s,r]=e,[n,o]=t;return[Math.max(s,n),Math.min(r,o)]},L=(e,t)=>{const[s,r]=e,[n,o]=t;if(g(e,t)){if(m(e,t))return!0;if(n===s)return{start:r,end:o};if(o===r)return{start:n,end:s};if(m(t,e))return{start:n,end:o};if(n<s)return{start:n,end:s};if(s<n)return{start:r,end:o}}else return{start:n,end:o};return{start:n,end:o}},y=(e,t,s)=>{const[r,n]=e,[o,i]=s,a=o-r,c=i-r;return t.slice(a,c)},P=(e,t,s)=>{for(var r=0;r<e.length;r++){const[n,o]=[e[r],t[r]];if(m(n,s))return y(n,o,s)}throw new Error("RequestSeg {requestSeg} not in {segments}")},G=e=>{for(var t=0,s=0;s<e.length;s++){const[r,n]=e[s];t+=n-r}return t},N=e=>{const[t,s]=e;return s-t},H=e=>Math.floor(e[0]+N(e)/2),T=(e,t)=>{const s=H(e),[r,n]=t,[o,i]=[s-r,n-s];return o<i?-o:i},U=(e,t)=>{for(var s=0,r=0;r<e.length;r++)if(g(e[r],t)){const[n,o]=D(e[r],t);s+=o-n}return s},z=(e,t)=>[Math.floor(e-t),Math.floor(e+t)],x=(e,t,s)=>U(s,z(e,t)),O=(e,t,s)=>{const[r,n]=[[],[]];for(var o=0;o<e.length;o++){const[i,a]=[e[o],t[o]];if(m(s,i))r.push(i),n.push(a);else if(g(s,i))if(R(s,i)){const c=[i[0],s[1]],u=y(i,a,c);r.push(c),n.push(u)}else{const c=[s[0],i[1]],u=y(i,a,c);r.push(c),n.push(u)}}return[r,n]};class I{constructor(){h(this,"segments",[]);h(this,"dfs",[]);h(this,"sentLength",-1);h(this,"maxSize",4e3);h(this,"trimFactor",.8);h(this,"lastRequest",[0,0])}usedSize(){return G(this.segments)}trimCache(){if(this.usedSize()<this.maxSize||this.lastRequest[0]===0&&this.lastRequest[1]===0)return;const t=this.lastRequest,r=(t[1]-t[0])/2+t[0];var n=0,o=Math.floor(this.maxSize*this.trimFactor/2);for(n=x(r,o,this.segments);n<this.maxSize;)n=x(r,o,this.segments),o*=2;const i=Math.floor(this.maxSize*this.trimFactor);for(;n>i;)o=Math.floor(.9*o),n=x(r,o,this.segments);const a=z(r,o),c=O(this.segments,this.dfs,a);this.segments=c[0],this.dfs=c[1]}getExtents(){if(this.segments.length===0)throw new Error("No Segments");const t=this.segments[this.segments.length-1];return[this.segments[0][0],t[1]]}safeGetExtents(){if(this.segments.length===0)return[];const t=this.segments[this.segments.length-1];return[this.segments[0][0],t[1]]}addRows(t,s){const r=t[1]-t[0];if(s.length!==r){if(t[0]+s.length===this.sentLength){const i=[t[0],this.sentLength];return this.addRows(i,s)}return}const[n,o]=C(this.segments,this.dfs,t,s);this.segments=n,this.dfs=o,this.trimCache()}hasRows(t){if(t[0]===0&&t[1]===0&&console.log("setting lastRequest to [0,0] in hasRows, this is unexpected"),this.sentLength>-1&&t[1]>this.sentLength){const s=[t[0],this.sentLength];return this.hasRows(s)}this.lastRequest=t;try{console.log("[SmartRowCache.hasRows] need",t,"extents",this.safeGetExtents(),"lastRequest",this.lastRequest)}catch{}for(const s of this.segments)if(g(s,t))return L(s,t);return L([0,0],t)}getRows(t){try{console.log("[SmartRowCache.getRows] range",t,"extents",this.safeGetExtents(),"segments",this.segments)}catch{}if(this.sentLength>0&&t[1]>this.sentLength)return this.getRows([t[0],this.sentLength]);if(this.hasRows(t)===!0)return t[0]===0&&t[1]===0&&console.log("unexpected setting lastRequest to [0,0] in getRows"),this.lastRequest=t,P(this.segments,this.dfs,t);throw console.error("[SmartRowCache.getRows] Missing rows error. range",t,"extents",this.safeGetExtents(),"segments",this.segments,"sentLength",this.sentLength),new Error("Missing rows for {range}")}}function W(e){debugger;return e.data.length!==0}class Q{constructor(t){h(this,"srcAccesses");h(this,"waitingCallbacks");h(this,"reqFn");h(this,"maxSize",1e4);h(this,"trimFactor",.8);h(this,"lastRequest",[0,0]);h(this,"reUpDist",300);h(this,"padding",200);this.reqFn=t,this.waitingCallbacks={},this.srcAccesses=new Map}usedSize(){return f.sum(Array.from(this.srcAccesses.values()).map(t=>t.usedSize()))}debugCacheState(){f.map(f.fromPairs(Array.from(this.srcAccesses.entries())),(t,s)=>{console.log(t,t.safeGetExtents())})}hasRows(t){const s=S(t),r=[t.start,t.origEnd];if(!this.srcAccesses.has(s))return console.log("500 hasRows, returning False because couldn't find srcKey"),!1;const n=this.srcAccesses.get(s);if(n===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);return n.hasRows(r)===!0?!0:(console.log("500 hasRows, returning False because src didn't have rows"),!1)}getRows(t){const s=S(t),r=[t.start,t.origEnd];if(!this.srcAccesses.has(s))throw new Error(`Missing source for ${t}`);let n=this.srcAccesses.get(s);if(n===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);if(this.srcAccesses.delete(s),this.srcAccesses.set(s,n),n.sentLength!==0&&n.sentLength<t.end){const o=Math.min(t.origEnd,n.sentLength),i=[t.start,o];return n.getRows(i)}return n.getRows(r)}maybeMakeLeadingRequest(t){const s=[t.start,t.origEnd],r=this.ensureRowCacheForPa(t),n=r.safeGetExtents();if(n[1]==r.sentLength){console.log("not making extra request because already have to the end of the available data",n,r.sentLength);return}const o=T(s,n);if(console.log("maybeMakeLeadingRequest",o,s,n),o>0&&o<this.reUpDist){const i=new Date-1,a={sourceName:t.sourceName,sort:t.sort,sort_direction:t.sort_direction,start:n[1],end:n[1]+this.padding,origEnd:n[1]+this.padding,request_time:i};r.hasRows([n[1],n[1]+this.padding]),this.reqFn(a)}}getRequestRows(t,s,r){const n=w(t),o=this.ensureRowCacheForPa(t),i=new Date-1;t.request_time=i;try{console.log("[KeyAware.getRequestRows] pa",t,"cbKey",n,"extents",o.safeGetExtents(),"sentLength",o.sentLength)}catch{}if(this.hasRows(t)){console.log(`request for ${[t.start,t.origEnd,t.end]} in cache, extents ${o.getExtents()}`);const a=[t.start,t.origEnd];s(o.getRows(a),o.sentLength);const c=w(t);delete this.waitingCallbacks[c],this.maybeMakeLeadingRequest(t);return}this.waitingCallbacks[n]=[s,r],this.reqFn(t)}ensureRowCacheForPa(t){const s=S(t);console.log("592 ensureRowCacheForPa",s,this.srcAccesses.has(s)),this.srcAccesses.has(s)||this.srcAccesses.set(s,new I);const r=this.srcAccesses.get(s);if(r===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);return r}addPayloadResponse(t){const s=[t.key.start,t.key.end];t.key.request_time,this.trim();const r=this.ensureRowCacheForPa(t.key),n=w(t.key);if(r.sentLength=t.length,t.data.length<s[1]-s[0]){const o=[t.key.start,t.key.start+t.data.length];r.addRows(o,t.data)}else r.addRows(s,t.data);if(f.has(this.waitingCallbacks,n)){const[o,i]=this.waitingCallbacks[n];W(t)?o(this.getRows(t.key),r.sentLength):i(),delete this.waitingCallbacks[n]}}addErrorResponse(t){const s=w(t.key);if(f.has(this.waitingCallbacks,s)){const[r,n]=this.waitingCallbacks[s];n(),delete this.waitingCallbacks[s]}}trim(){if(this.usedSize()>this.maxSize){const t=this.srcAccesses.keys().next().value;if(t!==void 0)this.srcAccesses.delete(t);else throw new Error("unexpected couldn't find any keys in srcAccesses ")}}}export{Q as K};
