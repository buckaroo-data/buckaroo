var _=Object.defineProperty;var $=(e,t,s)=>t in e?_(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var h=(e,t,s)=>$(e,typeof t!="symbol"?t+"":t,s);import{i as D}from"./_baseEach-B-y44WsN.js";import{m as P}from"./isString-CNnovG4X.js";import{f as G}from"./fromPairs-Dx9PT-t0.js";import{h as y}from"./gridUtils-BZUEEhMB.js";function N(e,t){for(var s,r=-1,n=e.length;++r<n;){var o=t(e[r]);o!==void 0&&(s=s===void 0?o:s+o)}return s}function H(e){return e&&e.length?N(e,D):0}const d=e=>`${e.sourceName}-${e.start}-${e.end}-${e.sort}-${e.sort_direction}`,E=e=>`${e.sourceName}-${e.sort}-${e.sort_direction}`,C=(e,t,s,r)=>{if(e.length==0)return[[s],[r]];const[n,o]=s,[i,a]=e[0];if(o<i)return[[s,...e],[r,...t]];const[c,u]=[[],[]];for(var l=0;l<e.length;l++){const[g,q]=[e[l],t[l]];if(f(g,s)){const[F,M]=v([g,q],[s,r]),A=c.concat(e.slice(l+1)),K=u.concat(t.slice(l+1));return C(A,K,F,M)}c.push(g),u.push(q),l<e.length-1&&k(s,g,e[l+1])&&(c.push(s),u.push(r))}const[b,R]=e[e.length-1];return R<n&&(c.push(s),u.push(r)),[c,u]},v=(e,t)=>{const[s,r]=e,[n,o]=t;if(m(n,s))return v(t,e);const[i,a]=s,[c,u]=n;if(i<c&&u<a)return e;if(a===c){const R=r.concat(o);return[[i,u],R]}const l=c-a,b=r.slice(0,l).concat(o);return[[i,u],b]},k=(e,t,s)=>{if(m(s,t))return k(e,s,t);const[r,n]=e,o=t[1],i=s[0];return o<r&&n<i},m=(e,t)=>{const[s,r]=e,[n,o]=t;return s<n?!0:s==n&&r<o},w=(e,t)=>{const[s,r]=e,[n,o]=t;return s<=n&&o<=r},f=(e,t)=>{if(m(t,e))return f(t,e);const[s,r]=e,[n,o]=t;return s<=o&&r>=n},T=(e,t)=>{const[s,r]=e,[n,o]=t;return[Math.max(s,n),Math.min(r,o)]},L=(e,t)=>{const[s,r]=e,[n,o]=t;if(f(e,t)){if(w(e,t))return!0;if(n===s)return{start:r,end:o};if(o===r)return{start:n,end:s};if(w(t,e))return{start:n,end:o};if(n<s)return{start:n,end:s};if(s<n)return{start:r,end:o}}else return{start:n,end:o};return{start:n,end:o}},x=(e,t,s)=>{const[r,n]=e,[o,i]=s,a=o-r,c=i-r;return t.slice(a,c)},U=(e,t,s)=>{for(var r=0;r<e.length;r++){const[n,o]=[e[r],t[r]];if(w(n,s))return x(n,o,s)}throw new Error("RequestSeg {requestSeg} not in {segments}")},O=e=>{for(var t=0,s=0;s<e.length;s++){const[r,n]=e[s];t+=n-r}return t},I=e=>{const[t,s]=e;return s-t},W=e=>Math.floor(e[0]+I(e)/2),j=(e,t)=>{const s=W(e),[r,n]=t,[o,i]=[s-r,n-s];return o<i?-o:i},J=(e,t)=>{for(var s=0,r=0;r<e.length;r++)if(f(e[r],t)){const[n,o]=T(e[r],t);s+=o-n}return s},z=(e,t)=>[Math.floor(e-t),Math.floor(e+t)],S=(e,t,s)=>J(s,z(e,t)),Q=(e,t,s)=>{const[r,n]=[[],[]];for(var o=0;o<e.length;o++){const[i,a]=[e[o],t[o]];if(w(s,i))r.push(i),n.push(a);else if(f(s,i))if(m(s,i)){const c=[i[0],s[1]],u=x(i,a,c);r.push(c),n.push(u)}else{const c=[s[0],i[1]],u=x(i,a,c);r.push(c),n.push(u)}}return[r,n]};class V{constructor(){h(this,"segments",[]);h(this,"dfs",[]);h(this,"sentLength",-1);h(this,"maxSize",4e3);h(this,"trimFactor",.8);h(this,"lastRequest",[0,0])}usedSize(){return O(this.segments)}trimCache(){if(this.usedSize()<this.maxSize||this.lastRequest[0]===0&&this.lastRequest[1]===0)return;const t=this.lastRequest,r=(t[1]-t[0])/2+t[0];var n=0,o=Math.floor(this.maxSize*this.trimFactor/2);for(n=S(r,o,this.segments);n<this.maxSize;)n=S(r,o,this.segments),o*=2;const i=Math.floor(this.maxSize*this.trimFactor);for(;n>i;)o=Math.floor(.9*o),n=S(r,o,this.segments);const a=z(r,o),c=Q(this.segments,this.dfs,a);this.segments=c[0],this.dfs=c[1]}getExtents(){if(this.segments.length===0)throw new Error("No Segments");const t=this.segments[this.segments.length-1];return[this.segments[0][0],t[1]]}safeGetExtents(){if(this.segments.length===0)return[];const t=this.segments[this.segments.length-1];return[this.segments[0][0],t[1]]}addRows(t,s){const r=t[1]-t[0];if(s.length!==r){if(t[0]+s.length===this.sentLength){const i=[t[0],this.sentLength];return this.addRows(i,s)}return}const[n,o]=C(this.segments,this.dfs,t,s);this.segments=n,this.dfs=o,this.trimCache()}hasRows(t){if(t[0]===0&&t[1]===0&&console.log("setting lastRequest to [0,0] in hasRows, this is unexpected"),this.sentLength>-1&&t[1]>this.sentLength){const s=[t[0],this.sentLength];return this.hasRows(s)}this.lastRequest=t;try{console.log("[SmartRowCache.hasRows] need",t,"extents",this.safeGetExtents(),"lastRequest",this.lastRequest)}catch{}for(const s of this.segments)if(f(s,t))return L(s,t);return L([0,0],t)}getRows(t){try{console.log("[SmartRowCache.getRows] range",t,"extents",this.safeGetExtents(),"segments",this.segments)}catch{}if(this.sentLength>0&&t[1]>this.sentLength)return this.getRows([t[0],this.sentLength]);if(this.hasRows(t)===!0)return t[0]===0&&t[1]===0&&console.log("unexpected setting lastRequest to [0,0] in getRows"),this.lastRequest=t,U(this.segments,this.dfs,t);throw console.error("[SmartRowCache.getRows] Missing rows error. range",t,"extents",this.safeGetExtents(),"segments",this.segments,"sentLength",this.sentLength),new Error("Missing rows for {range}")}}function X(e){debugger;return e.data.length!==0}class st{constructor(t){h(this,"srcAccesses");h(this,"waitingCallbacks");h(this,"reqFn");h(this,"maxSize",1e4);h(this,"trimFactor",.8);h(this,"lastRequest",[0,0]);h(this,"reUpDist",300);h(this,"padding",200);this.reqFn=t,this.waitingCallbacks={},this.srcAccesses=new Map}usedSize(){return H(Array.from(this.srcAccesses.values()).map(t=>t.usedSize()))}debugCacheState(){P(G(Array.from(this.srcAccesses.entries())),(t,s)=>{console.log(t,t.safeGetExtents())})}hasRows(t){const s=E(t),r=[t.start,t.origEnd];if(!this.srcAccesses.has(s))return console.log("500 hasRows, returning False because couldn't find srcKey"),!1;const n=this.srcAccesses.get(s);if(n===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);return n.hasRows(r)===!0?!0:(console.log("500 hasRows, returning False because src didn't have rows"),!1)}getRows(t){const s=E(t),r=[t.start,t.origEnd];if(!this.srcAccesses.has(s))throw new Error(`Missing source for ${t}`);let n=this.srcAccesses.get(s);if(n===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);if(this.srcAccesses.delete(s),this.srcAccesses.set(s,n),n.sentLength!==0&&n.sentLength<t.end){const o=Math.min(t.origEnd,n.sentLength),i=[t.start,o];return n.getRows(i)}return n.getRows(r)}maybeMakeLeadingRequest(t){const s=[t.start,t.origEnd],r=this.ensureRowCacheForPa(t),n=r.safeGetExtents();if(n[1]==r.sentLength){console.log("not making extra request because already have to the end of the available data",n,r.sentLength);return}const o=j(s,n);if(console.log("maybeMakeLeadingRequest",o,s,n),o>0&&o<this.reUpDist){const i=new Date-1,a={sourceName:t.sourceName,sort:t.sort,sort_direction:t.sort_direction,start:n[1],end:n[1]+this.padding,origEnd:n[1]+this.padding,request_time:i};r.hasRows([n[1],n[1]+this.padding]),this.reqFn(a)}}getRequestRows(t,s,r){const n=d(t),o=this.ensureRowCacheForPa(t),i=new Date-1;t.request_time=i;try{console.log("[KeyAware.getRequestRows] pa",t,"cbKey",n,"extents",o.safeGetExtents(),"sentLength",o.sentLength)}catch{}if(this.hasRows(t)){console.log(`request for ${[t.start,t.origEnd,t.end]} in cache, extents ${o.getExtents()}`);const a=[t.start,t.origEnd];s(o.getRows(a),o.sentLength);const c=d(t);delete this.waitingCallbacks[c],this.maybeMakeLeadingRequest(t);return}this.waitingCallbacks[n]=[s,r],this.reqFn(t)}ensureRowCacheForPa(t){const s=E(t);console.log("592 ensureRowCacheForPa",s,this.srcAccesses.has(s)),this.srcAccesses.has(s)||this.srcAccesses.set(s,new V);const r=this.srcAccesses.get(s);if(r===void 0)throw new Error(`unexpected couldn't find SmartRowCache for ${s}`);return r}addPayloadResponse(t){const s=[t.key.start,t.key.end];t.key.request_time,this.trim();const r=this.ensureRowCacheForPa(t.key),n=d(t.key);if(r.sentLength=t.length,t.data.length<s[1]-s[0]){const o=[t.key.start,t.key.start+t.data.length];r.addRows(o,t.data)}else r.addRows(s,t.data);if(y(this.waitingCallbacks,n)){const[o,i]=this.waitingCallbacks[n];X(t)?o(this.getRows(t.key),r.sentLength):i(),delete this.waitingCallbacks[n]}}addErrorResponse(t){const s=d(t.key);if(y(this.waitingCallbacks,s)){const[r,n]=this.waitingCallbacks[s];n(),delete this.waitingCallbacks[s]}}trim(){if(this.usedSize()>this.maxSize){const t=this.srcAccesses.keys().next().value;if(t!==void 0)this.srcAccesses.delete(t);else throw new Error("unexpected couldn't find any keys in srcAccesses ")}}}export{st as K};
